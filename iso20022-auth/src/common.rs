// Open Payment Message Parsing Library
// https://github.com/Open-Payments/messages
//
// This library is designed to parse message formats based on the ISO 20022 standards,
// including but not limited to FedNow messages. It supports various financial message types,
// such as customer credit transfers, payment status reports, administrative notifications, 
// and other ISO 20022 messages, using Serde for efficient serialization and deserialization.
//
// Copyright (c) 2024 Open Payments by Harishankar Narayanan
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// You may obtain a copy of this library at
// https://github.com/Open-Payments/messages

#![allow(unused_imports)]
use regex::Regex;

#[cfg(feature = "derive_serde")]
use serde::{Deserialize, Serialize};
use open_payments_common::ValidationError;

#[cfg(feature = "derive_samplify")]
use samplify_rs::Sampleable;


// AbnormalValuesData4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AbnormalValuesData4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPtyId") )]
	pub ctr_pty_id: CounterpartyData92,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfDerivsRptd") )]
	pub nb_of_derivs_rptd: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfDerivsRptdWthOtlrs") )]
	pub nb_of_derivs_rptd_wth_otlrs: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxDtls", skip_serializing_if = "Option::is_none") )]
	pub tx_dtls: Option<Vec<AbnormalValuesTransactionData2>>,
}

impl AbnormalValuesData4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.ctr_pty_id.validate()?;
		if let Some(ref vec) = self.tx_dtls { for item in vec { item.validate()? } }
		Ok(())
	}
}


// AbnormalValuesTransactionData2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AbnormalValuesTransactionData2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxId") )]
	pub tx_id: TradeTransactionIdentification24,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtnlAmt", skip_serializing_if = "Option::is_none") )]
	pub ntnl_amt: Option<NotionalAmountLegs5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtnlQty", skip_serializing_if = "Option::is_none") )]
	pub ntnl_qty: Option<NotionalQuantityLegs5>,
}

impl AbnormalValuesTransactionData2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.tx_id.validate()?;
		if let Some(ref val) = self.ntnl_amt { val.validate()? }
		if let Some(ref val) = self.ntnl_qty { val.validate()? }
		Ok(())
	}
}


// Absolute1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Absolute1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Unit") )]
	pub unit: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Qty") )]
	pub qty: f64,
}

impl Absolute1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.unit.chars().count() < 1 {
			return Err(ValidationError::new(1001, "unit is shorter than the minimum length of 1".to_string()));
		}
		if self.unit.chars().count() > 35 {
			return Err(ValidationError::new(1002, "unit exceeds the maximum length of 35".to_string()));
		}
		Ok(())
	}
}


// AccountAndParties3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AccountAndParties3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: CashAccount43,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InvstgtdPties") )]
	pub invstgtd_pties: InvestigatedParties1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AuthrtyReqTp") )]
	pub authrty_req_tp: Vec<AuthorityRequestType1>,
}

impl AccountAndParties3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.id.validate()?;
		self.invstgtd_pties.validate()?;
		for item in &self.authrty_req_tp { item.validate()? }
		Ok(())
	}
}


// AccountIdentification4Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AccountIdentification4Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "IBAN", skip_serializing_if = "Option::is_none") )]
	pub iban: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<GenericAccountIdentification1>,
}

impl AccountIdentification4Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.iban {
			let pattern = Regex::new("[A-Z]{2,2}[0-9]{2,2}[a-zA-Z0-9]{1,30}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "iban does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.othr { val.validate()? }
		Ok(())
	}
}


// AccountSchemeName1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AccountSchemeName1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl AccountSchemeName1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// ActiveCurrencyAnd13DecimalAmount ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ActiveCurrencyAnd13DecimalAmount {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ccy") )]
	pub ccy: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "$value") )]
	pub value: f64,
}

impl ActiveCurrencyAnd13DecimalAmount {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ActiveCurrencyAnd24Amount ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ActiveCurrencyAnd24Amount {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ccy") )]
	pub ccy: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "$value") )]
	pub value: f64,
}

impl ActiveCurrencyAnd24Amount {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ActiveCurrencyAndAmount ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ActiveCurrencyAndAmount {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ccy") )]
	pub ccy: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "$value") )]
	pub value: f64,
}

impl ActiveCurrencyAndAmount {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ActiveOrHistoricCurrencyAnd19DecimalAmount ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ActiveOrHistoricCurrencyAnd19DecimalAmount {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ccy") )]
	pub ccy: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "$value") )]
	pub value: f64,
}

impl ActiveOrHistoricCurrencyAnd19DecimalAmount {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ActiveOrHistoricCurrencyAnd20DecimalAmount ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ActiveOrHistoricCurrencyAnd20DecimalAmount {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ccy") )]
	pub ccy: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "$value") )]
	pub value: f64,
}

impl ActiveOrHistoricCurrencyAnd20DecimalAmount {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ActiveOrHistoricCurrencyAndAmount ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ActiveOrHistoricCurrencyAndAmount {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ccy") )]
	pub ccy: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "$value") )]
	pub value: f64,
}

impl ActiveOrHistoricCurrencyAndAmount {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AdditionalInformation1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AdditionalInformation1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "InfTp") )]
	pub inf_tp: InformationType1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InfVal") )]
	pub inf_val: String,
}

impl AdditionalInformation1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.inf_tp.validate()?;
		if self.inf_val.chars().count() < 1 {
			return Err(ValidationError::new(1001, "inf_val is shorter than the minimum length of 1".to_string()));
		}
		if self.inf_val.chars().count() > 350 {
			return Err(ValidationError::new(1002, "inf_val exceeds the maximum length of 350".to_string()));
		}
		Ok(())
	}
}


// AddressType2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AddressType2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ADDR") )]
	CodeADDR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PBOX") )]
	CodePBOX,
	#[cfg_attr( feature = "derive_serde", serde(rename = "HOME") )]
	CodeHOME,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BIZZ") )]
	CodeBIZZ,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MLTO") )]
	CodeMLTO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DLVY") )]
	CodeDLVY,
}

impl AddressType2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AddressType3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AddressType3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<AddressType2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification30>,
}

impl AddressType3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// AgreementType1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AgreementType1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl AgreementType1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tp {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tp is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "tp exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// AgreementType2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AgreementType2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl AgreementType2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tp {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tp is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "tp exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 50 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 50".to_string()));
			}
		}
		Ok(())
	}
}


// AgriculturalCommodityDairy1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AgriculturalCommodityDairy1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct") )]
	pub sub_pdct: AssetClassSubProductType20Code,
}

impl AgriculturalCommodityDairy1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		self.sub_pdct.validate()?;
		Ok(())
	}
}


// AgriculturalCommodityDairy2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AgriculturalCommodityDairy2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType20Code>,
}

impl AgriculturalCommodityDairy2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		Ok(())
	}
}


// AgriculturalCommodityForestry1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AgriculturalCommodityForestry1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct") )]
	pub sub_pdct: AssetClassSubProductType21Code,
}

impl AgriculturalCommodityForestry1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		self.sub_pdct.validate()?;
		Ok(())
	}
}


// AgriculturalCommodityForestry2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AgriculturalCommodityForestry2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType21Code>,
}

impl AgriculturalCommodityForestry2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		Ok(())
	}
}


// AgriculturalCommodityGrain1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AgriculturalCommodityGrain1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct") )]
	pub sub_pdct: AssetClassSubProductType5Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlSubPdct", skip_serializing_if = "Option::is_none") )]
	pub addtl_sub_pdct: Option<AssetClassDetailedSubProductType15Code>,
}

impl AgriculturalCommodityGrain1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		self.sub_pdct.validate()?;
		if let Some(ref val) = self.addtl_sub_pdct { val.validate()? }
		Ok(())
	}
}


// AgriculturalCommodityGrain2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AgriculturalCommodityGrain2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct") )]
	pub sub_pdct: AssetClassSubProductType5Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlSubPdct") )]
	pub addtl_sub_pdct: AssetClassDetailedSubProductType30Code,
}

impl AgriculturalCommodityGrain2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		self.sub_pdct.validate()?;
		self.addtl_sub_pdct.validate()?;
		Ok(())
	}
}


// AgriculturalCommodityGrain3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AgriculturalCommodityGrain3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType5Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlSubPdct", skip_serializing_if = "Option::is_none") )]
	pub addtl_sub_pdct: Option<AssetClassDetailedSubProductType30Code>,
}

impl AgriculturalCommodityGrain3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		if let Some(ref val) = self.addtl_sub_pdct { val.validate()? }
		Ok(())
	}
}


// AgriculturalCommodityLiveStock1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AgriculturalCommodityLiveStock1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct") )]
	pub sub_pdct: AssetClassSubProductType22Code,
}

impl AgriculturalCommodityLiveStock1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		self.sub_pdct.validate()?;
		Ok(())
	}
}


// AgriculturalCommodityLiveStock2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AgriculturalCommodityLiveStock2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType22Code>,
}

impl AgriculturalCommodityLiveStock2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		Ok(())
	}
}


// AgriculturalCommodityOilSeed1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AgriculturalCommodityOilSeed1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct") )]
	pub sub_pdct: AssetClassSubProductType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlSubPdct") )]
	pub addtl_sub_pdct: AssetClassDetailedSubProductType1Code,
}

impl AgriculturalCommodityOilSeed1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		self.sub_pdct.validate()?;
		self.addtl_sub_pdct.validate()?;
		Ok(())
	}
}


// AgriculturalCommodityOilSeed2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AgriculturalCommodityOilSeed2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlSubPdct", skip_serializing_if = "Option::is_none") )]
	pub addtl_sub_pdct: Option<AssetClassDetailedSubProductType1Code>,
}

impl AgriculturalCommodityOilSeed2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		if let Some(ref val) = self.addtl_sub_pdct { val.validate()? }
		Ok(())
	}
}


// AgriculturalCommodityOliveOil1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AgriculturalCommodityOliveOil1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct") )]
	pub sub_pdct: AssetClassSubProductType3Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlSubPdct", skip_serializing_if = "Option::is_none") )]
	pub addtl_sub_pdct: Option<AssetClassDetailedSubProductType4Code>,
}

impl AgriculturalCommodityOliveOil1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		self.sub_pdct.validate()?;
		if let Some(ref val) = self.addtl_sub_pdct { val.validate()? }
		Ok(())
	}
}


// AgriculturalCommodityOliveOil2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AgriculturalCommodityOliveOil2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct") )]
	pub sub_pdct: AssetClassSubProductType3Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlSubPdct") )]
	pub addtl_sub_pdct: AssetClassDetailedSubProductType29Code,
}

impl AgriculturalCommodityOliveOil2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		self.sub_pdct.validate()?;
		self.addtl_sub_pdct.validate()?;
		Ok(())
	}
}


// AgriculturalCommodityOliveOil3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AgriculturalCommodityOliveOil3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType3Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlSubPdct", skip_serializing_if = "Option::is_none") )]
	pub addtl_sub_pdct: Option<AssetClassDetailedSubProductType29Code>,
}

impl AgriculturalCommodityOliveOil3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		if let Some(ref val) = self.addtl_sub_pdct { val.validate()? }
		Ok(())
	}
}


// AgriculturalCommodityOther1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AgriculturalCommodityOther1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct") )]
	pub sub_pdct: AssetClassSubProductType49Code,
}

impl AgriculturalCommodityOther1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		self.sub_pdct.validate()?;
		Ok(())
	}
}


// AgriculturalCommodityOther2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AgriculturalCommodityOther2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType49Code>,
}

impl AgriculturalCommodityOther2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		Ok(())
	}
}


// AgriculturalCommodityPotato1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AgriculturalCommodityPotato1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct") )]
	pub sub_pdct: AssetClassSubProductType45Code,
}

impl AgriculturalCommodityPotato1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		self.sub_pdct.validate()?;
		Ok(())
	}
}


// AgriculturalCommodityPotato2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AgriculturalCommodityPotato2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType45Code>,
}

impl AgriculturalCommodityPotato2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		Ok(())
	}
}


// AgriculturalCommoditySeafood1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AgriculturalCommoditySeafood1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct") )]
	pub sub_pdct: AssetClassSubProductType23Code,
}

impl AgriculturalCommoditySeafood1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		self.sub_pdct.validate()?;
		Ok(())
	}
}


// AgriculturalCommoditySeafood2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AgriculturalCommoditySeafood2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType23Code>,
}

impl AgriculturalCommoditySeafood2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		Ok(())
	}
}


// AgriculturalCommoditySoft1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AgriculturalCommoditySoft1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct") )]
	pub sub_pdct: AssetClassSubProductType2Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlSubPdct") )]
	pub addtl_sub_pdct: AssetClassDetailedSubProductType2Code,
}

impl AgriculturalCommoditySoft1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		self.sub_pdct.validate()?;
		self.addtl_sub_pdct.validate()?;
		Ok(())
	}
}


// AgriculturalCommoditySoft2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AgriculturalCommoditySoft2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlSubPdct", skip_serializing_if = "Option::is_none") )]
	pub addtl_sub_pdct: Option<AssetClassDetailedSubProductType2Code>,
}

impl AgriculturalCommoditySoft2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		if let Some(ref val) = self.addtl_sub_pdct { val.validate()? }
		Ok(())
	}
}


// AllocationIndicator1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AllocationIndicator1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "POST") )]
	CodePOST,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PREA") )]
	CodePREA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UNAL") )]
	CodeUNAL,
}

impl AllocationIndicator1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// Amount3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Amount3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlAmt", skip_serializing_if = "Option::is_none") )]
	pub orgnl_amt: Option<ActiveCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgAmt") )]
	pub rptg_amt: ActiveCurrencyAndAmount,
}

impl Amount3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.orgnl_amt { val.validate()? }
		self.rptg_amt.validate()?;
		Ok(())
	}
}


// AmountAndDirection102 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AmountAndDirection102 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sgn") )]
	pub sgn: bool,
}

impl AmountAndDirection102 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.amt.validate()?;
		Ok(())
	}
}


// AmountAndDirection106 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AmountAndDirection106 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveOrHistoricCurrencyAnd19DecimalAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sgn", skip_serializing_if = "Option::is_none") )]
	pub sgn: Option<bool>,
}

impl AmountAndDirection106 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.amt.validate()?;
		Ok(())
	}
}


// AmountAndDirection107 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AmountAndDirection107 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveOrHistoricCurrencyAnd20DecimalAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sgn", skip_serializing_if = "Option::is_none") )]
	pub sgn: Option<bool>,
}

impl AmountAndDirection107 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.amt.validate()?;
		Ok(())
	}
}


// AmountAndDirection109 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AmountAndDirection109 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt", skip_serializing_if = "Option::is_none") )]
	pub amt: Option<ActiveOrHistoricCurrencyAnd19DecimalAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sgn", skip_serializing_if = "Option::is_none") )]
	pub sgn: Option<bool>,
}

impl AmountAndDirection109 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.amt { val.validate()? }
		Ok(())
	}
}


// AmountAndDirection53 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AmountAndDirection53 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveOrHistoricCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sgn", skip_serializing_if = "Option::is_none") )]
	pub sgn: Option<bool>,
}

impl AmountAndDirection53 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.amt.validate()?;
		Ok(())
	}
}


// AmountAndDirection61 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AmountAndDirection61 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveCurrencyAnd13DecimalAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sgn", skip_serializing_if = "Option::is_none") )]
	pub sgn: Option<bool>,
}

impl AmountAndDirection61 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.amt.validate()?;
		Ok(())
	}
}


// AmountAndDirection86 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AmountAndDirection86 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sgn") )]
	pub sgn: bool,
}

impl AmountAndDirection86 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.amt < 0.000000 {
			return Err(ValidationError::new(1003, "amt is less than the minimum value of 0.000000".to_string()));
		}
		Ok(())
	}
}


// AmountHaircutMargin1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AmountHaircutMargin1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: AmountAndDirection53,
	#[cfg_attr( feature = "derive_serde", serde(rename = "HrcutOrMrgn", skip_serializing_if = "Option::is_none") )]
	pub hrcut_or_mrgn: Option<f64>,
}

impl AmountHaircutMargin1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.amt.validate()?;
		Ok(())
	}
}


// AnyMIC1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AnyMIC1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ANYM") )]
	CodeANYM,
}

impl AnyMIC1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClass2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetClass2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cmmdty", skip_serializing_if = "Option::is_none") )]
	pub cmmdty: Option<DerivativeCommodity2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Intrst", skip_serializing_if = "Option::is_none") )]
	pub intrst: Option<DerivativeInterest3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FX", skip_serializing_if = "Option::is_none") )]
	pub fx: Option<DerivativeForeignExchange3>,
}

impl AssetClass2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cmmdty { val.validate()? }
		if let Some(ref val) = self.intrst { val.validate()? }
		if let Some(ref val) = self.fx { val.validate()? }
		Ok(())
	}
}


// AssetClassAndSubClassIdentification2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetClassAndSubClassIdentification2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AsstClss") )]
	pub asst_clss: NonEquityAssetClass1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DerivSubClss", skip_serializing_if = "Option::is_none") )]
	pub deriv_sub_clss: Option<NonEquitySubClass1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FinInstrmClssfctn", skip_serializing_if = "Option::is_none") )]
	pub fin_instrm_clssfctn: Option<NonEquityInstrumentReportingClassification1Code>,
}

impl AssetClassAndSubClassIdentification2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.asst_clss.validate()?;
		if let Some(ref val) = self.deriv_sub_clss { val.validate()? }
		if let Some(ref val) = self.fin_instrm_clssfctn { val.validate()? }
		Ok(())
	}
}


// AssetClassAttributes1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetClassAttributes1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Intrst") )]
	pub intrst: DerivativeInterest2,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FX") )]
	pub fx: DerivativeForeignExchange2,
}

impl AssetClassAttributes1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.intrst.validate()?;
		self.fx.validate()?;
		Ok(())
	}
}


// AssetClassAttributes1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetClassAttributes1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Intrst", skip_serializing_if = "Option::is_none") )]
	pub intrst: Option<DerivativeInterest2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FX", skip_serializing_if = "Option::is_none") )]
	pub fx: Option<DerivativeForeignExchange2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Both", skip_serializing_if = "Option::is_none") )]
	pub both: Option<AssetClassAttributes1>,
}

impl AssetClassAttributes1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.intrst { val.validate()? }
		if let Some(ref val) = self.fx { val.validate()? }
		if let Some(ref val) = self.both { val.validate()? }
		Ok(())
	}
}


// AssetClassCommodity3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetClassCommodity3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Agrcltrl", skip_serializing_if = "Option::is_none") )]
	pub agrcltrl: Option<AssetClassCommodityAgricultural1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nrgy", skip_serializing_if = "Option::is_none") )]
	pub nrgy: Option<AssetClassCommodityEnergy1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Envttl", skip_serializing_if = "Option::is_none") )]
	pub envttl: Option<AssetClassCommodityEnvironmental1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Frtlzr", skip_serializing_if = "Option::is_none") )]
	pub frtlzr: Option<AssetClassCommodityFertilizer1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Frght", skip_serializing_if = "Option::is_none") )]
	pub frght: Option<AssetClassCommodityFreight1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IndstrlPdct", skip_serializing_if = "Option::is_none") )]
	pub indstrl_pdct: Option<AssetClassCommodityIndustrialProduct1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Metl", skip_serializing_if = "Option::is_none") )]
	pub metl: Option<AssetClassCommodityMetal1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrC10", skip_serializing_if = "Option::is_none") )]
	pub othr_c10: Option<AssetClassCommodityOtherC102Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ppr", skip_serializing_if = "Option::is_none") )]
	pub ppr: Option<AssetClassCommodityPaper1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Plprpln", skip_serializing_if = "Option::is_none") )]
	pub plprpln: Option<AssetClassCommodityPolypropylene1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Infltn", skip_serializing_if = "Option::is_none") )]
	pub infltn: Option<AssetClassCommodityInflation1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MultiCmmdtyExtc", skip_serializing_if = "Option::is_none") )]
	pub multi_cmmdty_extc: Option<AssetClassCommodityMultiCommodityExotic1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OffclEcnmcSttstcs", skip_serializing_if = "Option::is_none") )]
	pub offcl_ecnmc_sttstcs: Option<AssetClassCommodityOfficialEconomicStatistics1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<AssetClassCommodityOther1>,
}

impl AssetClassCommodity3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.agrcltrl { val.validate()? }
		if let Some(ref val) = self.nrgy { val.validate()? }
		if let Some(ref val) = self.envttl { val.validate()? }
		if let Some(ref val) = self.frtlzr { val.validate()? }
		if let Some(ref val) = self.frght { val.validate()? }
		if let Some(ref val) = self.indstrl_pdct { val.validate()? }
		if let Some(ref val) = self.metl { val.validate()? }
		if let Some(ref val) = self.othr_c10 { val.validate()? }
		if let Some(ref val) = self.ppr { val.validate()? }
		if let Some(ref val) = self.plprpln { val.validate()? }
		if let Some(ref val) = self.infltn { val.validate()? }
		if let Some(ref val) = self.multi_cmmdty_extc { val.validate()? }
		if let Some(ref val) = self.offcl_ecnmc_sttstcs { val.validate()? }
		if let Some(ref val) = self.othr { val.validate()? }
		Ok(())
	}
}


// AssetClassCommodity5Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetClassCommodity5Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Agrcltrl", skip_serializing_if = "Option::is_none") )]
	pub agrcltrl: Option<AssetClassCommodityAgricultural5Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nrgy", skip_serializing_if = "Option::is_none") )]
	pub nrgy: Option<AssetClassCommodityEnergy2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Envttl", skip_serializing_if = "Option::is_none") )]
	pub envttl: Option<AssetClassCommodityEnvironmental2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Frtlzr", skip_serializing_if = "Option::is_none") )]
	pub frtlzr: Option<AssetClassCommodityFertilizer3Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Frght", skip_serializing_if = "Option::is_none") )]
	pub frght: Option<AssetClassCommodityFreight3Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IndstrlPdct", skip_serializing_if = "Option::is_none") )]
	pub indstrl_pdct: Option<AssetClassCommodityIndustrialProduct1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Metl", skip_serializing_if = "Option::is_none") )]
	pub metl: Option<AssetClassCommodityMetal1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrC10", skip_serializing_if = "Option::is_none") )]
	pub othr_c10: Option<AssetClassCommodityOtherC102Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ppr", skip_serializing_if = "Option::is_none") )]
	pub ppr: Option<AssetClassCommodityPaper3Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Plprpln", skip_serializing_if = "Option::is_none") )]
	pub plprpln: Option<AssetClassCommodityPolypropylene3Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Infltn", skip_serializing_if = "Option::is_none") )]
	pub infltn: Option<AssetClassCommodityInflation1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MultiCmmdtyExtc", skip_serializing_if = "Option::is_none") )]
	pub multi_cmmdty_extc: Option<AssetClassCommodityMultiCommodityExotic1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OffclEcnmcSttstcs", skip_serializing_if = "Option::is_none") )]
	pub offcl_ecnmc_sttstcs: Option<AssetClassCommodityOfficialEconomicStatistics1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<AssetClassCommodityOther1>,
}

impl AssetClassCommodity5Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.agrcltrl { val.validate()? }
		if let Some(ref val) = self.nrgy { val.validate()? }
		if let Some(ref val) = self.envttl { val.validate()? }
		if let Some(ref val) = self.frtlzr { val.validate()? }
		if let Some(ref val) = self.frght { val.validate()? }
		if let Some(ref val) = self.indstrl_pdct { val.validate()? }
		if let Some(ref val) = self.metl { val.validate()? }
		if let Some(ref val) = self.othr_c10 { val.validate()? }
		if let Some(ref val) = self.ppr { val.validate()? }
		if let Some(ref val) = self.plprpln { val.validate()? }
		if let Some(ref val) = self.infltn { val.validate()? }
		if let Some(ref val) = self.multi_cmmdty_extc { val.validate()? }
		if let Some(ref val) = self.offcl_ecnmc_sttstcs { val.validate()? }
		if let Some(ref val) = self.othr { val.validate()? }
		Ok(())
	}
}


// AssetClassCommodity6Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetClassCommodity6Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Agrcltrl", skip_serializing_if = "Option::is_none") )]
	pub agrcltrl: Option<AssetClassCommodityAgricultural6Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nrgy", skip_serializing_if = "Option::is_none") )]
	pub nrgy: Option<AssetClassCommodityEnergy3Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Envttl", skip_serializing_if = "Option::is_none") )]
	pub envttl: Option<AssetClassCommodityEnvironmental3Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Frtlzr", skip_serializing_if = "Option::is_none") )]
	pub frtlzr: Option<AssetClassCommodityFertilizer4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Frght", skip_serializing_if = "Option::is_none") )]
	pub frght: Option<AssetClassCommodityFreight4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Indx", skip_serializing_if = "Option::is_none") )]
	pub indx: Option<AssetClassCommodityIndex1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IndstrlPdct", skip_serializing_if = "Option::is_none") )]
	pub indstrl_pdct: Option<AssetClassCommodityIndustrialProduct2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Infltn", skip_serializing_if = "Option::is_none") )]
	pub infltn: Option<AssetClassCommodityInflation1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Metl", skip_serializing_if = "Option::is_none") )]
	pub metl: Option<AssetClassCommodityMetal2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MultiCmmdtyExtc", skip_serializing_if = "Option::is_none") )]
	pub multi_cmmdty_extc: Option<AssetClassCommodityMultiCommodityExotic1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OffclEcnmcSttstcs", skip_serializing_if = "Option::is_none") )]
	pub offcl_ecnmc_sttstcs: Option<AssetClassCommodityOfficialEconomicStatistics1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<AssetClassCommodityOther1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrC10", skip_serializing_if = "Option::is_none") )]
	pub othr_c10: Option<AssetClassCommodityC10Other1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ppr", skip_serializing_if = "Option::is_none") )]
	pub ppr: Option<AssetClassCommodityPaper4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Plprpln", skip_serializing_if = "Option::is_none") )]
	pub plprpln: Option<AssetClassCommodityPolypropylene4Choice>,
}

impl AssetClassCommodity6Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.agrcltrl { val.validate()? }
		if let Some(ref val) = self.nrgy { val.validate()? }
		if let Some(ref val) = self.envttl { val.validate()? }
		if let Some(ref val) = self.frtlzr { val.validate()? }
		if let Some(ref val) = self.frght { val.validate()? }
		if let Some(ref val) = self.indx { val.validate()? }
		if let Some(ref val) = self.indstrl_pdct { val.validate()? }
		if let Some(ref val) = self.infltn { val.validate()? }
		if let Some(ref val) = self.metl { val.validate()? }
		if let Some(ref val) = self.multi_cmmdty_extc { val.validate()? }
		if let Some(ref val) = self.offcl_ecnmc_sttstcs { val.validate()? }
		if let Some(ref val) = self.othr { val.validate()? }
		if let Some(ref val) = self.othr_c10 { val.validate()? }
		if let Some(ref val) = self.ppr { val.validate()? }
		if let Some(ref val) = self.plprpln { val.validate()? }
		Ok(())
	}
}


// AssetClassCommodity7Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetClassCommodity7Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Agrcltrl", skip_serializing_if = "Option::is_none") )]
	pub agrcltrl: Option<AssetClassCommodityAgricultural6Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nrgy", skip_serializing_if = "Option::is_none") )]
	pub nrgy: Option<AssetClassCommodityEnergy3Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Envttl", skip_serializing_if = "Option::is_none") )]
	pub envttl: Option<AssetClassCommodityEnvironmental3Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Frtlzr", skip_serializing_if = "Option::is_none") )]
	pub frtlzr: Option<AssetClassCommodityFertilizer4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Frght", skip_serializing_if = "Option::is_none") )]
	pub frght: Option<AssetClassCommodityFreight4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Indx", skip_serializing_if = "Option::is_none") )]
	pub indx: Option<AssetClassCommodityIndex1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IndstrlPdct", skip_serializing_if = "Option::is_none") )]
	pub indstrl_pdct: Option<AssetClassCommodityIndustrialProduct2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Infltn", skip_serializing_if = "Option::is_none") )]
	pub infltn: Option<AssetClassCommodityInflation1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Metl", skip_serializing_if = "Option::is_none") )]
	pub metl: Option<AssetClassCommodityMetal2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MultiCmmdtyExtc", skip_serializing_if = "Option::is_none") )]
	pub multi_cmmdty_extc: Option<AssetClassCommodityMultiCommodityExotic1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OffclEcnmcSttstcs", skip_serializing_if = "Option::is_none") )]
	pub offcl_ecnmc_sttstcs: Option<AssetClassCommodityOfficialEconomicStatistics1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<AssetClassCommodityOther1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrC10", skip_serializing_if = "Option::is_none") )]
	pub othr_c10: Option<AssetClassCommodityC10Other1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ppr", skip_serializing_if = "Option::is_none") )]
	pub ppr: Option<AssetClassCommodityPaper5Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Plprpln", skip_serializing_if = "Option::is_none") )]
	pub plprpln: Option<AssetClassCommodityPolypropylene4Choice>,
}

impl AssetClassCommodity7Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.agrcltrl { val.validate()? }
		if let Some(ref val) = self.nrgy { val.validate()? }
		if let Some(ref val) = self.envttl { val.validate()? }
		if let Some(ref val) = self.frtlzr { val.validate()? }
		if let Some(ref val) = self.frght { val.validate()? }
		if let Some(ref val) = self.indx { val.validate()? }
		if let Some(ref val) = self.indstrl_pdct { val.validate()? }
		if let Some(ref val) = self.infltn { val.validate()? }
		if let Some(ref val) = self.metl { val.validate()? }
		if let Some(ref val) = self.multi_cmmdty_extc { val.validate()? }
		if let Some(ref val) = self.offcl_ecnmc_sttstcs { val.validate()? }
		if let Some(ref val) = self.othr { val.validate()? }
		if let Some(ref val) = self.othr_c10 { val.validate()? }
		if let Some(ref val) = self.ppr { val.validate()? }
		if let Some(ref val) = self.plprpln { val.validate()? }
		Ok(())
	}
}


// AssetClassCommodityAgricultural1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetClassCommodityAgricultural1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "GrnOilSeed", skip_serializing_if = "Option::is_none") )]
	pub grn_oil_seed: Option<AgriculturalCommodityOilSeed1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Soft", skip_serializing_if = "Option::is_none") )]
	pub soft: Option<AgriculturalCommoditySoft1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ptt", skip_serializing_if = "Option::is_none") )]
	pub ptt: Option<AgriculturalCommodityPotato1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OlvOil", skip_serializing_if = "Option::is_none") )]
	pub olv_oil: Option<AgriculturalCommodityOliveOil1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dairy", skip_serializing_if = "Option::is_none") )]
	pub dairy: Option<AgriculturalCommodityDairy1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Frstry", skip_serializing_if = "Option::is_none") )]
	pub frstry: Option<AgriculturalCommodityForestry1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sfd", skip_serializing_if = "Option::is_none") )]
	pub sfd: Option<AgriculturalCommoditySeafood1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LiveStock", skip_serializing_if = "Option::is_none") )]
	pub live_stock: Option<AgriculturalCommodityLiveStock1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Grn", skip_serializing_if = "Option::is_none") )]
	pub grn: Option<AgriculturalCommodityGrain1>,
}

impl AssetClassCommodityAgricultural1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.grn_oil_seed { val.validate()? }
		if let Some(ref val) = self.soft { val.validate()? }
		if let Some(ref val) = self.ptt { val.validate()? }
		if let Some(ref val) = self.olv_oil { val.validate()? }
		if let Some(ref val) = self.dairy { val.validate()? }
		if let Some(ref val) = self.frstry { val.validate()? }
		if let Some(ref val) = self.sfd { val.validate()? }
		if let Some(ref val) = self.live_stock { val.validate()? }
		if let Some(ref val) = self.grn { val.validate()? }
		Ok(())
	}
}


// AssetClassCommodityAgricultural5Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetClassCommodityAgricultural5Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "GrnOilSeed", skip_serializing_if = "Option::is_none") )]
	pub grn_oil_seed: Option<AgriculturalCommodityOilSeed1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Soft", skip_serializing_if = "Option::is_none") )]
	pub soft: Option<AgriculturalCommoditySoft1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ptt", skip_serializing_if = "Option::is_none") )]
	pub ptt: Option<AgriculturalCommodityPotato1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OlvOil", skip_serializing_if = "Option::is_none") )]
	pub olv_oil: Option<AgriculturalCommodityOliveOil2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dairy", skip_serializing_if = "Option::is_none") )]
	pub dairy: Option<AgriculturalCommodityDairy1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Frstry", skip_serializing_if = "Option::is_none") )]
	pub frstry: Option<AgriculturalCommodityForestry1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sfd", skip_serializing_if = "Option::is_none") )]
	pub sfd: Option<AgriculturalCommoditySeafood1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LiveStock", skip_serializing_if = "Option::is_none") )]
	pub live_stock: Option<AgriculturalCommodityLiveStock1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Grn", skip_serializing_if = "Option::is_none") )]
	pub grn: Option<AgriculturalCommodityGrain2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<AgriculturalCommodityOther1>,
}

impl AssetClassCommodityAgricultural5Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.grn_oil_seed { val.validate()? }
		if let Some(ref val) = self.soft { val.validate()? }
		if let Some(ref val) = self.ptt { val.validate()? }
		if let Some(ref val) = self.olv_oil { val.validate()? }
		if let Some(ref val) = self.dairy { val.validate()? }
		if let Some(ref val) = self.frstry { val.validate()? }
		if let Some(ref val) = self.sfd { val.validate()? }
		if let Some(ref val) = self.live_stock { val.validate()? }
		if let Some(ref val) = self.grn { val.validate()? }
		if let Some(ref val) = self.othr { val.validate()? }
		Ok(())
	}
}


// AssetClassCommodityAgricultural6Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetClassCommodityAgricultural6Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "GrnOilSeed", skip_serializing_if = "Option::is_none") )]
	pub grn_oil_seed: Option<AgriculturalCommodityOilSeed2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Soft", skip_serializing_if = "Option::is_none") )]
	pub soft: Option<AgriculturalCommoditySoft2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ptt", skip_serializing_if = "Option::is_none") )]
	pub ptt: Option<AgriculturalCommodityPotato2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OlvOil", skip_serializing_if = "Option::is_none") )]
	pub olv_oil: Option<AgriculturalCommodityOliveOil3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dairy", skip_serializing_if = "Option::is_none") )]
	pub dairy: Option<AgriculturalCommodityDairy2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Frstry", skip_serializing_if = "Option::is_none") )]
	pub frstry: Option<AgriculturalCommodityForestry2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sfd", skip_serializing_if = "Option::is_none") )]
	pub sfd: Option<AgriculturalCommoditySeafood2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LiveStock", skip_serializing_if = "Option::is_none") )]
	pub live_stock: Option<AgriculturalCommodityLiveStock2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Grn", skip_serializing_if = "Option::is_none") )]
	pub grn: Option<AgriculturalCommodityGrain3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<AgriculturalCommodityOther2>,
}

impl AssetClassCommodityAgricultural6Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.grn_oil_seed { val.validate()? }
		if let Some(ref val) = self.soft { val.validate()? }
		if let Some(ref val) = self.ptt { val.validate()? }
		if let Some(ref val) = self.olv_oil { val.validate()? }
		if let Some(ref val) = self.dairy { val.validate()? }
		if let Some(ref val) = self.frstry { val.validate()? }
		if let Some(ref val) = self.sfd { val.validate()? }
		if let Some(ref val) = self.live_stock { val.validate()? }
		if let Some(ref val) = self.grn { val.validate()? }
		if let Some(ref val) = self.othr { val.validate()? }
		Ok(())
	}
}


// AssetClassCommodityC10Other1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetClassCommodityC10Other1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType11Code,
}

impl AssetClassCommodityC10Other1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		Ok(())
	}
}


// AssetClassCommodityEnergy1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetClassCommodityEnergy1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Elctrcty", skip_serializing_if = "Option::is_none") )]
	pub elctrcty: Option<EnergyCommodityElectricity1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtrlGas", skip_serializing_if = "Option::is_none") )]
	pub ntrl_gas: Option<EnergyCommodityNaturalGas1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Oil", skip_serializing_if = "Option::is_none") )]
	pub oil: Option<EnergyCommodityOil1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Coal", skip_serializing_if = "Option::is_none") )]
	pub coal: Option<EnergyCommodityCoal1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrNrgy", skip_serializing_if = "Option::is_none") )]
	pub intr_nrgy: Option<EnergyCommodityInterEnergy1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RnwblNrgy", skip_serializing_if = "Option::is_none") )]
	pub rnwbl_nrgy: Option<EnergyCommodityRenewableEnergy1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LghtEnd", skip_serializing_if = "Option::is_none") )]
	pub lght_end: Option<EnergyCommodityLightEnd1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dstllts", skip_serializing_if = "Option::is_none") )]
	pub dstllts: Option<EnergyCommodityDistillates1>,
}

impl AssetClassCommodityEnergy1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.elctrcty { val.validate()? }
		if let Some(ref val) = self.ntrl_gas { val.validate()? }
		if let Some(ref val) = self.oil { val.validate()? }
		if let Some(ref val) = self.coal { val.validate()? }
		if let Some(ref val) = self.intr_nrgy { val.validate()? }
		if let Some(ref val) = self.rnwbl_nrgy { val.validate()? }
		if let Some(ref val) = self.lght_end { val.validate()? }
		if let Some(ref val) = self.dstllts { val.validate()? }
		Ok(())
	}
}


// AssetClassCommodityEnergy2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetClassCommodityEnergy2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Elctrcty", skip_serializing_if = "Option::is_none") )]
	pub elctrcty: Option<EnergyCommodityElectricity1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtrlGas", skip_serializing_if = "Option::is_none") )]
	pub ntrl_gas: Option<EnergyCommodityNaturalGas2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Oil", skip_serializing_if = "Option::is_none") )]
	pub oil: Option<EnergyCommodityOil2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Coal", skip_serializing_if = "Option::is_none") )]
	pub coal: Option<EnergyCommodityCoal1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrNrgy", skip_serializing_if = "Option::is_none") )]
	pub intr_nrgy: Option<EnergyCommodityInterEnergy1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RnwblNrgy", skip_serializing_if = "Option::is_none") )]
	pub rnwbl_nrgy: Option<EnergyCommodityRenewableEnergy1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LghtEnd", skip_serializing_if = "Option::is_none") )]
	pub lght_end: Option<EnergyCommodityLightEnd1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dstllts", skip_serializing_if = "Option::is_none") )]
	pub dstllts: Option<EnergyCommodityDistillates1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<EnergyCommodityOther1>,
}

impl AssetClassCommodityEnergy2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.elctrcty { val.validate()? }
		if let Some(ref val) = self.ntrl_gas { val.validate()? }
		if let Some(ref val) = self.oil { val.validate()? }
		if let Some(ref val) = self.coal { val.validate()? }
		if let Some(ref val) = self.intr_nrgy { val.validate()? }
		if let Some(ref val) = self.rnwbl_nrgy { val.validate()? }
		if let Some(ref val) = self.lght_end { val.validate()? }
		if let Some(ref val) = self.dstllts { val.validate()? }
		if let Some(ref val) = self.othr { val.validate()? }
		Ok(())
	}
}


// AssetClassCommodityEnergy3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetClassCommodityEnergy3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Elctrcty", skip_serializing_if = "Option::is_none") )]
	pub elctrcty: Option<EnergyCommodityElectricity2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtrlGas", skip_serializing_if = "Option::is_none") )]
	pub ntrl_gas: Option<EnergyCommodityNaturalGas3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Oil", skip_serializing_if = "Option::is_none") )]
	pub oil: Option<EnergyCommodityOil3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Coal", skip_serializing_if = "Option::is_none") )]
	pub coal: Option<EnergyCommodityCoal2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrNrgy", skip_serializing_if = "Option::is_none") )]
	pub intr_nrgy: Option<EnergyCommodityInterEnergy2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RnwblNrgy", skip_serializing_if = "Option::is_none") )]
	pub rnwbl_nrgy: Option<EnergyCommodityRenewableEnergy2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LghtEnd", skip_serializing_if = "Option::is_none") )]
	pub lght_end: Option<EnergyCommodityLightEnd2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dstllts", skip_serializing_if = "Option::is_none") )]
	pub dstllts: Option<EnergyCommodityDistillates2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<EnergyCommodityOther2>,
}

impl AssetClassCommodityEnergy3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.elctrcty { val.validate()? }
		if let Some(ref val) = self.ntrl_gas { val.validate()? }
		if let Some(ref val) = self.oil { val.validate()? }
		if let Some(ref val) = self.coal { val.validate()? }
		if let Some(ref val) = self.intr_nrgy { val.validate()? }
		if let Some(ref val) = self.rnwbl_nrgy { val.validate()? }
		if let Some(ref val) = self.lght_end { val.validate()? }
		if let Some(ref val) = self.dstllts { val.validate()? }
		if let Some(ref val) = self.othr { val.validate()? }
		Ok(())
	}
}


// AssetClassCommodityEnvironmental1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetClassCommodityEnvironmental1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Emssns", skip_serializing_if = "Option::is_none") )]
	pub emssns: Option<EnvironmentalCommodityEmission1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Wthr", skip_serializing_if = "Option::is_none") )]
	pub wthr: Option<EnvironmentalCommodityWeather1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CrbnRltd", skip_serializing_if = "Option::is_none") )]
	pub crbn_rltd: Option<EnvironmentalCommodityCarbonRelated1>,
}

impl AssetClassCommodityEnvironmental1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.emssns { val.validate()? }
		if let Some(ref val) = self.wthr { val.validate()? }
		if let Some(ref val) = self.crbn_rltd { val.validate()? }
		Ok(())
	}
}


// AssetClassCommodityEnvironmental2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetClassCommodityEnvironmental2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Emssns", skip_serializing_if = "Option::is_none") )]
	pub emssns: Option<EnvironmentalCommodityEmission2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Wthr", skip_serializing_if = "Option::is_none") )]
	pub wthr: Option<EnvironmentalCommodityWeather1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CrbnRltd", skip_serializing_if = "Option::is_none") )]
	pub crbn_rltd: Option<EnvironmentalCommodityCarbonRelated1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<EnvironmentCommodityOther1>,
}

impl AssetClassCommodityEnvironmental2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.emssns { val.validate()? }
		if let Some(ref val) = self.wthr { val.validate()? }
		if let Some(ref val) = self.crbn_rltd { val.validate()? }
		if let Some(ref val) = self.othr { val.validate()? }
		Ok(())
	}
}


// AssetClassCommodityEnvironmental3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetClassCommodityEnvironmental3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Emssns", skip_serializing_if = "Option::is_none") )]
	pub emssns: Option<EnvironmentalCommodityEmission3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Wthr", skip_serializing_if = "Option::is_none") )]
	pub wthr: Option<EnvironmentalCommodityWeather2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CrbnRltd", skip_serializing_if = "Option::is_none") )]
	pub crbn_rltd: Option<EnvironmentalCommodityCarbonRelated2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<EnvironmentCommodityOther2>,
}

impl AssetClassCommodityEnvironmental3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.emssns { val.validate()? }
		if let Some(ref val) = self.wthr { val.validate()? }
		if let Some(ref val) = self.crbn_rltd { val.validate()? }
		if let Some(ref val) = self.othr { val.validate()? }
		Ok(())
	}
}


// AssetClassCommodityFertilizer1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetClassCommodityFertilizer1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ammn", skip_serializing_if = "Option::is_none") )]
	pub ammn: Option<FertilizerCommodityAmmonia1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DmmnmPhspht", skip_serializing_if = "Option::is_none") )]
	pub dmmnm_phspht: Option<FertilizerCommodityDiammoniumPhosphate1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ptsh", skip_serializing_if = "Option::is_none") )]
	pub ptsh: Option<FertilizerCommodityPotash1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Slphr", skip_serializing_if = "Option::is_none") )]
	pub slphr: Option<FertilizerCommoditySulphur1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Urea", skip_serializing_if = "Option::is_none") )]
	pub urea: Option<FertilizerCommodityUrea1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UreaAndAmmnmNtrt", skip_serializing_if = "Option::is_none") )]
	pub urea_and_ammnm_ntrt: Option<FertilizerCommodityUreaAndAmmoniumNitrate1>,
}

impl AssetClassCommodityFertilizer1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ammn { val.validate()? }
		if let Some(ref val) = self.dmmnm_phspht { val.validate()? }
		if let Some(ref val) = self.ptsh { val.validate()? }
		if let Some(ref val) = self.slphr { val.validate()? }
		if let Some(ref val) = self.urea { val.validate()? }
		if let Some(ref val) = self.urea_and_ammnm_ntrt { val.validate()? }
		Ok(())
	}
}


// AssetClassCommodityFertilizer3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetClassCommodityFertilizer3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ammn", skip_serializing_if = "Option::is_none") )]
	pub ammn: Option<FertilizerCommodityAmmonia1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DmmnmPhspht", skip_serializing_if = "Option::is_none") )]
	pub dmmnm_phspht: Option<FertilizerCommodityDiammoniumPhosphate1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ptsh", skip_serializing_if = "Option::is_none") )]
	pub ptsh: Option<FertilizerCommodityPotash1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Slphr", skip_serializing_if = "Option::is_none") )]
	pub slphr: Option<FertilizerCommoditySulphur1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Urea", skip_serializing_if = "Option::is_none") )]
	pub urea: Option<FertilizerCommodityUrea1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UreaAndAmmnmNtrt", skip_serializing_if = "Option::is_none") )]
	pub urea_and_ammnm_ntrt: Option<FertilizerCommodityUreaAndAmmoniumNitrate1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<FertilizerCommodityOther1>,
}

impl AssetClassCommodityFertilizer3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ammn { val.validate()? }
		if let Some(ref val) = self.dmmnm_phspht { val.validate()? }
		if let Some(ref val) = self.ptsh { val.validate()? }
		if let Some(ref val) = self.slphr { val.validate()? }
		if let Some(ref val) = self.urea { val.validate()? }
		if let Some(ref val) = self.urea_and_ammnm_ntrt { val.validate()? }
		if let Some(ref val) = self.othr { val.validate()? }
		Ok(())
	}
}


// AssetClassCommodityFertilizer4Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetClassCommodityFertilizer4Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ammn", skip_serializing_if = "Option::is_none") )]
	pub ammn: Option<FertilizerCommodityAmmonia2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DmmnmPhspht", skip_serializing_if = "Option::is_none") )]
	pub dmmnm_phspht: Option<FertilizerCommodityDiammoniumPhosphate2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ptsh", skip_serializing_if = "Option::is_none") )]
	pub ptsh: Option<FertilizerCommodityPotash2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Slphr", skip_serializing_if = "Option::is_none") )]
	pub slphr: Option<FertilizerCommoditySulphur2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Urea", skip_serializing_if = "Option::is_none") )]
	pub urea: Option<FertilizerCommodityUrea2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UreaAndAmmnmNtrt", skip_serializing_if = "Option::is_none") )]
	pub urea_and_ammnm_ntrt: Option<FertilizerCommodityUreaAndAmmoniumNitrate2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<FertilizerCommodityOther2>,
}

impl AssetClassCommodityFertilizer4Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ammn { val.validate()? }
		if let Some(ref val) = self.dmmnm_phspht { val.validate()? }
		if let Some(ref val) = self.ptsh { val.validate()? }
		if let Some(ref val) = self.slphr { val.validate()? }
		if let Some(ref val) = self.urea { val.validate()? }
		if let Some(ref val) = self.urea_and_ammnm_ntrt { val.validate()? }
		if let Some(ref val) = self.othr { val.validate()? }
		Ok(())
	}
}


// AssetClassCommodityFreight1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetClassCommodityFreight1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dry", skip_serializing_if = "Option::is_none") )]
	pub dry: Option<FreightCommodityDry1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Wet", skip_serializing_if = "Option::is_none") )]
	pub wet: Option<FreightCommodityWet1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CntnrShip", skip_serializing_if = "Option::is_none") )]
	pub cntnr_ship: Option<FreightCommodityContainerShip1>,
}

impl AssetClassCommodityFreight1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.dry { val.validate()? }
		if let Some(ref val) = self.wet { val.validate()? }
		if let Some(ref val) = self.cntnr_ship { val.validate()? }
		Ok(())
	}
}


// AssetClassCommodityFreight3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetClassCommodityFreight3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dry", skip_serializing_if = "Option::is_none") )]
	pub dry: Option<FreightCommodityDry2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Wet", skip_serializing_if = "Option::is_none") )]
	pub wet: Option<FreightCommodityWet2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CntnrShip", skip_serializing_if = "Option::is_none") )]
	pub cntnr_ship: Option<FreightCommodityContainerShip1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<FreightCommodityOther1>,
}

impl AssetClassCommodityFreight3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.dry { val.validate()? }
		if let Some(ref val) = self.wet { val.validate()? }
		if let Some(ref val) = self.cntnr_ship { val.validate()? }
		if let Some(ref val) = self.othr { val.validate()? }
		Ok(())
	}
}


// AssetClassCommodityFreight4Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetClassCommodityFreight4Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dry", skip_serializing_if = "Option::is_none") )]
	pub dry: Option<FreightCommodityDry3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Wet", skip_serializing_if = "Option::is_none") )]
	pub wet: Option<FreightCommodityWet3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CntnrShip", skip_serializing_if = "Option::is_none") )]
	pub cntnr_ship: Option<FreightCommodityContainerShip2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<FreightCommodityOther2>,
}

impl AssetClassCommodityFreight4Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.dry { val.validate()? }
		if let Some(ref val) = self.wet { val.validate()? }
		if let Some(ref val) = self.cntnr_ship { val.validate()? }
		if let Some(ref val) = self.othr { val.validate()? }
		Ok(())
	}
}


// AssetClassCommodityIndex1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetClassCommodityIndex1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType16Code,
}

impl AssetClassCommodityIndex1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		Ok(())
	}
}


// AssetClassCommodityIndustrialProduct1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetClassCommodityIndustrialProduct1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cnstrctn", skip_serializing_if = "Option::is_none") )]
	pub cnstrctn: Option<IndustrialProductCommodityConstruction1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Manfctg", skip_serializing_if = "Option::is_none") )]
	pub manfctg: Option<IndustrialProductCommodityManufacturing1>,
}

impl AssetClassCommodityIndustrialProduct1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cnstrctn { val.validate()? }
		if let Some(ref val) = self.manfctg { val.validate()? }
		Ok(())
	}
}


// AssetClassCommodityIndustrialProduct2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetClassCommodityIndustrialProduct2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cnstrctn", skip_serializing_if = "Option::is_none") )]
	pub cnstrctn: Option<IndustrialProductCommodityConstruction2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Manfctg", skip_serializing_if = "Option::is_none") )]
	pub manfctg: Option<IndustrialProductCommodityManufacturing2>,
}

impl AssetClassCommodityIndustrialProduct2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cnstrctn { val.validate()? }
		if let Some(ref val) = self.manfctg { val.validate()? }
		Ok(())
	}
}


// AssetClassCommodityInflation1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetClassCommodityInflation1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType12Code,
}

impl AssetClassCommodityInflation1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		Ok(())
	}
}


// AssetClassCommodityMetal1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetClassCommodityMetal1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NonPrcs", skip_serializing_if = "Option::is_none") )]
	pub non_prcs: Option<MetalCommodityNonPrecious1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prcs", skip_serializing_if = "Option::is_none") )]
	pub prcs: Option<MetalCommodityPrecious1>,
}

impl AssetClassCommodityMetal1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.non_prcs { val.validate()? }
		if let Some(ref val) = self.prcs { val.validate()? }
		Ok(())
	}
}


// AssetClassCommodityMetal2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetClassCommodityMetal2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NonPrcs", skip_serializing_if = "Option::is_none") )]
	pub non_prcs: Option<MetalCommodityNonPrecious2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prcs", skip_serializing_if = "Option::is_none") )]
	pub prcs: Option<MetalCommodityPrecious2>,
}

impl AssetClassCommodityMetal2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.non_prcs { val.validate()? }
		if let Some(ref val) = self.prcs { val.validate()? }
		Ok(())
	}
}


// AssetClassCommodityMultiCommodityExotic1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetClassCommodityMultiCommodityExotic1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType13Code,
}

impl AssetClassCommodityMultiCommodityExotic1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		Ok(())
	}
}


// AssetClassCommodityOfficialEconomicStatistics1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetClassCommodityOfficialEconomicStatistics1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType14Code,
}

impl AssetClassCommodityOfficialEconomicStatistics1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		Ok(())
	}
}


// AssetClassCommodityOther1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetClassCommodityOther1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType15Code,
}

impl AssetClassCommodityOther1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		Ok(())
	}
}


// AssetClassCommodityOtherC102Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetClassCommodityOtherC102Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dlvrbl", skip_serializing_if = "Option::is_none") )]
	pub dlvrbl: Option<OtherC10CommodityDeliverable2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NonDlvrbl", skip_serializing_if = "Option::is_none") )]
	pub non_dlvrbl: Option<OtherC10CommodityNonDeliverable2>,
}

impl AssetClassCommodityOtherC102Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.dlvrbl { val.validate()? }
		if let Some(ref val) = self.non_dlvrbl { val.validate()? }
		Ok(())
	}
}


// AssetClassCommodityPaper1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetClassCommodityPaper1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CntnrBrd", skip_serializing_if = "Option::is_none") )]
	pub cntnr_brd: Option<PaperCommodityContainerBoard1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nwsprnt", skip_serializing_if = "Option::is_none") )]
	pub nwsprnt: Option<PaperCommodityNewsprint1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pulp", skip_serializing_if = "Option::is_none") )]
	pub pulp: Option<PaperCommodityPulp1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RcvrdPpr", skip_serializing_if = "Option::is_none") )]
	pub rcvrd_ppr: Option<PaperCommodityRecoveredPaper1>,
}

impl AssetClassCommodityPaper1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cntnr_brd { val.validate()? }
		if let Some(ref val) = self.nwsprnt { val.validate()? }
		if let Some(ref val) = self.pulp { val.validate()? }
		if let Some(ref val) = self.rcvrd_ppr { val.validate()? }
		Ok(())
	}
}


// AssetClassCommodityPaper3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetClassCommodityPaper3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CntnrBrd", skip_serializing_if = "Option::is_none") )]
	pub cntnr_brd: Option<PaperCommodityContainerBoard1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nwsprnt", skip_serializing_if = "Option::is_none") )]
	pub nwsprnt: Option<PaperCommodityNewsprint1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pulp", skip_serializing_if = "Option::is_none") )]
	pub pulp: Option<PaperCommodityPulp1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RcvrdPpr", skip_serializing_if = "Option::is_none") )]
	pub rcvrd_ppr: Option<PaperCommodityRecoveredPaper1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<PaperCommodityRecoveredPaper2>,
}

impl AssetClassCommodityPaper3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cntnr_brd { val.validate()? }
		if let Some(ref val) = self.nwsprnt { val.validate()? }
		if let Some(ref val) = self.pulp { val.validate()? }
		if let Some(ref val) = self.rcvrd_ppr { val.validate()? }
		if let Some(ref val) = self.othr { val.validate()? }
		Ok(())
	}
}


// AssetClassCommodityPaper4Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetClassCommodityPaper4Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CntnrBrd", skip_serializing_if = "Option::is_none") )]
	pub cntnr_brd: Option<PaperCommodityContainerBoard2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nwsprnt", skip_serializing_if = "Option::is_none") )]
	pub nwsprnt: Option<PaperCommodityNewsprint2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pulp", skip_serializing_if = "Option::is_none") )]
	pub pulp: Option<PaperCommodityPulp2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RcvrdPpr", skip_serializing_if = "Option::is_none") )]
	pub rcvrd_ppr: Option<PaperCommodityOther1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<PaperCommodityOther1>,
}

impl AssetClassCommodityPaper4Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cntnr_brd { val.validate()? }
		if let Some(ref val) = self.nwsprnt { val.validate()? }
		if let Some(ref val) = self.pulp { val.validate()? }
		if let Some(ref val) = self.rcvrd_ppr { val.validate()? }
		if let Some(ref val) = self.othr { val.validate()? }
		Ok(())
	}
}


// AssetClassCommodityPaper5Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetClassCommodityPaper5Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CntnrBrd", skip_serializing_if = "Option::is_none") )]
	pub cntnr_brd: Option<PaperCommodityContainerBoard2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nwsprnt", skip_serializing_if = "Option::is_none") )]
	pub nwsprnt: Option<PaperCommodityNewsprint2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pulp", skip_serializing_if = "Option::is_none") )]
	pub pulp: Option<PaperCommodityPulp2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RcvrdPpr", skip_serializing_if = "Option::is_none") )]
	pub rcvrd_ppr: Option<PaperCommodityRecoveredPaper3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<PaperCommodityOther1>,
}

impl AssetClassCommodityPaper5Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cntnr_brd { val.validate()? }
		if let Some(ref val) = self.nwsprnt { val.validate()? }
		if let Some(ref val) = self.pulp { val.validate()? }
		if let Some(ref val) = self.rcvrd_ppr { val.validate()? }
		if let Some(ref val) = self.othr { val.validate()? }
		Ok(())
	}
}


// AssetClassCommodityPolypropylene1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetClassCommodityPolypropylene1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Plstc", skip_serializing_if = "Option::is_none") )]
	pub plstc: Option<PolypropyleneCommodityPlastic1>,
}

impl AssetClassCommodityPolypropylene1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.plstc { val.validate()? }
		Ok(())
	}
}


// AssetClassCommodityPolypropylene3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetClassCommodityPolypropylene3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Plstc", skip_serializing_if = "Option::is_none") )]
	pub plstc: Option<PolypropyleneCommodityPlastic1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<PolypropyleneCommodityOther1>,
}

impl AssetClassCommodityPolypropylene3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.plstc { val.validate()? }
		if let Some(ref val) = self.othr { val.validate()? }
		Ok(())
	}
}


// AssetClassCommodityPolypropylene4Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetClassCommodityPolypropylene4Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Plstc", skip_serializing_if = "Option::is_none") )]
	pub plstc: Option<PolypropyleneCommodityPlastic2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<PolypropyleneCommodityOther2>,
}

impl AssetClassCommodityPolypropylene4Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.plstc { val.validate()? }
		if let Some(ref val) = self.othr { val.validate()? }
		Ok(())
	}
}


// AssetClassDetailedSubProductType10Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassDetailedSubProductType10Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ALUM") )]
	CodeALUM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ALUA") )]
	CodeALUA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CBLT") )]
	CodeCBLT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "COPR") )]
	CodeCOPR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IRON") )]
	CodeIRON,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MOLY") )]
	CodeMOLY,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NASC") )]
	CodeNASC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NICK") )]
	CodeNICK,
	#[cfg_attr( feature = "derive_serde", serde(rename = "STEL") )]
	CodeSTEL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TINN") )]
	CodeTINN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ZINC") )]
	CodeZINC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LEAD") )]
	CodeLEAD,
}

impl AssetClassDetailedSubProductType10Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassDetailedSubProductType11Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassDetailedSubProductType11Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "GOLD") )]
	CodeGOLD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PLDM") )]
	CodePLDM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PTNM") )]
	CodePTNM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SLVR") )]
	CodeSLVR,
}

impl AssetClassDetailedSubProductType11Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassDetailedSubProductType12Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassDetailedSubProductType12Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "TNKR") )]
	CodeTNKR,
}

impl AssetClassDetailedSubProductType12Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassDetailedSubProductType14Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassDetailedSubProductType14Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "DBCR") )]
	CodeDBCR,
}

impl AssetClassDetailedSubProductType14Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassDetailedSubProductType15Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassDetailedSubProductType15Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "MWHT") )]
	CodeMWHT,
}

impl AssetClassDetailedSubProductType15Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassDetailedSubProductType16Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassDetailedSubProductType16Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "FXCR") )]
	CodeFXCR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FXEM") )]
	CodeFXEM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FXMJ") )]
	CodeFXMJ,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FUEL") )]
	CodeFUEL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FOIL") )]
	CodeFOIL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GOIL") )]
	CodeGOIL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GSLN") )]
	CodeGSLN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GASP") )]
	CodeGASP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "HEAT") )]
	CodeHEAT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IRON") )]
	CodeIRON,
	#[cfg_attr( feature = "derive_serde", serde(rename = "JTFL") )]
	CodeJTFL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "KERO") )]
	CodeKERO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LAMP") )]
	CodeLAMP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LEAD") )]
	CodeLEAD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LLSO") )]
	CodeLLSO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LNGG") )]
	CodeLNGG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CORN") )]
	CodeCORN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MARS") )]
	CodeMARS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MWHT") )]
	CodeMWHT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MOLY") )]
	CodeMOLY,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NAPH") )]
	CodeNAPH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NBPG") )]
	CodeNBPG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NASC") )]
	CodeNASC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NCGG") )]
	CodeNCGG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NGLO") )]
	CodeNGLO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NICK") )]
	CodeNICK,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OFFP") )]
	CodeOFFP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ALUM") )]
	CodeALUM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ALUA") )]
	CodeALUA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BAKK") )]
	CodeBAKK,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BSLD") )]
	CodeBSLD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BDSL") )]
	CodeBDSL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BRNT") )]
	CodeBRNT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BRNX") )]
	CodeBRNX,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CNDA") )]
	CodeCNDA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CERE") )]
	CodeCERE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CBLT") )]
	CodeCBLT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CCOA") )]
	CodeCCOA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "COND") )]
	CodeCOND,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CSHP") )]
	CodeCSHP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "COPR") )]
	CodeCOPR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DSEL") )]
	CodeDSEL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DBCR") )]
	CodeDBCR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DUBA") )]
	CodeDUBA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ERUE") )]
	CodeERUE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ESPO") )]
	CodeESPO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ETHA") )]
	CodeETHA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EUAE") )]
	CodeEUAE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EUAA") )]
	CodeEUAA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FWHT") )]
	CodeFWHT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FITR") )]
	CodeFITR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PLDM") )]
	CodePLDM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PKLD") )]
	CodePKLD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PTNM") )]
	CodePTNM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "POTA") )]
	CodePOTA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RPSD") )]
	CodeRPSD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BRWN") )]
	CodeBRWN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RICE") )]
	CodeRICE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ROBU") )]
	CodeROBU,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SLVR") )]
	CodeSLVR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SOYB") )]
	CodeSOYB,
	#[cfg_attr( feature = "derive_serde", serde(rename = "STEL") )]
	CodeSTEL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TNKR") )]
	CodeTNKR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TAPI") )]
	CodeTAPI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TINN") )]
	CodeTINN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TTFG") )]
	CodeTTFG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "URAL") )]
	CodeURAL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "WHSG") )]
	CodeWHSG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "WTIO") )]
	CodeWTIO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ZINC") )]
	CodeZINC,
}

impl AssetClassDetailedSubProductType16Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassDetailedSubProductType1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetClassDetailedSubProductType1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<AssetClassDetailedSubProductType16Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification36>,
}

impl AssetClassDetailedSubProductType1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// AssetClassDetailedSubProductType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassDetailedSubProductType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "FWHT") )]
	CodeFWHT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SOYB") )]
	CodeSOYB,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RPSD") )]
	CodeRPSD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CORN") )]
	CodeCORN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RICE") )]
	CodeRICE,
}

impl AssetClassDetailedSubProductType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassDetailedSubProductType29Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassDetailedSubProductType29Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "LAMP") )]
	CodeLAMP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
}

impl AssetClassDetailedSubProductType29Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassDetailedSubProductType2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassDetailedSubProductType2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ROBU") )]
	CodeROBU,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CCOA") )]
	CodeCCOA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BRWN") )]
	CodeBRWN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "WHSG") )]
	CodeWHSG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
}

impl AssetClassDetailedSubProductType2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassDetailedSubProductType30Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassDetailedSubProductType30Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "MWHT") )]
	CodeMWHT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
}

impl AssetClassDetailedSubProductType30Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassDetailedSubProductType31Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassDetailedSubProductType31Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "GASP") )]
	CodeGASP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LNGG") )]
	CodeLNGG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NCGG") )]
	CodeNCGG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TTFG") )]
	CodeTTFG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NBPG") )]
	CodeNBPG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
}

impl AssetClassDetailedSubProductType31Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassDetailedSubProductType32Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassDetailedSubProductType32Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "BAKK") )]
	CodeBAKK,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BDSL") )]
	CodeBDSL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BRNT") )]
	CodeBRNT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BRNX") )]
	CodeBRNX,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CNDA") )]
	CodeCNDA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "COND") )]
	CodeCOND,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DSEL") )]
	CodeDSEL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DUBA") )]
	CodeDUBA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ESPO") )]
	CodeESPO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ETHA") )]
	CodeETHA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FUEL") )]
	CodeFUEL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FOIL") )]
	CodeFOIL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GOIL") )]
	CodeGOIL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GSLN") )]
	CodeGSLN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "HEAT") )]
	CodeHEAT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "JTFL") )]
	CodeJTFL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "KERO") )]
	CodeKERO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LLSO") )]
	CodeLLSO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MARS") )]
	CodeMARS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NAPH") )]
	CodeNAPH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NGLO") )]
	CodeNGLO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TAPI") )]
	CodeTAPI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "WTIO") )]
	CodeWTIO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "URAL") )]
	CodeURAL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
}

impl AssetClassDetailedSubProductType32Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassDetailedSubProductType33Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassDetailedSubProductType33Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "DBCR") )]
	CodeDBCR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
}

impl AssetClassDetailedSubProductType33Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassDetailedSubProductType34Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassDetailedSubProductType34Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "TNKR") )]
	CodeTNKR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
}

impl AssetClassDetailedSubProductType34Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassDetailedSubProductType4Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassDetailedSubProductType4Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "LAMP") )]
	CodeLAMP,
}

impl AssetClassDetailedSubProductType4Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassDetailedSubProductType5Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassDetailedSubProductType5Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "BSLD") )]
	CodeBSLD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FITR") )]
	CodeFITR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PKLD") )]
	CodePKLD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OFFP") )]
	CodeOFFP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
}

impl AssetClassDetailedSubProductType5Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassDetailedSubProductType6Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassDetailedSubProductType6Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "GASP") )]
	CodeGASP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LNGG") )]
	CodeLNGG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NCGG") )]
	CodeNCGG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TTFG") )]
	CodeTTFG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NBPG") )]
	CodeNBPG,
}

impl AssetClassDetailedSubProductType6Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassDetailedSubProductType7Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassDetailedSubProductType7Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "BAKK") )]
	CodeBAKK,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BDSL") )]
	CodeBDSL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BRNT") )]
	CodeBRNT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BRNX") )]
	CodeBRNX,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CNDA") )]
	CodeCNDA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "COND") )]
	CodeCOND,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DSEL") )]
	CodeDSEL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DUBA") )]
	CodeDUBA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ESPO") )]
	CodeESPO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ETHA") )]
	CodeETHA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FUEL") )]
	CodeFUEL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FOIL") )]
	CodeFOIL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GOIL") )]
	CodeGOIL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GSLN") )]
	CodeGSLN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "HEAT") )]
	CodeHEAT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "JTFL") )]
	CodeJTFL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "KERO") )]
	CodeKERO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LLSO") )]
	CodeLLSO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MARS") )]
	CodeMARS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NAPH") )]
	CodeNAPH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NGLO") )]
	CodeNGLO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TAPI") )]
	CodeTAPI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "WTIO") )]
	CodeWTIO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "URAL") )]
	CodeURAL,
}

impl AssetClassDetailedSubProductType7Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassDetailedSubProductType8Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassDetailedSubProductType8Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "CERE") )]
	CodeCERE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ERUE") )]
	CodeERUE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EUAE") )]
	CodeEUAE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EUAA") )]
	CodeEUAA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
}

impl AssetClassDetailedSubProductType8Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassProductType11Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassProductType11Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHC") )]
	CodeOTHC,
}

impl AssetClassProductType11Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassProductType12Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassProductType12Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "INFL") )]
	CodeINFL,
}

impl AssetClassProductType12Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassProductType13Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassProductType13Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "MCEX") )]
	CodeMCEX,
}

impl AssetClassProductType13Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassProductType14Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassProductType14Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "OEST") )]
	CodeOEST,
}

impl AssetClassProductType14Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassProductType15Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassProductType15Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
}

impl AssetClassProductType15Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassProductType16Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassProductType16Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "INDX") )]
	CodeINDX,
}

impl AssetClassProductType16Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassProductType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassProductType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "AGRI") )]
	CodeAGRI,
}

impl AssetClassProductType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassProductType2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassProductType2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "NRGY") )]
	CodeNRGY,
}

impl AssetClassProductType2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassProductType3Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassProductType3Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ENVR") )]
	CodeENVR,
}

impl AssetClassProductType3Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassProductType4Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassProductType4Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "FRGT") )]
	CodeFRGT,
}

impl AssetClassProductType4Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassProductType5Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassProductType5Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "FRTL") )]
	CodeFRTL,
}

impl AssetClassProductType5Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassProductType6Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassProductType6Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "INDP") )]
	CodeINDP,
}

impl AssetClassProductType6Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassProductType7Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassProductType7Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "METL") )]
	CodeMETL,
}

impl AssetClassProductType7Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassProductType8Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassProductType8Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "PAPR") )]
	CodePAPR,
}

impl AssetClassProductType8Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassProductType9Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassProductType9Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "POLY") )]
	CodePOLY,
}

impl AssetClassProductType9Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassSubProductType10Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassSubProductType10Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "EMIS") )]
	CodeEMIS,
}

impl AssetClassSubProductType10Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassSubProductType15Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassSubProductType15Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "NPRM") )]
	CodeNPRM,
}

impl AssetClassSubProductType15Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassSubProductType16Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassSubProductType16Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "PRME") )]
	CodePRME,
}

impl AssetClassSubProductType16Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassSubProductType18Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassSubProductType18Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "PLST") )]
	CodePLST,
}

impl AssetClassSubProductType18Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassSubProductType19Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassSubProductType19Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "DLVR") )]
	CodeDLVR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NDLV") )]
	CodeNDLV,
}

impl AssetClassSubProductType19Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassSubProductType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassSubProductType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "GROS") )]
	CodeGROS,
}

impl AssetClassSubProductType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassSubProductType20Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassSubProductType20Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "DIRY") )]
	CodeDIRY,
}

impl AssetClassSubProductType20Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassSubProductType21Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassSubProductType21Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "FRST") )]
	CodeFRST,
}

impl AssetClassSubProductType21Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassSubProductType22Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassSubProductType22Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "LSTK") )]
	CodeLSTK,
}

impl AssetClassSubProductType22Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassSubProductType23Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassSubProductType23Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "SEAF") )]
	CodeSEAF,
}

impl AssetClassSubProductType23Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassSubProductType24Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassSubProductType24Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "COAL") )]
	CodeCOAL,
}

impl AssetClassSubProductType24Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassSubProductType25Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassSubProductType25Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "DIST") )]
	CodeDIST,
}

impl AssetClassSubProductType25Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassSubProductType26Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassSubProductType26Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "INRG") )]
	CodeINRG,
}

impl AssetClassSubProductType26Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassSubProductType27Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassSubProductType27Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "LGHT") )]
	CodeLGHT,
}

impl AssetClassSubProductType27Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassSubProductType28Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassSubProductType28Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "RNNG") )]
	CodeRNNG,
}

impl AssetClassSubProductType28Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassSubProductType29Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassSubProductType29Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "CRBR") )]
	CodeCRBR,
}

impl AssetClassSubProductType29Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassSubProductType2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassSubProductType2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "SOFT") )]
	CodeSOFT,
}

impl AssetClassSubProductType2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassSubProductType30Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassSubProductType30Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "WTHR") )]
	CodeWTHR,
}

impl AssetClassSubProductType30Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassSubProductType31Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassSubProductType31Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "DRYF") )]
	CodeDRYF,
}

impl AssetClassSubProductType31Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassSubProductType32Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassSubProductType32Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "WETF") )]
	CodeWETF,
}

impl AssetClassSubProductType32Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassSubProductType33Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassSubProductType33Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "CSTR") )]
	CodeCSTR,
}

impl AssetClassSubProductType33Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassSubProductType34Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassSubProductType34Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "MFTG") )]
	CodeMFTG,
}

impl AssetClassSubProductType34Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassSubProductType35Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassSubProductType35Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "CBRD") )]
	CodeCBRD,
}

impl AssetClassSubProductType35Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassSubProductType36Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassSubProductType36Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "NSPT") )]
	CodeNSPT,
}

impl AssetClassSubProductType36Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassSubProductType37Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassSubProductType37Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "PULP") )]
	CodePULP,
}

impl AssetClassSubProductType37Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassSubProductType38Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassSubProductType38Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "RCVP") )]
	CodeRCVP,
}

impl AssetClassSubProductType38Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassSubProductType39Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassSubProductType39Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "AMMO") )]
	CodeAMMO,
}

impl AssetClassSubProductType39Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassSubProductType3Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassSubProductType3Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "OOLI") )]
	CodeOOLI,
}

impl AssetClassSubProductType3Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassSubProductType40Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassSubProductType40Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "DAPH") )]
	CodeDAPH,
}

impl AssetClassSubProductType40Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassSubProductType41Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassSubProductType41Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "PTSH") )]
	CodePTSH,
}

impl AssetClassSubProductType41Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassSubProductType42Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassSubProductType42Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "SLPH") )]
	CodeSLPH,
}

impl AssetClassSubProductType42Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassSubProductType43Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassSubProductType43Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "UREA") )]
	CodeUREA,
}

impl AssetClassSubProductType43Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassSubProductType44Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassSubProductType44Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "UAAN") )]
	CodeUAAN,
}

impl AssetClassSubProductType44Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassSubProductType45Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassSubProductType45Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "POTA") )]
	CodePOTA,
}

impl AssetClassSubProductType45Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassSubProductType46Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassSubProductType46Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "CSHP") )]
	CodeCSHP,
}

impl AssetClassSubProductType46Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassSubProductType47Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassSubProductType47Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "DLVR") )]
	CodeDLVR,
}

impl AssetClassSubProductType47Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassSubProductType48Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassSubProductType48Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "NDLV") )]
	CodeNDLV,
}

impl AssetClassSubProductType48Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassSubProductType49Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassSubProductType49Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
}

impl AssetClassSubProductType49Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassSubProductType50Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassSubProductType50Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RCVP") )]
	CodeRCVP,
}

impl AssetClassSubProductType50Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassSubProductType5Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassSubProductType5Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "GRIN") )]
	CodeGRIN,
}

impl AssetClassSubProductType5Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassSubProductType6Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassSubProductType6Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ELEC") )]
	CodeELEC,
}

impl AssetClassSubProductType6Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassSubProductType7Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassSubProductType7Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "NGAS") )]
	CodeNGAS,
}

impl AssetClassSubProductType7Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassSubProductType8Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassSubProductType8Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "OILP") )]
	CodeOILP,
}

impl AssetClassSubProductType8Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetClassTransactionType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetClassTransactionType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "CRCK") )]
	CodeCRCK,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DIFF") )]
	CodeDIFF,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FUTR") )]
	CodeFUTR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MINI") )]
	CodeMINI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OPTN") )]
	CodeOPTN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTCT") )]
	CodeOTCT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ORIT") )]
	CodeORIT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SWAP") )]
	CodeSWAP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TAPO") )]
	CodeTAPO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
}

impl AssetClassTransactionType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetFXSubProductType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetFXSubProductType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "FXCR") )]
	CodeFXCR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FXEM") )]
	CodeFXEM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FXMJ") )]
	CodeFXMJ,
}

impl AssetFXSubProductType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AssetHolding1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetHolding1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstHrcutVal") )]
	pub pst_hrcut_val: ActiveCurrencyAnd24Amount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AsstTp") )]
	pub asst_tp: AssetHolding1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollRqrmnt") )]
	pub coll_rqrmnt: CollateralAccountType3Code,
}

impl AssetHolding1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.pst_hrcut_val.validate()?;
		self.asst_tp.validate()?;
		self.coll_rqrmnt.validate()?;
		Ok(())
	}
}


// AssetHolding1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetHolding1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Gold", skip_serializing_if = "Option::is_none") )]
	pub gold: Option<ActiveCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Trpty", skip_serializing_if = "Option::is_none") )]
	pub trpty: Option<ActiveCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Csh", skip_serializing_if = "Option::is_none") )]
	pub csh: Option<ActiveCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Scty", skip_serializing_if = "Option::is_none") )]
	pub scty: Option<SecurityIdentificationAndAmount1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Grnt", skip_serializing_if = "Option::is_none") )]
	pub grnt: Option<Guarantee1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cmmdty", skip_serializing_if = "Option::is_none") )]
	pub cmmdty: Option<Commodity2>,
}

impl AssetHolding1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.gold { val.validate()? }
		if let Some(ref val) = self.trpty { val.validate()? }
		if let Some(ref val) = self.csh { val.validate()? }
		if let Some(ref val) = self.scty { val.validate()? }
		if let Some(ref val) = self.grnt { val.validate()? }
		if let Some(ref val) = self.cmmdty { val.validate()? }
		Ok(())
	}
}


// AssetHolding3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetHolding3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstHrcutVal") )]
	pub pst_hrcut_val: ActiveCurrencyAnd24Amount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AsstTp") )]
	pub asst_tp: AssetHolding3Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollRqrmnt") )]
	pub coll_rqrmnt: CollateralAccountType3Code,
}

impl AssetHolding3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.pst_hrcut_val.validate()?;
		self.asst_tp.validate()?;
		self.coll_rqrmnt.validate()?;
		Ok(())
	}
}


// AssetHolding3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AssetHolding3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Gold", skip_serializing_if = "Option::is_none") )]
	pub gold: Option<ActiveCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Trpty", skip_serializing_if = "Option::is_none") )]
	pub trpty: Option<TripartyCollateralAndAmount1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Csh", skip_serializing_if = "Option::is_none") )]
	pub csh: Option<ActiveCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Scty", skip_serializing_if = "Option::is_none") )]
	pub scty: Option<SecurityIdentificationAndAmount1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Grnt", skip_serializing_if = "Option::is_none") )]
	pub grnt: Option<Guarantee1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cmmdty", skip_serializing_if = "Option::is_none") )]
	pub cmmdty: Option<Commodity2>,
}

impl AssetHolding3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.gold { val.validate()? }
		if let Some(ref val) = self.trpty { val.validate()? }
		if let Some(ref val) = self.csh { val.validate()? }
		if let Some(ref val) = self.scty { val.validate()? }
		if let Some(ref val) = self.grnt { val.validate()? }
		if let Some(ref val) = self.cmmdty { val.validate()? }
		Ok(())
	}
}


// AssetPriceType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum AssetPriceType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ARGM") )]
	CodeARGM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BLTC") )]
	CodeBLTC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EXOF") )]
	CodeEXOF,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GBCL") )]
	CodeGBCL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IHSM") )]
	CodeIHSM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PLAT") )]
	CodePLAT,
}

impl AssetPriceType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AuctionData2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AuctionData2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradgPhs", skip_serializing_if = "Option::is_none") )]
	pub tradg_phs: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IndctvAuctnPric", skip_serializing_if = "Option::is_none") )]
	pub indctv_auctn_pric: Option<SecuritiesTransactionPrice21Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IndctvAuctnVol", skip_serializing_if = "Option::is_none") )]
	pub indctv_auctn_vol: Option<FinancialInstrumentQuantity25Choice>,
}

impl AuctionData2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tradg_phs {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tradg_phs is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 50 {
				return Err(ValidationError::new(1002, "tradg_phs exceeds the maximum length of 50".to_string()));
			}
		}
		if let Some(ref val) = self.indctv_auctn_pric { val.validate()? }
		if let Some(ref val) = self.indctv_auctn_vol { val.validate()? }
		Ok(())
	}
}


// AuthorityInvestigation2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AuthorityInvestigation2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: AuthorityRequestType1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InvstgtdRoles") )]
	pub invstgtd_roles: InvestigatedParties1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlInvstgtdPties", skip_serializing_if = "Option::is_none") )]
	pub addtl_invstgtd_pties: Option<InvestigatedParties1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_inf: Option<String>,
}

impl AuthorityInvestigation2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.tp.validate()?;
		self.invstgtd_roles.validate()?;
		if let Some(ref val) = self.addtl_invstgtd_pties { val.validate()? }
		if let Some(ref val) = self.addtl_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 500 {
				return Err(ValidationError::new(1002, "addtl_inf exceeds the maximum length of 500".to_string()));
			}
		}
		Ok(())
	}
}


// AuthorityRequestType1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AuthorityRequestType1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgNmId") )]
	pub msg_nm_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgNm", skip_serializing_if = "Option::is_none") )]
	pub msg_nm: Option<String>,
}

impl AuthorityRequestType1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.msg_nm_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "msg_nm_id is shorter than the minimum length of 1".to_string()));
		}
		if self.msg_nm_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "msg_nm_id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.msg_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "msg_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "msg_nm exceeds the maximum length of 140".to_string()));
			}
		}
		Ok(())
	}
}


// AvailableFinancialResourcesAmount1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct AvailableFinancialResourcesAmount1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlInitlMrgn") )]
	pub ttl_initl_mrgn: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlPrfnddDfltFnd") )]
	pub ttl_prfndd_dflt_fnd: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CCPSkinInTheGame") )]
	pub ccp_skin_in_the_game: Vec<ReportingAssetBreakdown1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrDfltFndCntrbtn") )]
	pub othr_dflt_fnd_cntrbtn: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UfnddMmbCmmtmnt") )]
	pub ufndd_mmb_cmmtmnt: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UfnddThrdPtyCmmtmnt") )]
	pub ufndd_thrd_pty_cmmtmnt: ActiveCurrencyAndAmount,
}

impl AvailableFinancialResourcesAmount1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.ttl_initl_mrgn.validate()?;
		self.ttl_prfndd_dflt_fnd.validate()?;
		for item in &self.ccp_skin_in_the_game { item.validate()? }
		self.othr_dflt_fnd_cntrbtn.validate()?;
		self.ufndd_mmb_cmmtmnt.validate()?;
		self.ufndd_thrd_pty_cmmtmnt.validate()?;
		Ok(())
	}
}


// BackTestingMethodology1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct BackTestingMethodology1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RskMdlTp") )]
	pub rsk_mdl_tp: ModelType1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MdlCnfdncLvl") )]
	pub mdl_cnfdnc_lvl: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VartnMrgnCleanInd") )]
	pub vartn_mrgn_clean_ind: bool,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Desc", skip_serializing_if = "Option::is_none") )]
	pub desc: Option<String>,
}

impl BackTestingMethodology1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.rsk_mdl_tp.validate()?;
		if let Some(ref val) = self.desc {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "desc is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 2000 {
				return Err(ValidationError::new(1002, "desc exceeds the maximum length of 2000".to_string()));
			}
		}
		Ok(())
	}
}


// BasketConstituents3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct BasketConstituents3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstrmId") )]
	pub instrm_id: InstrumentIdentification6Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Qty", skip_serializing_if = "Option::is_none") )]
	pub qty: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnitOfMeasr", skip_serializing_if = "Option::is_none") )]
	pub unit_of_measr: Option<UnitOfMeasure8Choice>,
}

impl BasketConstituents3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.instrm_id.validate()?;
		if let Some(ref val) = self.unit_of_measr { val.validate()? }
		Ok(())
	}
}


// BasketDescription3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct BasketDescription3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ISIN", skip_serializing_if = "Option::is_none") )]
	pub isin: Option<Vec<String>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Indx", skip_serializing_if = "Option::is_none") )]
	pub indx: Option<Vec<FinancialInstrument58>>,
}

impl BasketDescription3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.isin {
			for item in vec {
				let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
				if !pattern.is_match(&item) {
					return Err(ValidationError::new(1005, "isin does not match the required pattern".to_string()));
				}
			}
		}
		if let Some(ref vec) = self.indx { for item in vec { item.validate()? } }
		Ok(())
	}
}


// BasketQuery1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct BasketQuery1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Strr", skip_serializing_if = "Option::is_none") )]
	pub strr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Idr", skip_serializing_if = "Option::is_none") )]
	pub idr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ISIN", skip_serializing_if = "Option::is_none") )]
	pub isin: Option<String>,
}

impl BasketQuery1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.strr {
			let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "strr does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.idr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "idr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 52 {
				return Err(ValidationError::new(1002, "idr exceeds the maximum length of 52".to_string()));
			}
		}
		if let Some(ref val) = self.isin {
			let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "isin does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// BenchmarkCancellation1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct BenchmarkCancellation1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechRcrdId", skip_serializing_if = "Option::is_none") )]
	pub tech_rcrd_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: SecurityIdentification19,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl BenchmarkCancellation1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tech_rcrd_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tech_rcrd_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "tech_rcrd_id exceeds the maximum length of 35".to_string()));
			}
		}
		self.id.validate()?;
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// BenchmarkCreate1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct BenchmarkCreate1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechRcrdId", skip_serializing_if = "Option::is_none") )]
	pub tech_rcrd_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: SecurityIdentification19,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr") )]
	pub othr: BenchmarkDetail1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Admstr") )]
	pub admstr: PartyIdentification136,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NdrsngPty", skip_serializing_if = "Option::is_none") )]
	pub ndrsng_pty: Option<PartyIdentification136>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sts", skip_serializing_if = "Option::is_none") )]
	pub sts: Option<StatusDetail1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechVldtyPrd", skip_serializing_if = "Option::is_none") )]
	pub tech_vldty_prd: Option<Period4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl BenchmarkCreate1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tech_rcrd_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tech_rcrd_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "tech_rcrd_id exceeds the maximum length of 35".to_string()));
			}
		}
		self.id.validate()?;
		self.othr.validate()?;
		self.admstr.validate()?;
		if let Some(ref val) = self.ndrsng_pty { val.validate()? }
		if let Some(ref val) = self.sts { val.validate()? }
		if let Some(ref val) = self.tech_vldty_prd { val.validate()? }
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// BenchmarkCurveName10Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct BenchmarkCurveName10Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Indx", skip_serializing_if = "Option::is_none") )]
	pub indx: Option<BenchmarkCurveName3Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm", skip_serializing_if = "Option::is_none") )]
	pub nm: Option<String>,
}

impl BenchmarkCurveName10Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.indx { val.validate()? }
		if let Some(ref val) = self.nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 350 {
				return Err(ValidationError::new(1002, "nm exceeds the maximum length of 350".to_string()));
			}
		}
		Ok(())
	}
}


// BenchmarkCurveName2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum BenchmarkCurveName2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "WIBO") )]
	CodeWIBO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TREA") )]
	CodeTREA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TIBO") )]
	CodeTIBO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TLBO") )]
	CodeTLBO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SWAP") )]
	CodeSWAP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "STBO") )]
	CodeSTBO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PRBO") )]
	CodePRBO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PFAN") )]
	CodePFAN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NIBO") )]
	CodeNIBO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MAAA") )]
	CodeMAAA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MOSP") )]
	CodeMOSP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LIBO") )]
	CodeLIBO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LIBI") )]
	CodeLIBI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "JIBA") )]
	CodeJIBA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ISDA") )]
	CodeISDA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GCFR") )]
	CodeGCFR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FUSW") )]
	CodeFUSW,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EUCH") )]
	CodeEUCH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EUUS") )]
	CodeEUUS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EURI") )]
	CodeEURI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EONS") )]
	CodeEONS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EONA") )]
	CodeEONA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CIBO") )]
	CodeCIBO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CDOR") )]
	CodeCDOR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BUBO") )]
	CodeBUBO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BBSW") )]
	CodeBBSW,
}

impl BenchmarkCurveName2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// BenchmarkCurveName3Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum BenchmarkCurveName3Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ESTR") )]
	CodeESTR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BBSW") )]
	CodeBBSW,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BUBO") )]
	CodeBUBO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CDOR") )]
	CodeCDOR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CIBO") )]
	CodeCIBO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EONA") )]
	CodeEONA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EONS") )]
	CodeEONS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EURI") )]
	CodeEURI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EUUS") )]
	CodeEUUS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EUCH") )]
	CodeEUCH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FUSW") )]
	CodeFUSW,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GCFR") )]
	CodeGCFR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ISDA") )]
	CodeISDA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "JIBA") )]
	CodeJIBA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LIBI") )]
	CodeLIBI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LIBO") )]
	CodeLIBO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MOSP") )]
	CodeMOSP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MAAA") )]
	CodeMAAA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NIBO") )]
	CodeNIBO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PFAN") )]
	CodePFAN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PRBO") )]
	CodePRBO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "STBO") )]
	CodeSTBO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SWAP") )]
	CodeSWAP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TLBO") )]
	CodeTLBO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TIBO") )]
	CodeTIBO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TREA") )]
	CodeTREA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "WIBO") )]
	CodeWIBO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SOFR") )]
	CodeSOFR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SONA") )]
	CodeSONA,
}

impl BenchmarkCurveName3Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// BenchmarkCurveName4Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct BenchmarkCurveName4Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ISIN", skip_serializing_if = "Option::is_none") )]
	pub isin: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Indx", skip_serializing_if = "Option::is_none") )]
	pub indx: Option<BenchmarkCurveName2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm", skip_serializing_if = "Option::is_none") )]
	pub nm: Option<String>,
}

impl BenchmarkCurveName4Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.isin {
			let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "isin does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.indx { val.validate()? }
		if let Some(ref val) = self.nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 25 {
				return Err(ValidationError::new(1002, "nm exceeds the maximum length of 25".to_string()));
			}
		}
		Ok(())
	}
}


// BenchmarkCurveName5Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct BenchmarkCurveName5Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Indx", skip_serializing_if = "Option::is_none") )]
	pub indx: Option<BenchmarkCurveName2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm", skip_serializing_if = "Option::is_none") )]
	pub nm: Option<String>,
}

impl BenchmarkCurveName5Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.indx { val.validate()? }
		if let Some(ref val) = self.nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 25 {
				return Err(ValidationError::new(1002, "nm exceeds the maximum length of 25".to_string()));
			}
		}
		Ok(())
	}
}


// BenchmarkCurveName6Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct BenchmarkCurveName6Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ISIN", skip_serializing_if = "Option::is_none") )]
	pub isin: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Indx", skip_serializing_if = "Option::is_none") )]
	pub indx: Option<BenchmarkCurveName2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm", skip_serializing_if = "Option::is_none") )]
	pub nm: Option<String>,
}

impl BenchmarkCurveName6Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.isin {
			let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "isin does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.indx { val.validate()? }
		if let Some(ref val) = self.nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 25 {
				return Err(ValidationError::new(1002, "nm exceeds the maximum length of 25".to_string()));
			}
		}
		Ok(())
	}
}


// BenchmarkDetail1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct BenchmarkDetail1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FullNm") )]
	pub full_nm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Indx", skip_serializing_if = "Option::is_none") )]
	pub indx: Option<BenchmarkCurveName2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cmnt", skip_serializing_if = "Option::is_none") )]
	pub cmnt: Option<String>,
}

impl BenchmarkDetail1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.full_nm.chars().count() < 1 {
			return Err(ValidationError::new(1001, "full_nm is shorter than the minimum length of 1".to_string()));
		}
		if self.full_nm.chars().count() > 350 {
			return Err(ValidationError::new(1002, "full_nm exceeds the maximum length of 350".to_string()));
		}
		if let Some(ref val) = self.indx { val.validate()? }
		if let Some(ref val) = self.cmnt {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cmnt is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 20000 {
				return Err(ValidationError::new(1002, "cmnt exceeds the maximum length of 20000".to_string()));
			}
		}
		Ok(())
	}
}


// BenchmarkReport1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct BenchmarkReport1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cret", skip_serializing_if = "Option::is_none") )]
	pub cret: Option<BenchmarkCreate1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Upd", skip_serializing_if = "Option::is_none") )]
	pub upd: Option<BenchmarkUpdate1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cxl", skip_serializing_if = "Option::is_none") )]
	pub cxl: Option<BenchmarkCancellation1>,
}

impl BenchmarkReport1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cret { val.validate()? }
		if let Some(ref val) = self.upd { val.validate()? }
		if let Some(ref val) = self.cxl { val.validate()? }
		Ok(())
	}
}


// BenchmarkUpdate1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct BenchmarkUpdate1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechRcrdId", skip_serializing_if = "Option::is_none") )]
	pub tech_rcrd_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: SecurityIdentification19,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrvsId", skip_serializing_if = "Option::is_none") )]
	pub prvs_id: Option<SecurityIdentification19>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr") )]
	pub othr: BenchmarkDetail1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Admstr") )]
	pub admstr: PartyIdentification136,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NdrsngPty", skip_serializing_if = "Option::is_none") )]
	pub ndrsng_pty: Option<PartyIdentification136>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sts", skip_serializing_if = "Option::is_none") )]
	pub sts: Option<StatusDetail1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechVldtyPrd", skip_serializing_if = "Option::is_none") )]
	pub tech_vldty_prd: Option<Period4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl BenchmarkUpdate1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tech_rcrd_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tech_rcrd_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "tech_rcrd_id exceeds the maximum length of 35".to_string()));
			}
		}
		self.id.validate()?;
		if let Some(ref val) = self.prvs_id { val.validate()? }
		self.othr.validate()?;
		self.admstr.validate()?;
		if let Some(ref val) = self.ndrsng_pty { val.validate()? }
		if let Some(ref val) = self.sts { val.validate()? }
		if let Some(ref val) = self.tech_vldty_prd { val.validate()? }
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// BinaryFile1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct BinaryFile1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MIMETp", skip_serializing_if = "Option::is_none") )]
	pub mime_tp: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NcodgTp", skip_serializing_if = "Option::is_none") )]
	pub ncodg_tp: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CharSet", skip_serializing_if = "Option::is_none") )]
	pub char_set: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InclBinryObjct", skip_serializing_if = "Option::is_none") )]
	pub incl_binry_objct: Option<String>,
}

impl BinaryFile1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.mime_tp {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "mime_tp is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "mime_tp exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.ncodg_tp {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "ncodg_tp is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "ncodg_tp exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.char_set {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "char_set is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "char_set exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.incl_binry_objct {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "incl_binry_objct is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 102400 {
				return Err(ValidationError::new(1002, "incl_binry_objct exceeds the maximum length of 102400".to_string()));
			}
		}
		Ok(())
	}
}


// BondDerivative2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct BondDerivative2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr") )]
	pub issr: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MtrtyDt", skip_serializing_if = "Option::is_none") )]
	pub mtrty_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IssncDt", skip_serializing_if = "Option::is_none") )]
	pub issnc_dt: Option<String>,
}

impl BondDerivative2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
		if !pattern.is_match(&self.issr) {
			return Err(ValidationError::new(1005, "issr does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// BondType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum BondType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "EUSB") )]
	CodeEUSB,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OEPB") )]
	CodeOEPB,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CVTB") )]
	CodeCVTB,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CRPB") )]
	CodeCRPB,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CVDB") )]
	CodeCVDB,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
}

impl BondType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// Branch5Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Branch5Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<OrganisationIdentification15Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ctry", skip_serializing_if = "Option::is_none") )]
	pub ctry: Option<String>,
}

impl Branch5Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.id { val.validate()? }
		if let Some(ref val) = self.ctry {
			let pattern = Regex::new("[A-Z]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ctry does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// Branch6Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Branch6Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<PartyIdentification236Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ctry", skip_serializing_if = "Option::is_none") )]
	pub ctry: Option<String>,
}

impl Branch6Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.id { val.validate()? }
		if let Some(ref val) = self.ctry {
			let pattern = Regex::new("[A-Z]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ctry does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// BranchAndFinancialInstitutionIdentification8 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct BranchAndFinancialInstitutionIdentification8 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FinInstnId") )]
	pub fin_instn_id: FinancialInstitutionIdentification23,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BrnchId", skip_serializing_if = "Option::is_none") )]
	pub brnch_id: Option<BranchData5>,
}

impl BranchAndFinancialInstitutionIdentification8 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.fin_instn_id.validate()?;
		if let Some(ref val) = self.brnch_id { val.validate()? }
		Ok(())
	}
}


// BranchData5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct BranchData5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LEI", skip_serializing_if = "Option::is_none") )]
	pub lei: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm", skip_serializing_if = "Option::is_none") )]
	pub nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstlAdr", skip_serializing_if = "Option::is_none") )]
	pub pstl_adr: Option<PostalAddress27>,
}

impl BranchData5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.lei {
			let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "lei does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "nm exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.pstl_adr { val.validate()? }
		Ok(())
	}
}


// BrokeredDeal1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum BrokeredDeal1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "BILA") )]
	CodeBILA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BROK") )]
	CodeBROK,
}

impl BrokeredDeal1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// CancelOrderReport1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CancelOrderReport1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptId") )]
	pub rpt_id: String,
}

impl CancelOrderReport1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.rpt_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "rpt_id is shorter than the minimum length of 1".to_string()));
		}
		if self.rpt_id.chars().count() > 140 {
			return Err(ValidationError::new(1002, "rpt_id exceeds the maximum length of 140".to_string()));
		}
		Ok(())
	}
}


// CancelledStatusReason15Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum CancelledStatusReason15Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "CANI") )]
	CodeCANI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CSUB") )]
	CodeCSUB,
}

impl CancelledStatusReason15Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// CapitalRequirement1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CapitalRequirement1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "WndgDwnOrRstrgRsk") )]
	pub wndg_dwn_or_rstrg_rsk: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OprlAndLglRsk") )]
	pub oprl_and_lgl_rsk: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtRsk") )]
	pub cdt_rsk: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CntrPtyRsk") )]
	pub cntr_pty_rsk: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MktRsk") )]
	pub mkt_rsk: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BizRsk") )]
	pub biz_rsk: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtfctnBffr", skip_serializing_if = "Option::is_none") )]
	pub ntfctn_bffr: Option<f64>,
}

impl CapitalRequirement1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.wndg_dwn_or_rstrg_rsk.validate()?;
		self.oprl_and_lgl_rsk.validate()?;
		self.cdt_rsk.validate()?;
		self.cntr_pty_rsk.validate()?;
		self.mkt_rsk.validate()?;
		self.biz_rsk.validate()?;
		Ok(())
	}
}


// CashAccount40 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CashAccount40 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<AccountIdentification4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<CashAccountType2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ccy", skip_serializing_if = "Option::is_none") )]
	pub ccy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm", skip_serializing_if = "Option::is_none") )]
	pub nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prxy", skip_serializing_if = "Option::is_none") )]
	pub prxy: Option<ProxyAccountIdentification1>,
}

impl CashAccount40 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.id { val.validate()? }
		if let Some(ref val) = self.tp { val.validate()? }
		if let Some(ref val) = self.ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ccy does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 70 {
				return Err(ValidationError::new(1002, "nm exceeds the maximum length of 70".to_string()));
			}
		}
		if let Some(ref val) = self.prxy { val.validate()? }
		Ok(())
	}
}


// CashAccount43 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CashAccount43 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<AccountIdentification4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<CashAccountType2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ccy", skip_serializing_if = "Option::is_none") )]
	pub ccy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm", skip_serializing_if = "Option::is_none") )]
	pub nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prxy", skip_serializing_if = "Option::is_none") )]
	pub prxy: Option<ProxyAccountIdentification1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ownr", skip_serializing_if = "Option::is_none") )]
	pub ownr: Option<PartyIdentification272>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Svcr", skip_serializing_if = "Option::is_none") )]
	pub svcr: Option<BranchAndFinancialInstitutionIdentification8>,
}

impl CashAccount43 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.id { val.validate()? }
		if let Some(ref val) = self.tp { val.validate()? }
		if let Some(ref val) = self.ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ccy does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 70 {
				return Err(ValidationError::new(1002, "nm exceeds the maximum length of 70".to_string()));
			}
		}
		if let Some(ref val) = self.prxy { val.validate()? }
		if let Some(ref val) = self.ownr { val.validate()? }
		if let Some(ref val) = self.svcr { val.validate()? }
		Ok(())
	}
}


// CashAccountType2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CashAccountType2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl CashAccountType2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// CashCollateral5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CashCollateral5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollId", skip_serializing_if = "Option::is_none") )]
	pub coll_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshAcctId", skip_serializing_if = "Option::is_none") )]
	pub csh_acct_id: Option<AccountIdentification4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AsstNb", skip_serializing_if = "Option::is_none") )]
	pub asst_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DpstAmt", skip_serializing_if = "Option::is_none") )]
	pub dpst_amt: Option<ActiveCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DpstTp", skip_serializing_if = "Option::is_none") )]
	pub dpst_tp: Option<DepositType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MtrtyDt", skip_serializing_if = "Option::is_none") )]
	pub mtrty_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ValDt", skip_serializing_if = "Option::is_none") )]
	pub val_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XchgRate", skip_serializing_if = "Option::is_none") )]
	pub xchg_rate: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollVal") )]
	pub coll_val: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Hrcut", skip_serializing_if = "Option::is_none") )]
	pub hrcut: Option<f64>,
}

impl CashCollateral5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.coll_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "coll_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "coll_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.csh_acct_id { val.validate()? }
		if let Some(ref val) = self.asst_nb {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "asst_nb is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "asst_nb exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.dpst_amt { val.validate()? }
		if let Some(ref val) = self.dpst_tp { val.validate()? }
		self.coll_val.validate()?;
		Ok(())
	}
}


// CashCompare3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CashCompare3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val", skip_serializing_if = "Option::is_none") )]
	pub val: Option<CompareAmountAndDirection2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "HrcutOrMrgn", skip_serializing_if = "Option::is_none") )]
	pub hrcut_or_mrgn: Option<ComparePercentageRate3>,
}

impl CashCompare3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val { val.validate()? }
		if let Some(ref val) = self.hrcut_or_mrgn { val.validate()? }
		Ok(())
	}
}


// CashReuseData1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CashReuseData1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RinvstdCsh") )]
	pub rinvstd_csh: Vec<ReinvestedCashTypeAndAmount1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshRinvstmtRate") )]
	pub csh_rinvstmt_rate: f64,
}

impl CashReuseData1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		for item in &self.rinvstd_csh { item.validate()? }
		Ok(())
	}
}


// CertificateIdentification1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CertificateIdentification1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgId", skip_serializing_if = "Option::is_none") )]
	pub msg_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctSvcrRef", skip_serializing_if = "Option::is_none") )]
	pub acct_svcr_ref: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtInfId", skip_serializing_if = "Option::is_none") )]
	pub pmt_inf_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstrId", skip_serializing_if = "Option::is_none") )]
	pub instr_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EndToEndId", skip_serializing_if = "Option::is_none") )]
	pub end_to_end_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<ProprietaryReference1>,
}

impl CertificateIdentification1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.msg_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "msg_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "msg_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.acct_svcr_ref {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "acct_svcr_ref is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "acct_svcr_ref exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.pmt_inf_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "pmt_inf_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "pmt_inf_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.instr_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "instr_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "instr_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.end_to_end_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "end_to_end_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "end_to_end_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// CertificateReference2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CertificateReference2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: CertificateIdentification1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dt", skip_serializing_if = "Option::is_none") )]
	pub dt: Option<String>,
}

impl CertificateReference2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.id.validate()?;
		Ok(())
	}
}


// Cleared16Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Cleared16Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Clrd", skip_serializing_if = "Option::is_none") )]
	pub clrd: Option<ClearingPartyAndTime14>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NonClrd", skip_serializing_if = "Option::is_none") )]
	pub non_clrd: Option<NoReasonCode>,
}

impl Cleared16Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.clrd { val.validate()? }
		if let Some(ref val) = self.non_clrd { val.validate()? }
		Ok(())
	}
}


// Cleared23Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Cleared23Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Clrd", skip_serializing_if = "Option::is_none") )]
	pub clrd: Option<ClearingPartyAndTime21Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntndToClear", skip_serializing_if = "Option::is_none") )]
	pub intnd_to_clear: Option<ClearingPartyAndTime22Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NonClrd", skip_serializing_if = "Option::is_none") )]
	pub non_clrd: Option<ClearingExceptionOrExemption3Choice>,
}

impl Cleared23Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.clrd { val.validate()? }
		if let Some(ref val) = self.intnd_to_clear { val.validate()? }
		if let Some(ref val) = self.non_clrd { val.validate()? }
		Ok(())
	}
}


// Cleared4Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Cleared4Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Clrd", skip_serializing_if = "Option::is_none") )]
	pub clrd: Option<NoReasonCode>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NonClrd", skip_serializing_if = "Option::is_none") )]
	pub non_clrd: Option<NoReasonCode>,
}

impl Cleared4Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.clrd { val.validate()? }
		if let Some(ref val) = self.non_clrd { val.validate()? }
		Ok(())
	}
}


// ClearedProduct1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ClearedProduct1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradgVn") )]
	pub tradg_vn: Vec<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CCPPdctId") )]
	pub ccp_pdct_id: GenericIdentification168,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UvrslPdctId", skip_serializing_if = "Option::is_none") )]
	pub uvrsl_pdct_id: Option<GenericIdentification168>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pdct") )]
	pub pdct: Product1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OpnIntrst") )]
	pub opn_intrst: OpenInterest1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TrdsClrd", skip_serializing_if = "Option::is_none") )]
	pub trds_clrd: Option<f64>,
}

impl ClearedProduct1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		for item in &self.tradg_vn {
			let pattern = Regex::new("[A-Z0-9]{4,4}").unwrap();
			if !pattern.is_match(&item) {
				return Err(ValidationError::new(1005, "tradg_vn does not match the required pattern".to_string()));
			}
		}
		self.ccp_pdct_id.validate()?;
		if let Some(ref val) = self.uvrsl_pdct_id { val.validate()? }
		self.pdct.validate()?;
		self.opn_intrst.validate()?;
		if let Some(ref val) = self.trds_clrd {
			if *val < 0.000000 {
				return Err(ValidationError::new(1003, "trds_clrd is less than the minimum value of 0.000000".to_string()));
			}
		}
		Ok(())
	}
}


// ClearingAccount1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ClearingAccount1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctTp") )]
	pub acct_tp: ClearingAccountType3Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollAcctOwnr") )]
	pub coll_acct_ownr: Vec<CollateralAccount5>,
}

impl ClearingAccount1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.acct_tp.validate()?;
		for item in &self.coll_acct_ownr { item.validate()? }
		Ok(())
	}
}


// ClearingAccountType3Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum ClearingAccountType3Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "NOSA") )]
	CodeNOSA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ISEG") )]
	CodeISEG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "HOUS") )]
	CodeHOUS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GOSA") )]
	CodeGOSA,
}

impl ClearingAccountType3Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ClearingAccountType4Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum ClearingAccountType4Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "CLIE") )]
	CodeCLIE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "HOUS") )]
	CodeHOUS,
}

impl ClearingAccountType4Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ClearingExceptionOrExemption2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ClearingExceptionOrExemption2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgCtrPty") )]
	pub rptg_ctr_pty: NonClearingReason2,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrCtrPty", skip_serializing_if = "Option::is_none") )]
	pub othr_ctr_pty: Option<NonClearingReason2>,
}

impl ClearingExceptionOrExemption2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.rptg_ctr_pty.validate()?;
		if let Some(ref val) = self.othr_ctr_pty { val.validate()? }
		Ok(())
	}
}


// ClearingExceptionOrExemption3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ClearingExceptionOrExemption3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn", skip_serializing_if = "Option::is_none") )]
	pub rsn: Option<NoReasonCode>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPties", skip_serializing_if = "Option::is_none") )]
	pub ctr_pties: Option<ClearingExceptionOrExemption2>,
}

impl ClearingExceptionOrExemption3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.rsn { val.validate()? }
		if let Some(ref val) = self.ctr_pties { val.validate()? }
		Ok(())
	}
}


// ClearingExemptionException1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum ClearingExemptionException1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "COOP") )]
	CodeCOOP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ENDU") )]
	CodeENDU,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AFFL") )]
	CodeAFFL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NOAL") )]
	CodeNOAL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NORE") )]
	CodeNORE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SMBK") )]
	CodeSMBK,
}

impl ClearingExemptionException1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ClearingMember1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ClearingMember1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: PartyIdentification118Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtQlty") )]
	pub cdt_qlty: CreditQuality1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UltmtPrntId", skip_serializing_if = "Option::is_none") )]
	pub ultmt_prnt_id: Option<PartyIdentification118Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FutrsComssnMrchntInd") )]
	pub futrs_comssn_mrchnt_ind: bool,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MmbshVldFr") )]
	pub mmbsh_vld_fr: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MmbshVldTo", skip_serializing_if = "Option::is_none") )]
	pub mmbsh_vld_to: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SpnsrgClrMmbId", skip_serializing_if = "Option::is_none") )]
	pub spnsrg_clr_mmb_id: Option<PartyIdentification118Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrAcctOwnr") )]
	pub clr_acct_ownr: Vec<ClearingAccount1>,
}

impl ClearingMember1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.id.validate()?;
		self.cdt_qlty.validate()?;
		if let Some(ref val) = self.ultmt_prnt_id { val.validate()? }
		if let Some(ref val) = self.spnsrg_clr_mmb_id { val.validate()? }
		for item in &self.clr_acct_ownr { item.validate()? }
		Ok(())
	}
}


// ClearingObligationType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum ClearingObligationType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "FLSE") )]
	CodeFLSE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UKWN") )]
	CodeUKWN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TRUE") )]
	CodeTRUE,
}

impl ClearingObligationType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ClearingPartyAndTime14 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ClearingPartyAndTime14 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CCP", skip_serializing_if = "Option::is_none") )]
	pub ccp: Option<OrganisationIdentification15Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrDtTm", skip_serializing_if = "Option::is_none") )]
	pub clr_dt_tm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptTrckgNb", skip_serializing_if = "Option::is_none") )]
	pub rpt_trckg_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrtflCd", skip_serializing_if = "Option::is_none") )]
	pub prtfl_cd: Option<String>,
}

impl ClearingPartyAndTime14 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ccp { val.validate()? }
		if let Some(ref val) = self.rpt_trckg_nb {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "rpt_trckg_nb is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 52 {
				return Err(ValidationError::new(1002, "rpt_trckg_nb exceeds the maximum length of 52".to_string()));
			}
		}
		if let Some(ref val) = self.prtfl_cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtfl_cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 52 {
				return Err(ValidationError::new(1002, "prtfl_cd exceeds the maximum length of 52".to_string()));
			}
		}
		Ok(())
	}
}


// ClearingPartyAndTime21Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ClearingPartyAndTime21Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn", skip_serializing_if = "Option::is_none") )]
	pub rsn: Option<NoReasonCode>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dtls", skip_serializing_if = "Option::is_none") )]
	pub dtls: Option<ClearingPartyAndTime22>,
}

impl ClearingPartyAndTime21Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.rsn { val.validate()? }
		if let Some(ref val) = self.dtls { val.validate()? }
		Ok(())
	}
}


// ClearingPartyAndTime22 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ClearingPartyAndTime22 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CCP", skip_serializing_if = "Option::is_none") )]
	pub ccp: Option<OrganisationIdentification15Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrRctDtTm", skip_serializing_if = "Option::is_none") )]
	pub clr_rct_dt_tm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrDtTm", skip_serializing_if = "Option::is_none") )]
	pub clr_dt_tm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrIdr", skip_serializing_if = "Option::is_none") )]
	pub clr_idr: Option<UniqueTransactionIdentifier2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlIdr", skip_serializing_if = "Option::is_none") )]
	pub orgnl_idr: Option<UniqueTransactionIdentifier2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlTradRpstryIdr", skip_serializing_if = "Option::is_none") )]
	pub orgnl_trad_rpstry_idr: Option<OrganisationIdentification15Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrAcctOrgn", skip_serializing_if = "Option::is_none") )]
	pub clr_acct_orgn: Option<ClearingAccountType4Code>,
}

impl ClearingPartyAndTime22 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ccp { val.validate()? }
		if let Some(ref val) = self.clr_idr { val.validate()? }
		if let Some(ref val) = self.orgnl_idr { val.validate()? }
		if let Some(ref val) = self.orgnl_trad_rpstry_idr { val.validate()? }
		if let Some(ref val) = self.clr_acct_orgn { val.validate()? }
		Ok(())
	}
}


// ClearingPartyAndTime22Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ClearingPartyAndTime22Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn", skip_serializing_if = "Option::is_none") )]
	pub rsn: Option<NoReasonCode>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dtls", skip_serializing_if = "Option::is_none") )]
	pub dtls: Option<ClearingPartyAndTime23>,
}

impl ClearingPartyAndTime22Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.rsn { val.validate()? }
		if let Some(ref val) = self.dtls { val.validate()? }
		Ok(())
	}
}


// ClearingPartyAndTime23 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ClearingPartyAndTime23 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CCP", skip_serializing_if = "Option::is_none") )]
	pub ccp: Option<OrganisationIdentification15Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrRctDtTm", skip_serializing_if = "Option::is_none") )]
	pub clr_rct_dt_tm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrDtTm", skip_serializing_if = "Option::is_none") )]
	pub clr_dt_tm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrIdr", skip_serializing_if = "Option::is_none") )]
	pub clr_idr: Option<UniqueTransactionIdentifier1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlIdr", skip_serializing_if = "Option::is_none") )]
	pub orgnl_idr: Option<UniqueTransactionIdentifier1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlTradRpstryIdr", skip_serializing_if = "Option::is_none") )]
	pub orgnl_trad_rpstry_idr: Option<OrganisationIdentification15Choice>,
}

impl ClearingPartyAndTime23 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ccp { val.validate()? }
		if let Some(ref val) = self.clr_idr { val.validate()? }
		if let Some(ref val) = self.orgnl_idr { val.validate()? }
		if let Some(ref val) = self.orgnl_trad_rpstry_idr { val.validate()? }
		Ok(())
	}
}


// ClearingSystemIdentification2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ClearingSystemIdentification2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl ClearingSystemIdentification2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 5 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 5".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// ClearingSystemMemberIdentification2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ClearingSystemMemberIdentification2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrSysId", skip_serializing_if = "Option::is_none") )]
	pub clr_sys_id: Option<ClearingSystemIdentification2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MmbId") )]
	pub mmb_id: String,
}

impl ClearingSystemMemberIdentification2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.clr_sys_id { val.validate()? }
		if self.mmb_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "mmb_id is shorter than the minimum length of 1".to_string()));
		}
		if self.mmb_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "mmb_id exceeds the maximum length of 35".to_string()));
		}
		Ok(())
	}
}


// Collateral18 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Collateral18 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Valtn") )]
	pub valtn: SecuredCollateral2Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Hrcut", skip_serializing_if = "Option::is_none") )]
	pub hrcut: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SpclCollInd", skip_serializing_if = "Option::is_none") )]
	pub spcl_coll_ind: Option<SpecialCollateral2Code>,
}

impl Collateral18 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.valtn.validate()?;
		if let Some(ref val) = self.spcl_coll_ind { val.validate()? }
		Ok(())
	}
}


// Collateral52 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Collateral52 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollValDt", skip_serializing_if = "Option::is_none") )]
	pub coll_val_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AsstTp", skip_serializing_if = "Option::is_none") )]
	pub asst_tp: Option<CollateralType21>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NetXpsrCollstnInd", skip_serializing_if = "Option::is_none") )]
	pub net_xpsr_collstn_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BsktIdr", skip_serializing_if = "Option::is_none") )]
	pub bskt_idr: Option<SecurityIdentification26Choice>,
}

impl Collateral52 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.asst_tp { val.validate()? }
		if let Some(ref val) = self.bskt_idr { val.validate()? }
		Ok(())
	}
}


// CollateralAccount4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CollateralAccount4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: GenericIdentification165,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AsstHldg") )]
	pub asst_hldg: Vec<AssetHolding1>,
}

impl CollateralAccount4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.id.validate()?;
		for item in &self.asst_hldg { item.validate()? }
		Ok(())
	}
}


// CollateralAccount5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CollateralAccount5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: PartyIdentification118Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RltdMrgnAcct") )]
	pub rltd_mrgn_acct: Vec<MarginAccount1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TitlTrfCollArrgmnt", skip_serializing_if = "Option::is_none") )]
	pub titl_trf_coll_arrgmnt: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollSgrtnByVal", skip_serializing_if = "Option::is_none") )]
	pub coll_sgrtn_by_val: Option<bool>,
}

impl CollateralAccount5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.id.validate()?;
		for item in &self.rltd_mrgn_acct { item.validate()? }
		Ok(())
	}
}


// CollateralAccountType3Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum CollateralAccountType3Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "MGIN") )]
	CodeMGIN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DFLT") )]
	CodeDFLT,
}

impl CollateralAccountType3Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// CollateralData33 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CollateralData33 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NetXpsrCollstnInd", skip_serializing_if = "Option::is_none") )]
	pub net_xpsr_collstn_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CmpntTp", skip_serializing_if = "Option::is_none") )]
	pub cmpnt_tp: Option<CollateralType6Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshCollCcy", skip_serializing_if = "Option::is_none") )]
	pub csh_coll_ccy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PricCcy", skip_serializing_if = "Option::is_none") )]
	pub pric_ccy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Qlty", skip_serializing_if = "Option::is_none") )]
	pub qlty: Option<CollateralQualityType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Mtrty", skip_serializing_if = "Option::is_none") )]
	pub mtrty: Option<ContractTerm6Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IssrJursdctn", skip_serializing_if = "Option::is_none") )]
	pub issr_jursdctn: Option<IssuerJurisdiction1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<SecuritiesLendingType3Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradRpstry", skip_serializing_if = "Option::is_none") )]
	pub trad_rpstry: Option<OrganisationIdentification15Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RcncltnFlg", skip_serializing_if = "Option::is_none") )]
	pub rcncltn_flg: Option<ReconciliationFlag2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RinvstdCsh", skip_serializing_if = "Option::is_none") )]
	pub rinvstd_csh: Option<ReinvestedCashTypeAndAmount2>,
}

impl CollateralData33 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cmpnt_tp { val.validate()? }
		if let Some(ref val) = self.csh_coll_ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "csh_coll_ccy does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.pric_ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "pric_ccy does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.qlty { val.validate()? }
		if let Some(ref val) = self.mtrty { val.validate()? }
		if let Some(ref val) = self.issr_jursdctn { val.validate()? }
		if let Some(ref val) = self.tp { val.validate()? }
		if let Some(ref val) = self.trad_rpstry { val.validate()? }
		if let Some(ref val) = self.rcncltn_flg { val.validate()? }
		if let Some(ref val) = self.rinvstd_csh { val.validate()? }
		Ok(())
	}
}


// CollateralData35 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CollateralData35 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AsstTp", skip_serializing_if = "Option::is_none") )]
	pub asst_tp: Option<CollateralType21>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NetXpsrCollstnInd", skip_serializing_if = "Option::is_none") )]
	pub net_xpsr_collstn_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BsktIdr", skip_serializing_if = "Option::is_none") )]
	pub bskt_idr: Option<SecurityIdentification26Choice>,
}

impl CollateralData35 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.asst_tp { val.validate()? }
		if let Some(ref val) = self.bskt_idr { val.validate()? }
		Ok(())
	}
}


// CollateralDeliveryMethod1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum CollateralDeliveryMethod1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "SICA") )]
	CodeSICA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SIUR") )]
	CodeSIUR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TTCA") )]
	CodeTTCA,
}

impl CollateralDeliveryMethod1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// CollateralFlag13Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CollateralFlag13Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Collsd", skip_serializing_if = "Option::is_none") )]
	pub collsd: Option<CollaterisedData12>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Uncollsd", skip_serializing_if = "Option::is_none") )]
	pub uncollsd: Option<NoReasonCode>,
}

impl CollateralFlag13Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.collsd { val.validate()? }
		if let Some(ref val) = self.uncollsd { val.validate()? }
		Ok(())
	}
}


// CollateralMarginCorrection6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CollateralMarginCorrection6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechRcrdId", skip_serializing_if = "Option::is_none") )]
	pub tech_rcrd_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgDtTm") )]
	pub rptg_dt_tm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EvtDt") )]
	pub evt_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPty") )]
	pub ctr_pty: Counterparty39,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollPrtflId") )]
	pub coll_prtfl_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstdMrgnOrColl", skip_serializing_if = "Option::is_none") )]
	pub pstd_mrgn_or_coll: Option<PostedMarginOrCollateral4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RcvdMrgnOrColl", skip_serializing_if = "Option::is_none") )]
	pub rcvd_mrgn_or_coll: Option<ReceivedMarginOrCollateral4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl CollateralMarginCorrection6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tech_rcrd_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tech_rcrd_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "tech_rcrd_id exceeds the maximum length of 140".to_string()));
			}
		}
		self.ctr_pty.validate()?;
		if self.coll_prtfl_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "coll_prtfl_id is shorter than the minimum length of 1".to_string()));
		}
		if self.coll_prtfl_id.chars().count() > 52 {
			return Err(ValidationError::new(1002, "coll_prtfl_id exceeds the maximum length of 52".to_string()));
		}
		if let Some(ref val) = self.pstd_mrgn_or_coll { val.validate()? }
		if let Some(ref val) = self.rcvd_mrgn_or_coll { val.validate()? }
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// CollateralMarginError4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CollateralMarginError4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechRcrdId", skip_serializing_if = "Option::is_none") )]
	pub tech_rcrd_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgDtTm") )]
	pub rptg_dt_tm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPty") )]
	pub ctr_pty: Counterparty39,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollPrtflId") )]
	pub coll_prtfl_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl CollateralMarginError4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tech_rcrd_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tech_rcrd_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "tech_rcrd_id exceeds the maximum length of 140".to_string()));
			}
		}
		self.ctr_pty.validate()?;
		if self.coll_prtfl_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "coll_prtfl_id is shorter than the minimum length of 1".to_string()));
		}
		if self.coll_prtfl_id.chars().count() > 52 {
			return Err(ValidationError::new(1002, "coll_prtfl_id exceeds the maximum length of 52".to_string()));
		}
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// CollateralMarginMarginUpdate5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CollateralMarginMarginUpdate5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechRcrdId", skip_serializing_if = "Option::is_none") )]
	pub tech_rcrd_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgDtTm") )]
	pub rptg_dt_tm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EvtDt") )]
	pub evt_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPty", skip_serializing_if = "Option::is_none") )]
	pub ctr_pty: Option<Counterparty39>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollPrtflId") )]
	pub coll_prtfl_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstdMrgnOrColl", skip_serializing_if = "Option::is_none") )]
	pub pstd_mrgn_or_coll: Option<PostedMarginOrCollateral4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RcvdMrgnOrColl", skip_serializing_if = "Option::is_none") )]
	pub rcvd_mrgn_or_coll: Option<ReceivedMarginOrCollateral4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl CollateralMarginMarginUpdate5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tech_rcrd_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tech_rcrd_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "tech_rcrd_id exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.ctr_pty { val.validate()? }
		if self.coll_prtfl_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "coll_prtfl_id is shorter than the minimum length of 1".to_string()));
		}
		if self.coll_prtfl_id.chars().count() > 52 {
			return Err(ValidationError::new(1002, "coll_prtfl_id exceeds the maximum length of 52".to_string()));
		}
		if let Some(ref val) = self.pstd_mrgn_or_coll { val.validate()? }
		if let Some(ref val) = self.rcvd_mrgn_or_coll { val.validate()? }
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// CollateralMarginNew10 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CollateralMarginNew10 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechRcrdId", skip_serializing_if = "Option::is_none") )]
	pub tech_rcrd_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgDtTm") )]
	pub rptg_dt_tm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EvtDt") )]
	pub evt_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPty") )]
	pub ctr_pty: Counterparty39,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollPrtflId") )]
	pub coll_prtfl_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstdMrgnOrColl", skip_serializing_if = "Option::is_none") )]
	pub pstd_mrgn_or_coll: Option<PostedMarginOrCollateral4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RcvdMrgnOrColl", skip_serializing_if = "Option::is_none") )]
	pub rcvd_mrgn_or_coll: Option<ReceivedMarginOrCollateral4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RcncltnFlg", skip_serializing_if = "Option::is_none") )]
	pub rcncltn_flg: Option<ReconciliationFlag2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrctMod") )]
	pub ctrct_mod: ContractModification3,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl CollateralMarginNew10 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tech_rcrd_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tech_rcrd_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "tech_rcrd_id exceeds the maximum length of 140".to_string()));
			}
		}
		self.ctr_pty.validate()?;
		if self.coll_prtfl_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "coll_prtfl_id is shorter than the minimum length of 1".to_string()));
		}
		if self.coll_prtfl_id.chars().count() > 52 {
			return Err(ValidationError::new(1002, "coll_prtfl_id exceeds the maximum length of 52".to_string()));
		}
		if let Some(ref val) = self.pstd_mrgn_or_coll { val.validate()? }
		if let Some(ref val) = self.rcvd_mrgn_or_coll { val.validate()? }
		if let Some(ref val) = self.rcncltn_flg { val.validate()? }
		self.ctrct_mod.validate()?;
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// CollateralMatchingCriteria6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CollateralMatchingCriteria6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "UncollsdFlg", skip_serializing_if = "Option::is_none") )]
	pub uncollsd_flg: Option<CompareTrueFalseIndicator3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NetXpsrCollstnInd", skip_serializing_if = "Option::is_none") )]
	pub net_xpsr_collstn_ind: Option<CompareTrueFalseIndicator3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollValDt", skip_serializing_if = "Option::is_none") )]
	pub coll_val_dt: Option<CompareDate3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AsstTp", skip_serializing_if = "Option::is_none") )]
	pub asst_tp: Option<SecurityCommodityCash4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BsktIdr", skip_serializing_if = "Option::is_none") )]
	pub bskt_idr: Option<CompareSecurityIdentification4>,
}

impl CollateralMatchingCriteria6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.uncollsd_flg { val.validate()? }
		if let Some(ref val) = self.net_xpsr_collstn_ind { val.validate()? }
		if let Some(ref val) = self.coll_val_dt { val.validate()? }
		if let Some(ref val) = self.asst_tp { val.validate()? }
		if let Some(ref val) = self.bskt_idr { val.validate()? }
		Ok(())
	}
}


// CollateralPool1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum CollateralPool1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "NOPL") )]
	CodeNOPL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "POOL") )]
	CodePOOL,
}

impl CollateralPool1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// CollateralPortfolioCode5Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CollateralPortfolioCode5Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtfl", skip_serializing_if = "Option::is_none") )]
	pub prtfl: Option<PortfolioCode3Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MrgnPrtflCd", skip_serializing_if = "Option::is_none") )]
	pub mrgn_prtfl_cd: Option<MarginPortfolio3>,
}

impl CollateralPortfolioCode5Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.prtfl { val.validate()? }
		if let Some(ref val) = self.mrgn_prtfl_cd { val.validate()? }
		Ok(())
	}
}


// CollateralPortfolioCode6Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CollateralPortfolioCode6Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtfl", skip_serializing_if = "Option::is_none") )]
	pub prtfl: Option<PortfolioCode3Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MrgnPrtflCd", skip_serializing_if = "Option::is_none") )]
	pub mrgn_prtfl_cd: Option<MarginPortfolio4>,
}

impl CollateralPortfolioCode6Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.prtfl { val.validate()? }
		if let Some(ref val) = self.mrgn_prtfl_cd { val.validate()? }
		Ok(())
	}
}


// CollateralQualityType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum CollateralQualityType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "INVG") )]
	CodeINVG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NIVG") )]
	CodeNIVG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NOTR") )]
	CodeNOTR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NOAP") )]
	CodeNOAP,
}

impl CollateralQualityType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// CollateralRole1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum CollateralRole1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "GIVE") )]
	CodeGIVE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TAKE") )]
	CodeTAKE,
}

impl CollateralRole1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// CollateralType19 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CollateralType19 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Scty", skip_serializing_if = "Option::is_none") )]
	pub scty: Option<Vec<SecurityReuseData1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Csh", skip_serializing_if = "Option::is_none") )]
	pub csh: Option<Vec<CashReuseData1>>,
}

impl CollateralType19 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.scty { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.csh { for item in vec { item.validate()? } }
		Ok(())
	}
}


// CollateralType21 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CollateralType21 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Scty", skip_serializing_if = "Option::is_none") )]
	pub scty: Option<Vec<Security52>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Csh", skip_serializing_if = "Option::is_none") )]
	pub csh: Option<Vec<AmountHaircutMargin1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cmmdty", skip_serializing_if = "Option::is_none") )]
	pub cmmdty: Option<Vec<Commodity43>>,
}

impl CollateralType21 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.scty { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.csh { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.cmmdty { for item in vec { item.validate()? } }
		Ok(())
	}
}


// CollateralType22Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CollateralType22Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "GnlColl", skip_serializing_if = "Option::is_none") )]
	pub gnl_coll: Option<GeneralCollateral4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SpcfcColl", skip_serializing_if = "Option::is_none") )]
	pub spcfc_coll: Option<SpecificCollateral3>,
}

impl CollateralType22Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.gnl_coll { val.validate()? }
		if let Some(ref val) = self.spcfc_coll { val.validate()? }
		Ok(())
	}
}


// CollateralType6Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum CollateralType6Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "GBBK") )]
	CodeGBBK,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BOND") )]
	CodeBOND,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CASH") )]
	CodeCASH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "COMM") )]
	CodeCOMM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INSU") )]
	CodeINSU,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LCRE") )]
	CodeLCRE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PHYS") )]
	CodePHYS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SECU") )]
	CodeSECU,
	#[cfg_attr( feature = "derive_serde", serde(rename = "STCF") )]
	CodeSTCF,
}

impl CollateralType6Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// CollateralValuation6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CollateralValuation6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NmnlAmt", skip_serializing_if = "Option::is_none") )]
	pub nmnl_amt: Option<ActiveCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ISIN") )]
	pub isin: String,
}

impl CollateralValuation6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.nmnl_amt { val.validate()? }
		let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
		if !pattern.is_match(&self.isin) {
			return Err(ValidationError::new(1005, "isin does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// CollateralValuation7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CollateralValuation7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PoolSts") )]
	pub pool_sts: CollateralPool1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sctr") )]
	pub sctr: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NmnlAmt", skip_serializing_if = "Option::is_none") )]
	pub nmnl_amt: Option<ActiveCurrencyAndAmount>,
}

impl CollateralValuation7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.pool_sts.validate()?;
		let pattern = Regex::new("[A-Z]{6,6}").unwrap();
		if !pattern.is_match(&self.tp) {
			return Err(ValidationError::new(1005, "tp does not match the required pattern".to_string()));
		}
		if let Some(ref val) = self.nmnl_amt { val.validate()? }
		Ok(())
	}
}


// CollateralisationType3Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum CollateralisationType3Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "FLCL") )]
	CodeFLCL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OWCL") )]
	CodeOWCL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OWC1") )]
	CodeOWC1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OWC2") )]
	CodeOWC2,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OWP1") )]
	CodeOWP1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OWP2") )]
	CodeOWP2,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PRCL") )]
	CodePRCL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PRC1") )]
	CodePRC1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PRC2") )]
	CodePRC2,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UNCL") )]
	CodeUNCL,
}

impl CollateralisationType3Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// CollaterisedData12 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CollaterisedData12 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollValDt", skip_serializing_if = "Option::is_none") )]
	pub coll_val_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AsstTp", skip_serializing_if = "Option::is_none") )]
	pub asst_tp: Option<CollateralType21>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NetXpsrCollstnInd", skip_serializing_if = "Option::is_none") )]
	pub net_xpsr_collstn_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BsktIdr", skip_serializing_if = "Option::is_none") )]
	pub bskt_idr: Option<SecurityIdentification26Choice>,
}

impl CollaterisedData12 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.asst_tp { val.validate()? }
		if let Some(ref val) = self.bskt_idr { val.validate()? }
		Ok(())
	}
}


// Commodity2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Commodity2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MktVal") )]
	pub mkt_val: ActiveCurrencyAnd24Amount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CmmdtyTp") )]
	pub cmmdty_tp: AssetClassDetailedSubProductType1Choice,
}

impl Commodity2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.mkt_val.validate()?;
		self.cmmdty_tp.validate()?;
		Ok(())
	}
}


// Commodity42 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Commodity42 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Clssfctn", skip_serializing_if = "Option::is_none") )]
	pub clssfctn: Option<CompareCommodityAssetClass3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Qty", skip_serializing_if = "Option::is_none") )]
	pub qty: Option<CompareDecimalNumber3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnitPric", skip_serializing_if = "Option::is_none") )]
	pub unit_pric: Option<CompareUnitPrice6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MktVal", skip_serializing_if = "Option::is_none") )]
	pub mkt_val: Option<CompareAmountAndDirection2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnitOfMeasr", skip_serializing_if = "Option::is_none") )]
	pub unit_of_measr: Option<CompareUnitOfMeasure3>,
}

impl Commodity42 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.clssfctn { val.validate()? }
		if let Some(ref val) = self.qty { val.validate()? }
		if let Some(ref val) = self.unit_pric { val.validate()? }
		if let Some(ref val) = self.mkt_val { val.validate()? }
		if let Some(ref val) = self.unit_of_measr { val.validate()? }
		Ok(())
	}
}


// Commodity43 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Commodity43 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Clssfctn", skip_serializing_if = "Option::is_none") )]
	pub clssfctn: Option<AssetClassCommodity5Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Qty", skip_serializing_if = "Option::is_none") )]
	pub qty: Option<Quantity17>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnitPric", skip_serializing_if = "Option::is_none") )]
	pub unit_pric: Option<SecuritiesTransactionPrice19Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MktVal", skip_serializing_if = "Option::is_none") )]
	pub mkt_val: Option<AmountAndDirection53>,
}

impl Commodity43 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.clssfctn { val.validate()? }
		if let Some(ref val) = self.qty { val.validate()? }
		if let Some(ref val) = self.unit_pric { val.validate()? }
		if let Some(ref val) = self.mkt_val { val.validate()? }
		Ok(())
	}
}


// CommodityDerivative2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CommodityDerivative2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Frght", skip_serializing_if = "Option::is_none") )]
	pub frght: Option<CommodityDerivative5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nrgy", skip_serializing_if = "Option::is_none") )]
	pub nrgy: Option<CommodityDerivative6>,
}

impl CommodityDerivative2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.frght { val.validate()? }
		if let Some(ref val) = self.nrgy { val.validate()? }
		Ok(())
	}
}


// CommodityDerivative4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CommodityDerivative4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClssSpcfc", skip_serializing_if = "Option::is_none") )]
	pub clss_spcfc: Option<CommodityDerivative2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtnlCcy") )]
	pub ntnl_ccy: String,
}

impl CommodityDerivative4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.clss_spcfc { val.validate()? }
		let pattern = Regex::new("[A-Z]{3,3}").unwrap();
		if !pattern.is_match(&self.ntnl_ccy) {
			return Err(ValidationError::new(1005, "ntnl_ccy does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// CommodityDerivative5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CommodityDerivative5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sz") )]
	pub sz: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AvrgTmChrtr") )]
	pub avrg_tm_chrtr: String,
}

impl CommodityDerivative5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.sz.chars().count() < 1 {
			return Err(ValidationError::new(1001, "sz is shorter than the minimum length of 1".to_string()));
		}
		if self.sz.chars().count() > 25 {
			return Err(ValidationError::new(1002, "sz exceeds the maximum length of 25".to_string()));
		}
		if self.avrg_tm_chrtr.chars().count() < 1 {
			return Err(ValidationError::new(1001, "avrg_tm_chrtr is shorter than the minimum length of 1".to_string()));
		}
		if self.avrg_tm_chrtr.chars().count() > 25 {
			return Err(ValidationError::new(1002, "avrg_tm_chrtr exceeds the maximum length of 25".to_string()));
		}
		Ok(())
	}
}


// CommodityDerivative6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CommodityDerivative6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttlmLctn") )]
	pub sttlm_lctn: String,
}

impl CommodityDerivative6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.sttlm_lctn.chars().count() < 1 {
			return Err(ValidationError::new(1001, "sttlm_lctn is shorter than the minimum length of 1".to_string()));
		}
		if self.sttlm_lctn.chars().count() > 25 {
			return Err(ValidationError::new(1002, "sttlm_lctn exceeds the maximum length of 25".to_string()));
		}
		Ok(())
	}
}


// CommonTradeDataReport71 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CommonTradeDataReport71 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrctData", skip_serializing_if = "Option::is_none") )]
	pub ctrct_data: Option<ContractType15>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxData") )]
	pub tx_data: TradeTransaction50,
}

impl CommonTradeDataReport71 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ctrct_data { val.validate()? }
		self.tx_data.validate()?;
		Ok(())
	}
}


// CommonTradeDataReport72 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CommonTradeDataReport72 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrctData", skip_serializing_if = "Option::is_none") )]
	pub ctrct_data: Option<ContractType15>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxData") )]
	pub tx_data: TradeTransaction50,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrctMod", skip_serializing_if = "Option::is_none") )]
	pub ctrct_mod: Option<ContractModification9>,
}

impl CommonTradeDataReport72 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ctrct_data { val.validate()? }
		self.tx_data.validate()?;
		if let Some(ref val) = self.ctrct_mod { val.validate()? }
		Ok(())
	}
}


// CommunicationAddress7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CommunicationAddress7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Email", skip_serializing_if = "Option::is_none") )]
	pub email: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PhneNb", skip_serializing_if = "Option::is_none") )]
	pub phne_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MobNb", skip_serializing_if = "Option::is_none") )]
	pub mob_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FaxNb", skip_serializing_if = "Option::is_none") )]
	pub fax_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TlxAdr", skip_serializing_if = "Option::is_none") )]
	pub tlx_adr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "URLAdr", skip_serializing_if = "Option::is_none") )]
	pub url_adr: Option<String>,
}

impl CommunicationAddress7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.email {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "email is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 2048 {
				return Err(ValidationError::new(1002, "email exceeds the maximum length of 2048".to_string()));
			}
		}
		if let Some(ref val) = self.phne_nb {
			let pattern = Regex::new("\\+[0-9]{1,3}-[0-9()+\\-]{1,30}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "phne_nb does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.mob_nb {
			let pattern = Regex::new("\\+[0-9]{1,3}-[0-9()+\\-]{1,30}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "mob_nb does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.fax_nb {
			let pattern = Regex::new("\\+[0-9]{1,3}-[0-9()+\\-]{1,30}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "fax_nb does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.tlx_adr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tlx_adr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "tlx_adr exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.url_adr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "url_adr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 2048 {
				return Err(ValidationError::new(1002, "url_adr exceeds the maximum length of 2048".to_string()));
			}
		}
		Ok(())
	}
}


// CommunicationMethod4Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum CommunicationMethod4Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "EMAL") )]
	CodeEMAL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FAXI") )]
	CodeFAXI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FILE") )]
	CodeFILE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ONLI") )]
	CodeONLI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PHON") )]
	CodePHON,
	#[cfg_attr( feature = "derive_serde", serde(rename = "POST") )]
	CodePOST,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PROP") )]
	CodePROP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SWMT") )]
	CodeSWMT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SWMX") )]
	CodeSWMX,
}

impl CommunicationMethod4Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// CompareActiveOrHistoricCurrencyAndAmount3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareActiveOrHistoricCurrencyAndAmount3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<ActiveOrHistoricCurrencyAndAmount>,
}

impl CompareActiveOrHistoricCurrencyAndAmount3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareActiveOrHistoricCurrencyAndAmount4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareActiveOrHistoricCurrencyAndAmount4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<ActiveOrHistoricCurrencyAnd19DecimalAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<ActiveOrHistoricCurrencyAnd19DecimalAmount>,
}

impl CompareActiveOrHistoricCurrencyAndAmount4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareActiveOrHistoricCurrencyCode1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareActiveOrHistoricCurrencyCode1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<String>,
}

impl CompareActiveOrHistoricCurrencyCode1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "val1 does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.val2 {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "val2 does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// CompareAgreementType2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareAgreementType2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<AgreementType1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<AgreementType1Choice>,
}

impl CompareAgreementType2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareAmountAndDirection1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareAmountAndDirection1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<AmountAndDirection53>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<AmountAndDirection53>,
}

impl CompareAmountAndDirection1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareAmountAndDirection2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareAmountAndDirection2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<AmountAndDirection53>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<AmountAndDirection53>,
}

impl CompareAmountAndDirection2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareAmountAndDirection3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareAmountAndDirection3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<AmountAndDirection106>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<AmountAndDirection106>,
}

impl CompareAmountAndDirection3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareAssetClass1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareAssetClass1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<ProductType4Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<ProductType4Code>,
}

impl CompareAssetClass1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareBenchmarkCode1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareBenchmarkCode1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<String>,
}

impl CompareBenchmarkCode1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "val1 is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "val1 exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.val2 {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "val2 is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "val2 exceeds the maximum length of 4".to_string()));
			}
		}
		Ok(())
	}
}


// CompareBenchmarkCurveName3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareBenchmarkCurveName3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<BenchmarkCurveName10Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<BenchmarkCurveName10Choice>,
}

impl CompareBenchmarkCurveName3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareCFIIdentifier3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareCFIIdentifier3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<String>,
}

impl CompareCFIIdentifier3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 {
			let pattern = Regex::new("[A-Z]{6,6}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "val1 does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.val2 {
			let pattern = Regex::new("[A-Z]{6,6}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "val2 does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// CompareClearingStatus3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareClearingStatus3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<Cleared4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<Cleared4Choice>,
}

impl CompareClearingStatus3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareCollateralQualityType3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareCollateralQualityType3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<CollateralQualityType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<CollateralQualityType1Code>,
}

impl CompareCollateralQualityType3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareCommodityAssetClass3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareCommodityAssetClass3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<AssetClassCommodity5Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<AssetClassCommodity5Choice>,
}

impl CompareCommodityAssetClass3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareCommodityAssetClass4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareCommodityAssetClass4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<AssetClassCommodity6Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<AssetClassCommodity6Choice>,
}

impl CompareCommodityAssetClass4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareCounterpartySide2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareCounterpartySide2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<CollateralRole1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<CollateralRole1Code>,
}

impl CompareCounterpartySide2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareCountryCode3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareCountryCode3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<String>,
}

impl CompareCountryCode3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 {
			let pattern = Regex::new("[A-Z]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "val1 does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.val2 {
			let pattern = Regex::new("[A-Z]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "val2 does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// CompareDate3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareDate3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<String>,
}

impl CompareDate3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// CompareDatePeriod2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareDatePeriod2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<DatePeriod4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<DatePeriod4>,
}

impl CompareDatePeriod2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareDateTime3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareDateTime3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<String>,
}

impl CompareDateTime3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// CompareDayCount1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareDayCount1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<InterestComputationMethodFormat7>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<InterestComputationMethodFormat7>,
}

impl CompareDayCount1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareDecimalNumber3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareDecimalNumber3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<f64>,
}

impl CompareDecimalNumber3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// CompareDeliveryInterconnectionPoint1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareDeliveryInterconnectionPoint1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<DeliveryInterconnectionPoint1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<DeliveryInterconnectionPoint1Choice>,
}

impl CompareDeliveryInterconnectionPoint1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareDeliveryMethod3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareDeliveryMethod3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<CollateralDeliveryMethod1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<CollateralDeliveryMethod1Code>,
}

impl CompareDeliveryMethod3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareDeliveryType1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareDeliveryType1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<PhysicalTransferType4Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<PhysicalTransferType4Code>,
}

impl CompareDeliveryType1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareDerivativeEvent1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareDerivativeEvent1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<DerivativeEvent6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<DerivativeEvent6>,
}

impl CompareDerivativeEvent1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareDurationType1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareDurationType1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<DurationType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<DurationType1Code>,
}

impl CompareDurationType1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareEnergyDeliveryAttribute1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareEnergyDeliveryAttribute1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NrgyDlvryIntrvl", skip_serializing_if = "Option::is_none") )]
	pub nrgy_dlvry_intrvl: Option<Vec<CompareTimePeriod2>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NrgyDt", skip_serializing_if = "Option::is_none") )]
	pub nrgy_dt: Option<CompareDatePeriod2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NrgyDrtn", skip_serializing_if = "Option::is_none") )]
	pub nrgy_drtn: Option<CompareDurationType1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NrgyWkDay", skip_serializing_if = "Option::is_none") )]
	pub nrgy_wk_day: Option<Vec<CompareWeekDay1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NrgyDlvryCpcty", skip_serializing_if = "Option::is_none") )]
	pub nrgy_dlvry_cpcty: Option<CompareLongFraction19DecimalNumber1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NrgyQtyUnit", skip_serializing_if = "Option::is_none") )]
	pub nrgy_qty_unit: Option<CompareEnergyQuantityUnit1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NrgyPricTmIntrvlQty", skip_serializing_if = "Option::is_none") )]
	pub nrgy_pric_tm_intrvl_qty: Option<CompareAmountAndDirection3>,
}

impl CompareEnergyDeliveryAttribute1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.nrgy_dlvry_intrvl { for item in vec { item.validate()? } }
		if let Some(ref val) = self.nrgy_dt { val.validate()? }
		if let Some(ref val) = self.nrgy_drtn { val.validate()? }
		if let Some(ref vec) = self.nrgy_wk_day { for item in vec { item.validate()? } }
		if let Some(ref val) = self.nrgy_dlvry_cpcty { val.validate()? }
		if let Some(ref val) = self.nrgy_qty_unit { val.validate()? }
		if let Some(ref val) = self.nrgy_pric_tm_intrvl_qty { val.validate()? }
		Ok(())
	}
}


// CompareEnergyLoadType1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareEnergyLoadType1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<EnergyLoadType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<EnergyLoadType1Code>,
}

impl CompareEnergyLoadType1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareEnergyQuantityUnit1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareEnergyQuantityUnit1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<EnergyQuantityUnit2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<EnergyQuantityUnit2Choice>,
}

impl CompareEnergyQuantityUnit1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareExchangeRate1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareExchangeRate1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<f64>,
}

impl CompareExchangeRate1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// CompareExchangeRateBasis1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareExchangeRateBasis1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<ExchangeRateBasis1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<ExchangeRateBasis1Choice>,
}

impl CompareExchangeRateBasis1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareExposureType3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareExposureType3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<ExposureType10Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<ExposureType10Code>,
}

impl CompareExposureType3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareFinancialInstrumentContractType1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareFinancialInstrumentContractType1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<FinancialInstrumentContractType2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<FinancialInstrumentContractType2Code>,
}

impl CompareFinancialInstrumentContractType1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareFrequencyUnit1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareFrequencyUnit1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<Frequency13Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<Frequency13Code>,
}

impl CompareFrequencyUnit1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareISINIdentifier2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareISINIdentifier2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<String>,
}

impl CompareISINIdentifier2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 {
			let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "val1 does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.val2 {
			let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "val2 does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// CompareISINIdentifier4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareISINIdentifier4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<String>,
}

impl CompareISINIdentifier4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 {
			let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "val1 does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.val2 {
			let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "val2 does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// CompareInterestComputationMethod3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareInterestComputationMethod3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<InterestComputationMethodFormat6Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<InterestComputationMethodFormat6Choice>,
}

impl CompareInterestComputationMethod3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareInterestRate1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareInterestRate1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MrgnLnAmt", skip_serializing_if = "Option::is_none") )]
	pub mrgn_ln_amt: Option<CompareAmountAndDirection1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FxdIntrstRate", skip_serializing_if = "Option::is_none") )]
	pub fxd_intrst_rate: Option<ComparePercentageRate3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DayCntBsis", skip_serializing_if = "Option::is_none") )]
	pub day_cnt_bsis: Option<CompareInterestComputationMethod3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FltgIntrstRefRate", skip_serializing_if = "Option::is_none") )]
	pub fltg_intrst_ref_rate: Option<CompareBenchmarkCurveName3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FltgIntrstRateTermUnit", skip_serializing_if = "Option::is_none") )]
	pub fltg_intrst_rate_term_unit: Option<CompareRateBasis3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FltgIntrstRateTermVal", skip_serializing_if = "Option::is_none") )]
	pub fltg_intrst_rate_term_val: Option<CompareNumber5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FltgIntrstRatePmtFrqcyUnit", skip_serializing_if = "Option::is_none") )]
	pub fltg_intrst_rate_pmt_frqcy_unit: Option<CompareRateBasis3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FltgIntrstRatePmtFrqcyVal", skip_serializing_if = "Option::is_none") )]
	pub fltg_intrst_rate_pmt_frqcy_val: Option<CompareNumber5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FltgIntrstRateRstFrqcyUnit", skip_serializing_if = "Option::is_none") )]
	pub fltg_intrst_rate_rst_frqcy_unit: Option<CompareRateBasis3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FltgIntrstRateRstFrqcyVal", skip_serializing_if = "Option::is_none") )]
	pub fltg_intrst_rate_rst_frqcy_val: Option<CompareNumber6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BsisPtSprd", skip_serializing_if = "Option::is_none") )]
	pub bsis_pt_sprd: Option<CompareDecimalNumber3>,
}

impl CompareInterestRate1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.mrgn_ln_amt { val.validate()? }
		if let Some(ref val) = self.fxd_intrst_rate { val.validate()? }
		if let Some(ref val) = self.day_cnt_bsis { val.validate()? }
		if let Some(ref val) = self.fltg_intrst_ref_rate { val.validate()? }
		if let Some(ref val) = self.fltg_intrst_rate_term_unit { val.validate()? }
		if let Some(ref val) = self.fltg_intrst_rate_term_val { val.validate()? }
		if let Some(ref val) = self.fltg_intrst_rate_pmt_frqcy_unit { val.validate()? }
		if let Some(ref val) = self.fltg_intrst_rate_pmt_frqcy_val { val.validate()? }
		if let Some(ref val) = self.fltg_intrst_rate_rst_frqcy_unit { val.validate()? }
		if let Some(ref val) = self.fltg_intrst_rate_rst_frqcy_val { val.validate()? }
		if let Some(ref val) = self.bsis_pt_sprd { val.validate()? }
		Ok(())
	}
}


// CompareLegDirection2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareLegDirection2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<Direction4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<Direction4Choice>,
}

impl CompareLegDirection2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareLongFraction19DecimalNumber1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareLongFraction19DecimalNumber1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<f64>,
}

impl CompareLongFraction19DecimalNumber1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// CompareMICIdentifier3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareMICIdentifier3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<String>,
}

impl CompareMICIdentifier3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 {
			let pattern = Regex::new("[A-Z0-9]{4,4}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "val1 does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.val2 {
			let pattern = Regex::new("[A-Z0-9]{4,4}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "val2 does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// CompareMasterAgreementType1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareMasterAgreementType1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<AgreementType2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<AgreementType2Choice>,
}

impl CompareMasterAgreementType1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareMax350Text1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareMax350Text1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<String>,
}

impl CompareMax350Text1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "val1 is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 350 {
				return Err(ValidationError::new(1002, "val1 exceeds the maximum length of 350".to_string()));
			}
		}
		if let Some(ref val) = self.val2 {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "val2 is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 350 {
				return Err(ValidationError::new(1002, "val2 exceeds the maximum length of 350".to_string()));
			}
		}
		Ok(())
	}
}


// CompareMax50Text1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareMax50Text1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<String>,
}

impl CompareMax50Text1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "val1 is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 50 {
				return Err(ValidationError::new(1002, "val1 exceeds the maximum length of 50".to_string()));
			}
		}
		if let Some(ref val) = self.val2 {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "val2 is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 50 {
				return Err(ValidationError::new(1002, "val2 exceeds the maximum length of 50".to_string()));
			}
		}
		Ok(())
	}
}


// CompareNumber5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareNumber5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<f64>,
}

impl CompareNumber5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// CompareNumber6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareNumber6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<f64>,
}

impl CompareNumber6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// CompareNumber7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareNumber7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<f64>,
}

impl CompareNumber7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// CompareOptionStyle1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareOptionStyle1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<OptionStyle6Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<OptionStyle6Code>,
}

impl CompareOptionStyle1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareOptionType1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareOptionType1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<OptionType2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<OptionType2Code>,
}

impl CompareOptionType1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareOrganisationIdentification6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareOrganisationIdentification6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<OrganisationIdentification15Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<OrganisationIdentification15Choice>,
}

impl CompareOrganisationIdentification6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareOrganisationIdentification7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareOrganisationIdentification7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<PartyIdentification236Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<PartyIdentification236Choice>,
}

impl CompareOrganisationIdentification7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareOtherPayment1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareOtherPayment1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrPmtTp", skip_serializing_if = "Option::is_none") )]
	pub othr_pmt_tp: Option<CompareOtherPaymentType1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrPmtAmt", skip_serializing_if = "Option::is_none") )]
	pub othr_pmt_amt: Option<CompareAmountAndDirection3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrPmtDt", skip_serializing_if = "Option::is_none") )]
	pub othr_pmt_dt: Option<CompareDate3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrPmtPyer", skip_serializing_if = "Option::is_none") )]
	pub othr_pmt_pyer: Option<CompareOrganisationIdentification7>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrPmtRcvr", skip_serializing_if = "Option::is_none") )]
	pub othr_pmt_rcvr: Option<CompareOrganisationIdentification7>,
}

impl CompareOtherPayment1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.othr_pmt_tp { val.validate()? }
		if let Some(ref val) = self.othr_pmt_amt { val.validate()? }
		if let Some(ref val) = self.othr_pmt_dt { val.validate()? }
		if let Some(ref val) = self.othr_pmt_pyer { val.validate()? }
		if let Some(ref val) = self.othr_pmt_rcvr { val.validate()? }
		Ok(())
	}
}


// CompareOtherPaymentType1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareOtherPaymentType1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<PaymentType5Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<PaymentType5Choice>,
}

impl CompareOtherPaymentType1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// ComparePercentageRate3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ComparePercentageRate3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<f64>,
}

impl ComparePercentageRate3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ComparePostTradeRiskReduction2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ComparePostTradeRiskReduction2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<PTRREvent3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<PTRREvent3>,
}

impl ComparePostTradeRiskReduction2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareRateBasis3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareRateBasis3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<RateBasis1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<RateBasis1Code>,
}

impl CompareRateBasis3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareReferenceParty1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareReferenceParty1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<DerivativePartyIdentification1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<DerivativePartyIdentification1Choice>,
}

impl CompareReferenceParty1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareReportingLevelType2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareReportingLevelType2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<ModificationLevel1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<ModificationLevel1Code>,
}

impl CompareReportingLevelType2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareReportingLevelType3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareReportingLevelType3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<ModificationLevel1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<ModificationLevel1Code>,
}

impl CompareReportingLevelType3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareSecuritiesLendingType3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareSecuritiesLendingType3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<SecuritiesLendingType3Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<SecuritiesLendingType3Choice>,
}

impl CompareSecuritiesLendingType3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareSecurityIdentification4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareSecurityIdentification4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<SecurityIdentification26Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<SecurityIdentification26Choice>,
}

impl CompareSecurityIdentification4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareSeniorityType1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareSeniorityType1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<DebtInstrumentSeniorityType2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<DebtInstrumentSeniorityType2Code>,
}

impl CompareSeniorityType1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareSpecialCollateral3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareSpecialCollateral3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<SpecialCollateral1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<SpecialCollateral1Code>,
}

impl CompareSpecialCollateral3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareTerminationOption3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareTerminationOption3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<RepoTerminationOption2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<RepoTerminationOption2Code>,
}

impl CompareTerminationOption3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareText1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareText1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<String>,
}

impl CompareText1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "val1 is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 52 {
				return Err(ValidationError::new(1002, "val1 exceeds the maximum length of 52".to_string()));
			}
		}
		if let Some(ref val) = self.val2 {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "val2 is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 52 {
				return Err(ValidationError::new(1002, "val2 exceeds the maximum length of 52".to_string()));
			}
		}
		Ok(())
	}
}


// CompareText2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareText2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<String>,
}

impl CompareText2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "val1 is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 52 {
				return Err(ValidationError::new(1002, "val1 exceeds the maximum length of 52".to_string()));
			}
		}
		if let Some(ref val) = self.val2 {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "val2 is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 52 {
				return Err(ValidationError::new(1002, "val2 exceeds the maximum length of 52".to_string()));
			}
		}
		Ok(())
	}
}


// CompareTimePeriod2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareTimePeriod2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<TimePeriod3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<TimePeriod3>,
}

impl CompareTimePeriod2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareTradeClearingObligation1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareTradeClearingObligation1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<ClearingObligationType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<ClearingObligationType1Code>,
}

impl CompareTradeClearingObligation1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareTradeClearingStatus3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareTradeClearingStatus3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<Cleared23Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<Cleared23Choice>,
}

impl CompareTradeClearingStatus3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareTradeConfirmation2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareTradeConfirmation2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<TradeConfirmation3Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<TradeConfirmation3Choice>,
}

impl CompareTradeConfirmation2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareTrancheIndicator1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareTrancheIndicator1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<TrancheIndicator3Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<TrancheIndicator3Choice>,
}

impl CompareTrancheIndicator1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareTrueFalseIndicator3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareTrueFalseIndicator3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<bool>,
}

impl CompareTrueFalseIndicator3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// CompareUnderlyingInstrument3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareUnderlyingInstrument3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<SecurityIdentification41Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<SecurityIdentification41Choice>,
}

impl CompareUnderlyingInstrument3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareUniqueProductIdentifier2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareUniqueProductIdentifier2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<UniqueProductIdentifier2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<UniqueProductIdentifier2Choice>,
}

impl CompareUniqueProductIdentifier2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareUniqueTransactionIdentifier2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareUniqueTransactionIdentifier2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<UniqueTransactionIdentifier2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<UniqueTransactionIdentifier2Choice>,
}

impl CompareUniqueTransactionIdentifier2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareUnitOfMeasure3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareUnitOfMeasure3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<UnitOfMeasure11Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<UnitOfMeasure11Code>,
}

impl CompareUnitOfMeasure3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareUnitPrice4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareUnitPrice4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<SecuritiesTransactionPrice17Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<SecuritiesTransactionPrice17Choice>,
}

impl CompareUnitPrice4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareUnitPrice5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareUnitPrice5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<SecuritiesTransactionPrice17Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<SecuritiesTransactionPrice17Choice>,
}

impl CompareUnitPrice5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareUnitPrice6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareUnitPrice6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<SecuritiesTransactionPrice19Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<SecuritiesTransactionPrice19Choice>,
}

impl CompareUnitPrice6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareUnitPrice7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareUnitPrice7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<SecuritiesTransactionPrice14Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<SecuritiesTransactionPrice14Choice>,
}

impl CompareUnitPrice7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareUnitPrice8 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareUnitPrice8 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<SecuritiesTransactionPrice13Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<SecuritiesTransactionPrice13Choice>,
}

impl CompareUnitPrice8 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareValuationType1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareValuationType1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<ValuationType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<ValuationType1Code>,
}

impl CompareValuationType1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// CompareWeekDay1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CompareWeekDay1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val1", skip_serializing_if = "Option::is_none") )]
	pub val1: Option<WeekDay3Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val2", skip_serializing_if = "Option::is_none") )]
	pub val2: Option<WeekDay3Code>,
}

impl CompareWeekDay1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val1 { val.validate()? }
		if let Some(ref val) = self.val2 { val.validate()? }
		Ok(())
	}
}


// ConcentrationAccount1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ConcentrationAccount1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "InFlow") )]
	pub in_flow: Flows1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OutFlow") )]
	pub out_flow: Flows1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EndOfDay") )]
	pub end_of_day: AmountAndDirection102,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PeakCdt") )]
	pub peak_cdt: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PeakDbt") )]
	pub peak_dbt: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LatePmtConf") )]
	pub late_pmt_conf: String,
}

impl ConcentrationAccount1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.in_flow.validate()?;
		self.out_flow.validate()?;
		self.end_of_day.validate()?;
		self.peak_cdt.validate()?;
		self.peak_dbt.validate()?;
		let pattern = Regex::new("[0-9]{1,10}").unwrap();
		if !pattern.is_match(&self.late_pmt_conf) {
			return Err(ValidationError::new(1005, "late_pmt_conf does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// ConcentrationAgent1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ConcentrationAgent1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Acct") )]
	pub acct: Vec<ConcentrationAccount1>,
}

impl ConcentrationAgent1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
		if !pattern.is_match(&self.id) {
			return Err(ValidationError::new(1005, "id does not match the required pattern".to_string()));
		}
		for item in &self.acct { item.validate()? }
		Ok(())
	}
}


// Contact13 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Contact13 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NmPrfx", skip_serializing_if = "Option::is_none") )]
	pub nm_prfx: Option<NamePrefix2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm", skip_serializing_if = "Option::is_none") )]
	pub nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PhneNb", skip_serializing_if = "Option::is_none") )]
	pub phne_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MobNb", skip_serializing_if = "Option::is_none") )]
	pub mob_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FaxNb", skip_serializing_if = "Option::is_none") )]
	pub fax_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "URLAdr", skip_serializing_if = "Option::is_none") )]
	pub url_adr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EmailAdr", skip_serializing_if = "Option::is_none") )]
	pub email_adr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EmailPurp", skip_serializing_if = "Option::is_none") )]
	pub email_purp: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "JobTitl", skip_serializing_if = "Option::is_none") )]
	pub job_titl: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rspnsblty", skip_serializing_if = "Option::is_none") )]
	pub rspnsblty: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dept", skip_serializing_if = "Option::is_none") )]
	pub dept: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<Vec<OtherContact1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrefrdMtd", skip_serializing_if = "Option::is_none") )]
	pub prefrd_mtd: Option<PreferredContactMethod2Code>,
}

impl Contact13 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.nm_prfx { val.validate()? }
		if let Some(ref val) = self.nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "nm exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.phne_nb {
			let pattern = Regex::new("\\+[0-9]{1,3}-[0-9()+\\-]{1,30}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "phne_nb does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.mob_nb {
			let pattern = Regex::new("\\+[0-9]{1,3}-[0-9()+\\-]{1,30}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "mob_nb does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.fax_nb {
			let pattern = Regex::new("\\+[0-9]{1,3}-[0-9()+\\-]{1,30}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "fax_nb does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.url_adr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "url_adr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 2048 {
				return Err(ValidationError::new(1002, "url_adr exceeds the maximum length of 2048".to_string()));
			}
		}
		if let Some(ref val) = self.email_adr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "email_adr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 256 {
				return Err(ValidationError::new(1002, "email_adr exceeds the maximum length of 256".to_string()));
			}
		}
		if let Some(ref val) = self.email_purp {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "email_purp is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "email_purp exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.job_titl {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "job_titl is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "job_titl exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.rspnsblty {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "rspnsblty is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "rspnsblty exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.dept {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "dept is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 70 {
				return Err(ValidationError::new(1002, "dept exceeds the maximum length of 70".to_string()));
			}
		}
		if let Some(ref vec) = self.othr { for item in vec { item.validate()? } }
		if let Some(ref val) = self.prefrd_mtd { val.validate()? }
		Ok(())
	}
}


// Contact9 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Contact9 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm") )]
	pub nm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PhneNb") )]
	pub phne_nb: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EmailAdr") )]
	pub email_adr: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Fctn", skip_serializing_if = "Option::is_none") )]
	pub fctn: Option<String>,
}

impl Contact9 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.nm.chars().count() < 1 {
			return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
		}
		if self.nm.chars().count() > 140 {
			return Err(ValidationError::new(1002, "nm exceeds the maximum length of 140".to_string()));
		}
		let pattern = Regex::new("\\+[0-9]{1,3}-[0-9()+\\-]{1,30}").unwrap();
		if !pattern.is_match(&self.phne_nb) {
			return Err(ValidationError::new(1005, "phne_nb does not match the required pattern".to_string()));
		}
		if self.email_adr.chars().count() < 1 {
			return Err(ValidationError::new(1001, "email_adr is shorter than the minimum length of 1".to_string()));
		}
		if self.email_adr.chars().count() > 256 {
			return Err(ValidationError::new(1002, "email_adr exceeds the maximum length of 256".to_string()));
		}
		if let Some(ref val) = self.fctn {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "fctn is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "fctn exceeds the maximum length of 140".to_string()));
			}
		}
		Ok(())
	}
}


// ContactDetails2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ContactDetails2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NmPrfx", skip_serializing_if = "Option::is_none") )]
	pub nm_prfx: Option<NamePrefix1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm", skip_serializing_if = "Option::is_none") )]
	pub nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PhneNb", skip_serializing_if = "Option::is_none") )]
	pub phne_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MobNb", skip_serializing_if = "Option::is_none") )]
	pub mob_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FaxNb", skip_serializing_if = "Option::is_none") )]
	pub fax_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EmailAdr", skip_serializing_if = "Option::is_none") )]
	pub email_adr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<String>,
}

impl ContactDetails2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.nm_prfx { val.validate()? }
		if let Some(ref val) = self.nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "nm exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.phne_nb {
			let pattern = Regex::new("\\+[0-9]{1,3}-[0-9()+\\-]{1,30}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "phne_nb does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.mob_nb {
			let pattern = Regex::new("\\+[0-9]{1,3}-[0-9()+\\-]{1,30}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "mob_nb does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.fax_nb {
			let pattern = Regex::new("\\+[0-9]{1,3}-[0-9()+\\-]{1,30}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "fax_nb does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.email_adr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "email_adr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 2048 {
				return Err(ValidationError::new(1002, "email_adr exceeds the maximum length of 2048".to_string()));
			}
		}
		if let Some(ref val) = self.othr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "othr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "othr exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// ContactDetails4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ContactDetails4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm") )]
	pub nm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PhneNb") )]
	pub phne_nb: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EmailAdr") )]
	pub email_adr: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Fctn") )]
	pub fctn: String,
}

impl ContactDetails4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.nm.chars().count() < 1 {
			return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
		}
		if self.nm.chars().count() > 140 {
			return Err(ValidationError::new(1002, "nm exceeds the maximum length of 140".to_string()));
		}
		let pattern = Regex::new("\\+[0-9]{1,3}-[0-9()+\\-]{1,30}").unwrap();
		if !pattern.is_match(&self.phne_nb) {
			return Err(ValidationError::new(1005, "phne_nb does not match the required pattern".to_string()));
		}
		if self.email_adr.chars().count() < 1 {
			return Err(ValidationError::new(1001, "email_adr is shorter than the minimum length of 1".to_string()));
		}
		if self.email_adr.chars().count() > 2048 {
			return Err(ValidationError::new(1002, "email_adr exceeds the maximum length of 2048".to_string()));
		}
		if self.fctn.chars().count() < 1 {
			return Err(ValidationError::new(1001, "fctn is shorter than the minimum length of 1".to_string()));
		}
		if self.fctn.chars().count() > 140 {
			return Err(ValidationError::new(1002, "fctn exceeds the maximum length of 140".to_string()));
		}
		Ok(())
	}
}


// ContractBalance1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ContractBalance1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: ContractBalanceType1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtDbtInd") )]
	pub cdt_dbt_ind: CreditDebit3Code,
}

impl ContractBalance1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.tp.validate()?;
		self.amt.validate()?;
		self.cdt_dbt_ind.validate()?;
		Ok(())
	}
}


// ContractBalanceType1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ContractBalanceType1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl ContractBalanceType1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// ContractCessionData2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ContractCessionData2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pty") )]
	pub pty: TradeParty6,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DocNb", skip_serializing_if = "Option::is_none") )]
	pub doc_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DocDt", skip_serializing_if = "Option::is_none") )]
	pub doc_dt: Option<String>,
}

impl ContractCessionData2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.pty.validate()?;
		if let Some(ref val) = self.doc_nb {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "doc_nb is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "doc_nb exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// ContractClosureReason1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ContractClosureReason1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl ContractClosureReason1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// ContractCollateral1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ContractCollateral1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlAmt") )]
	pub ttl_amt: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollDesc", skip_serializing_if = "Option::is_none") )]
	pub coll_desc: Option<Vec<CashCollateral5>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_inf: Option<String>,
}

impl ContractCollateral1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.ttl_amt.validate()?;
		if let Some(ref vec) = self.coll_desc { for item in vec { item.validate()? } }
		if let Some(ref val) = self.addtl_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 1025 {
				return Err(ValidationError::new(1002, "addtl_inf exceeds the maximum length of 1025".to_string()));
			}
		}
		Ok(())
	}
}


// ContractForDifference2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ContractForDifference2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "UndrlygTp") )]
	pub undrlyg_tp: UnderlyingContractForDifferenceType3Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtnlCcy1", skip_serializing_if = "Option::is_none") )]
	pub ntnl_ccy1: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtnlCcy2", skip_serializing_if = "Option::is_none") )]
	pub ntnl_ccy2: Option<String>,
}

impl ContractForDifference2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.undrlyg_tp.validate()?;
		if let Some(ref val) = self.ntnl_ccy1 {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ntnl_ccy1 does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.ntnl_ccy2 {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ntnl_ccy2 does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// ContractMatchingCriteria3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ContractMatchingCriteria3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ISIN", skip_serializing_if = "Option::is_none") )]
	pub isin: Option<CompareISINIdentifier2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnqPdctIdr", skip_serializing_if = "Option::is_none") )]
	pub unq_pdct_idr: Option<CompareUniqueProductIdentifier2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AltrntvInstrmId", skip_serializing_if = "Option::is_none") )]
	pub altrntv_instrm_id: Option<CompareText1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PdctClssfctn", skip_serializing_if = "Option::is_none") )]
	pub pdct_clssfctn: Option<CompareCFIIdentifier3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrctTp", skip_serializing_if = "Option::is_none") )]
	pub ctrct_tp: Option<CompareFinancialInstrumentContractType1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AsstClss", skip_serializing_if = "Option::is_none") )]
	pub asst_clss: Option<CompareAssetClass1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DerivBasedOnCrptAsst", skip_serializing_if = "Option::is_none") )]
	pub deriv_based_on_crpt_asst: Option<CompareTrueFalseIndicator3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UndrlygInstrm", skip_serializing_if = "Option::is_none") )]
	pub undrlyg_instrm: Option<CompareUnderlyingInstrument3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttlmCcy", skip_serializing_if = "Option::is_none") )]
	pub sttlm_ccy: Option<CompareActiveOrHistoricCurrencyCode1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttlmCcyScndLeg", skip_serializing_if = "Option::is_none") )]
	pub sttlm_ccy_scnd_leg: Option<CompareActiveOrHistoricCurrencyCode1>,
}

impl ContractMatchingCriteria3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.isin { val.validate()? }
		if let Some(ref val) = self.unq_pdct_idr { val.validate()? }
		if let Some(ref val) = self.altrntv_instrm_id { val.validate()? }
		if let Some(ref val) = self.pdct_clssfctn { val.validate()? }
		if let Some(ref val) = self.ctrct_tp { val.validate()? }
		if let Some(ref val) = self.asst_clss { val.validate()? }
		if let Some(ref val) = self.deriv_based_on_crpt_asst { val.validate()? }
		if let Some(ref val) = self.undrlyg_instrm { val.validate()? }
		if let Some(ref val) = self.sttlm_ccy { val.validate()? }
		if let Some(ref val) = self.sttlm_ccy_scnd_leg { val.validate()? }
		Ok(())
	}
}


// ContractModification3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ContractModification3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ActnTp") )]
	pub actn_tp: TransactionOperationType6Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Lvl", skip_serializing_if = "Option::is_none") )]
	pub lvl: Option<ModificationLevel1Code>,
}

impl ContractModification3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.actn_tp.validate()?;
		if let Some(ref val) = self.lvl { val.validate()? }
		Ok(())
	}
}


// ContractModification8 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ContractModification8 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ActnTp") )]
	pub actn_tp: TransactionOperationType11Code,
}

impl ContractModification8 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.actn_tp.validate()?;
		Ok(())
	}
}


// ContractModification9 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ContractModification9 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ActnTp", skip_serializing_if = "Option::is_none") )]
	pub actn_tp: Option<TransactionOperationType10Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Lvl", skip_serializing_if = "Option::is_none") )]
	pub lvl: Option<ModificationLevel1Code>,
}

impl ContractModification9 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.actn_tp { val.validate()? }
		if let Some(ref val) = self.lvl { val.validate()? }
		Ok(())
	}
}


// ContractRegistration7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ContractRegistration7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrctRegnId") )]
	pub ctrct_regn_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgPty") )]
	pub rptg_pty: TradeParty6,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RegnAgt") )]
	pub regn_agt: BranchAndFinancialInstitutionIdentification8,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrctRegnOpng") )]
	pub ctrct_regn_opng: Vec<ContractRegistration8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl ContractRegistration7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.ctrct_regn_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "ctrct_regn_id is shorter than the minimum length of 1".to_string()));
		}
		if self.ctrct_regn_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "ctrct_regn_id exceeds the maximum length of 35".to_string()));
		}
		self.rptg_pty.validate()?;
		self.regn_agt.validate()?;
		for item in &self.ctrct_regn_opng { item.validate()? }
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// ContractRegistration8 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ContractRegistration8 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrctRegnOpngId") )]
	pub ctrct_regn_opng_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prty") )]
	pub prty: Priority2Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ctrct") )]
	pub ctrct: UnderlyingContract4Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrctBal", skip_serializing_if = "Option::is_none") )]
	pub ctrct_bal: Option<Vec<ContractBalance1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtSchdlTp", skip_serializing_if = "Option::is_none") )]
	pub pmt_schdl_tp: Option<PaymentScheduleType2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrvsRegnId", skip_serializing_if = "Option::is_none") )]
	pub prvs_regn_id: Option<Vec<DocumentIdentification22>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_inf: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Attchmnt", skip_serializing_if = "Option::is_none") )]
	pub attchmnt: Option<Vec<DocumentGeneralInformation5>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl ContractRegistration8 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.ctrct_regn_opng_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "ctrct_regn_opng_id is shorter than the minimum length of 1".to_string()));
		}
		if self.ctrct_regn_opng_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "ctrct_regn_opng_id exceeds the maximum length of 35".to_string()));
		}
		self.prty.validate()?;
		self.ctrct.validate()?;
		if let Some(ref vec) = self.ctrct_bal { for item in vec { item.validate()? } }
		if let Some(ref val) = self.pmt_schdl_tp { val.validate()? }
		if let Some(ref vec) = self.prvs_regn_id { for item in vec { item.validate()? } }
		if let Some(ref val) = self.addtl_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 1025 {
				return Err(ValidationError::new(1002, "addtl_inf exceeds the maximum length of 1025".to_string()));
			}
		}
		if let Some(ref vec) = self.attchmnt { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// ContractRegistrationReference2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ContractRegistrationReference2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RegdCtrctId", skip_serializing_if = "Option::is_none") )]
	pub regd_ctrct_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ctrct", skip_serializing_if = "Option::is_none") )]
	pub ctrct: Option<DocumentIdentification35>,
}

impl ContractRegistrationReference2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.regd_ctrct_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "regd_ctrct_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "regd_ctrct_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.ctrct { val.validate()? }
		Ok(())
	}
}


// ContractRegistrationStatement4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ContractRegistrationStatement4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "StmtId", skip_serializing_if = "Option::is_none") )]
	pub stmt_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgPty") )]
	pub rptg_pty: TradeParty6,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RegnAgt") )]
	pub regn_agt: BranchAndFinancialInstitutionIdentification8,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgPrd") )]
	pub rptg_prd: ReportingPeriod4,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RegdCtrct") )]
	pub regd_ctrct: RegisteredContract18,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxJrnl", skip_serializing_if = "Option::is_none") )]
	pub tx_jrnl: Option<Vec<TransactionCertificate4>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SpprtgDocJrnl", skip_serializing_if = "Option::is_none") )]
	pub spprtg_doc_jrnl: Option<Vec<SupportingDocument4>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlSpprtgDocJrnl", skip_serializing_if = "Option::is_none") )]
	pub addtl_spprtg_doc_jrnl: Option<Vec<SupportingDocument4>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RgltryRuleVldtn", skip_serializing_if = "Option::is_none") )]
	pub rgltry_rule_vldtn: Option<Vec<GenericValidationRuleIdentification1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlCtrctTrnvrSum") )]
	pub ttl_ctrct_trnvr_sum: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl ContractRegistrationStatement4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.stmt_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "stmt_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "stmt_id exceeds the maximum length of 35".to_string()));
			}
		}
		self.rptg_pty.validate()?;
		self.regn_agt.validate()?;
		self.rptg_prd.validate()?;
		self.regd_ctrct.validate()?;
		if let Some(ref vec) = self.tx_jrnl { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.spprtg_doc_jrnl { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.addtl_spprtg_doc_jrnl { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.rgltry_rule_vldtn { for item in vec { item.validate()? } }
		self.ttl_ctrct_trnvr_sum.validate()?;
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// ContractRegistrationStatementCriteria1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ContractRegistrationStatementCriteria1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxJrnl", skip_serializing_if = "Option::is_none") )]
	pub tx_jrnl: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SpprtgDocJrnl", skip_serializing_if = "Option::is_none") )]
	pub spprtg_doc_jrnl: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlSpprtgDocJrnl", skip_serializing_if = "Option::is_none") )]
	pub addtl_spprtg_doc_jrnl: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RgltryRuleVldtn", skip_serializing_if = "Option::is_none") )]
	pub rgltry_rule_vldtn: Option<bool>,
}

impl ContractRegistrationStatementCriteria1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ContractRegistrationStatementRequest3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ContractRegistrationStatementRequest3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "StmtReqId") )]
	pub stmt_req_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgPrd") )]
	pub rptg_prd: ReportingPeriod4,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgPty") )]
	pub rptg_pty: TradeParty6,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RegnAgt") )]
	pub regn_agt: BranchAndFinancialInstitutionIdentification8,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RegdCtrctId") )]
	pub regd_ctrct_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RtrCrit", skip_serializing_if = "Option::is_none") )]
	pub rtr_crit: Option<ContractRegistrationStatementCriteria1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl ContractRegistrationStatementRequest3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.stmt_req_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "stmt_req_id is shorter than the minimum length of 1".to_string()));
		}
		if self.stmt_req_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "stmt_req_id exceeds the maximum length of 35".to_string()));
		}
		self.rptg_prd.validate()?;
		self.rptg_pty.validate()?;
		self.regn_agt.validate()?;
		if self.regd_ctrct_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "regd_ctrct_id is shorter than the minimum length of 1".to_string()));
		}
		if self.regd_ctrct_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "regd_ctrct_id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.rtr_crit { val.validate()? }
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// ContractSize1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ContractSize1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "LotSz") )]
	pub lot_sz: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Unit", skip_serializing_if = "Option::is_none") )]
	pub unit: Option<UnitOfMeasure5Choice>,
}

impl ContractSize1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.lot_sz < 1.000000 {
			return Err(ValidationError::new(1003, "lot_sz is less than the minimum value of 1.000000".to_string()));
		}
		if let Some(ref val) = self.unit { val.validate()? }
		Ok(())
	}
}


// ContractTerm6Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ContractTerm6Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Opn", skip_serializing_if = "Option::is_none") )]
	pub opn: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Fxd", skip_serializing_if = "Option::is_none") )]
	pub fxd: Option<TimeToMaturity2Choice>,
}

impl ContractTerm6Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.fxd { val.validate()? }
		Ok(())
	}
}


// ContractTerm7Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ContractTerm7Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Opn", skip_serializing_if = "Option::is_none") )]
	pub opn: Option<FixedOpenTermContract2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Fxd", skip_serializing_if = "Option::is_none") )]
	pub fxd: Option<FixedOpenTermContract2>,
}

impl ContractTerm7Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.opn { val.validate()? }
		if let Some(ref val) = self.fxd { val.validate()? }
		Ok(())
	}
}


// ContractType15 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ContractType15 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrctTp", skip_serializing_if = "Option::is_none") )]
	pub ctrct_tp: Option<FinancialInstrumentContractType2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AsstClss", skip_serializing_if = "Option::is_none") )]
	pub asst_clss: Option<ProductType4Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PdctClssfctn", skip_serializing_if = "Option::is_none") )]
	pub pdct_clssfctn: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PdctId", skip_serializing_if = "Option::is_none") )]
	pub pdct_id: Option<SecurityIdentification46>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UndrlygInstrm", skip_serializing_if = "Option::is_none") )]
	pub undrlyg_instrm: Option<SecurityIdentification41Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UndrlygAsstTradgPltfmIdr", skip_serializing_if = "Option::is_none") )]
	pub undrlyg_asst_tradg_pltfm_idr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UndrlygAsstPricSrc", skip_serializing_if = "Option::is_none") )]
	pub undrlyg_asst_pric_src: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttlmCcy", skip_serializing_if = "Option::is_none") )]
	pub sttlm_ccy: Option<CurrencyExchange23>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttlmCcyScndLeg", skip_serializing_if = "Option::is_none") )]
	pub sttlm_ccy_scnd_leg: Option<CurrencyExchange23>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PlcOfSttlm", skip_serializing_if = "Option::is_none") )]
	pub plc_of_sttlm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DerivBasedOnCrptAsst", skip_serializing_if = "Option::is_none") )]
	pub deriv_based_on_crpt_asst: Option<bool>,
}

impl ContractType15 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ctrct_tp { val.validate()? }
		if let Some(ref val) = self.asst_clss { val.validate()? }
		if let Some(ref val) = self.pdct_clssfctn {
			let pattern = Regex::new("[A-Z]{6,6}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "pdct_clssfctn does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.pdct_id { val.validate()? }
		if let Some(ref val) = self.undrlyg_instrm { val.validate()? }
		if let Some(ref val) = self.undrlyg_asst_tradg_pltfm_idr {
			let pattern = Regex::new("[A-Z0-9]{4,4}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "undrlyg_asst_tradg_pltfm_idr does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.undrlyg_asst_pric_src {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "undrlyg_asst_pric_src is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 50 {
				return Err(ValidationError::new(1002, "undrlyg_asst_pric_src exceeds the maximum length of 50".to_string()));
			}
		}
		if let Some(ref val) = self.sttlm_ccy { val.validate()? }
		if let Some(ref val) = self.sttlm_ccy_scnd_leg { val.validate()? }
		if let Some(ref val) = self.plc_of_sttlm {
			let pattern = Regex::new("[A-Z]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "plc_of_sttlm does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// ContractValuationData8 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ContractValuationData8 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrctVal", skip_serializing_if = "Option::is_none") )]
	pub ctrct_val: Option<AmountAndDirection109>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TmStmp", skip_serializing_if = "Option::is_none") )]
	pub tm_stmp: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<ValuationType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dlta", skip_serializing_if = "Option::is_none") )]
	pub dlta: Option<f64>,
}

impl ContractValuationData8 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ctrct_val { val.validate()? }
		if let Some(ref val) = self.tp { val.validate()? }
		Ok(())
	}
}


// CorporateSectorCriteria5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CorporateSectorCriteria5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FISctr", skip_serializing_if = "Option::is_none") )]
	pub fi_sctr: Option<Vec<FinancialPartySectorType2Code>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NFISctr", skip_serializing_if = "Option::is_none") )]
	pub nfi_sctr: Option<Vec<String>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NotRptd", skip_serializing_if = "Option::is_none") )]
	pub not_rptd: Option<NotReported1Code>,
}

impl CorporateSectorCriteria5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.fi_sctr { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.nfi_sctr {
			for item in vec {
				let pattern = Regex::new("[A-U]{1,1}").unwrap();
				if !pattern.is_match(&item) {
					return Err(ValidationError::new(1005, "nfi_sctr does not match the required pattern".to_string()));
				}
			}
		}
		if let Some(ref val) = self.not_rptd { val.validate()? }
		Ok(())
	}
}


// CorporateSectorCriteria6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CorporateSectorCriteria6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FISctr", skip_serializing_if = "Option::is_none") )]
	pub fi_sctr: Option<Vec<FinancialPartySectorType2Code>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NFISctr", skip_serializing_if = "Option::is_none") )]
	pub nfi_sctr: Option<Vec<NonFinancialPartySector1Code>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NotRptd", skip_serializing_if = "Option::is_none") )]
	pub not_rptd: Option<NotReported1Code>,
}

impl CorporateSectorCriteria6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.fi_sctr { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.nfi_sctr { for item in vec { item.validate()? } }
		if let Some(ref val) = self.not_rptd { val.validate()? }
		Ok(())
	}
}


// Counterparty39 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Counterparty39 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgCtrPty") )]
	pub rptg_ctr_pty: OrganisationIdentification15Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrCtrPty") )]
	pub othr_ctr_pty: PartyIdentification236Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NttyRspnsblForRpt", skip_serializing_if = "Option::is_none") )]
	pub ntty_rspnsbl_for_rpt: Option<OrganisationIdentification15Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptSubmitgNtty", skip_serializing_if = "Option::is_none") )]
	pub rpt_submitg_ntty: Option<OrganisationIdentification15Choice>,
}

impl Counterparty39 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.rptg_ctr_pty.validate()?;
		self.othr_ctr_pty.validate()?;
		if let Some(ref val) = self.ntty_rspnsbl_for_rpt { val.validate()? }
		if let Some(ref val) = self.rpt_submitg_ntty { val.validate()? }
		Ok(())
	}
}


// Counterparty45 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Counterparty45 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: PartyIdentification248Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ntr", skip_serializing_if = "Option::is_none") )]
	pub ntr: Option<CounterpartyTradeNature15Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradgCpcty", skip_serializing_if = "Option::is_none") )]
	pub tradg_cpcty: Option<TradingCapacity7Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DrctnOrSd", skip_serializing_if = "Option::is_none") )]
	pub drctn_or_sd: Option<Direction4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradrLctn", skip_serializing_if = "Option::is_none") )]
	pub tradr_lctn: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BookgLctn", skip_serializing_if = "Option::is_none") )]
	pub bookg_lctn: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgXmptn", skip_serializing_if = "Option::is_none") )]
	pub rptg_xmptn: Option<ReportingExemption1>,
}

impl Counterparty45 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.id.validate()?;
		if let Some(ref val) = self.ntr { val.validate()? }
		if let Some(ref val) = self.tradg_cpcty { val.validate()? }
		if let Some(ref val) = self.drctn_or_sd { val.validate()? }
		if let Some(ref val) = self.tradr_lctn {
			let pattern = Regex::new("[A-Z]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "tradr_lctn does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.bookg_lctn {
			let pattern = Regex::new("[A-Z]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "bookg_lctn does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.rptg_xmptn { val.validate()? }
		Ok(())
	}
}


// Counterparty46 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Counterparty46 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "IdTp", skip_serializing_if = "Option::is_none") )]
	pub id_tp: Option<PartyIdentification248Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ntr", skip_serializing_if = "Option::is_none") )]
	pub ntr: Option<CounterpartyTradeNature15Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgOblgtn", skip_serializing_if = "Option::is_none") )]
	pub rptg_oblgtn: Option<bool>,
}

impl Counterparty46 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.id_tp { val.validate()? }
		if let Some(ref val) = self.ntr { val.validate()? }
		Ok(())
	}
}


// CounterpartyData86 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CounterpartyData86 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgCtrPty", skip_serializing_if = "Option::is_none") )]
	pub rptg_ctr_pty: Option<CounterpartyIdentification10>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrCtrPty", skip_serializing_if = "Option::is_none") )]
	pub othr_ctr_pty: Option<OrganisationIdentification15Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TrptyAgt", skip_serializing_if = "Option::is_none") )]
	pub trpty_agt: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AgtLndr", skip_serializing_if = "Option::is_none") )]
	pub agt_lndr: Option<bool>,
}

impl CounterpartyData86 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.rptg_ctr_pty { val.validate()? }
		if let Some(ref val) = self.othr_ctr_pty { val.validate()? }
		Ok(())
	}
}


// CounterpartyData87 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CounterpartyData87 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptSubmitgNtty") )]
	pub rpt_submitg_ntty: OrganisationIdentification15Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgCtrPty") )]
	pub rptg_ctr_pty: OrganisationIdentification15Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NttyRspnsblForRpt", skip_serializing_if = "Option::is_none") )]
	pub ntty_rspnsbl_for_rpt: Option<OrganisationIdentification15Choice>,
}

impl CounterpartyData87 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.rpt_submitg_ntty.validate()?;
		self.rptg_ctr_pty.validate()?;
		if let Some(ref val) = self.ntty_rspnsbl_for_rpt { val.validate()? }
		Ok(())
	}
}


// CounterpartyData88 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CounterpartyData88 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgDtTm") )]
	pub rptg_dt_tm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptSubmitgNtty") )]
	pub rpt_submitg_ntty: OrganisationIdentification15Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPty") )]
	pub ctr_pty: Vec<CounterpartyData89>,
}

impl CounterpartyData88 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.rpt_submitg_ntty.validate()?;
		for item in &self.ctr_pty { item.validate()? }
		Ok(())
	}
}


// CounterpartyData89 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CounterpartyData89 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgCtrPty") )]
	pub rptg_ctr_pty: CounterpartyIdentification11,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrCtrPty") )]
	pub othr_ctr_pty: CounterpartyIdentification12,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NttyRspnsblForRpt", skip_serializing_if = "Option::is_none") )]
	pub ntty_rspnsbl_for_rpt: Option<OrganisationIdentification15Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrPtyData", skip_serializing_if = "Option::is_none") )]
	pub othr_pty_data: Option<TransactionCounterpartyData11>,
}

impl CounterpartyData89 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.rptg_ctr_pty.validate()?;
		self.othr_ctr_pty.validate()?;
		if let Some(ref val) = self.ntty_rspnsbl_for_rpt { val.validate()? }
		if let Some(ref val) = self.othr_pty_data { val.validate()? }
		Ok(())
	}
}


// CounterpartyData91 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CounterpartyData91 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgCtrPty", skip_serializing_if = "Option::is_none") )]
	pub rptg_ctr_pty: Option<OrganisationIdentification15Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrCtrPty", skip_serializing_if = "Option::is_none") )]
	pub othr_ctr_pty: Option<PartyIdentification236Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptSubmitgNtty", skip_serializing_if = "Option::is_none") )]
	pub rpt_submitg_ntty: Option<OrganisationIdentification15Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NttyRspnsblForRpt", skip_serializing_if = "Option::is_none") )]
	pub ntty_rspnsbl_for_rpt: Option<OrganisationIdentification15Choice>,
}

impl CounterpartyData91 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.rptg_ctr_pty { val.validate()? }
		if let Some(ref val) = self.othr_ctr_pty { val.validate()? }
		if let Some(ref val) = self.rpt_submitg_ntty { val.validate()? }
		if let Some(ref val) = self.ntty_rspnsbl_for_rpt { val.validate()? }
		Ok(())
	}
}


// CounterpartyData92 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CounterpartyData92 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgCtrPty", skip_serializing_if = "Option::is_none") )]
	pub rptg_ctr_pty: Option<OrganisationIdentification15Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptSubmitgNtty", skip_serializing_if = "Option::is_none") )]
	pub rpt_submitg_ntty: Option<OrganisationIdentification15Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NttyRspnsblForRpt", skip_serializing_if = "Option::is_none") )]
	pub ntty_rspnsbl_for_rpt: Option<OrganisationIdentification15Choice>,
}

impl CounterpartyData92 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.rptg_ctr_pty { val.validate()? }
		if let Some(ref val) = self.rpt_submitg_ntty { val.validate()? }
		if let Some(ref val) = self.ntty_rspnsbl_for_rpt { val.validate()? }
		Ok(())
	}
}


// CounterpartyIdentification10 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CounterpartyIdentification10 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<OrganisationIdentification15Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sd", skip_serializing_if = "Option::is_none") )]
	pub sd: Option<CollateralRole1Code>,
}

impl CounterpartyIdentification10 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.id { val.validate()? }
		if let Some(ref val) = self.sd { val.validate()? }
		Ok(())
	}
}


// CounterpartyIdentification11 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CounterpartyIdentification11 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: OrganisationIdentification15Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ntr", skip_serializing_if = "Option::is_none") )]
	pub ntr: Option<CounterpartyTradeNature7Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Brnch", skip_serializing_if = "Option::is_none") )]
	pub brnch: Option<Branch5Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sd", skip_serializing_if = "Option::is_none") )]
	pub sd: Option<CollateralRole1Code>,
}

impl CounterpartyIdentification11 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.id.validate()?;
		if let Some(ref val) = self.ntr { val.validate()? }
		if let Some(ref val) = self.brnch { val.validate()? }
		if let Some(ref val) = self.sd { val.validate()? }
		Ok(())
	}
}


// CounterpartyIdentification12 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CounterpartyIdentification12 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: PartyIdentification236Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Brnch", skip_serializing_if = "Option::is_none") )]
	pub brnch: Option<Branch6Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtryCd", skip_serializing_if = "Option::is_none") )]
	pub ctry_cd: Option<String>,
}

impl CounterpartyIdentification12 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.id.validate()?;
		if let Some(ref val) = self.brnch { val.validate()? }
		if let Some(ref val) = self.ctry_cd {
			let pattern = Regex::new("[A-Z]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ctry_cd does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// CounterpartyIdentification3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CounterpartyIdentification3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "LEI", skip_serializing_if = "Option::is_none") )]
	pub lei: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SctrAndLctn", skip_serializing_if = "Option::is_none") )]
	pub sctr_and_lctn: Option<SectorAndLocation1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NmAndLctn", skip_serializing_if = "Option::is_none") )]
	pub nm_and_lctn: Option<NameAndLocation1>,
}

impl CounterpartyIdentification3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.lei {
			let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "lei does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.sctr_and_lctn { val.validate()? }
		if let Some(ref val) = self.nm_and_lctn { val.validate()? }
		Ok(())
	}
}


// CounterpartyMatchingCriteria4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CounterpartyMatchingCriteria4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgCtrPty", skip_serializing_if = "Option::is_none") )]
	pub rptg_ctr_pty: Option<CompareOrganisationIdentification6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrCtrPty", skip_serializing_if = "Option::is_none") )]
	pub othr_ctr_pty: Option<CompareOrganisationIdentification7>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPtySd", skip_serializing_if = "Option::is_none") )]
	pub ctr_pty_sd: Option<CompareCounterpartySide2>,
}

impl CounterpartyMatchingCriteria4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.rptg_ctr_pty { val.validate()? }
		if let Some(ref val) = self.othr_ctr_pty { val.validate()? }
		if let Some(ref val) = self.ctr_pty_sd { val.validate()? }
		Ok(())
	}
}


// CounterpartyMatchingCriteria6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CounterpartyMatchingCriteria6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgCtrPty", skip_serializing_if = "Option::is_none") )]
	pub rptg_ctr_pty: Option<CompareOrganisationIdentification6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrCtrPty", skip_serializing_if = "Option::is_none") )]
	pub othr_ctr_pty: Option<CompareOrganisationIdentification7>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DrctnOrSd", skip_serializing_if = "Option::is_none") )]
	pub drctn_or_sd: Option<CompareLegDirection2>,
}

impl CounterpartyMatchingCriteria6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.rptg_ctr_pty { val.validate()? }
		if let Some(ref val) = self.othr_ctr_pty { val.validate()? }
		if let Some(ref val) = self.drctn_or_sd { val.validate()? }
		Ok(())
	}
}


// CounterpartySpecificData36 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CounterpartySpecificData36 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPty") )]
	pub ctr_pty: TradeCounterpartyReport20,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Valtn", skip_serializing_if = "Option::is_none") )]
	pub valtn: Option<ContractValuationData8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgTmStmp", skip_serializing_if = "Option::is_none") )]
	pub rptg_tm_stmp: Option<String>,
}

impl CounterpartySpecificData36 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.ctr_pty.validate()?;
		if let Some(ref val) = self.valtn { val.validate()? }
		Ok(())
	}
}


// CounterpartyTradeNature15Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CounterpartyTradeNature15Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FI", skip_serializing_if = "Option::is_none") )]
	pub fi: Option<FinancialInstitutionSector1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NFI", skip_serializing_if = "Option::is_none") )]
	pub nfi: Option<NonFinancialInstitutionSector10>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CntrlCntrPty", skip_serializing_if = "Option::is_none") )]
	pub cntrl_cntr_pty: Option<NoReasonCode>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<NoReasonCode>,
}

impl CounterpartyTradeNature15Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.fi { val.validate()? }
		if let Some(ref val) = self.nfi { val.validate()? }
		if let Some(ref val) = self.cntrl_cntr_pty { val.validate()? }
		if let Some(ref val) = self.othr { val.validate()? }
		Ok(())
	}
}


// CounterpartyTradeNature7Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CounterpartyTradeNature7Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FI", skip_serializing_if = "Option::is_none") )]
	pub fi: Option<FinancialPartyClassification1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NFI", skip_serializing_if = "Option::is_none") )]
	pub nfi: Option<Vec<FinancialPartyClassification2>>,
}

impl CounterpartyTradeNature7Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.fi { val.validate()? }
		if let Some(ref vec) = self.nfi { for item in vec { item.validate()? } }
		Ok(())
	}
}


// CountryCodeAndName3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CountryCodeAndName3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd") )]
	pub cd: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm") )]
	pub nm: String,
}

impl CountryCodeAndName3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z]{2,2}").unwrap();
		if !pattern.is_match(&self.cd) {
			return Err(ValidationError::new(1005, "cd does not match the required pattern".to_string()));
		}
		if self.nm.chars().count() < 1 {
			return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
		}
		if self.nm.chars().count() > 70 {
			return Err(ValidationError::new(1002, "nm exceeds the maximum length of 70".to_string()));
		}
		Ok(())
	}
}


// CoverTwoDefaulters1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CoverTwoDefaulters1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cover1Id") )]
	pub cover1_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cover2Id") )]
	pub cover2_id: String,
}

impl CoverTwoDefaulters1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
		if !pattern.is_match(&self.cover1_id) {
			return Err(ValidationError::new(1005, "cover1_id does not match the required pattern".to_string()));
		}
		let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
		if !pattern.is_match(&self.cover2_id) {
			return Err(ValidationError::new(1005, "cover2_id does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// CreditDebit3Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum CreditDebit3Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "CRDT") )]
	CodeCRDT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DBIT") )]
	CodeDBIT,
}

impl CreditDebit3Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// CreditDefaultSwapDerivative5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CreditDefaultSwapDerivative5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "UndrlygCdtDfltSwpId", skip_serializing_if = "Option::is_none") )]
	pub undrlyg_cdt_dflt_swp_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UndrlygCdtDfltSwpIndx") )]
	pub undrlyg_cdt_dflt_swp_indx: CreditDefaultSwapIndex3,
}

impl CreditDefaultSwapDerivative5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.undrlyg_cdt_dflt_swp_id {
			let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "undrlyg_cdt_dflt_swp_id does not match the required pattern".to_string()));
			}
		}
		self.undrlyg_cdt_dflt_swp_indx.validate()?;
		Ok(())
	}
}


// CreditDefaultSwapDerivative6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CreditDefaultSwapDerivative6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "UndrlygCdtDfltSwpId", skip_serializing_if = "Option::is_none") )]
	pub undrlyg_cdt_dflt_swp_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OblgtnId") )]
	pub oblgtn_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SnglNm") )]
	pub sngl_nm: CreditDefaultSwapSingleName2,
}

impl CreditDefaultSwapDerivative6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.undrlyg_cdt_dflt_swp_id {
			let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "undrlyg_cdt_dflt_swp_id does not match the required pattern".to_string()));
			}
		}
		let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
		if !pattern.is_match(&self.oblgtn_id) {
			return Err(ValidationError::new(1005, "oblgtn_id does not match the required pattern".to_string()));
		}
		self.sngl_nm.validate()?;
		Ok(())
	}
}


// CreditDefaultSwapIndex3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CreditDefaultSwapIndex3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "UndrlygIndxId", skip_serializing_if = "Option::is_none") )]
	pub undrlyg_indx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UndrlygIndxNm", skip_serializing_if = "Option::is_none") )]
	pub undrlyg_indx_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Srs", skip_serializing_if = "Option::is_none") )]
	pub srs: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Vrsn", skip_serializing_if = "Option::is_none") )]
	pub vrsn: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RollMnth", skip_serializing_if = "Option::is_none") )]
	pub roll_mnth: Option<Vec<f64>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NxtRollDt", skip_serializing_if = "Option::is_none") )]
	pub nxt_roll_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtnlCcy") )]
	pub ntnl_ccy: String,
}

impl CreditDefaultSwapIndex3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.undrlyg_indx_id {
			let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "undrlyg_indx_id does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.undrlyg_indx_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "undrlyg_indx_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 25 {
				return Err(ValidationError::new(1002, "undrlyg_indx_nm exceeds the maximum length of 25".to_string()));
			}
		}
		if let Some(ref vec) = self.roll_mnth {
			for item in vec {
				if *item < 1.000000 {
					return Err(ValidationError::new(1003, "roll_mnth is less than the minimum value of 1.000000".to_string()));
				}
				if *item > 12.000000 {
					return Err(ValidationError::new(1004, "roll_mnth exceeds the maximum value of 12.000000".to_string()));
				}
			}
		}
		let pattern = Regex::new("[A-Z]{3,3}").unwrap();
		if !pattern.is_match(&self.ntnl_ccy) {
			return Err(ValidationError::new(1005, "ntnl_ccy does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// CreditDefaultSwapSingleName2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CreditDefaultSwapSingleName2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SvrgnIssr") )]
	pub svrgn_issr: bool,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RefPty", skip_serializing_if = "Option::is_none") )]
	pub ref_pty: Option<DerivativePartyIdentification1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtnlCcy") )]
	pub ntnl_ccy: String,
}

impl CreditDefaultSwapSingleName2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ref_pty { val.validate()? }
		let pattern = Regex::new("[A-Z]{3,3}").unwrap();
		if !pattern.is_match(&self.ntnl_ccy) {
			return Err(ValidationError::new(1005, "ntnl_ccy does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// CreditDefaultSwapsDerivative4Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CreditDefaultSwapsDerivative4Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SnglNmCdtDfltSwp", skip_serializing_if = "Option::is_none") )]
	pub sngl_nm_cdt_dflt_swp: Option<CreditDefaultSwapSingleName2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtDfltSwpIndx", skip_serializing_if = "Option::is_none") )]
	pub cdt_dflt_swp_indx: Option<CreditDefaultSwapIndex3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SnglNmCdtDfltSwpDeriv", skip_serializing_if = "Option::is_none") )]
	pub sngl_nm_cdt_dflt_swp_deriv: Option<CreditDefaultSwapDerivative6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtDfltSwpIndxDeriv", skip_serializing_if = "Option::is_none") )]
	pub cdt_dflt_swp_indx_deriv: Option<CreditDefaultSwapDerivative5>,
}

impl CreditDefaultSwapsDerivative4Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.sngl_nm_cdt_dflt_swp { val.validate()? }
		if let Some(ref val) = self.cdt_dflt_swp_indx { val.validate()? }
		if let Some(ref val) = self.sngl_nm_cdt_dflt_swp_deriv { val.validate()? }
		if let Some(ref val) = self.cdt_dflt_swp_indx_deriv { val.validate()? }
		Ok(())
	}
}


// CreditDerivative4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CreditDerivative4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Snrty", skip_serializing_if = "Option::is_none") )]
	pub snrty: Option<DebtInstrumentSeniorityType2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RefPty", skip_serializing_if = "Option::is_none") )]
	pub ref_pty: Option<DerivativePartyIdentification1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtFrqcy", skip_serializing_if = "Option::is_none") )]
	pub pmt_frqcy: Option<Frequency13Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClctnBsis", skip_serializing_if = "Option::is_none") )]
	pub clctn_bsis: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Srs", skip_serializing_if = "Option::is_none") )]
	pub srs: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Vrsn", skip_serializing_if = "Option::is_none") )]
	pub vrsn: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IndxFctr", skip_serializing_if = "Option::is_none") )]
	pub indx_fctr: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Trch", skip_serializing_if = "Option::is_none") )]
	pub trch: Option<TrancheIndicator3Choice>,
}

impl CreditDerivative4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.snrty { val.validate()? }
		if let Some(ref val) = self.ref_pty { val.validate()? }
		if let Some(ref val) = self.pmt_frqcy { val.validate()? }
		if let Some(ref val) = self.clctn_bsis {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "clctn_bsis is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "clctn_bsis exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.trch { val.validate()? }
		Ok(())
	}
}


// CreditDerivative7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CreditDerivative7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Snrty", skip_serializing_if = "Option::is_none") )]
	pub snrty: Option<DebtInstrumentSeniorityType2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RefPty", skip_serializing_if = "Option::is_none") )]
	pub ref_pty: Option<DerivativePartyIdentification1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtFrqcy", skip_serializing_if = "Option::is_none") )]
	pub pmt_frqcy: Option<Frequency13Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClctnBsis", skip_serializing_if = "Option::is_none") )]
	pub clctn_bsis: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Srs", skip_serializing_if = "Option::is_none") )]
	pub srs: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Vrsn", skip_serializing_if = "Option::is_none") )]
	pub vrsn: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IndxFctr", skip_serializing_if = "Option::is_none") )]
	pub indx_fctr: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TrchInd", skip_serializing_if = "Option::is_none") )]
	pub trch_ind: Option<bool>,
}

impl CreditDerivative7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.snrty { val.validate()? }
		if let Some(ref val) = self.ref_pty { val.validate()? }
		if let Some(ref val) = self.pmt_frqcy { val.validate()? }
		if let Some(ref val) = self.clctn_bsis {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "clctn_bsis is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "clctn_bsis exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// CreditQuality1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum CreditQuality1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "DFIM") )]
	CodeDFIM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EXSP") )]
	CodeEXSP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "HIGR") )]
	CodeHIGR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "HISP") )]
	CodeHISP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INDF") )]
	CodeINDF,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LMGR") )]
	CodeLMGR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NIGS") )]
	CodeNIGS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PRIM") )]
	CodePRIM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SURI") )]
	CodeSURI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UMGR") )]
	CodeUMGR,
}

impl CreditQuality1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// CreditorReferenceInformation2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CreditorReferenceInformation2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<CreditorReferenceType2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ref", skip_serializing_if = "Option::is_none") )]
	pub ref_attr: Option<String>,
}

impl CreditorReferenceInformation2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tp { val.validate()? }
		if let Some(ref val) = self.ref_attr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "ref_attr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "ref_attr exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// CreditorReferenceType1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CreditorReferenceType1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<DocumentType3Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl CreditorReferenceType1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// CreditorReferenceType2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CreditorReferenceType2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdOrPrtry") )]
	pub cd_or_prtry: CreditorReferenceType1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr", skip_serializing_if = "Option::is_none") )]
	pub issr: Option<String>,
}

impl CreditorReferenceType2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.cd_or_prtry.validate()?;
		if let Some(ref val) = self.issr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "issr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "issr exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// CurrencyAndAmount ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CurrencyAndAmount {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ccy") )]
	pub ccy: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "$value") )]
	pub value: f64,
}

impl CurrencyAndAmount {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// CurrencyCodeAndName1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CurrencyCodeAndName1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd") )]
	pub cd: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm") )]
	pub nm: String,
}

impl CurrencyCodeAndName1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z]{3,3}").unwrap();
		if !pattern.is_match(&self.cd) {
			return Err(ValidationError::new(1005, "cd does not match the required pattern".to_string()));
		}
		if self.nm.chars().count() < 1 {
			return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
		}
		if self.nm.chars().count() > 70 {
			return Err(ValidationError::new(1002, "nm exceeds the maximum length of 70".to_string()));
		}
		Ok(())
	}
}


// CurrencyControlGroupStatus3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CurrencyControlGroupStatus3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlRefs") )]
	pub orgnl_refs: OriginalMessage7,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgPty") )]
	pub rptg_pty: TradeParty6,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RegnAgt") )]
	pub regn_agt: BranchAndFinancialInstitutionIdentification8,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgPrd", skip_serializing_if = "Option::is_none") )]
	pub rptg_prd: Option<Period4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sts", skip_serializing_if = "Option::is_none") )]
	pub sts: Option<StatisticalReportingStatus1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StsRsn", skip_serializing_if = "Option::is_none") )]
	pub sts_rsn: Option<Vec<ValidationStatusReason3>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StsDtTm", skip_serializing_if = "Option::is_none") )]
	pub sts_dt_tm: Option<String>,
}

impl CurrencyControlGroupStatus3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.orgnl_refs.validate()?;
		self.rptg_pty.validate()?;
		self.regn_agt.validate()?;
		if let Some(ref val) = self.rptg_prd { val.validate()? }
		if let Some(ref val) = self.sts { val.validate()? }
		if let Some(ref vec) = self.sts_rsn { for item in vec { item.validate()? } }
		Ok(())
	}
}


// CurrencyControlHeader7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CurrencyControlHeader7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgId") )]
	pub msg_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CreDtTm") )]
	pub cre_dt_tm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfItms") )]
	pub nb_of_itms: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RcvgPty") )]
	pub rcvg_pty: PartyIdentification272,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RegnAgt") )]
	pub regn_agt: BranchAndFinancialInstitutionIdentification8,
}

impl CurrencyControlHeader7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.msg_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "msg_id is shorter than the minimum length of 1".to_string()));
		}
		if self.msg_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "msg_id exceeds the maximum length of 35".to_string()));
		}
		let pattern = Regex::new("[0-9]{1,15}").unwrap();
		if !pattern.is_match(&self.nb_of_itms) {
			return Err(ValidationError::new(1005, "nb_of_itms does not match the required pattern".to_string()));
		}
		self.rcvg_pty.validate()?;
		self.regn_agt.validate()?;
		Ok(())
	}
}


// CurrencyControlHeader8 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CurrencyControlHeader8 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgId") )]
	pub msg_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CreDtTm") )]
	pub cre_dt_tm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfItms") )]
	pub nb_of_itms: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InitgPty") )]
	pub initg_pty: PartyIdentification272,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FwdgAgt", skip_serializing_if = "Option::is_none") )]
	pub fwdg_agt: Option<BranchAndFinancialInstitutionIdentification8>,
}

impl CurrencyControlHeader8 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.msg_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "msg_id is shorter than the minimum length of 1".to_string()));
		}
		if self.msg_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "msg_id exceeds the maximum length of 35".to_string()));
		}
		let pattern = Regex::new("[0-9]{1,15}").unwrap();
		if !pattern.is_match(&self.nb_of_itms) {
			return Err(ValidationError::new(1005, "nb_of_itms does not match the required pattern".to_string()));
		}
		self.initg_pty.validate()?;
		if let Some(ref val) = self.fwdg_agt { val.validate()? }
		Ok(())
	}
}


// CurrencyControlHeader9 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CurrencyControlHeader9 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgId") )]
	pub msg_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CreDtTm") )]
	pub cre_dt_tm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfItms") )]
	pub nb_of_itms: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InitgPty") )]
	pub initg_pty: Party50Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FwdgAgt", skip_serializing_if = "Option::is_none") )]
	pub fwdg_agt: Option<BranchAndFinancialInstitutionIdentification8>,
}

impl CurrencyControlHeader9 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.msg_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "msg_id is shorter than the minimum length of 1".to_string()));
		}
		if self.msg_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "msg_id exceeds the maximum length of 35".to_string()));
		}
		let pattern = Regex::new("[0-9]{1,15}").unwrap();
		if !pattern.is_match(&self.nb_of_itms) {
			return Err(ValidationError::new(1005, "nb_of_itms does not match the required pattern".to_string()));
		}
		self.initg_pty.validate()?;
		if let Some(ref val) = self.fwdg_agt { val.validate()? }
		Ok(())
	}
}


// CurrencyControlPackageStatus3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CurrencyControlPackageStatus3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PackgId") )]
	pub packg_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sts") )]
	pub sts: StatisticalReportingStatus1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StsRsn", skip_serializing_if = "Option::is_none") )]
	pub sts_rsn: Option<Vec<ValidationStatusReason3>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StsDtTm", skip_serializing_if = "Option::is_none") )]
	pub sts_dt_tm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RcrdSts", skip_serializing_if = "Option::is_none") )]
	pub rcrd_sts: Option<Vec<CurrencyControlRecordStatus3>>,
}

impl CurrencyControlPackageStatus3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.packg_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "packg_id is shorter than the minimum length of 1".to_string()));
		}
		if self.packg_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "packg_id exceeds the maximum length of 35".to_string()));
		}
		self.sts.validate()?;
		if let Some(ref vec) = self.sts_rsn { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.rcrd_sts { for item in vec { item.validate()? } }
		Ok(())
	}
}


// CurrencyControlRecordStatus3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CurrencyControlRecordStatus3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RcrdId") )]
	pub rcrd_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sts") )]
	pub sts: StatisticalReportingStatus1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StsRsn", skip_serializing_if = "Option::is_none") )]
	pub sts_rsn: Option<Vec<ValidationStatusReason3>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StsDtTm", skip_serializing_if = "Option::is_none") )]
	pub sts_dt_tm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DocId", skip_serializing_if = "Option::is_none") )]
	pub doc_id: Option<DocumentIdentification28>,
}

impl CurrencyControlRecordStatus3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.rcrd_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "rcrd_id is shorter than the minimum length of 1".to_string()));
		}
		if self.rcrd_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "rcrd_id exceeds the maximum length of 35".to_string()));
		}
		self.sts.validate()?;
		if let Some(ref vec) = self.sts_rsn { for item in vec { item.validate()? } }
		if let Some(ref val) = self.doc_id { val.validate()? }
		Ok(())
	}
}


// CurrencyExchange22 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CurrencyExchange22 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DlvrblCrossCcy", skip_serializing_if = "Option::is_none") )]
	pub dlvrbl_cross_ccy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XchgRate", skip_serializing_if = "Option::is_none") )]
	pub xchg_rate: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FwdXchgRate", skip_serializing_if = "Option::is_none") )]
	pub fwd_xchg_rate: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XchgRateBsis", skip_serializing_if = "Option::is_none") )]
	pub xchg_rate_bsis: Option<ExchangeRateBasis1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FxgDt", skip_serializing_if = "Option::is_none") )]
	pub fxg_dt: Option<String>,
}

impl CurrencyExchange22 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.dlvrbl_cross_ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "dlvrbl_cross_ccy does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.xchg_rate_bsis { val.validate()? }
		Ok(())
	}
}


// CurrencyExchange23 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CurrencyExchange23 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ccy") )]
	pub ccy: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XchgRate", skip_serializing_if = "Option::is_none") )]
	pub xchg_rate: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FwdXchgRate", skip_serializing_if = "Option::is_none") )]
	pub fwd_xchg_rate: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XchgRateBsis", skip_serializing_if = "Option::is_none") )]
	pub xchg_rate_bsis: Option<ExchangeRateBasis1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FxgDt", skip_serializing_if = "Option::is_none") )]
	pub fxg_dt: Option<String>,
}

impl CurrencyExchange23 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z]{3,3}").unwrap();
		if !pattern.is_match(&self.ccy) {
			return Err(ValidationError::new(1005, "ccy does not match the required pattern".to_string()));
		}
		if let Some(ref val) = self.xchg_rate_bsis { val.validate()? }
		Ok(())
	}
}


// CurrencyReference3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CurrencyReference3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TrgtCcy") )]
	pub trgt_ccy: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SrcCcy") )]
	pub src_ccy: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XchgRateInf", skip_serializing_if = "Option::is_none") )]
	pub xchg_rate_inf: Option<Vec<ExchangeRateInformation1>>,
}

impl CurrencyReference3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z]{3,3}").unwrap();
		if !pattern.is_match(&self.trgt_ccy) {
			return Err(ValidationError::new(1005, "trgt_ccy does not match the required pattern".to_string()));
		}
		let pattern = Regex::new("[A-Z]{3,3}").unwrap();
		if !pattern.is_match(&self.src_ccy) {
			return Err(ValidationError::new(1005, "src_ccy does not match the required pattern".to_string()));
		}
		if let Some(ref vec) = self.xchg_rate_inf { for item in vec { item.validate()? } }
		Ok(())
	}
}


// CustomBasket4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CustomBasket4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Strr", skip_serializing_if = "Option::is_none") )]
	pub strr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cnsttnts", skip_serializing_if = "Option::is_none") )]
	pub cnsttnts: Option<Vec<BasketConstituents3>>,
}

impl CustomBasket4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.strr {
			let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "strr does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 52 {
				return Err(ValidationError::new(1002, "id exceeds the maximum length of 52".to_string()));
			}
		}
		if let Some(ref vec) = self.cnsttnts { for item in vec { item.validate()? } }
		Ok(())
	}
}


// CustomerIdentification2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct CustomerIdentification2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pty") )]
	pub pty: PartyIdentification272,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AuthrtyReq") )]
	pub authrty_req: Vec<AuthorityInvestigation2>,
}

impl CustomerIdentification2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.pty.validate()?;
		for item in &self.authrty_req { item.validate()? }
		Ok(())
	}
}


// DateAndDateTime2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DateAndDateTime2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dt", skip_serializing_if = "Option::is_none") )]
	pub dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtTm", skip_serializing_if = "Option::is_none") )]
	pub dt_tm: Option<String>,
}

impl DateAndDateTime2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// DateAndDateTimeChoice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DateAndDateTimeChoice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dt", skip_serializing_if = "Option::is_none") )]
	pub dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtTm", skip_serializing_if = "Option::is_none") )]
	pub dt_tm: Option<String>,
}

impl DateAndDateTimeChoice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// DateAndPlaceOfBirth ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DateAndPlaceOfBirth {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BirthDt") )]
	pub birth_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrvcOfBirth", skip_serializing_if = "Option::is_none") )]
	pub prvc_of_birth: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CityOfBirth") )]
	pub city_of_birth: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtryOfBirth") )]
	pub ctry_of_birth: String,
}

impl DateAndPlaceOfBirth {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.prvc_of_birth {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prvc_of_birth is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prvc_of_birth exceeds the maximum length of 35".to_string()));
			}
		}
		if self.city_of_birth.chars().count() < 1 {
			return Err(ValidationError::new(1001, "city_of_birth is shorter than the minimum length of 1".to_string()));
		}
		if self.city_of_birth.chars().count() > 35 {
			return Err(ValidationError::new(1002, "city_of_birth exceeds the maximum length of 35".to_string()));
		}
		let pattern = Regex::new("[A-Z]{2,2}").unwrap();
		if !pattern.is_match(&self.ctry_of_birth) {
			return Err(ValidationError::new(1005, "ctry_of_birth does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// DateAndPlaceOfBirth1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DateAndPlaceOfBirth1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BirthDt") )]
	pub birth_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrvcOfBirth", skip_serializing_if = "Option::is_none") )]
	pub prvc_of_birth: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CityOfBirth") )]
	pub city_of_birth: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtryOfBirth") )]
	pub ctry_of_birth: String,
}

impl DateAndPlaceOfBirth1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.prvc_of_birth {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prvc_of_birth is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prvc_of_birth exceeds the maximum length of 35".to_string()));
			}
		}
		if self.city_of_birth.chars().count() < 1 {
			return Err(ValidationError::new(1001, "city_of_birth is shorter than the minimum length of 1".to_string()));
		}
		if self.city_of_birth.chars().count() > 35 {
			return Err(ValidationError::new(1002, "city_of_birth exceeds the maximum length of 35".to_string()));
		}
		let pattern = Regex::new("[A-Z]{2,2}").unwrap();
		if !pattern.is_match(&self.ctry_of_birth) {
			return Err(ValidationError::new(1005, "ctry_of_birth does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// DateOrBlankQuery2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DateOrBlankQuery2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rg", skip_serializing_if = "Option::is_none") )]
	pub rg: Option<DatePeriod1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NotRptd", skip_serializing_if = "Option::is_none") )]
	pub not_rptd: Option<NotReported1Code>,
}

impl DateOrBlankQuery2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.rg { val.validate()? }
		if let Some(ref val) = self.not_rptd { val.validate()? }
		Ok(())
	}
}


// DateOrDateTimePeriod1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DateOrDateTimePeriod1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dt", skip_serializing_if = "Option::is_none") )]
	pub dt: Option<DatePeriod2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtTm", skip_serializing_if = "Option::is_none") )]
	pub dt_tm: Option<DateTimePeriod1>,
}

impl DateOrDateTimePeriod1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.dt { val.validate()? }
		if let Some(ref val) = self.dt_tm { val.validate()? }
		Ok(())
	}
}


// DatePeriod1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DatePeriod1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrDt", skip_serializing_if = "Option::is_none") )]
	pub fr_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ToDt") )]
	pub to_dt: String,
}

impl DatePeriod1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// DatePeriod2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DatePeriod2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrDt") )]
	pub fr_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ToDt") )]
	pub to_dt: String,
}

impl DatePeriod2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// DatePeriod3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DatePeriod3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrDt") )]
	pub fr_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ToDt", skip_serializing_if = "Option::is_none") )]
	pub to_dt: Option<String>,
}

impl DatePeriod3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// DatePeriod4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DatePeriod4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrDt", skip_serializing_if = "Option::is_none") )]
	pub fr_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ToDt", skip_serializing_if = "Option::is_none") )]
	pub to_dt: Option<String>,
}

impl DatePeriod4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// DateTimeOrBlankQuery1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DateTimeOrBlankQuery1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rg", skip_serializing_if = "Option::is_none") )]
	pub rg: Option<DateTimePeriod1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NotRptd", skip_serializing_if = "Option::is_none") )]
	pub not_rptd: Option<NotReported1Code>,
}

impl DateTimeOrBlankQuery1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.rg { val.validate()? }
		if let Some(ref val) = self.not_rptd { val.validate()? }
		Ok(())
	}
}


// DateTimePeriod1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DateTimePeriod1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrDtTm") )]
	pub fr_dt_tm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ToDtTm") )]
	pub to_dt_tm: String,
}

impl DateTimePeriod1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// DebtInstrument2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DebtInstrument2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlIssdNmnlAmt") )]
	pub ttl_issd_nmnl_amt: ActiveOrHistoricCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MtrtyDt", skip_serializing_if = "Option::is_none") )]
	pub mtrty_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NmnlValPerUnit") )]
	pub nmnl_val_per_unit: ActiveOrHistoricCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstRate") )]
	pub intrst_rate: InterestRate6Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DebtSnrty", skip_serializing_if = "Option::is_none") )]
	pub debt_snrty: Option<DebtInstrumentSeniorityType1Code>,
}

impl DebtInstrument2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.ttl_issd_nmnl_amt.validate()?;
		self.nmnl_val_per_unit.validate()?;
		self.intrst_rate.validate()?;
		if let Some(ref val) = self.debt_snrty { val.validate()? }
		Ok(())
	}
}


// DebtInstrument4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DebtInstrument4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MtrtyDt") )]
	pub mtrty_dt: String,
}

impl DebtInstrument4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// DebtInstrument5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DebtInstrument5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: BondType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IssncDt") )]
	pub issnc_dt: String,
}

impl DebtInstrument5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.tp.validate()?;
		Ok(())
	}
}


// DebtInstrumentSeniorityType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum DebtInstrumentSeniorityType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "SBOD") )]
	CodeSBOD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SNDB") )]
	CodeSNDB,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MZZD") )]
	CodeMZZD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "JUND") )]
	CodeJUND,
}

impl DebtInstrumentSeniorityType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// DebtInstrumentSeniorityType2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum DebtInstrumentSeniorityType2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "SBOD") )]
	CodeSBOD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SNDB") )]
	CodeSNDB,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
}

impl DebtInstrumentSeniorityType2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// DefaultFundRequirement1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DefaultFundRequirement1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrMmbId") )]
	pub clr_mmb_id: GenericIdentification165,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SvcId", skip_serializing_if = "Option::is_none") )]
	pub svc_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveCurrencyAndAmount,
}

impl DefaultFundRequirement1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.clr_mmb_id.validate()?;
		if let Some(ref val) = self.svc_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "svc_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "svc_id exceeds the maximum length of 35".to_string()));
			}
		}
		self.amt.validate()?;
		Ok(())
	}
}


// DefinedAttributes1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DefinedAttributes1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "QtyDfndAttrbts", skip_serializing_if = "Option::is_none") )]
	pub qty_dfnd_attrbts: Option<FinancialInstrumentAttributes89>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ValDfndAttrbts", skip_serializing_if = "Option::is_none") )]
	pub val_dfnd_attrbts: Option<FinancialInstrumentAttributes90>,
}

impl DefinedAttributes1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.qty_dfnd_attrbts { val.validate()? }
		if let Some(ref val) = self.val_dfnd_attrbts { val.validate()? }
		Ok(())
	}
}


// DeliveryInterconnectionPoint1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DeliveryInterconnectionPoint1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl DeliveryInterconnectionPoint1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			let pattern = Regex::new("[A-Z0-9\\-]{16}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "cd does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 52 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 52".to_string()));
			}
		}
		Ok(())
	}
}


// Deposit1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Deposit1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MtrtyDt") )]
	pub mtrty_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val") )]
	pub val: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPtyId") )]
	pub ctr_pty_id: String,
}

impl Deposit1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.val.validate()?;
		let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
		if !pattern.is_match(&self.ctr_pty_id) {
			return Err(ValidationError::new(1005, "ctr_pty_id does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// DepositType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum DepositType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "FITE") )]
	CodeFITE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CALL") )]
	CodeCALL,
}

impl DepositType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// Derivative3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Derivative3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DerivClssfctn") )]
	pub deriv_clssfctn: DerivativeClassification1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DerivUndrlygLeg") )]
	pub deriv_undrlyg_leg: Vec<DerivativeUnderlyingLeg1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OptnAttrbts", skip_serializing_if = "Option::is_none") )]
	pub optn_attrbts: Option<Option14>,
}

impl Derivative3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.deriv_clssfctn.validate()?;
		for item in &self.deriv_undrlyg_leg { item.validate()? }
		if let Some(ref val) = self.optn_attrbts { val.validate()? }
		Ok(())
	}
}


// Derivative3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Derivative3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cmmdty", skip_serializing_if = "Option::is_none") )]
	pub cmmdty: Option<CommodityDerivative4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstRate", skip_serializing_if = "Option::is_none") )]
	pub intrst_rate: Option<InterestRateDerivative5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FX", skip_serializing_if = "Option::is_none") )]
	pub fx: Option<ForeignExchangeDerivative2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Eqty", skip_serializing_if = "Option::is_none") )]
	pub eqty: Option<EquityDerivative2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrctForDiff", skip_serializing_if = "Option::is_none") )]
	pub ctrct_for_diff: Option<ContractForDifference2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cdt", skip_serializing_if = "Option::is_none") )]
	pub cdt: Option<CreditDefaultSwapsDerivative4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EmssnAllwnc", skip_serializing_if = "Option::is_none") )]
	pub emssn_allwnc: Option<EmissionAllowanceProductType1Code>,
}

impl Derivative3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cmmdty { val.validate()? }
		if let Some(ref val) = self.intrst_rate { val.validate()? }
		if let Some(ref val) = self.fx { val.validate()? }
		if let Some(ref val) = self.eqty { val.validate()? }
		if let Some(ref val) = self.ctrct_for_diff { val.validate()? }
		if let Some(ref val) = self.cdt { val.validate()? }
		if let Some(ref val) = self.emssn_allwnc { val.validate()? }
		Ok(())
	}
}


// DerivativeClassification1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DerivativeClassification1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AsstClss") )]
	pub asst_clss: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct", skip_serializing_if = "Option::is_none") )]
	pub base_pdct: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubCmmdty", skip_serializing_if = "Option::is_none") )]
	pub sub_cmmdty: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxTp", skip_serializing_if = "Option::is_none") )]
	pub tx_tp: Option<String>,
}

impl DerivativeClassification1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.asst_clss.chars().count() < 1 {
			return Err(ValidationError::new(1001, "asst_clss is shorter than the minimum length of 1".to_string()));
		}
		if self.asst_clss.chars().count() > 35 {
			return Err(ValidationError::new(1002, "asst_clss exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.base_pdct {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "base_pdct is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "base_pdct exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.sub_pdct {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "sub_pdct is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "sub_pdct exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.sub_cmmdty {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "sub_cmmdty is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "sub_cmmdty exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.tx_tp {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tx_tp is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "tx_tp exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// DerivativeCommodity2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DerivativeCommodity2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pdct") )]
	pub pdct: AssetClassCommodity3Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxTp", skip_serializing_if = "Option::is_none") )]
	pub tx_tp: Option<AssetClassTransactionType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FnlPricTp", skip_serializing_if = "Option::is_none") )]
	pub fnl_pric_tp: Option<AssetPriceType1Code>,
}

impl DerivativeCommodity2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.pdct.validate()?;
		if let Some(ref val) = self.tx_tp { val.validate()? }
		if let Some(ref val) = self.fnl_pric_tp { val.validate()? }
		Ok(())
	}
}


// DerivativeEvent6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DerivativeEvent6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<DerivativeEventType3Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<EventIdentifier1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TmStmp", skip_serializing_if = "Option::is_none") )]
	pub tm_stmp: Option<DateAndDateTime2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AmdmntInd", skip_serializing_if = "Option::is_none") )]
	pub amdmnt_ind: Option<bool>,
}

impl DerivativeEvent6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tp { val.validate()? }
		if let Some(ref val) = self.id { val.validate()? }
		if let Some(ref val) = self.tm_stmp { val.validate()? }
		Ok(())
	}
}


// DerivativeEventType3Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum DerivativeEventType3Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ALOC") )]
	CodeALOC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CLRG") )]
	CodeCLRG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CLAL") )]
	CodeCLAL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "COMP") )]
	CodeCOMP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CORP") )]
	CodeCORP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CREV") )]
	CodeCREV,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ETRM") )]
	CodeETRM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EXER") )]
	CodeEXER,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INCP") )]
	CodeINCP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NOVA") )]
	CodeNOVA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PTNG") )]
	CodePTNG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TRAD") )]
	CodeTRAD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UPDT") )]
	CodeUPDT,
}

impl DerivativeEventType3Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// DerivativeForeignExchange2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DerivativeForeignExchange2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrNtnlCcy") )]
	pub othr_ntnl_ccy: String,
}

impl DerivativeForeignExchange2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z]{3,3}").unwrap();
		if !pattern.is_match(&self.othr_ntnl_ccy) {
			return Err(ValidationError::new(1005, "othr_ntnl_ccy does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// DerivativeForeignExchange3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DerivativeForeignExchange3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FxTp", skip_serializing_if = "Option::is_none") )]
	pub fx_tp: Option<AssetFXSubProductType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrNtnlCcy", skip_serializing_if = "Option::is_none") )]
	pub othr_ntnl_ccy: Option<String>,
}

impl DerivativeForeignExchange3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.fx_tp { val.validate()? }
		if let Some(ref val) = self.othr_ntnl_ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "othr_ntnl_ccy does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// DerivativeInstrument5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DerivativeInstrument5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "XpryDt", skip_serializing_if = "Option::is_none") )]
	pub xpry_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PricMltplr", skip_serializing_if = "Option::is_none") )]
	pub pric_mltplr: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UndrlygInstrm", skip_serializing_if = "Option::is_none") )]
	pub undrlyg_instrm: Option<FinancialInstrumentIdentification5Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OptnTp", skip_serializing_if = "Option::is_none") )]
	pub optn_tp: Option<OptionType2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StrkPric", skip_serializing_if = "Option::is_none") )]
	pub strk_pric: Option<SecuritiesTransactionPrice4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OptnExrcStyle", skip_serializing_if = "Option::is_none") )]
	pub optn_exrc_style: Option<OptionStyle7Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DlvryTp", skip_serializing_if = "Option::is_none") )]
	pub dlvry_tp: Option<PhysicalTransferType4Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AsstClssSpcfcAttrbts", skip_serializing_if = "Option::is_none") )]
	pub asst_clss_spcfc_attrbts: Option<AssetClass2>,
}

impl DerivativeInstrument5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.pric_mltplr {
			if *val < 0.000000 {
				return Err(ValidationError::new(1003, "pric_mltplr is less than the minimum value of 0.000000".to_string()));
			}
		}
		if let Some(ref val) = self.undrlyg_instrm { val.validate()? }
		if let Some(ref val) = self.optn_tp { val.validate()? }
		if let Some(ref val) = self.strk_pric { val.validate()? }
		if let Some(ref val) = self.optn_exrc_style { val.validate()? }
		if let Some(ref val) = self.dlvry_tp { val.validate()? }
		if let Some(ref val) = self.asst_clss_spcfc_attrbts { val.validate()? }
		Ok(())
	}
}


// DerivativeInstrument6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DerivativeInstrument6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "XpryDt", skip_serializing_if = "Option::is_none") )]
	pub xpry_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PricMltplr") )]
	pub pric_mltplr: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UndrlygInstrm") )]
	pub undrlyg_instrm: UnderlyingIdentification2Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OptnTp", skip_serializing_if = "Option::is_none") )]
	pub optn_tp: Option<OptionType2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StrkPric", skip_serializing_if = "Option::is_none") )]
	pub strk_pric: Option<SecuritiesTransactionPrice4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OptnExrcStyle", skip_serializing_if = "Option::is_none") )]
	pub optn_exrc_style: Option<OptionStyle7Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DlvryTp") )]
	pub dlvry_tp: PhysicalTransferType4Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AsstClssSpcfcAttrbts", skip_serializing_if = "Option::is_none") )]
	pub asst_clss_spcfc_attrbts: Option<AssetClassAttributes1Choice>,
}

impl DerivativeInstrument6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.pric_mltplr < 0.000000 {
			return Err(ValidationError::new(1003, "pric_mltplr is less than the minimum value of 0.000000".to_string()));
		}
		self.undrlyg_instrm.validate()?;
		if let Some(ref val) = self.optn_tp { val.validate()? }
		if let Some(ref val) = self.strk_pric { val.validate()? }
		if let Some(ref val) = self.optn_exrc_style { val.validate()? }
		self.dlvry_tp.validate()?;
		if let Some(ref val) = self.asst_clss_spcfc_attrbts { val.validate()? }
		Ok(())
	}
}


// DerivativeInterest2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DerivativeInterest2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrNtnlCcy") )]
	pub othr_ntnl_ccy: String,
}

impl DerivativeInterest2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z]{3,3}").unwrap();
		if !pattern.is_match(&self.othr_ntnl_ccy) {
			return Err(ValidationError::new(1005, "othr_ntnl_ccy does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// DerivativeInterest3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DerivativeInterest3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstRate") )]
	pub intrst_rate: FloatingInterestRate8,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrstLegIntrstRate", skip_serializing_if = "Option::is_none") )]
	pub frst_leg_intrst_rate: Option<InterestRate8Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrNtnlCcy", skip_serializing_if = "Option::is_none") )]
	pub othr_ntnl_ccy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrLegIntrstRate", skip_serializing_if = "Option::is_none") )]
	pub othr_leg_intrst_rate: Option<InterestRate8Choice>,
}

impl DerivativeInterest3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.intrst_rate.validate()?;
		if let Some(ref val) = self.frst_leg_intrst_rate { val.validate()? }
		if let Some(ref val) = self.othr_ntnl_ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "othr_ntnl_ccy does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.othr_leg_intrst_rate { val.validate()? }
		Ok(())
	}
}


// DerivativePartyIdentification1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DerivativePartyIdentification1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ctry", skip_serializing_if = "Option::is_none") )]
	pub ctry: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrySubDvsn", skip_serializing_if = "Option::is_none") )]
	pub ctry_sub_dvsn: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LEI", skip_serializing_if = "Option::is_none") )]
	pub lei: Option<String>,
}

impl DerivativePartyIdentification1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ctry {
			let pattern = Regex::new("[A-Z]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ctry does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.ctry_sub_dvsn {
			let pattern = Regex::new("[A-Z]{2,2}\\-[0-9A-Z]{1,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ctry_sub_dvsn does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.lei {
			let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "lei does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// DerivativeUnderlyingLeg1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DerivativeUnderlyingLeg1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrctAttrbts") )]
	pub ctrct_attrbts: FinancialInstrumentAttributes88,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DfndAttrbts", skip_serializing_if = "Option::is_none") )]
	pub dfnd_attrbts: Option<DefinedAttributes1Choice>,
}

impl DerivativeUnderlyingLeg1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.ctrct_attrbts.validate()?;
		if let Some(ref val) = self.dfnd_attrbts { val.validate()? }
		Ok(())
	}
}


// DetailedAbnormalValuesStatistics4Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DetailedAbnormalValuesStatistics4Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DataSetActn", skip_serializing_if = "Option::is_none") )]
	pub data_set_actn: Option<ReportPeriodActivity1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rpt", skip_serializing_if = "Option::is_none") )]
	pub rpt: Option<DetailedTransactionStatistics28>,
}

impl DetailedAbnormalValuesStatistics4Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.data_set_actn { val.validate()? }
		if let Some(ref val) = self.rpt { val.validate()? }
		Ok(())
	}
}


// DetailedMissingMarginInformationStatistics4Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DetailedMissingMarginInformationStatistics4Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DataSetActn", skip_serializing_if = "Option::is_none") )]
	pub data_set_actn: Option<ReportPeriodActivity1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rpt", skip_serializing_if = "Option::is_none") )]
	pub rpt: Option<DetailedTransactionStatistics26>,
}

impl DetailedMissingMarginInformationStatistics4Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.data_set_actn { val.validate()? }
		if let Some(ref val) = self.rpt { val.validate()? }
		Ok(())
	}
}


// DetailedMissingValuationsStatistics4Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DetailedMissingValuationsStatistics4Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DataSetActn", skip_serializing_if = "Option::is_none") )]
	pub data_set_actn: Option<ReportPeriodActivity1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rpt", skip_serializing_if = "Option::is_none") )]
	pub rpt: Option<DetailedTransactionStatistics27>,
}

impl DetailedMissingValuationsStatistics4Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.data_set_actn { val.validate()? }
		if let Some(ref val) = self.rpt { val.validate()? }
		Ok(())
	}
}


// DetailedReportStatistics5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DetailedReportStatistics5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlNbOfRpts") )]
	pub ttl_nb_of_rpts: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlNbOfRptsAccptd") )]
	pub ttl_nb_of_rpts_accptd: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlNbOfRptsRjctd") )]
	pub ttl_nb_of_rpts_rjctd: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfRptsRjctdPerErr", skip_serializing_if = "Option::is_none") )]
	pub nb_of_rpts_rjctd_per_err: Option<Vec<NumberOfTransactionsPerValidationRule5>>,
}

impl DetailedReportStatistics5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[0-9]{1,15}").unwrap();
		if !pattern.is_match(&self.ttl_nb_of_rpts) {
			return Err(ValidationError::new(1005, "ttl_nb_of_rpts does not match the required pattern".to_string()));
		}
		let pattern = Regex::new("[0-9]{1,15}").unwrap();
		if !pattern.is_match(&self.ttl_nb_of_rpts_accptd) {
			return Err(ValidationError::new(1005, "ttl_nb_of_rpts_accptd does not match the required pattern".to_string()));
		}
		let pattern = Regex::new("[0-9]{1,15}").unwrap();
		if !pattern.is_match(&self.ttl_nb_of_rpts_rjctd) {
			return Err(ValidationError::new(1005, "ttl_nb_of_rpts_rjctd does not match the required pattern".to_string()));
		}
		if let Some(ref vec) = self.nb_of_rpts_rjctd_per_err { for item in vec { item.validate()? } }
		Ok(())
	}
}


// DetailedReportStatistics7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DetailedReportStatistics7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlNbOfRpts") )]
	pub ttl_nb_of_rpts: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlNbOfRptsAccptd") )]
	pub ttl_nb_of_rpts_accptd: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlNbOfRptsRjctd") )]
	pub ttl_nb_of_rpts_rjctd: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfRptsRjctdPerErr", skip_serializing_if = "Option::is_none") )]
	pub nb_of_rpts_rjctd_per_err: Option<Vec<NumberOfTransactionsPerValidationRule6>>,
}

impl DetailedReportStatistics7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.ttl_nb_of_rpts < 0.000000 {
			return Err(ValidationError::new(1003, "ttl_nb_of_rpts is less than the minimum value of 0.000000".to_string()));
		}
		if self.ttl_nb_of_rpts_accptd < 0.000000 {
			return Err(ValidationError::new(1003, "ttl_nb_of_rpts_accptd is less than the minimum value of 0.000000".to_string()));
		}
		if self.ttl_nb_of_rpts_rjctd < 0.000000 {
			return Err(ValidationError::new(1003, "ttl_nb_of_rpts_rjctd is less than the minimum value of 0.000000".to_string()));
		}
		if let Some(ref vec) = self.nb_of_rpts_rjctd_per_err { for item in vec { item.validate()? } }
		Ok(())
	}
}


// DetailedStatisticsPerCounterparty17 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DetailedStatisticsPerCounterparty17 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RefDt") )]
	pub ref_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MssngValtn") )]
	pub mssng_valtn: DetailedMissingValuationsStatistics4Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MssngMrgnInf") )]
	pub mssng_mrgn_inf: DetailedMissingMarginInformationStatistics4Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AbnrmlVals") )]
	pub abnrml_vals: DetailedAbnormalValuesStatistics4Choice,
}

impl DetailedStatisticsPerCounterparty17 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.mssng_valtn.validate()?;
		self.mssng_mrgn_inf.validate()?;
		self.abnrml_vals.validate()?;
		Ok(())
	}
}


// DetailedStatisticsPerCounterparty19 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DetailedStatisticsPerCounterparty19 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RefDt") )]
	pub ref_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlNbOfRpts") )]
	pub ttl_nb_of_rpts: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlNbOfRptsAccptd") )]
	pub ttl_nb_of_rpts_accptd: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlNbOfRptsRjctd") )]
	pub ttl_nb_of_rpts_rjctd: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlNbOfTxs") )]
	pub ttl_nb_of_txs: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlNbOfTxsAccptd") )]
	pub ttl_nb_of_txs_accptd: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlNbOfTxsRjctd") )]
	pub ttl_nb_of_txs_rjctd: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlCrrctdRjctns", skip_serializing_if = "Option::is_none") )]
	pub ttl_crrctd_rjctns: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RjctnSttstcs") )]
	pub rjctn_sttstcs: Vec<RejectionStatistics9>,
}

impl DetailedStatisticsPerCounterparty19 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.ttl_nb_of_rpts < 0.000000 {
			return Err(ValidationError::new(1003, "ttl_nb_of_rpts is less than the minimum value of 0.000000".to_string()));
		}
		if self.ttl_nb_of_rpts_accptd < 0.000000 {
			return Err(ValidationError::new(1003, "ttl_nb_of_rpts_accptd is less than the minimum value of 0.000000".to_string()));
		}
		if self.ttl_nb_of_rpts_rjctd < 0.000000 {
			return Err(ValidationError::new(1003, "ttl_nb_of_rpts_rjctd is less than the minimum value of 0.000000".to_string()));
		}
		if self.ttl_nb_of_txs < 0.000000 {
			return Err(ValidationError::new(1003, "ttl_nb_of_txs is less than the minimum value of 0.000000".to_string()));
		}
		if self.ttl_nb_of_txs_accptd < 0.000000 {
			return Err(ValidationError::new(1003, "ttl_nb_of_txs_accptd is less than the minimum value of 0.000000".to_string()));
		}
		if self.ttl_nb_of_txs_rjctd < 0.000000 {
			return Err(ValidationError::new(1003, "ttl_nb_of_txs_rjctd is less than the minimum value of 0.000000".to_string()));
		}
		if let Some(ref val) = self.ttl_crrctd_rjctns {
			if *val < 0.000000 {
				return Err(ValidationError::new(1003, "ttl_crrctd_rjctns is less than the minimum value of 0.000000".to_string()));
			}
		}
		for item in &self.rjctn_sttstcs { item.validate()? }
		Ok(())
	}
}


// DetailedTransactionStatistics13 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DetailedTransactionStatistics13 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlNbOfTxs") )]
	pub ttl_nb_of_txs: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlNbOfTxsAccptd") )]
	pub ttl_nb_of_txs_accptd: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlNbOfTxsRjctd") )]
	pub ttl_nb_of_txs_rjctd: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxsRjctnsRsn", skip_serializing_if = "Option::is_none") )]
	pub txs_rjctns_rsn: Option<Vec<RejectionReason53>>,
}

impl DetailedTransactionStatistics13 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[0-9]{1,15}").unwrap();
		if !pattern.is_match(&self.ttl_nb_of_txs) {
			return Err(ValidationError::new(1005, "ttl_nb_of_txs does not match the required pattern".to_string()));
		}
		let pattern = Regex::new("[0-9]{1,15}").unwrap();
		if !pattern.is_match(&self.ttl_nb_of_txs_accptd) {
			return Err(ValidationError::new(1005, "ttl_nb_of_txs_accptd does not match the required pattern".to_string()));
		}
		let pattern = Regex::new("[0-9]{1,15}").unwrap();
		if !pattern.is_match(&self.ttl_nb_of_txs_rjctd) {
			return Err(ValidationError::new(1005, "ttl_nb_of_txs_rjctd does not match the required pattern".to_string()));
		}
		if let Some(ref vec) = self.txs_rjctns_rsn { for item in vec { item.validate()? } }
		Ok(())
	}
}


// DetailedTransactionStatistics26 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DetailedTransactionStatistics26 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfOutsdngDerivs") )]
	pub nb_of_outsdng_derivs: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfOutsdngDerivsWthNoMrgnInf") )]
	pub nb_of_outsdng_derivs_wth_no_mrgn_inf: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfOutsdngDerivsWthOutdtdMrgnInf") )]
	pub nb_of_outsdng_derivs_wth_outdtd_mrgn_inf: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Wrnngs") )]
	pub wrnngs: Vec<MissingMarginData2>,
}

impl DetailedTransactionStatistics26 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		for item in &self.wrnngs { item.validate()? }
		Ok(())
	}
}


// DetailedTransactionStatistics27 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DetailedTransactionStatistics27 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfOutsdngDerivs") )]
	pub nb_of_outsdng_derivs: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfOutsdngDerivsWthNoValtn") )]
	pub nb_of_outsdng_derivs_wth_no_valtn: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfOutsdngDerivsWthOutdtdValtn") )]
	pub nb_of_outsdng_derivs_wth_outdtd_valtn: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Wrnngs") )]
	pub wrnngs: Vec<MissingValuationsData2>,
}

impl DetailedTransactionStatistics27 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		for item in &self.wrnngs { item.validate()? }
		Ok(())
	}
}


// DetailedTransactionStatistics28 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DetailedTransactionStatistics28 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfDerivsRptd") )]
	pub nb_of_derivs_rptd: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfDerivsRptdWthOtlrs") )]
	pub nb_of_derivs_rptd_wth_otlrs: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Wrnngs") )]
	pub wrnngs: Vec<AbnormalValuesData4>,
}

impl DetailedTransactionStatistics28 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		for item in &self.wrnngs { item.validate()? }
		Ok(())
	}
}


// DetailedTransactionStatistics2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DetailedTransactionStatistics2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DataSetActn", skip_serializing_if = "Option::is_none") )]
	pub data_set_actn: Option<ReportPeriodActivity1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtldSttstcs", skip_serializing_if = "Option::is_none") )]
	pub dtld_sttstcs: Option<DetailedTransactionStatistics13>,
}

impl DetailedTransactionStatistics2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.data_set_actn { val.validate()? }
		if let Some(ref val) = self.dtld_sttstcs { val.validate()? }
		Ok(())
	}
}


// DetailedTransactionStatistics30 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DetailedTransactionStatistics30 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlNbOfTxs") )]
	pub ttl_nb_of_txs: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlNbOfTxsAccptd") )]
	pub ttl_nb_of_txs_accptd: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlNbOfTxsRjctd") )]
	pub ttl_nb_of_txs_rjctd: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlCrrctdRjctns", skip_serializing_if = "Option::is_none") )]
	pub ttl_crrctd_rjctns: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxsRjctnsRsn", skip_serializing_if = "Option::is_none") )]
	pub txs_rjctns_rsn: Option<Vec<RejectionReason71>>,
}

impl DetailedTransactionStatistics30 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.ttl_nb_of_txs < 0.000000 {
			return Err(ValidationError::new(1003, "ttl_nb_of_txs is less than the minimum value of 0.000000".to_string()));
		}
		if self.ttl_nb_of_txs_accptd < 0.000000 {
			return Err(ValidationError::new(1003, "ttl_nb_of_txs_accptd is less than the minimum value of 0.000000".to_string()));
		}
		if self.ttl_nb_of_txs_rjctd < 0.000000 {
			return Err(ValidationError::new(1003, "ttl_nb_of_txs_rjctd is less than the minimum value of 0.000000".to_string()));
		}
		if let Some(ref val) = self.ttl_crrctd_rjctns {
			if *val < 0.000000 {
				return Err(ValidationError::new(1003, "ttl_crrctd_rjctns is less than the minimum value of 0.000000".to_string()));
			}
		}
		if let Some(ref vec) = self.txs_rjctns_rsn { for item in vec { item.validate()? } }
		Ok(())
	}
}


// DetailedTransactionStatistics7Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DetailedTransactionStatistics7Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DataSetActn", skip_serializing_if = "Option::is_none") )]
	pub data_set_actn: Option<ReportPeriodActivity1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtldSttstcs", skip_serializing_if = "Option::is_none") )]
	pub dtld_sttstcs: Option<DetailedTransactionStatistics30>,
}

impl DetailedTransactionStatistics7Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.data_set_actn { val.validate()? }
		if let Some(ref val) = self.dtld_sttstcs { val.validate()? }
		Ok(())
	}
}


// DigitalTokenAmount2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DigitalTokenAmount2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Idr") )]
	pub idr: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Unit", skip_serializing_if = "Option::is_none") )]
	pub unit: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Desc", skip_serializing_if = "Option::is_none") )]
	pub desc: Option<String>,
}

impl DigitalTokenAmount2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[1-9B-DF-HJ-NP-XZ][0-9B-DF-HJ-NP-XZ]{8,8}").unwrap();
		if !pattern.is_match(&self.idr) {
			return Err(ValidationError::new(1005, "idr does not match the required pattern".to_string()));
		}
		if let Some(ref val) = self.desc {
			if val.chars().count() > 30 {
				return Err(ValidationError::new(1002, "desc exceeds the maximum length of 30".to_string()));
			}
		}
		Ok(())
	}
}


// Direction2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Direction2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DrctnOfTheFrstLeg") )]
	pub drctn_of_the_frst_leg: OptionParty3Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DrctnOfTheScndLeg", skip_serializing_if = "Option::is_none") )]
	pub drctn_of_the_scnd_leg: Option<OptionParty3Code>,
}

impl Direction2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.drctn_of_the_frst_leg.validate()?;
		if let Some(ref val) = self.drctn_of_the_scnd_leg { val.validate()? }
		Ok(())
	}
}


// Direction4Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Direction4Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Drctn", skip_serializing_if = "Option::is_none") )]
	pub drctn: Option<Direction2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPtySd", skip_serializing_if = "Option::is_none") )]
	pub ctr_pty_sd: Option<OptionParty1Code>,
}

impl Direction4Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.drctn { val.validate()? }
		if let Some(ref val) = self.ctr_pty_sd { val.validate()? }
		Ok(())
	}
}


// DisseminationData1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DisseminationData1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DssmntnIdr") )]
	pub dssmntn_idr: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlDssmntnIdr", skip_serializing_if = "Option::is_none") )]
	pub orgnl_dssmntn_idr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TmStmp") )]
	pub tm_stmp: String,
}

impl DisseminationData1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.dssmntn_idr.chars().count() < 1 {
			return Err(ValidationError::new(1001, "dssmntn_idr is shorter than the minimum length of 1".to_string()));
		}
		if self.dssmntn_idr.chars().count() > 52 {
			return Err(ValidationError::new(1002, "dssmntn_idr exceeds the maximum length of 52".to_string()));
		}
		if let Some(ref val) = self.orgnl_dssmntn_idr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_dssmntn_idr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 52 {
				return Err(ValidationError::new(1002, "orgnl_dssmntn_idr exceeds the maximum length of 52".to_string()));
			}
		}
		Ok(())
	}
}


// DocumentAmendment1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DocumentAmendment1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CrrctnId") )]
	pub crrctn_id: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlDocId", skip_serializing_if = "Option::is_none") )]
	pub orgnl_doc_id: Option<String>,
}

impl DocumentAmendment1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.orgnl_doc_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_doc_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_doc_id exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// DocumentEntryAmendment1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DocumentEntryAmendment1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CrrctgNtryNb") )]
	pub crrctg_ntry_nb: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlDoc") )]
	pub orgnl_doc: DocumentIdentification28,
}

impl DocumentEntryAmendment1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.orgnl_doc.validate()?;
		Ok(())
	}
}


// DocumentGeneralInformation2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DocumentGeneralInformation2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DocTp") )]
	pub doc_tp: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DocNb") )]
	pub doc_nb: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SndrRcvrSeqId", skip_serializing_if = "Option::is_none") )]
	pub sndr_rcvr_seq_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IsseDt", skip_serializing_if = "Option::is_none") )]
	pub isse_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "URL", skip_serializing_if = "Option::is_none") )]
	pub url: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AttchdBinryFile", skip_serializing_if = "Option::is_none") )]
	pub attchd_binry_file: Option<Vec<BinaryFile1>>,
}

impl DocumentGeneralInformation2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.doc_tp.chars().count() < 1 {
			return Err(ValidationError::new(1001, "doc_tp is shorter than the minimum length of 1".to_string()));
		}
		if self.doc_tp.chars().count() > 4 {
			return Err(ValidationError::new(1002, "doc_tp exceeds the maximum length of 4".to_string()));
		}
		if self.doc_nb.chars().count() < 1 {
			return Err(ValidationError::new(1001, "doc_nb is shorter than the minimum length of 1".to_string()));
		}
		if self.doc_nb.chars().count() > 35 {
			return Err(ValidationError::new(1002, "doc_nb exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.sndr_rcvr_seq_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "sndr_rcvr_seq_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "sndr_rcvr_seq_id exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.url {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "url is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 256 {
				return Err(ValidationError::new(1002, "url exceeds the maximum length of 256".to_string()));
			}
		}
		if let Some(ref vec) = self.attchd_binry_file { for item in vec { item.validate()? } }
		Ok(())
	}
}


// DocumentGeneralInformation5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DocumentGeneralInformation5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DocTp") )]
	pub doc_tp: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DocNb") )]
	pub doc_nb: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DocNm", skip_serializing_if = "Option::is_none") )]
	pub doc_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SndrRcvrSeqId", skip_serializing_if = "Option::is_none") )]
	pub sndr_rcvr_seq_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IsseDt", skip_serializing_if = "Option::is_none") )]
	pub isse_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "URL", skip_serializing_if = "Option::is_none") )]
	pub url: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LkFileHash", skip_serializing_if = "Option::is_none") )]
	pub lk_file_hash: Option<SignatureEnvelopeReference>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AttchdBinryFile") )]
	pub attchd_binry_file: BinaryFile1,
}

impl DocumentGeneralInformation5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.doc_tp.chars().count() < 1 {
			return Err(ValidationError::new(1001, "doc_tp is shorter than the minimum length of 1".to_string()));
		}
		if self.doc_tp.chars().count() > 4 {
			return Err(ValidationError::new(1002, "doc_tp exceeds the maximum length of 4".to_string()));
		}
		if self.doc_nb.chars().count() < 1 {
			return Err(ValidationError::new(1001, "doc_nb is shorter than the minimum length of 1".to_string()));
		}
		if self.doc_nb.chars().count() > 35 {
			return Err(ValidationError::new(1002, "doc_nb exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.doc_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "doc_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "doc_nm exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.sndr_rcvr_seq_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "sndr_rcvr_seq_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "sndr_rcvr_seq_id exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.url {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "url is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 256 {
				return Err(ValidationError::new(1002, "url exceeds the maximum length of 256".to_string()));
			}
		}
		if let Some(ref val) = self.lk_file_hash { val.validate()? }
		self.attchd_binry_file.validate()?;
		Ok(())
	}
}


// DocumentIdentification22 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DocumentIdentification22 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtOfIsse", skip_serializing_if = "Option::is_none") )]
	pub dt_of_isse: Option<String>,
}

impl DocumentIdentification22 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
		}
		Ok(())
	}
}


// DocumentIdentification28 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DocumentIdentification28 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtOfIsse") )]
	pub dt_of_isse: String,
}

impl DocumentIdentification28 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// DocumentIdentification29 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DocumentIdentification29 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtOfIsse") )]
	pub dt_of_isse: String,
}

impl DocumentIdentification29 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
		}
		Ok(())
	}
}


// DocumentIdentification35 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DocumentIdentification35 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtOfIsse", skip_serializing_if = "Option::is_none") )]
	pub dt_of_isse: Option<String>,
}

impl DocumentIdentification35 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// DocumentType3Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum DocumentType3Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "RADM") )]
	CodeRADM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RPIN") )]
	CodeRPIN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FXDR") )]
	CodeFXDR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DISP") )]
	CodeDISP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PUOR") )]
	CodePUOR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SCOR") )]
	CodeSCOR,
}

impl DocumentType3Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// DueDate1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct DueDate1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DueDt", skip_serializing_if = "Option::is_none") )]
	pub due_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_inf: Option<String>,
}

impl DueDate1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.addtl_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "addtl_inf exceeds the maximum length of 140".to_string()));
			}
		}
		Ok(())
	}
}


// DurationType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum DurationType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "YEAR") )]
	CodeYEAR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "WEEK") )]
	CodeWEEK,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SEAS") )]
	CodeSEAS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "QURT") )]
	CodeQURT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MNTH") )]
	CodeMNTH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MNUT") )]
	CodeMNUT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "HOUR") )]
	CodeHOUR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DASD") )]
	CodeDASD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
}

impl DurationType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// EarlyPayment1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct EarlyPayment1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "EarlyPmtDt") )]
	pub early_pmt_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DscntPct") )]
	pub dscnt_pct: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DscntAmt") )]
	pub dscnt_amt: CurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EarlyPmtTaxSpcfctn", skip_serializing_if = "Option::is_none") )]
	pub early_pmt_tax_spcfctn: Option<Vec<EarlyPaymentsVAT1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EarlyPmtTaxTtl", skip_serializing_if = "Option::is_none") )]
	pub early_pmt_tax_ttl: Option<CurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DuePyblAmtWthEarlyPmt", skip_serializing_if = "Option::is_none") )]
	pub due_pybl_amt_wth_early_pmt: Option<CurrencyAndAmount>,
}

impl EarlyPayment1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.dscnt_amt.validate()?;
		if let Some(ref vec) = self.early_pmt_tax_spcfctn { for item in vec { item.validate()? } }
		if let Some(ref val) = self.early_pmt_tax_ttl { val.validate()? }
		if let Some(ref val) = self.due_pybl_amt_wth_early_pmt { val.validate()? }
		Ok(())
	}
}


// EarlyPaymentsVAT1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct EarlyPaymentsVAT1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TaxRate") )]
	pub tax_rate: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DscntTaxTp") )]
	pub dscnt_tax_tp: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DscntTaxAmt") )]
	pub dscnt_tax_amt: CurrencyAndAmount,
}

impl EarlyPaymentsVAT1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.dscnt_tax_tp.chars().count() < 1 {
			return Err(ValidationError::new(1001, "dscnt_tax_tp is shorter than the minimum length of 1".to_string()));
		}
		if self.dscnt_tax_tp.chars().count() > 4 {
			return Err(ValidationError::new(1002, "dscnt_tax_tp exceeds the maximum length of 4".to_string()));
		}
		self.dscnt_tax_amt.validate()?;
		Ok(())
	}
}


// EmbeddedType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum EmbeddedType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "CANC") )]
	CodeCANC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EXTD") )]
	CodeEXTD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OPET") )]
	CodeOPET,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MDET") )]
	CodeMDET,
}

impl EmbeddedType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// EmissionAllowanceProductType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum EmissionAllowanceProductType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "EUAA") )]
	CodeEUAA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EUAE") )]
	CodeEUAE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ERUE") )]
	CodeERUE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CERE") )]
	CodeCERE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
}

impl EmissionAllowanceProductType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// EndOfDayRequirement1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct EndOfDayRequirement1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "InitlMrgnRqrmnt", skip_serializing_if = "Option::is_none") )]
	pub initl_mrgn_rqrmnt: Option<ActiveCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VartnMrgnRqrmnt", skip_serializing_if = "Option::is_none") )]
	pub vartn_mrgn_rqrmnt: Option<AmountAndDirection102>,
}

impl EndOfDayRequirement1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.initl_mrgn_rqrmnt { val.validate()? }
		if let Some(ref val) = self.vartn_mrgn_rqrmnt { val.validate()? }
		Ok(())
	}
}


// EndOfDayRequirement2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct EndOfDayRequirement2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "InitlMrgnRqrmnts") )]
	pub initl_mrgn_rqrmnts: InitialMarginRequirement1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VartnMrgnRqrmnts") )]
	pub vartn_mrgn_rqrmnts: AmountAndDirection102,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MrgnAcctId") )]
	pub mrgn_acct_id: GenericIdentification165,
}

impl EndOfDayRequirement2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.initl_mrgn_rqrmnts.validate()?;
		self.vartn_mrgn_rqrmnts.validate()?;
		self.mrgn_acct_id.validate()?;
		Ok(())
	}
}


// EnergyCommodityCoal1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct EnergyCommodityCoal1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType2Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct") )]
	pub sub_pdct: AssetClassSubProductType24Code,
}

impl EnergyCommodityCoal1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		self.sub_pdct.validate()?;
		Ok(())
	}
}


// EnergyCommodityCoal2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct EnergyCommodityCoal2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType2Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType24Code>,
}

impl EnergyCommodityCoal2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		Ok(())
	}
}


// EnergyCommodityDistillates1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct EnergyCommodityDistillates1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType2Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct") )]
	pub sub_pdct: AssetClassSubProductType25Code,
}

impl EnergyCommodityDistillates1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		self.sub_pdct.validate()?;
		Ok(())
	}
}


// EnergyCommodityDistillates2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct EnergyCommodityDistillates2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType2Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType25Code>,
}

impl EnergyCommodityDistillates2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		Ok(())
	}
}


// EnergyCommodityElectricity1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct EnergyCommodityElectricity1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType2Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct") )]
	pub sub_pdct: AssetClassSubProductType6Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlSubPdct") )]
	pub addtl_sub_pdct: AssetClassDetailedSubProductType5Code,
}

impl EnergyCommodityElectricity1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		self.sub_pdct.validate()?;
		self.addtl_sub_pdct.validate()?;
		Ok(())
	}
}


// EnergyCommodityElectricity2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct EnergyCommodityElectricity2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType2Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType6Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlSubPdct", skip_serializing_if = "Option::is_none") )]
	pub addtl_sub_pdct: Option<AssetClassDetailedSubProductType5Code>,
}

impl EnergyCommodityElectricity2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		if let Some(ref val) = self.addtl_sub_pdct { val.validate()? }
		Ok(())
	}
}


// EnergyCommodityInterEnergy1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct EnergyCommodityInterEnergy1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType2Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct") )]
	pub sub_pdct: AssetClassSubProductType26Code,
}

impl EnergyCommodityInterEnergy1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		self.sub_pdct.validate()?;
		Ok(())
	}
}


// EnergyCommodityInterEnergy2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct EnergyCommodityInterEnergy2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType2Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType26Code>,
}

impl EnergyCommodityInterEnergy2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		Ok(())
	}
}


// EnergyCommodityLightEnd1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct EnergyCommodityLightEnd1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType2Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct") )]
	pub sub_pdct: AssetClassSubProductType27Code,
}

impl EnergyCommodityLightEnd1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		self.sub_pdct.validate()?;
		Ok(())
	}
}


// EnergyCommodityLightEnd2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct EnergyCommodityLightEnd2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType2Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType27Code>,
}

impl EnergyCommodityLightEnd2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		Ok(())
	}
}


// EnergyCommodityNaturalGas1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct EnergyCommodityNaturalGas1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType2Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct") )]
	pub sub_pdct: AssetClassSubProductType7Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlSubPdct", skip_serializing_if = "Option::is_none") )]
	pub addtl_sub_pdct: Option<AssetClassDetailedSubProductType6Code>,
}

impl EnergyCommodityNaturalGas1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		self.sub_pdct.validate()?;
		if let Some(ref val) = self.addtl_sub_pdct { val.validate()? }
		Ok(())
	}
}


// EnergyCommodityNaturalGas2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct EnergyCommodityNaturalGas2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType2Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct") )]
	pub sub_pdct: AssetClassSubProductType7Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlSubPdct") )]
	pub addtl_sub_pdct: AssetClassDetailedSubProductType31Code,
}

impl EnergyCommodityNaturalGas2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		self.sub_pdct.validate()?;
		self.addtl_sub_pdct.validate()?;
		Ok(())
	}
}


// EnergyCommodityNaturalGas3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct EnergyCommodityNaturalGas3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType2Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType7Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlSubPdct", skip_serializing_if = "Option::is_none") )]
	pub addtl_sub_pdct: Option<AssetClassDetailedSubProductType31Code>,
}

impl EnergyCommodityNaturalGas3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		if let Some(ref val) = self.addtl_sub_pdct { val.validate()? }
		Ok(())
	}
}


// EnergyCommodityOil1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct EnergyCommodityOil1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType2Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct") )]
	pub sub_pdct: AssetClassSubProductType8Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlSubPdct", skip_serializing_if = "Option::is_none") )]
	pub addtl_sub_pdct: Option<AssetClassDetailedSubProductType7Code>,
}

impl EnergyCommodityOil1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		self.sub_pdct.validate()?;
		if let Some(ref val) = self.addtl_sub_pdct { val.validate()? }
		Ok(())
	}
}


// EnergyCommodityOil2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct EnergyCommodityOil2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType2Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct") )]
	pub sub_pdct: AssetClassSubProductType8Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlSubPdct") )]
	pub addtl_sub_pdct: AssetClassDetailedSubProductType32Code,
}

impl EnergyCommodityOil2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		self.sub_pdct.validate()?;
		self.addtl_sub_pdct.validate()?;
		Ok(())
	}
}


// EnergyCommodityOil3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct EnergyCommodityOil3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType2Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType8Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlSubPdct", skip_serializing_if = "Option::is_none") )]
	pub addtl_sub_pdct: Option<AssetClassDetailedSubProductType32Code>,
}

impl EnergyCommodityOil3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		if let Some(ref val) = self.addtl_sub_pdct { val.validate()? }
		Ok(())
	}
}


// EnergyCommodityOther1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct EnergyCommodityOther1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType2Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct") )]
	pub sub_pdct: AssetClassSubProductType49Code,
}

impl EnergyCommodityOther1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		self.sub_pdct.validate()?;
		Ok(())
	}
}


// EnergyCommodityOther2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct EnergyCommodityOther2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType2Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType49Code>,
}

impl EnergyCommodityOther2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		Ok(())
	}
}


// EnergyCommodityRenewableEnergy1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct EnergyCommodityRenewableEnergy1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType2Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct") )]
	pub sub_pdct: AssetClassSubProductType28Code,
}

impl EnergyCommodityRenewableEnergy1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		self.sub_pdct.validate()?;
		Ok(())
	}
}


// EnergyCommodityRenewableEnergy2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct EnergyCommodityRenewableEnergy2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType2Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType28Code>,
}

impl EnergyCommodityRenewableEnergy2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		Ok(())
	}
}


// EnergyDeliveryAttribute10 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct EnergyDeliveryAttribute10 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DlvryIntrvl", skip_serializing_if = "Option::is_none") )]
	pub dlvry_intrvl: Option<Vec<TimePeriodDetails1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DlvryDt", skip_serializing_if = "Option::is_none") )]
	pub dlvry_dt: Option<DatePeriod1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Drtn", skip_serializing_if = "Option::is_none") )]
	pub drtn: Option<DurationType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "WkDay", skip_serializing_if = "Option::is_none") )]
	pub wk_day: Option<Vec<WeekDay3Code>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DlvryCpcty", skip_serializing_if = "Option::is_none") )]
	pub dlvry_cpcty: Option<Quantity47Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "QtyUnit", skip_serializing_if = "Option::is_none") )]
	pub qty_unit: Option<EnergyQuantityUnit2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PricTmIntrvlQty", skip_serializing_if = "Option::is_none") )]
	pub pric_tm_intrvl_qty: Option<AmountAndDirection106>,
}

impl EnergyDeliveryAttribute10 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.dlvry_intrvl { for item in vec { item.validate()? } }
		if let Some(ref val) = self.dlvry_dt { val.validate()? }
		if let Some(ref val) = self.drtn { val.validate()? }
		if let Some(ref vec) = self.wk_day { for item in vec { item.validate()? } }
		if let Some(ref val) = self.dlvry_cpcty { val.validate()? }
		if let Some(ref val) = self.qty_unit { val.validate()? }
		if let Some(ref val) = self.pric_tm_intrvl_qty { val.validate()? }
		Ok(())
	}
}


// EnergyLoadType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum EnergyLoadType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "BSLD") )]
	CodeBSLD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GASD") )]
	CodeGASD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "HABH") )]
	CodeHABH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OFFP") )]
	CodeOFFP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PKLD") )]
	CodePKLD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SHPD") )]
	CodeSHPD,
}

impl EnergyLoadType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// EnergyQuantityUnit2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct EnergyQuantityUnit2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<EnergyQuantityUnit2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl EnergyQuantityUnit2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 52 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 52".to_string()));
			}
		}
		Ok(())
	}
}


// EnergyQuantityUnit2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum EnergyQuantityUnit2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "BTUD") )]
	CodeBTUD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CMPD") )]
	CodeCMPD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GJDD") )]
	CodeGJDD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GWAT") )]
	CodeGWAT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GWHD") )]
	CodeGWHD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GWHH") )]
	CodeGWHH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "HMJD") )]
	CodeHMJD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "KTMD") )]
	CodeKTMD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "KWAT") )]
	CodeKWAT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "KWHD") )]
	CodeKWHD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "KWHH") )]
	CodeKWHH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MCMD") )]
	CodeMCMD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MJDD") )]
	CodeMJDD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MBTD") )]
	CodeMBTD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MMJD") )]
	CodeMMJD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MTMD") )]
	CodeMTMD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MWAT") )]
	CodeMWAT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MWHD") )]
	CodeMWHD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MWHH") )]
	CodeMWHH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "THMD") )]
	CodeTHMD,
}

impl EnergyQuantityUnit2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// EnergySpecificAttribute9 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct EnergySpecificAttribute9 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DlvryPtOrZone", skip_serializing_if = "Option::is_none") )]
	pub dlvry_pt_or_zone: Option<Vec<DeliveryInterconnectionPoint1Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrCnnctnPt", skip_serializing_if = "Option::is_none") )]
	pub intr_cnnctn_pt: Option<DeliveryInterconnectionPoint1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LdTp", skip_serializing_if = "Option::is_none") )]
	pub ld_tp: Option<EnergyLoadType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DlvryAttr", skip_serializing_if = "Option::is_none") )]
	pub dlvry_attr: Option<Vec<EnergyDeliveryAttribute10>>,
}

impl EnergySpecificAttribute9 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.dlvry_pt_or_zone { for item in vec { item.validate()? } }
		if let Some(ref val) = self.intr_cnnctn_pt { val.validate()? }
		if let Some(ref val) = self.ld_tp { val.validate()? }
		if let Some(ref vec) = self.dlvry_attr { for item in vec { item.validate()? } }
		Ok(())
	}
}


// EnvironmentCommodityOther1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct EnvironmentCommodityOther1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType3Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct") )]
	pub sub_pdct: AssetClassSubProductType49Code,
}

impl EnvironmentCommodityOther1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		self.sub_pdct.validate()?;
		Ok(())
	}
}


// EnvironmentCommodityOther2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct EnvironmentCommodityOther2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType3Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType49Code>,
}

impl EnvironmentCommodityOther2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		Ok(())
	}
}


// EnvironmentalCommodityCarbonRelated1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct EnvironmentalCommodityCarbonRelated1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType3Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct") )]
	pub sub_pdct: AssetClassSubProductType29Code,
}

impl EnvironmentalCommodityCarbonRelated1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		self.sub_pdct.validate()?;
		Ok(())
	}
}


// EnvironmentalCommodityCarbonRelated2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct EnvironmentalCommodityCarbonRelated2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType3Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType29Code>,
}

impl EnvironmentalCommodityCarbonRelated2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		Ok(())
	}
}


// EnvironmentalCommodityEmission1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct EnvironmentalCommodityEmission1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType3Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct") )]
	pub sub_pdct: AssetClassSubProductType10Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlSubPdct", skip_serializing_if = "Option::is_none") )]
	pub addtl_sub_pdct: Option<AssetClassDetailedSubProductType8Code>,
}

impl EnvironmentalCommodityEmission1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		self.sub_pdct.validate()?;
		if let Some(ref val) = self.addtl_sub_pdct { val.validate()? }
		Ok(())
	}
}


// EnvironmentalCommodityEmission2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct EnvironmentalCommodityEmission2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType3Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct") )]
	pub sub_pdct: AssetClassSubProductType10Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlSubPdct") )]
	pub addtl_sub_pdct: AssetClassDetailedSubProductType8Code,
}

impl EnvironmentalCommodityEmission2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		self.sub_pdct.validate()?;
		self.addtl_sub_pdct.validate()?;
		Ok(())
	}
}


// EnvironmentalCommodityEmission3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct EnvironmentalCommodityEmission3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType3Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType10Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlSubPdct", skip_serializing_if = "Option::is_none") )]
	pub addtl_sub_pdct: Option<AssetClassDetailedSubProductType8Code>,
}

impl EnvironmentalCommodityEmission3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		if let Some(ref val) = self.addtl_sub_pdct { val.validate()? }
		Ok(())
	}
}


// EnvironmentalCommodityWeather1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct EnvironmentalCommodityWeather1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType3Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct") )]
	pub sub_pdct: AssetClassSubProductType30Code,
}

impl EnvironmentalCommodityWeather1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		self.sub_pdct.validate()?;
		Ok(())
	}
}


// EnvironmentalCommodityWeather2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct EnvironmentalCommodityWeather2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType3Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType30Code>,
}

impl EnvironmentalCommodityWeather2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		Ok(())
	}
}


// EquityDerivative2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct EquityDerivative2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "UndrlygTp") )]
	pub undrlyg_tp: EquityDerivative3Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Param", skip_serializing_if = "Option::is_none") )]
	pub param: Option<EquityReturnParameter1Code>,
}

impl EquityDerivative2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.undrlyg_tp.validate()?;
		if let Some(ref val) = self.param { val.validate()? }
		Ok(())
	}
}


// EquityDerivative3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct EquityDerivative3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Bskt", skip_serializing_if = "Option::is_none") )]
	pub bskt: Option<UnderlyingEquityType3Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Indx", skip_serializing_if = "Option::is_none") )]
	pub indx: Option<UnderlyingEquityType4Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SnglNm", skip_serializing_if = "Option::is_none") )]
	pub sngl_nm: Option<UnderlyingEquityType5Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<UnderlyingEquityType6Code>,
}

impl EquityDerivative3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.bskt { val.validate()? }
		if let Some(ref val) = self.indx { val.validate()? }
		if let Some(ref val) = self.sngl_nm { val.validate()? }
		if let Some(ref val) = self.othr { val.validate()? }
		Ok(())
	}
}


// EquityInstrumentReportingClassification1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum EquityInstrumentReportingClassification1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "SHRS") )]
	CodeSHRS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ETFS") )]
	CodeETFS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DPRS") )]
	CodeDPRS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CRFT") )]
	CodeCRFT,
}

impl EquityInstrumentReportingClassification1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// EquityReturnParameter1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum EquityReturnParameter1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "PRDV") )]
	CodePRDV,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PRVA") )]
	CodePRVA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PRVO") )]
	CodePRVO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PRBP") )]
	CodePRBP,
}

impl EquityReturnParameter1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// EventIdentifier1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct EventIdentifier1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "EvtIdr", skip_serializing_if = "Option::is_none") )]
	pub evt_idr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstTradRskRdctnIdr", skip_serializing_if = "Option::is_none") )]
	pub pst_trad_rsk_rdctn_idr: Option<PostTradeRiskReductionIdentifier1>,
}

impl EventIdentifier1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.evt_idr {
			let pattern = Regex::new("[A-Z0-9]{18}[0-9]{2}[A-Z0-9]{0,32}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "evt_idr does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.pst_trad_rsk_rdctn_idr { val.validate()? }
		Ok(())
	}
}


// ExchangeRate1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ExchangeRate1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnitCcy", skip_serializing_if = "Option::is_none") )]
	pub unit_ccy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XchgRate", skip_serializing_if = "Option::is_none") )]
	pub xchg_rate: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RateTp", skip_serializing_if = "Option::is_none") )]
	pub rate_tp: Option<ExchangeRateType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrctId", skip_serializing_if = "Option::is_none") )]
	pub ctrct_id: Option<String>,
}

impl ExchangeRate1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.unit_ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "unit_ccy does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.rate_tp { val.validate()? }
		if let Some(ref val) = self.ctrct_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "ctrct_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "ctrct_id exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// ExchangeRateBasis1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ExchangeRateBasis1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BaseCcy") )]
	pub base_ccy: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "QtdCcy") )]
	pub qtd_ccy: String,
}

impl ExchangeRateBasis1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z]{3,3}").unwrap();
		if !pattern.is_match(&self.base_ccy) {
			return Err(ValidationError::new(1005, "base_ccy does not match the required pattern".to_string()));
		}
		let pattern = Regex::new("[A-Z]{3,3}").unwrap();
		if !pattern.is_match(&self.qtd_ccy) {
			return Err(ValidationError::new(1005, "qtd_ccy does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// ExchangeRateBasis1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ExchangeRateBasis1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CcyPair", skip_serializing_if = "Option::is_none") )]
	pub ccy_pair: Option<ExchangeRateBasis1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl ExchangeRateBasis1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ccy_pair { val.validate()? }
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 52 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 52".to_string()));
			}
		}
		Ok(())
	}
}


// ExchangeRateInformation1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ExchangeRateInformation1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "XchgRate", skip_serializing_if = "Option::is_none") )]
	pub xchg_rate: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RateTp", skip_serializing_if = "Option::is_none") )]
	pub rate_tp: Option<ExchangeRateType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrctId", skip_serializing_if = "Option::is_none") )]
	pub ctrct_id: Option<String>,
}

impl ExchangeRateInformation1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.rate_tp { val.validate()? }
		if let Some(ref val) = self.ctrct_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "ctrct_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "ctrct_id exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// ExchangeRateType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum ExchangeRateType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "SPOT") )]
	CodeSPOT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SALE") )]
	CodeSALE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AGRD") )]
	CodeAGRD,
}

impl ExchangeRateType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ExecutingParty1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ExecutingParty1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prsn", skip_serializing_if = "Option::is_none") )]
	pub prsn: Option<PersonIdentification12>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Algo", skip_serializing_if = "Option::is_none") )]
	pub algo: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Clnt", skip_serializing_if = "Option::is_none") )]
	pub clnt: Option<NoReasonCode>,
}

impl ExecutingParty1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.prsn { val.validate()? }
		if let Some(ref val) = self.algo {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "algo is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 50 {
				return Err(ValidationError::new(1002, "algo exceeds the maximum length of 50".to_string()));
			}
		}
		if let Some(ref val) = self.clnt { val.validate()? }
		Ok(())
	}
}


// ExecutingParty2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ExecutingParty2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prsn", skip_serializing_if = "Option::is_none") )]
	pub prsn: Option<GenericPersonIdentification1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Algo", skip_serializing_if = "Option::is_none") )]
	pub algo: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Clnt", skip_serializing_if = "Option::is_none") )]
	pub clnt: Option<NoReasonCode>,
}

impl ExecutingParty2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.prsn { val.validate()? }
		if let Some(ref val) = self.algo {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "algo is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 50 {
				return Err(ValidationError::new(1002, "algo exceeds the maximum length of 50".to_string()));
			}
		}
		if let Some(ref val) = self.clnt { val.validate()? }
		Ok(())
	}
}


// ExerciseDate1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ExerciseDate1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrstExrcDt", skip_serializing_if = "Option::is_none") )]
	pub frst_exrc_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PdgDtAplbl", skip_serializing_if = "Option::is_none") )]
	pub pdg_dt_aplbl: Option<PriceStatus2Code>,
}

impl ExerciseDate1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.pdg_dt_aplbl { val.validate()? }
		Ok(())
	}
}


// ExoticOptionStyle1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum ExoticOptionStyle1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "BINA") )]
	CodeBINA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DIGI") )]
	CodeDIGI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NOTO") )]
	CodeNOTO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VANI") )]
	CodeVANI,
}

impl ExoticOptionStyle1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ExposureMetrics4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ExposureMetrics4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrncplAmt", skip_serializing_if = "Option::is_none") )]
	pub prncpl_amt: Option<PrincipalAmount3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LnVal", skip_serializing_if = "Option::is_none") )]
	pub ln_val: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MktVal", skip_serializing_if = "Option::is_none") )]
	pub mkt_val: Option<AmountAndDirection53>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OutsdngMrgnLnAmt", skip_serializing_if = "Option::is_none") )]
	pub outsdng_mrgn_ln_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ShrtMktValAmt", skip_serializing_if = "Option::is_none") )]
	pub shrt_mkt_val_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MrgnLn", skip_serializing_if = "Option::is_none") )]
	pub mrgn_ln: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshCollAmt", skip_serializing_if = "Option::is_none") )]
	pub csh_coll_amt: Option<AmountAndDirection53>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollMktVal", skip_serializing_if = "Option::is_none") )]
	pub coll_mkt_val: Option<AmountAndDirection53>,
}

impl ExposureMetrics4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.prncpl_amt { val.validate()? }
		if let Some(ref val) = self.ln_val { val.validate()? }
		if let Some(ref val) = self.mkt_val { val.validate()? }
		if let Some(ref val) = self.outsdng_mrgn_ln_amt { val.validate()? }
		if let Some(ref val) = self.shrt_mkt_val_amt { val.validate()? }
		if let Some(ref val) = self.mrgn_ln { val.validate()? }
		if let Some(ref val) = self.csh_coll_amt { val.validate()? }
		if let Some(ref val) = self.coll_mkt_val { val.validate()? }
		Ok(())
	}
}


// ExposureMetrics5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ExposureMetrics5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshCollAmt", skip_serializing_if = "Option::is_none") )]
	pub csh_coll_amt: Option<AmountAndDirection53>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollMktVal", skip_serializing_if = "Option::is_none") )]
	pub coll_mkt_val: Option<AmountAndDirection53>,
}

impl ExposureMetrics5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.csh_coll_amt { val.validate()? }
		if let Some(ref val) = self.coll_mkt_val { val.validate()? }
		Ok(())
	}
}


// ExposureMetrics6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ExposureMetrics6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstdMrgnOrColl", skip_serializing_if = "Option::is_none") )]
	pub pstd_mrgn_or_coll: Option<PostedMarginOrCollateral4>,
}

impl ExposureMetrics6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.pstd_mrgn_or_coll { val.validate()? }
		Ok(())
	}
}


// ExposureType10Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum ExposureType10Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "SBSC") )]
	CodeSBSC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MGLD") )]
	CodeMGLD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SLEB") )]
	CodeSLEB,
	#[cfg_attr( feature = "derive_serde", serde(rename = "REPO") )]
	CodeREPO,
}

impl ExposureType10Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// FertilizerCommodityAmmonia1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FertilizerCommodityAmmonia1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType5Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct") )]
	pub sub_pdct: AssetClassSubProductType39Code,
}

impl FertilizerCommodityAmmonia1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		self.sub_pdct.validate()?;
		Ok(())
	}
}


// FertilizerCommodityAmmonia2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FertilizerCommodityAmmonia2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType5Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType39Code>,
}

impl FertilizerCommodityAmmonia2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		Ok(())
	}
}


// FertilizerCommodityDiammoniumPhosphate1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FertilizerCommodityDiammoniumPhosphate1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType5Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct") )]
	pub sub_pdct: AssetClassSubProductType40Code,
}

impl FertilizerCommodityDiammoniumPhosphate1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		self.sub_pdct.validate()?;
		Ok(())
	}
}


// FertilizerCommodityDiammoniumPhosphate2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FertilizerCommodityDiammoniumPhosphate2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType5Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType40Code>,
}

impl FertilizerCommodityDiammoniumPhosphate2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		Ok(())
	}
}


// FertilizerCommodityOther1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FertilizerCommodityOther1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType5Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct") )]
	pub sub_pdct: AssetClassSubProductType49Code,
}

impl FertilizerCommodityOther1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		self.sub_pdct.validate()?;
		Ok(())
	}
}


// FertilizerCommodityOther2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FertilizerCommodityOther2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType5Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType49Code>,
}

impl FertilizerCommodityOther2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		Ok(())
	}
}


// FertilizerCommodityPotash1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FertilizerCommodityPotash1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType5Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct") )]
	pub sub_pdct: AssetClassSubProductType41Code,
}

impl FertilizerCommodityPotash1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		self.sub_pdct.validate()?;
		Ok(())
	}
}


// FertilizerCommodityPotash2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FertilizerCommodityPotash2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType5Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType41Code>,
}

impl FertilizerCommodityPotash2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		Ok(())
	}
}


// FertilizerCommoditySulphur1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FertilizerCommoditySulphur1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType5Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct") )]
	pub sub_pdct: AssetClassSubProductType42Code,
}

impl FertilizerCommoditySulphur1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		self.sub_pdct.validate()?;
		Ok(())
	}
}


// FertilizerCommoditySulphur2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FertilizerCommoditySulphur2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType5Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType42Code>,
}

impl FertilizerCommoditySulphur2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		Ok(())
	}
}


// FertilizerCommodityUrea1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FertilizerCommodityUrea1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType5Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct") )]
	pub sub_pdct: AssetClassSubProductType43Code,
}

impl FertilizerCommodityUrea1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		self.sub_pdct.validate()?;
		Ok(())
	}
}


// FertilizerCommodityUrea2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FertilizerCommodityUrea2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType5Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType43Code>,
}

impl FertilizerCommodityUrea2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		Ok(())
	}
}


// FertilizerCommodityUreaAndAmmoniumNitrate1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FertilizerCommodityUreaAndAmmoniumNitrate1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType5Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct") )]
	pub sub_pdct: AssetClassSubProductType44Code,
}

impl FertilizerCommodityUreaAndAmmoniumNitrate1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		self.sub_pdct.validate()?;
		Ok(())
	}
}


// FertilizerCommodityUreaAndAmmoniumNitrate2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FertilizerCommodityUreaAndAmmoniumNitrate2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType5Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType44Code>,
}

impl FertilizerCommodityUreaAndAmmoniumNitrate2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		Ok(())
	}
}


// FinancialIdentificationSchemeName1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FinancialIdentificationSchemeName1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl FinancialIdentificationSchemeName1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// FinancialInstitutionIdentification23 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FinancialInstitutionIdentification23 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BICFI", skip_serializing_if = "Option::is_none") )]
	pub bicfi: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrSysMmbId", skip_serializing_if = "Option::is_none") )]
	pub clr_sys_mmb_id: Option<ClearingSystemMemberIdentification2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LEI", skip_serializing_if = "Option::is_none") )]
	pub lei: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm", skip_serializing_if = "Option::is_none") )]
	pub nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstlAdr", skip_serializing_if = "Option::is_none") )]
	pub pstl_adr: Option<PostalAddress27>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<GenericFinancialIdentification1>,
}

impl FinancialInstitutionIdentification23 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.bicfi {
			let pattern = Regex::new("[A-Z0-9]{4,4}[A-Z]{2,2}[A-Z0-9]{2,2}([A-Z0-9]{3,3}){0,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "bicfi does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.clr_sys_mmb_id { val.validate()? }
		if let Some(ref val) = self.lei {
			let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "lei does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "nm exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.pstl_adr { val.validate()? }
		if let Some(ref val) = self.othr { val.validate()? }
		Ok(())
	}
}


// FinancialInstitutionSector1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FinancialInstitutionSector1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sctr") )]
	pub sctr: Vec<FinancialPartyClassification2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrThrshld", skip_serializing_if = "Option::is_none") )]
	pub clr_thrshld: Option<bool>,
}

impl FinancialInstitutionSector1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		for item in &self.sctr { item.validate()? }
		Ok(())
	}
}


// FinancialInstrument104 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FinancialInstrument104 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr") )]
	pub issr: String,
}

impl FinancialInstrument104 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
		if !pattern.is_match(&self.id) {
			return Err(ValidationError::new(1005, "id does not match the required pattern".to_string()));
		}
		let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
		if !pattern.is_match(&self.issr) {
			return Err(ValidationError::new(1005, "issr does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// FinancialInstrument46Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FinancialInstrument46Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ISIN", skip_serializing_if = "Option::is_none") )]
	pub isin: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Indx", skip_serializing_if = "Option::is_none") )]
	pub indx: Option<BenchmarkCurveName2Code>,
}

impl FinancialInstrument46Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.isin {
			let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "isin does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.indx { val.validate()? }
		Ok(())
	}
}


// FinancialInstrument48Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FinancialInstrument48Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ISIN", skip_serializing_if = "Option::is_none") )]
	pub isin: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LEI", skip_serializing_if = "Option::is_none") )]
	pub lei: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Indx", skip_serializing_if = "Option::is_none") )]
	pub indx: Option<FinancialInstrument58>,
}

impl FinancialInstrument48Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.isin {
			let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "isin does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.lei {
			let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "lei does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.indx { val.validate()? }
		Ok(())
	}
}


// FinancialInstrument53 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FinancialInstrument53 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ISIN", skip_serializing_if = "Option::is_none") )]
	pub isin: Option<Vec<String>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LEI", skip_serializing_if = "Option::is_none") )]
	pub lei: Option<Vec<String>>,
}

impl FinancialInstrument53 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.isin {
			for item in vec {
				let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
				if !pattern.is_match(&item) {
					return Err(ValidationError::new(1005, "isin does not match the required pattern".to_string()));
				}
			}
		}
		if let Some(ref vec) = self.lei {
			for item in vec {
				let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
				if !pattern.is_match(&item) {
					return Err(ValidationError::new(1005, "lei does not match the required pattern".to_string()));
				}
			}
		}
		Ok(())
	}
}


// FinancialInstrument58 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FinancialInstrument58 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ISIN", skip_serializing_if = "Option::is_none") )]
	pub isin: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm") )]
	pub nm: FloatingInterestRate8,
}

impl FinancialInstrument58 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.isin {
			let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "isin does not match the required pattern".to_string()));
			}
		}
		self.nm.validate()?;
		Ok(())
	}
}


// FinancialInstrument59 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FinancialInstrument59 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr") )]
	pub issr: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sctr", skip_serializing_if = "Option::is_none") )]
	pub sctr: Option<String>,
}

impl FinancialInstrument59 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
		if !pattern.is_match(&self.id) {
			return Err(ValidationError::new(1005, "id does not match the required pattern".to_string()));
		}
		let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
		if !pattern.is_match(&self.issr) {
			return Err(ValidationError::new(1005, "issr does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// FinancialInstrument99Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FinancialInstrument99Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StrtgyInstrms", skip_serializing_if = "Option::is_none") )]
	pub strtgy_instrms: Option<Vec<String>>,
}

impl FinancialInstrument99Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.id {
			let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "id does not match the required pattern".to_string()));
			}
		}
		if let Some(ref vec) = self.strtgy_instrms {
			for item in vec {
				let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
				if !pattern.is_match(&item) {
					return Err(ValidationError::new(1005, "strtgy_instrms does not match the required pattern".to_string()));
				}
			}
		}
		Ok(())
	}
}


// FinancialInstrumentAttributes5Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FinancialInstrumentAttributes5Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AltrnId", skip_serializing_if = "Option::is_none") )]
	pub altrn_id: Option<SecurityIdentification19>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<SecurityInstrumentDescription22>,
}

impl FinancialInstrumentAttributes5Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.id {
			let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "id does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.altrn_id { val.validate()? }
		if let Some(ref val) = self.othr { val.validate()? }
		Ok(())
	}
}


// FinancialInstrumentAttributes88 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FinancialInstrumentAttributes88 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrctTerm", skip_serializing_if = "Option::is_none") )]
	pub ctrct_term: Option<InterestRateContractTerm1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Stdstn", skip_serializing_if = "Option::is_none") )]
	pub stdstn: Option<Vec<Standardisation1Code>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtFrqcy") )]
	pub pmt_frqcy: Frequency11Code,
}

impl FinancialInstrumentAttributes88 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ctrct_term { val.validate()? }
		if let Some(ref vec) = self.stdstn { for item in vec { item.validate()? } }
		self.pmt_frqcy.validate()?;
		Ok(())
	}
}


// FinancialInstrumentAttributes89 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FinancialInstrumentAttributes89 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrctSz") )]
	pub ctrct_sz: ContractSize1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DlvryTp") )]
	pub dlvry_tp: PhysicalTransferType4Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UndrlygId") )]
	pub undrlyg_id: GenericIdentification165,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PricCcy") )]
	pub pric_ccy: String,
}

impl FinancialInstrumentAttributes89 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.ctrct_sz.validate()?;
		self.dlvry_tp.validate()?;
		self.undrlyg_id.validate()?;
		let pattern = Regex::new("[A-Z]{3,3}").unwrap();
		if !pattern.is_match(&self.pric_ccy) {
			return Err(ValidationError::new(1005, "pric_ccy does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// FinancialInstrumentAttributes90 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FinancialInstrumentAttributes90 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ntnl", skip_serializing_if = "Option::is_none") )]
	pub ntnl: Option<ActiveCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnitVal") )]
	pub unit_val: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IndxId") )]
	pub indx_id: GenericIdentification168,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IndxUnit") )]
	pub indx_unit: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstRateTerms", skip_serializing_if = "Option::is_none") )]
	pub intrst_rate_terms: Option<InterestComputationMethod2Code>,
}

impl FinancialInstrumentAttributes90 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ntnl { val.validate()? }
		self.unit_val.validate()?;
		self.indx_id.validate()?;
		if self.indx_unit.chars().count() < 1 {
			return Err(ValidationError::new(1001, "indx_unit is shorter than the minimum length of 1".to_string()));
		}
		if self.indx_unit.chars().count() > 35 {
			return Err(ValidationError::new(1002, "indx_unit exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.intrst_rate_terms { val.validate()? }
		Ok(())
	}
}


// FinancialInstrumentContractType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum FinancialInstrumentContractType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "CFDS") )]
	CodeCFDS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FORW") )]
	CodeFORW,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FRAS") )]
	CodeFRAS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FUTR") )]
	CodeFUTR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OPTN") )]
	CodeOPTN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SPDB") )]
	CodeSPDB,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SWAP") )]
	CodeSWAP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SWPT") )]
	CodeSWPT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FONS") )]
	CodeFONS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PSWP") )]
	CodePSWP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FFAS") )]
	CodeFFAS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FWOS") )]
	CodeFWOS,
}

impl FinancialInstrumentContractType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// FinancialInstrumentContractType2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum FinancialInstrumentContractType2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "CFDS") )]
	CodeCFDS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FRAS") )]
	CodeFRAS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FUTR") )]
	CodeFUTR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FORW") )]
	CodeFORW,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OPTN") )]
	CodeOPTN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SPDB") )]
	CodeSPDB,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SWAP") )]
	CodeSWAP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SWPT") )]
	CodeSWPT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
}

impl FinancialInstrumentContractType2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// FinancialInstrumentIdentification5Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FinancialInstrumentIdentification5Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sngl", skip_serializing_if = "Option::is_none") )]
	pub sngl: Option<FinancialInstrument48Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Bskt", skip_serializing_if = "Option::is_none") )]
	pub bskt: Option<FinancialInstrument53>,
}

impl FinancialInstrumentIdentification5Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.sngl { val.validate()? }
		if let Some(ref val) = self.bskt { val.validate()? }
		Ok(())
	}
}


// FinancialInstrumentIdentification6Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FinancialInstrumentIdentification6Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ISIN", skip_serializing_if = "Option::is_none") )]
	pub isin: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Indx", skip_serializing_if = "Option::is_none") )]
	pub indx: Option<FinancialInstrument58>,
}

impl FinancialInstrumentIdentification6Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.isin {
			let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "isin does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.indx { val.validate()? }
		Ok(())
	}
}


// FinancialInstrumentIdentification7Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FinancialInstrumentIdentification7Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sngl", skip_serializing_if = "Option::is_none") )]
	pub sngl: Option<FinancialInstrumentIdentification6Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Bskt", skip_serializing_if = "Option::is_none") )]
	pub bskt: Option<BasketDescription3>,
}

impl FinancialInstrumentIdentification7Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.sngl { val.validate()? }
		if let Some(ref val) = self.bskt { val.validate()? }
		Ok(())
	}
}


// FinancialInstrumentProductType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum FinancialInstrumentProductType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "CEOD") )]
	CodeCEOD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "COPR") )]
	CodeCOPR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ABCP") )]
	CodeABCP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FRNT") )]
	CodeFRNT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CACM") )]
	CodeCACM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DPST") )]
	CodeDPST,
}

impl FinancialInstrumentProductType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// FinancialInstrumentQuantity25Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FinancialInstrumentQuantity25Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Unit", skip_serializing_if = "Option::is_none") )]
	pub unit: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NmnlVal", skip_serializing_if = "Option::is_none") )]
	pub nmnl_val: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MntryVal", skip_serializing_if = "Option::is_none") )]
	pub mntry_val: Option<ActiveOrHistoricCurrencyAndAmount>,
}

impl FinancialInstrumentQuantity25Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.nmnl_val { val.validate()? }
		if let Some(ref val) = self.mntry_val { val.validate()? }
		Ok(())
	}
}


// FinancialInstrumentQuantity32Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FinancialInstrumentQuantity32Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Unit", skip_serializing_if = "Option::is_none") )]
	pub unit: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NmnlVal", skip_serializing_if = "Option::is_none") )]
	pub nmnl_val: Option<ActiveOrHistoricCurrencyAnd19DecimalAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MntryVal", skip_serializing_if = "Option::is_none") )]
	pub mntry_val: Option<ActiveOrHistoricCurrencyAnd19DecimalAmount>,
}

impl FinancialInstrumentQuantity32Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.nmnl_val { val.validate()? }
		if let Some(ref val) = self.mntry_val { val.validate()? }
		Ok(())
	}
}


// FinancialPartyClassification1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FinancialPartyClassification1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Clssfctn") )]
	pub clssfctn: Vec<FinancialPartySectorType2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InvstmtFndClssfctn", skip_serializing_if = "Option::is_none") )]
	pub invstmt_fnd_clssfctn: Option<FundType2Code>,
}

impl FinancialPartyClassification1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		for item in &self.clssfctn { item.validate()? }
		if let Some(ref val) = self.invstmt_fnd_clssfctn { val.validate()? }
		Ok(())
	}
}


// FinancialPartyClassification2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FinancialPartyClassification2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Clssfctn") )]
	pub clssfctn: Vec<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InvstmtFndClssfctn", skip_serializing_if = "Option::is_none") )]
	pub invstmt_fnd_clssfctn: Option<FundType2Code>,
}

impl FinancialPartyClassification2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		for item in &self.clssfctn {
			let pattern = Regex::new("[A-U]{1,1}").unwrap();
			if !pattern.is_match(&item) {
				return Err(ValidationError::new(1005, "clssfctn does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.invstmt_fnd_clssfctn { val.validate()? }
		Ok(())
	}
}


// FinancialPartyClassification2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FinancialPartyClassification2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<FinancialPartySectorType3Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification175>,
}

impl FinancialPartyClassification2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// FinancialPartySectorType2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum FinancialPartySectorType2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "AIFD") )]
	CodeAIFD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CSDS") )]
	CodeCSDS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CCPS") )]
	CodeCCPS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CDTI") )]
	CodeCDTI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INUN") )]
	CodeINUN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ORPI") )]
	CodeORPI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INVF") )]
	CodeINVF,
	#[cfg_attr( feature = "derive_serde", serde(rename = "REIN") )]
	CodeREIN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UCIT") )]
	CodeUCIT,
}

impl FinancialPartySectorType2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// FinancialPartySectorType3Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum FinancialPartySectorType3Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "AIFD") )]
	CodeAIFD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CSDS") )]
	CodeCSDS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CCPS") )]
	CodeCCPS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CDTI") )]
	CodeCDTI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INUN") )]
	CodeINUN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ORPI") )]
	CodeORPI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INVF") )]
	CodeINVF,
	#[cfg_attr( feature = "derive_serde", serde(rename = "REIN") )]
	CodeREIN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UCIT") )]
	CodeUCIT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ASSU") )]
	CodeASSU,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
}

impl FinancialPartySectorType3Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// FixedOpenTermContract2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FixedOpenTermContract2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MtrtyDt", skip_serializing_if = "Option::is_none") )]
	pub mtrty_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TermntnOptn", skip_serializing_if = "Option::is_none") )]
	pub termntn_optn: Option<RepoTerminationOption2Code>,
}

impl FixedOpenTermContract2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.termntn_optn { val.validate()? }
		Ok(())
	}
}


// FixedRate10 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FixedRate10 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rate", skip_serializing_if = "Option::is_none") )]
	pub rate: Option<SecuritiesTransactionPrice14Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DayCnt", skip_serializing_if = "Option::is_none") )]
	pub day_cnt: Option<InterestComputationMethodFormat7>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtFrqcy", skip_serializing_if = "Option::is_none") )]
	pub pmt_frqcy: Option<InterestRateFrequency3Choice>,
}

impl FixedRate10 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.rate { val.validate()? }
		if let Some(ref val) = self.day_cnt { val.validate()? }
		if let Some(ref val) = self.pmt_frqcy { val.validate()? }
		Ok(())
	}
}


// FixedRate11 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FixedRate11 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rate", skip_serializing_if = "Option::is_none") )]
	pub rate: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DayCntBsis", skip_serializing_if = "Option::is_none") )]
	pub day_cnt_bsis: Option<InterestComputationMethodFormat6Choice>,
}

impl FixedRate11 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.day_cnt_bsis { val.validate()? }
		Ok(())
	}
}


// FloatingInterestRate22 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FloatingInterestRate22 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RefRate", skip_serializing_if = "Option::is_none") )]
	pub ref_rate: Option<BenchmarkCurveName10Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Term", skip_serializing_if = "Option::is_none") )]
	pub term: Option<InterestRateContractTerm2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtFrqcy", skip_serializing_if = "Option::is_none") )]
	pub pmt_frqcy: Option<InterestRateContractTerm2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RstFrqcy", skip_serializing_if = "Option::is_none") )]
	pub rst_frqcy: Option<InterestRateContractTerm2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sprd", skip_serializing_if = "Option::is_none") )]
	pub sprd: Option<SecuritiesTransactionPrice18Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RateAdjstmnt", skip_serializing_if = "Option::is_none") )]
	pub rate_adjstmnt: Option<Vec<RateAdjustment1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DayCntBsis", skip_serializing_if = "Option::is_none") )]
	pub day_cnt_bsis: Option<InterestComputationMethodFormat6Choice>,
}

impl FloatingInterestRate22 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ref_rate { val.validate()? }
		if let Some(ref val) = self.term { val.validate()? }
		if let Some(ref val) = self.pmt_frqcy { val.validate()? }
		if let Some(ref val) = self.rst_frqcy { val.validate()? }
		if let Some(ref val) = self.sprd { val.validate()? }
		if let Some(ref vec) = self.rate_adjstmnt { for item in vec { item.validate()? } }
		if let Some(ref val) = self.day_cnt_bsis { val.validate()? }
		Ok(())
	}
}


// FloatingInterestRate4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FloatingInterestRate4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RefRate") )]
	pub ref_rate: BenchmarkCurveName4Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Term") )]
	pub term: InterestRateContractTerm1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BsisPtSprd") )]
	pub bsis_pt_sprd: f64,
}

impl FloatingInterestRate4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.ref_rate.validate()?;
		self.term.validate()?;
		Ok(())
	}
}


// FloatingInterestRate6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FloatingInterestRate6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RefRate") )]
	pub ref_rate: BenchmarkCurveName6Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Term") )]
	pub term: InterestRateContractTerm2,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BsisPtSprd") )]
	pub bsis_pt_sprd: f64,
}

impl FloatingInterestRate6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.ref_rate.validate()?;
		self.term.validate()?;
		Ok(())
	}
}


// FloatingInterestRate8 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FloatingInterestRate8 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RefRate") )]
	pub ref_rate: BenchmarkCurveName5Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Term", skip_serializing_if = "Option::is_none") )]
	pub term: Option<InterestRateContractTerm2>,
}

impl FloatingInterestRate8 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.ref_rate.validate()?;
		if let Some(ref val) = self.term { val.validate()? }
		Ok(())
	}
}


// FloatingRate13 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FloatingRate13 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm", skip_serializing_if = "Option::is_none") )]
	pub nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rate", skip_serializing_if = "Option::is_none") )]
	pub rate: Option<FloatingRateIdentification8Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RefPrd", skip_serializing_if = "Option::is_none") )]
	pub ref_prd: Option<InterestRateContractTerm4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sprd", skip_serializing_if = "Option::is_none") )]
	pub sprd: Option<SecuritiesTransactionPrice20Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DayCnt", skip_serializing_if = "Option::is_none") )]
	pub day_cnt: Option<InterestComputationMethodFormat7>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtFrqcy", skip_serializing_if = "Option::is_none") )]
	pub pmt_frqcy: Option<InterestRateFrequency3Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RstFrqcy", skip_serializing_if = "Option::is_none") )]
	pub rst_frqcy: Option<InterestRateFrequency3Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NxtFltgRst", skip_serializing_if = "Option::is_none") )]
	pub nxt_fltg_rst: Option<ResetDateAndValue1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LastFltgRst", skip_serializing_if = "Option::is_none") )]
	pub last_fltg_rst: Option<ResetDateAndValue1>,
}

impl FloatingRate13 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.id {
			let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "id does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 350 {
				return Err(ValidationError::new(1002, "nm exceeds the maximum length of 350".to_string()));
			}
		}
		if let Some(ref val) = self.rate { val.validate()? }
		if let Some(ref val) = self.ref_prd { val.validate()? }
		if let Some(ref val) = self.sprd { val.validate()? }
		if let Some(ref val) = self.day_cnt { val.validate()? }
		if let Some(ref val) = self.pmt_frqcy { val.validate()? }
		if let Some(ref val) = self.rst_frqcy { val.validate()? }
		if let Some(ref val) = self.nxt_fltg_rst { val.validate()? }
		if let Some(ref val) = self.last_fltg_rst { val.validate()? }
		Ok(())
	}
}


// FloatingRateIdentification8Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FloatingRateIdentification8Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl FloatingRateIdentification8Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 350 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 350".to_string()));
			}
		}
		Ok(())
	}
}


// FloatingRateNote2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FloatingRateNote2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RefRateIndx") )]
	pub ref_rate_indx: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BsisPtSprd") )]
	pub bsis_pt_sprd: f64,
}

impl FloatingRateNote2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
		if !pattern.is_match(&self.ref_rate_indx) {
			return Err(ValidationError::new(1005, "ref_rate_indx does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// Flows1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Flows1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtBkFlows") )]
	pub pmt_bk_flows: AmountAndDirection102,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InvstmtFlows") )]
	pub invstmt_flows: AmountAndDirection102,
}

impl Flows1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.pmt_bk_flows.validate()?;
		self.invstmt_flows.validate()?;
		Ok(())
	}
}


// ForeignExchange1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ForeignExchange1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrgnCcy") )]
	pub frgn_ccy: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XchgSpotRate") )]
	pub xchg_spot_rate: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XchgFwdPt") )]
	pub xchg_fwd_pt: f64,
}

impl ForeignExchange1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z]{3,3}").unwrap();
		if !pattern.is_match(&self.frgn_ccy) {
			return Err(ValidationError::new(1005, "frgn_ccy does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// ForeignExchangeDerivative2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ForeignExchangeDerivative2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrctSubTp") )]
	pub ctrct_sub_tp: AssetClassSubProductType19Code,
}

impl ForeignExchangeDerivative2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.ctrct_sub_tp.validate()?;
		Ok(())
	}
}


// ForeignExchangeSwap3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ForeignExchangeSwap3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DataSetActn", skip_serializing_if = "Option::is_none") )]
	pub data_set_actn: Option<ReportPeriodActivity3Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tx", skip_serializing_if = "Option::is_none") )]
	pub tx: Option<Vec<ForeignExchangeSwapTransaction3>>,
}

impl ForeignExchangeSwap3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.data_set_actn { val.validate()? }
		if let Some(ref vec) = self.tx { for item in vec { item.validate()? } }
		Ok(())
	}
}


// ForeignExchangeSwapTransaction3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ForeignExchangeSwapTransaction3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptdTxSts") )]
	pub rptd_tx_sts: TransactionOperationType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NvtnSts", skip_serializing_if = "Option::is_none") )]
	pub nvtn_sts: Option<NovationStatus1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BrnchId", skip_serializing_if = "Option::is_none") )]
	pub brnch_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnqTxIdr", skip_serializing_if = "Option::is_none") )]
	pub unq_tx_idr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrtryTxId") )]
	pub prtry_tx_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RltdPrtryTxId", skip_serializing_if = "Option::is_none") )]
	pub rltd_prtry_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPtyPrtryTxId", skip_serializing_if = "Option::is_none") )]
	pub ctr_pty_prtry_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPtyId") )]
	pub ctr_pty_id: CounterpartyIdentification3Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradDt") )]
	pub trad_dt: DateAndDateTimeChoice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SpotValDt") )]
	pub spot_val_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MtrtyDt") )]
	pub mtrty_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxTp") )]
	pub tx_tp: SecuritiesTransactionType15Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxNmnlAmt") )]
	pub tx_nmnl_amt: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FX") )]
	pub fx: ForeignExchange1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl ForeignExchangeSwapTransaction3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.rptd_tx_sts.validate()?;
		if let Some(ref val) = self.nvtn_sts { val.validate()? }
		if let Some(ref val) = self.brnch_id {
			let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "brnch_id does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.unq_tx_idr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "unq_tx_idr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 105 {
				return Err(ValidationError::new(1002, "unq_tx_idr exceeds the maximum length of 105".to_string()));
			}
		}
		if self.prtry_tx_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "prtry_tx_id is shorter than the minimum length of 1".to_string()));
		}
		if self.prtry_tx_id.chars().count() > 105 {
			return Err(ValidationError::new(1002, "prtry_tx_id exceeds the maximum length of 105".to_string()));
		}
		if let Some(ref val) = self.rltd_prtry_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "rltd_prtry_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 105 {
				return Err(ValidationError::new(1002, "rltd_prtry_tx_id exceeds the maximum length of 105".to_string()));
			}
		}
		if let Some(ref val) = self.ctr_pty_prtry_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "ctr_pty_prtry_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 105 {
				return Err(ValidationError::new(1002, "ctr_pty_prtry_tx_id exceeds the maximum length of 105".to_string()));
			}
		}
		self.ctr_pty_id.validate()?;
		self.trad_dt.validate()?;
		self.tx_tp.validate()?;
		self.tx_nmnl_amt.validate()?;
		self.fx.validate()?;
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// FreightCommodityContainerShip1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FreightCommodityContainerShip1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType4Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct") )]
	pub sub_pdct: AssetClassSubProductType46Code,
}

impl FreightCommodityContainerShip1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		self.sub_pdct.validate()?;
		Ok(())
	}
}


// FreightCommodityContainerShip2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FreightCommodityContainerShip2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType4Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType46Code>,
}

impl FreightCommodityContainerShip2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		Ok(())
	}
}


// FreightCommodityDry1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FreightCommodityDry1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType4Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct") )]
	pub sub_pdct: AssetClassSubProductType31Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlSubPdct", skip_serializing_if = "Option::is_none") )]
	pub addtl_sub_pdct: Option<AssetClassDetailedSubProductType14Code>,
}

impl FreightCommodityDry1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		self.sub_pdct.validate()?;
		if let Some(ref val) = self.addtl_sub_pdct { val.validate()? }
		Ok(())
	}
}


// FreightCommodityDry2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FreightCommodityDry2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType4Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct") )]
	pub sub_pdct: AssetClassSubProductType31Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlSubPdct") )]
	pub addtl_sub_pdct: AssetClassDetailedSubProductType33Code,
}

impl FreightCommodityDry2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		self.sub_pdct.validate()?;
		self.addtl_sub_pdct.validate()?;
		Ok(())
	}
}


// FreightCommodityDry3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FreightCommodityDry3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType4Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType31Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlSubPdct", skip_serializing_if = "Option::is_none") )]
	pub addtl_sub_pdct: Option<AssetClassDetailedSubProductType33Code>,
}

impl FreightCommodityDry3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		if let Some(ref val) = self.addtl_sub_pdct { val.validate()? }
		Ok(())
	}
}


// FreightCommodityOther1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FreightCommodityOther1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType4Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct") )]
	pub sub_pdct: AssetClassSubProductType49Code,
}

impl FreightCommodityOther1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		self.sub_pdct.validate()?;
		Ok(())
	}
}


// FreightCommodityOther2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FreightCommodityOther2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType4Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType49Code>,
}

impl FreightCommodityOther2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		Ok(())
	}
}


// FreightCommodityWet1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FreightCommodityWet1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType4Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct") )]
	pub sub_pdct: AssetClassSubProductType32Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlSubPdct", skip_serializing_if = "Option::is_none") )]
	pub addtl_sub_pdct: Option<AssetClassDetailedSubProductType12Code>,
}

impl FreightCommodityWet1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		self.sub_pdct.validate()?;
		if let Some(ref val) = self.addtl_sub_pdct { val.validate()? }
		Ok(())
	}
}


// FreightCommodityWet2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FreightCommodityWet2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType4Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct") )]
	pub sub_pdct: AssetClassSubProductType32Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlSubPdct") )]
	pub addtl_sub_pdct: AssetClassDetailedSubProductType34Code,
}

impl FreightCommodityWet2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		self.sub_pdct.validate()?;
		self.addtl_sub_pdct.validate()?;
		Ok(())
	}
}


// FreightCommodityWet3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FreightCommodityWet3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType4Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType32Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlSubPdct", skip_serializing_if = "Option::is_none") )]
	pub addtl_sub_pdct: Option<AssetClassDetailedSubProductType34Code>,
}

impl FreightCommodityWet3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		if let Some(ref val) = self.addtl_sub_pdct { val.validate()? }
		Ok(())
	}
}


// Frequency11Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum Frequency11Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "YEAR") )]
	CodeYEAR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DAIL") )]
	CodeDAIL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MNTH") )]
	CodeMNTH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EXPI") )]
	CodeEXPI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OVNG") )]
	CodeOVNG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "QURT") )]
	CodeQURT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MIAN") )]
	CodeMIAN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UPFR") )]
	CodeUPFR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "WEEK") )]
	CodeWEEK,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CRED") )]
	CodeCRED,
}

impl Frequency11Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// Frequency13Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum Frequency13Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "DAIL") )]
	CodeDAIL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "WEEK") )]
	CodeWEEK,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MNTH") )]
	CodeMNTH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "YEAR") )]
	CodeYEAR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ADHO") )]
	CodeADHO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EXPI") )]
	CodeEXPI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MIAN") )]
	CodeMIAN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "QURT") )]
	CodeQURT,
}

impl Frequency13Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// Frequency14Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum Frequency14Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "DAIL") )]
	CodeDAIL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "WEEK") )]
	CodeWEEK,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MNTH") )]
	CodeMNTH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ADHO") )]
	CodeADHO,
}

impl Frequency14Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// Frequency19Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum Frequency19Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "DAIL") )]
	CodeDAIL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "WEEK") )]
	CodeWEEK,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MNTH") )]
	CodeMNTH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "YEAR") )]
	CodeYEAR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ADHO") )]
	CodeADHO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EXPI") )]
	CodeEXPI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MIAN") )]
	CodeMIAN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "QURT") )]
	CodeQURT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "HOUL") )]
	CodeHOUL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ODMD") )]
	CodeODMD,
}

impl Frequency19Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// FromToQuantityRange2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FromToQuantityRange2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrQty") )]
	pub fr_qty: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ToQty") )]
	pub to_qty: f64,
}

impl FromToQuantityRange2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// FundType2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum FundType2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ETFT") )]
	CodeETFT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MMFT") )]
	CodeMMFT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "REIT") )]
	CodeREIT,
}

impl FundType2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// FundingSource3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct FundingSource3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: FundingSourceType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MktVal") )]
	pub mkt_val: AmountAndDirection53,
}

impl FundingSource3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.tp.validate()?;
		self.mkt_val.validate()?;
		Ok(())
	}
}


// FundingSourceType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum FundingSourceType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "SECL") )]
	CodeSECL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FREE") )]
	CodeFREE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BSHS") )]
	CodeBSHS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CSHS") )]
	CodeCSHS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "REPO") )]
	CodeREPO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UBOR") )]
	CodeUBOR,
}

impl FundingSourceType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// GeneralCollateral2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct GeneralCollateral2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ElgblFinInstrmId") )]
	pub elgbl_fin_instrm_id: Vec<String>,
}

impl GeneralCollateral2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		for item in &self.elgbl_fin_instrm_id {
			if item.chars().count() < 1 {
				return Err(ValidationError::new(1001, "elgbl_fin_instrm_id is shorter than the minimum length of 1".to_string()));
			}
			if item.chars().count() > 35 {
				return Err(ValidationError::new(1002, "elgbl_fin_instrm_id exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// GeneralCollateral3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct GeneralCollateral3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FinInstrmId", skip_serializing_if = "Option::is_none") )]
	pub fin_instrm_id: Option<Vec<FinancialInstrument59>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ElgblFinInstrmId", skip_serializing_if = "Option::is_none") )]
	pub elgbl_fin_instrm_id: Option<Vec<String>>,
}

impl GeneralCollateral3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.fin_instrm_id { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.elgbl_fin_instrm_id {
			for item in vec {
				let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
				if !pattern.is_match(&item) {
					return Err(ValidationError::new(1005, "elgbl_fin_instrm_id does not match the required pattern".to_string()));
				}
			}
		}
		Ok(())
	}
}


// GeneralCollateral4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct GeneralCollateral4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FinInstrmId", skip_serializing_if = "Option::is_none") )]
	pub fin_instrm_id: Option<Vec<FinancialInstrument104>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MktVal") )]
	pub mkt_val: ActiveCurrencyAnd24Amount,
}

impl GeneralCollateral4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.fin_instrm_id { for item in vec { item.validate()? } }
		self.mkt_val.validate()?;
		Ok(())
	}
}


// GenericAccountIdentification1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct GenericAccountIdentification1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SchmeNm", skip_serializing_if = "Option::is_none") )]
	pub schme_nm: Option<AccountSchemeName1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr", skip_serializing_if = "Option::is_none") )]
	pub issr: Option<String>,
}

impl GenericAccountIdentification1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 34 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 34".to_string()));
		}
		if let Some(ref val) = self.schme_nm { val.validate()? }
		if let Some(ref val) = self.issr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "issr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "issr exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// GenericFinancialIdentification1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct GenericFinancialIdentification1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SchmeNm", skip_serializing_if = "Option::is_none") )]
	pub schme_nm: Option<FinancialIdentificationSchemeName1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr", skip_serializing_if = "Option::is_none") )]
	pub issr: Option<String>,
}

impl GenericFinancialIdentification1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.schme_nm { val.validate()? }
		if let Some(ref val) = self.issr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "issr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "issr exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// GenericIdentification1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct GenericIdentification1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SchmeNm", skip_serializing_if = "Option::is_none") )]
	pub schme_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr", skip_serializing_if = "Option::is_none") )]
	pub issr: Option<String>,
}

impl GenericIdentification1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.schme_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "schme_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "schme_nm exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.issr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "issr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "issr exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// GenericIdentification165 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct GenericIdentification165 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Desc", skip_serializing_if = "Option::is_none") )]
	pub desc: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr", skip_serializing_if = "Option::is_none") )]
	pub issr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SchmeNm", skip_serializing_if = "Option::is_none") )]
	pub schme_nm: Option<SchemeIdentificationType1Code>,
}

impl GenericIdentification165 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 256 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 256".to_string()));
		}
		if let Some(ref val) = self.desc {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "desc is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "desc exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.issr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "issr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "issr exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.schme_nm { val.validate()? }
		Ok(())
	}
}


// GenericIdentification168 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct GenericIdentification168 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Desc", skip_serializing_if = "Option::is_none") )]
	pub desc: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr", skip_serializing_if = "Option::is_none") )]
	pub issr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SchmeNm", skip_serializing_if = "Option::is_none") )]
	pub schme_nm: Option<String>,
}

impl GenericIdentification168 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 256 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 256".to_string()));
		}
		if let Some(ref val) = self.desc {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "desc is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "desc exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.issr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "issr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "issr exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.schme_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "schme_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "schme_nm exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// GenericIdentification175 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct GenericIdentification175 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SchmeNm", skip_serializing_if = "Option::is_none") )]
	pub schme_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr", skip_serializing_if = "Option::is_none") )]
	pub issr: Option<String>,
}

impl GenericIdentification175 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 72 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 72".to_string()));
		}
		if let Some(ref val) = self.schme_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "schme_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "schme_nm exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.issr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "issr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "issr exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// GenericIdentification179 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct GenericIdentification179 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr", skip_serializing_if = "Option::is_none") )]
	pub issr: Option<String>,
}

impl GenericIdentification179 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 52 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 52".to_string()));
		}
		if let Some(ref val) = self.issr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "issr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "issr exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// GenericIdentification184 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct GenericIdentification184 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Src") )]
	pub src: String,
}

impl GenericIdentification184 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 210 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 210".to_string()));
		}
		if self.src.chars().count() < 1 {
			return Err(ValidationError::new(1001, "src is shorter than the minimum length of 1".to_string()));
		}
		if self.src.chars().count() > 100 {
			return Err(ValidationError::new(1002, "src exceeds the maximum length of 100".to_string()));
		}
		Ok(())
	}
}


// GenericIdentification185 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct GenericIdentification185 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SchmeNm", skip_serializing_if = "Option::is_none") )]
	pub schme_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr", skip_serializing_if = "Option::is_none") )]
	pub issr: Option<String>,
}

impl GenericIdentification185 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 100 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 100".to_string()));
		}
		if let Some(ref val) = self.schme_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "schme_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "schme_nm exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.issr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "issr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "issr exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// GenericIdentification30 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct GenericIdentification30 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr") )]
	pub issr: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SchmeNm", skip_serializing_if = "Option::is_none") )]
	pub schme_nm: Option<String>,
}

impl GenericIdentification30 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[a-zA-Z0-9]{4}").unwrap();
		if !pattern.is_match(&self.id) {
			return Err(ValidationError::new(1005, "id does not match the required pattern".to_string()));
		}
		if self.issr.chars().count() < 1 {
			return Err(ValidationError::new(1001, "issr is shorter than the minimum length of 1".to_string()));
		}
		if self.issr.chars().count() > 35 {
			return Err(ValidationError::new(1002, "issr exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.schme_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "schme_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "schme_nm exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// GenericIdentification36 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct GenericIdentification36 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr") )]
	pub issr: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SchmeNm", skip_serializing_if = "Option::is_none") )]
	pub schme_nm: Option<String>,
}

impl GenericIdentification36 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
		}
		if self.issr.chars().count() < 1 {
			return Err(ValidationError::new(1001, "issr is shorter than the minimum length of 1".to_string()));
		}
		if self.issr.chars().count() > 35 {
			return Err(ValidationError::new(1002, "issr exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.schme_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "schme_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "schme_nm exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// GenericOrganisationIdentification1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct GenericOrganisationIdentification1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SchmeNm", skip_serializing_if = "Option::is_none") )]
	pub schme_nm: Option<OrganisationIdentificationSchemeName1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr", skip_serializing_if = "Option::is_none") )]
	pub issr: Option<String>,
}

impl GenericOrganisationIdentification1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.schme_nm { val.validate()? }
		if let Some(ref val) = self.issr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "issr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "issr exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// GenericOrganisationIdentification3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct GenericOrganisationIdentification3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SchmeNm", skip_serializing_if = "Option::is_none") )]
	pub schme_nm: Option<OrganisationIdentificationSchemeName1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr", skip_serializing_if = "Option::is_none") )]
	pub issr: Option<String>,
}

impl GenericOrganisationIdentification3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 256 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 256".to_string()));
		}
		if let Some(ref val) = self.schme_nm { val.validate()? }
		if let Some(ref val) = self.issr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "issr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "issr exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// GenericPersonIdentification1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct GenericPersonIdentification1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SchmeNm", skip_serializing_if = "Option::is_none") )]
	pub schme_nm: Option<PersonIdentificationSchemeName1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr", skip_serializing_if = "Option::is_none") )]
	pub issr: Option<String>,
}

impl GenericPersonIdentification1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.schme_nm { val.validate()? }
		if let Some(ref val) = self.issr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "issr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "issr exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// GenericPersonIdentification2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct GenericPersonIdentification2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SchmeNm", skip_serializing_if = "Option::is_none") )]
	pub schme_nm: Option<PersonIdentificationSchemeName1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr", skip_serializing_if = "Option::is_none") )]
	pub issr: Option<String>,
}

impl GenericPersonIdentification2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 256 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 256".to_string()));
		}
		if let Some(ref val) = self.schme_nm { val.validate()? }
		if let Some(ref val) = self.issr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "issr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "issr exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// GenericValidationRuleIdentification1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct GenericValidationRuleIdentification1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Desc", skip_serializing_if = "Option::is_none") )]
	pub desc: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SchmeNm", skip_serializing_if = "Option::is_none") )]
	pub schme_nm: Option<ValidationRuleSchemeName1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr", skip_serializing_if = "Option::is_none") )]
	pub issr: Option<String>,
}

impl GenericValidationRuleIdentification1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.desc {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "desc is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 350 {
				return Err(ValidationError::new(1002, "desc exceeds the maximum length of 350".to_string()));
			}
		}
		if let Some(ref val) = self.schme_nm { val.validate()? }
		if let Some(ref val) = self.issr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "issr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "issr exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// GroupHeader69 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct GroupHeader69 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IssdDt") )]
	pub issd_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptCtgy") )]
	pub rpt_ctgy: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TaxRptPurp") )]
	pub tax_rpt_purp: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlId", skip_serializing_if = "Option::is_none") )]
	pub orgnl_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SellrTaxRprtv", skip_serializing_if = "Option::is_none") )]
	pub sellr_tax_rprtv: Option<PartyIdentification116>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BuyrTaxRprtv", skip_serializing_if = "Option::is_none") )]
	pub buyr_tax_rprtv: Option<PartyIdentification116>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LangCd", skip_serializing_if = "Option::is_none") )]
	pub lang_cd: Option<String>,
}

impl GroupHeader69 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
		}
		if self.rpt_ctgy.chars().count() < 1 {
			return Err(ValidationError::new(1001, "rpt_ctgy is shorter than the minimum length of 1".to_string()));
		}
		if self.rpt_ctgy.chars().count() > 4 {
			return Err(ValidationError::new(1002, "rpt_ctgy exceeds the maximum length of 4".to_string()));
		}
		if self.tax_rpt_purp.chars().count() < 1 {
			return Err(ValidationError::new(1001, "tax_rpt_purp is shorter than the minimum length of 1".to_string()));
		}
		if self.tax_rpt_purp.chars().count() > 4 {
			return Err(ValidationError::new(1002, "tax_rpt_purp exceeds the maximum length of 4".to_string()));
		}
		if let Some(ref val) = self.orgnl_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.sellr_tax_rprtv { val.validate()? }
		if let Some(ref val) = self.buyr_tax_rprtv { val.validate()? }
		Ok(())
	}
}


// Guarantee1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Guarantee1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prvdr") )]
	pub prvdr: PartyIdentification118Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveCurrencyAndAmount,
}

impl Guarantee1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.prvdr.validate()?;
		self.amt.validate()?;
		Ok(())
	}
}


// HypotheticalCapitalMeasure1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct HypotheticalCapitalMeasure1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DfltWtrfllId") )]
	pub dflt_wtrfll_id: String,
}

impl HypotheticalCapitalMeasure1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.amt.validate()?;
		if self.dflt_wtrfll_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "dflt_wtrfll_id is shorter than the minimum length of 1".to_string()));
		}
		if self.dflt_wtrfll_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "dflt_wtrfll_id exceeds the maximum length of 35".to_string()));
		}
		Ok(())
	}
}


// ISINQueryCriteria1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ISINQueryCriteria1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Idr", skip_serializing_if = "Option::is_none") )]
	pub idr: Option<Vec<String>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NotRptd", skip_serializing_if = "Option::is_none") )]
	pub not_rptd: Option<NotReported1Code>,
}

impl ISINQueryCriteria1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.idr {
			for item in vec {
				let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
				if !pattern.is_match(&item) {
					return Err(ValidationError::new(1005, "idr does not match the required pattern".to_string()));
				}
			}
		}
		if let Some(ref val) = self.not_rptd { val.validate()? }
		Ok(())
	}
}


// IdentificationSource3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct IdentificationSource3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl IdentificationSource3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// IncomeStatement1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct IncomeStatement1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrFees") )]
	pub clr_fees: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrOprgRvn") )]
	pub othr_oprg_rvn: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OprgExpnss") )]
	pub oprg_expnss: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OprgPrftOrLoss") )]
	pub oprg_prft_or_loss: AmountAndDirection102,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NetIntrstIncm") )]
	pub net_intrst_incm: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrNonOprgRvn") )]
	pub othr_non_oprg_rvn: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NonOprgExpnss") )]
	pub non_oprg_expnss: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PreTaxPrftOrLoss") )]
	pub pre_tax_prft_or_loss: AmountAndDirection102,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstTaxPrftOrLoss") )]
	pub pst_tax_prft_or_loss: AmountAndDirection102,
}

impl IncomeStatement1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.clr_fees.validate()?;
		self.othr_oprg_rvn.validate()?;
		self.oprg_expnss.validate()?;
		self.oprg_prft_or_loss.validate()?;
		self.net_intrst_incm.validate()?;
		self.othr_non_oprg_rvn.validate()?;
		self.non_oprg_expnss.validate()?;
		self.pre_tax_prft_or_loss.validate()?;
		self.pst_tax_prft_or_loss.validate()?;
		Ok(())
	}
}


// IndexIdentification1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct IndexIdentification1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ISIN", skip_serializing_if = "Option::is_none") )]
	pub isin: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm", skip_serializing_if = "Option::is_none") )]
	pub nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Indx", skip_serializing_if = "Option::is_none") )]
	pub indx: Option<String>,
}

impl IndexIdentification1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.isin {
			let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "isin does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 350 {
				return Err(ValidationError::new(1002, "nm exceeds the maximum length of 350".to_string()));
			}
		}
		if let Some(ref val) = self.indx {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "indx is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "indx exceeds the maximum length of 4".to_string()));
			}
		}
		Ok(())
	}
}


// IndustrialProductCommodityConstruction1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct IndustrialProductCommodityConstruction1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType6Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType33Code>,
}

impl IndustrialProductCommodityConstruction1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		Ok(())
	}
}


// IndustrialProductCommodityConstruction2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct IndustrialProductCommodityConstruction2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType6Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType33Code>,
}

impl IndustrialProductCommodityConstruction2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		Ok(())
	}
}


// IndustrialProductCommodityManufacturing1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct IndustrialProductCommodityManufacturing1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType6Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType34Code>,
}

impl IndustrialProductCommodityManufacturing1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		Ok(())
	}
}


// IndustrialProductCommodityManufacturing2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct IndustrialProductCommodityManufacturing2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType6Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType34Code>,
}

impl IndustrialProductCommodityManufacturing2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		Ok(())
	}
}


// InflationIndex1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct InflationIndex1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ISIN", skip_serializing_if = "Option::is_none") )]
	pub isin: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm", skip_serializing_if = "Option::is_none") )]
	pub nm: Option<String>,
}

impl InflationIndex1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.isin {
			let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "isin does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 25 {
				return Err(ValidationError::new(1002, "nm exceeds the maximum length of 25".to_string()));
			}
		}
		Ok(())
	}
}


// InformationType1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct InformationType1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<InformationType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl InformationType1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 140".to_string()));
			}
		}
		Ok(())
	}
}


// InformationType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum InformationType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "INST") )]
	CodeINST,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RELY") )]
	CodeRELY,
}

impl InformationType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// InitialMarginExposure1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct InitialMarginExposure1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: Amount3,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: MarginType2Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CoreInd") )]
	pub core_ind: bool,
}

impl InitialMarginExposure1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.amt.validate()?;
		self.tp.validate()?;
		Ok(())
	}
}


// InitialMarginRequirement1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct InitialMarginRequirement1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "InitlMrgnXpsr") )]
	pub initl_mrgn_xpsr: Vec<InitialMarginExposure1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cdt") )]
	pub cdt: ActiveCurrencyAndAmount,
}

impl InitialMarginRequirement1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		for item in &self.initl_mrgn_xpsr { item.validate()? }
		self.cdt.validate()?;
		Ok(())
	}
}


// InstrumentAndSubClassIdentification2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct InstrumentAndSubClassIdentification2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ISIN") )]
	pub isin: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DerivSubClss", skip_serializing_if = "Option::is_none") )]
	pub deriv_sub_clss: Option<NonEquitySubClass1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FinInstrmClssfctn", skip_serializing_if = "Option::is_none") )]
	pub fin_instrm_clssfctn: Option<NonEquityInstrumentReportingClassification1Code>,
}

impl InstrumentAndSubClassIdentification2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
		if !pattern.is_match(&self.isin) {
			return Err(ValidationError::new(1005, "isin does not match the required pattern".to_string()));
		}
		if let Some(ref val) = self.deriv_sub_clss { val.validate()? }
		if let Some(ref val) = self.fin_instrm_clssfctn { val.validate()? }
		Ok(())
	}
}


// InstrumentIdentification6Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct InstrumentIdentification6Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ISIN", skip_serializing_if = "Option::is_none") )]
	pub isin: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AltrntvInstrmId", skip_serializing_if = "Option::is_none") )]
	pub altrntv_instrm_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnqPdctIdr", skip_serializing_if = "Option::is_none") )]
	pub unq_pdct_idr: Option<UniqueProductIdentifier1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrId", skip_serializing_if = "Option::is_none") )]
	pub othr_id: Option<GenericIdentification184>,
}

impl InstrumentIdentification6Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.isin {
			let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "isin does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.altrntv_instrm_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "altrntv_instrm_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 52 {
				return Err(ValidationError::new(1002, "altrntv_instrm_id exceeds the maximum length of 52".to_string()));
			}
		}
		if let Some(ref val) = self.unq_pdct_idr { val.validate()? }
		if let Some(ref val) = self.othr_id { val.validate()? }
		Ok(())
	}
}


// InstrumentOrSubClassIdentification2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct InstrumentOrSubClassIdentification2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ISINAndSubClss", skip_serializing_if = "Option::is_none") )]
	pub isin_and_sub_clss: Option<InstrumentAndSubClassIdentification2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AsstClssAndSubClss", skip_serializing_if = "Option::is_none") )]
	pub asst_clss_and_sub_clss: Option<AssetClassAndSubClassIdentification2>,
}

impl InstrumentOrSubClassIdentification2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.isin_and_sub_clss { val.validate()? }
		if let Some(ref val) = self.asst_clss_and_sub_clss { val.validate()? }
		Ok(())
	}
}


// InterestComputationMethod1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum InterestComputationMethod1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "A001") )]
	CodeA001,
	#[cfg_attr( feature = "derive_serde", serde(rename = "A002") )]
	CodeA002,
	#[cfg_attr( feature = "derive_serde", serde(rename = "A003") )]
	CodeA003,
	#[cfg_attr( feature = "derive_serde", serde(rename = "A004") )]
	CodeA004,
	#[cfg_attr( feature = "derive_serde", serde(rename = "A005") )]
	CodeA005,
	#[cfg_attr( feature = "derive_serde", serde(rename = "A006") )]
	CodeA006,
	#[cfg_attr( feature = "derive_serde", serde(rename = "A007") )]
	CodeA007,
	#[cfg_attr( feature = "derive_serde", serde(rename = "A008") )]
	CodeA008,
	#[cfg_attr( feature = "derive_serde", serde(rename = "A009") )]
	CodeA009,
	#[cfg_attr( feature = "derive_serde", serde(rename = "A010") )]
	CodeA010,
	#[cfg_attr( feature = "derive_serde", serde(rename = "A011") )]
	CodeA011,
	#[cfg_attr( feature = "derive_serde", serde(rename = "A012") )]
	CodeA012,
	#[cfg_attr( feature = "derive_serde", serde(rename = "A013") )]
	CodeA013,
	#[cfg_attr( feature = "derive_serde", serde(rename = "A014") )]
	CodeA014,
}

impl InterestComputationMethod1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// InterestComputationMethod2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum InterestComputationMethod2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "A001") )]
	CodeA001,
	#[cfg_attr( feature = "derive_serde", serde(rename = "A002") )]
	CodeA002,
	#[cfg_attr( feature = "derive_serde", serde(rename = "A003") )]
	CodeA003,
	#[cfg_attr( feature = "derive_serde", serde(rename = "A004") )]
	CodeA004,
	#[cfg_attr( feature = "derive_serde", serde(rename = "A005") )]
	CodeA005,
	#[cfg_attr( feature = "derive_serde", serde(rename = "A006") )]
	CodeA006,
	#[cfg_attr( feature = "derive_serde", serde(rename = "A007") )]
	CodeA007,
	#[cfg_attr( feature = "derive_serde", serde(rename = "A008") )]
	CodeA008,
	#[cfg_attr( feature = "derive_serde", serde(rename = "A009") )]
	CodeA009,
	#[cfg_attr( feature = "derive_serde", serde(rename = "A010") )]
	CodeA010,
	#[cfg_attr( feature = "derive_serde", serde(rename = "A011") )]
	CodeA011,
	#[cfg_attr( feature = "derive_serde", serde(rename = "A012") )]
	CodeA012,
	#[cfg_attr( feature = "derive_serde", serde(rename = "A013") )]
	CodeA013,
	#[cfg_attr( feature = "derive_serde", serde(rename = "A014") )]
	CodeA014,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NARR") )]
	CodeNARR,
}

impl InterestComputationMethod2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// InterestComputationMethod4Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum InterestComputationMethod4Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "A004") )]
	CodeA004,
	#[cfg_attr( feature = "derive_serde", serde(rename = "A019") )]
	CodeA019,
	#[cfg_attr( feature = "derive_serde", serde(rename = "A017") )]
	CodeA017,
	#[cfg_attr( feature = "derive_serde", serde(rename = "A005") )]
	CodeA005,
	#[cfg_attr( feature = "derive_serde", serde(rename = "A009") )]
	CodeA009,
	#[cfg_attr( feature = "derive_serde", serde(rename = "A014") )]
	CodeA014,
	#[cfg_attr( feature = "derive_serde", serde(rename = "A010") )]
	CodeA010,
	#[cfg_attr( feature = "derive_serde", serde(rename = "A006") )]
	CodeA006,
	#[cfg_attr( feature = "derive_serde", serde(rename = "A008") )]
	CodeA008,
	#[cfg_attr( feature = "derive_serde", serde(rename = "A015") )]
	CodeA015,
	#[cfg_attr( feature = "derive_serde", serde(rename = "A018") )]
	CodeA018,
	#[cfg_attr( feature = "derive_serde", serde(rename = "A011") )]
	CodeA011,
	#[cfg_attr( feature = "derive_serde", serde(rename = "A001") )]
	CodeA001,
	#[cfg_attr( feature = "derive_serde", serde(rename = "A002") )]
	CodeA002,
	#[cfg_attr( feature = "derive_serde", serde(rename = "A003") )]
	CodeA003,
	#[cfg_attr( feature = "derive_serde", serde(rename = "A012") )]
	CodeA012,
	#[cfg_attr( feature = "derive_serde", serde(rename = "A013") )]
	CodeA013,
	#[cfg_attr( feature = "derive_serde", serde(rename = "A007") )]
	CodeA007,
	#[cfg_attr( feature = "derive_serde", serde(rename = "A016") )]
	CodeA016,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NARR") )]
	CodeNARR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "A020") )]
	CodeA020,
}

impl InterestComputationMethod4Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// InterestComputationMethodFormat6Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct InterestComputationMethodFormat6Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<InterestComputationMethod1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl InterestComputationMethodFormat6Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// InterestComputationMethodFormat7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct InterestComputationMethodFormat7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd") )]
	pub cd: InterestComputationMethod4Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nrrtv", skip_serializing_if = "Option::is_none") )]
	pub nrrtv: Option<String>,
}

impl InterestComputationMethodFormat7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.cd.validate()?;
		if let Some(ref val) = self.nrrtv {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nrrtv is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 1000 {
				return Err(ValidationError::new(1002, "nrrtv exceeds the maximum length of 1000".to_string()));
			}
		}
		Ok(())
	}
}


// InterestPaymentDateRange1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct InterestPaymentDateRange1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstSchdlId", skip_serializing_if = "Option::is_none") )]
	pub intrst_schdl_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XpctdDt", skip_serializing_if = "Option::is_none") )]
	pub xpctd_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DueDt", skip_serializing_if = "Option::is_none") )]
	pub due_dt: Option<String>,
}

impl InterestPaymentDateRange1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.intrst_schdl_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "intrst_schdl_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "intrst_schdl_id exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// InterestPaymentSchedule1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct InterestPaymentSchedule1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstSchdlId", skip_serializing_if = "Option::is_none") )]
	pub intrst_schdl_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt", skip_serializing_if = "Option::is_none") )]
	pub amt: Option<ActiveCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XpctdDt", skip_serializing_if = "Option::is_none") )]
	pub xpctd_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DueDt", skip_serializing_if = "Option::is_none") )]
	pub due_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_inf: Option<String>,
}

impl InterestPaymentSchedule1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.intrst_schdl_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "intrst_schdl_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "intrst_schdl_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.amt { val.validate()? }
		if let Some(ref val) = self.addtl_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 1025 {
				return Err(ValidationError::new(1002, "addtl_inf exceeds the maximum length of 1025".to_string()));
			}
		}
		Ok(())
	}
}


// InterestRate27Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct InterestRate27Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Fxd", skip_serializing_if = "Option::is_none") )]
	pub fxd: Option<FixedRate11>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Fltg", skip_serializing_if = "Option::is_none") )]
	pub fltg: Option<FloatingInterestRate22>,
}

impl InterestRate27Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.fxd { val.validate()? }
		if let Some(ref val) = self.fltg { val.validate()? }
		Ok(())
	}
}


// InterestRate2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct InterestRate2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Fxd", skip_serializing_if = "Option::is_none") )]
	pub fxd: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Fltg", skip_serializing_if = "Option::is_none") )]
	pub fltg: Option<FloatingInterestRate4>,
}

impl InterestRate2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.fltg { val.validate()? }
		Ok(())
	}
}


// InterestRate33Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct InterestRate33Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Fxd", skip_serializing_if = "Option::is_none") )]
	pub fxd: Option<FixedRate10>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Fltg", skip_serializing_if = "Option::is_none") )]
	pub fltg: Option<FloatingRate13>,
}

impl InterestRate33Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.fxd { val.validate()? }
		if let Some(ref val) = self.fltg { val.validate()? }
		Ok(())
	}
}


// InterestRate6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct InterestRate6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: AmountAndDirection53,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstRate") )]
	pub intrst_rate: InterestRate27Choice,
}

impl InterestRate6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.amt.validate()?;
		self.intrst_rate.validate()?;
		Ok(())
	}
}


// InterestRate6Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct InterestRate6Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Fxd", skip_serializing_if = "Option::is_none") )]
	pub fxd: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Fltg", skip_serializing_if = "Option::is_none") )]
	pub fltg: Option<FloatingInterestRate6>,
}

impl InterestRate6Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.fltg { val.validate()? }
		Ok(())
	}
}


// InterestRate8Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct InterestRate8Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Fxd", skip_serializing_if = "Option::is_none") )]
	pub fxd: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Fltg", skip_serializing_if = "Option::is_none") )]
	pub fltg: Option<FloatingInterestRate8>,
}

impl InterestRate8Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.fltg { val.validate()? }
		Ok(())
	}
}


// InterestRateContractTerm1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct InterestRateContractTerm1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Unit") )]
	pub unit: RateBasis1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val") )]
	pub val: f64,
}

impl InterestRateContractTerm1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.unit.validate()?;
		Ok(())
	}
}


// InterestRateContractTerm2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct InterestRateContractTerm2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Unit") )]
	pub unit: RateBasis1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val") )]
	pub val: f64,
}

impl InterestRateContractTerm2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.unit.validate()?;
		Ok(())
	}
}


// InterestRateContractTerm4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct InterestRateContractTerm4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Unit", skip_serializing_if = "Option::is_none") )]
	pub unit: Option<Frequency13Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val", skip_serializing_if = "Option::is_none") )]
	pub val: Option<f64>,
}

impl InterestRateContractTerm4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.unit { val.validate()? }
		Ok(())
	}
}


// InterestRateDerivative2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct InterestRateDerivative2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SwpRltd", skip_serializing_if = "Option::is_none") )]
	pub swp_rltd: Option<SwapType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<UnderlyingInterestRateType3Code>,
}

impl InterestRateDerivative2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.swp_rltd { val.validate()? }
		if let Some(ref val) = self.othr { val.validate()? }
		Ok(())
	}
}


// InterestRateDerivative5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct InterestRateDerivative5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "UndrlygTp") )]
	pub undrlyg_tp: InterestRateDerivative2Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UndrlygBd", skip_serializing_if = "Option::is_none") )]
	pub undrlyg_bd: Option<BondDerivative2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SwptnNtnlCcy", skip_serializing_if = "Option::is_none") )]
	pub swptn_ntnl_ccy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UndrlygSwpMtrtyDt", skip_serializing_if = "Option::is_none") )]
	pub undrlyg_swp_mtrty_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InfltnIndx", skip_serializing_if = "Option::is_none") )]
	pub infltn_indx: Option<InflationIndex1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstRateRef") )]
	pub intrst_rate_ref: FloatingInterestRate8,
}

impl InterestRateDerivative5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.undrlyg_tp.validate()?;
		if let Some(ref val) = self.undrlyg_bd { val.validate()? }
		if let Some(ref val) = self.swptn_ntnl_ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "swptn_ntnl_ccy does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.infltn_indx { val.validate()? }
		self.intrst_rate_ref.validate()?;
		Ok(())
	}
}


// InterestRateFrequency3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct InterestRateFrequency3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Term", skip_serializing_if = "Option::is_none") )]
	pub term: Option<InterestRateContractTerm4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl InterestRateFrequency3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.term { val.validate()? }
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 52 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 52".to_string()));
			}
		}
		Ok(())
	}
}


// InterestRateLegs14 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct InterestRateLegs14 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrstLeg", skip_serializing_if = "Option::is_none") )]
	pub frst_leg: Option<InterestRate33Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ScndLeg", skip_serializing_if = "Option::is_none") )]
	pub scnd_leg: Option<InterestRate33Choice>,
}

impl InterestRateLegs14 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.frst_leg { val.validate()? }
		if let Some(ref val) = self.scnd_leg { val.validate()? }
		Ok(())
	}
}


// InterestRateType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum InterestRateType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "FIXE") )]
	CodeFIXE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VARI") )]
	CodeVARI,
}

impl InterestRateType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// InternalPartyRole1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum InternalPartyRole1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "INTC") )]
	CodeINTC,
}

impl InternalPartyRole1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// InternalisationData1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct InternalisationData1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Aggt") )]
	pub aggt: InternalisationData2,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FaildRate") )]
	pub faild_rate: InternalisationDataRate1,
}

impl InternalisationData1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.aggt.validate()?;
		self.faild_rate.validate()?;
		Ok(())
	}
}


// InternalisationData2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct InternalisationData2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sttld") )]
	pub sttld: InternalisationDataVolume1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Faild") )]
	pub faild: InternalisationDataVolume1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ttl") )]
	pub ttl: InternalisationDataVolume1,
}

impl InternalisationData2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.sttld.validate()?;
		self.faild.validate()?;
		self.ttl.validate()?;
		Ok(())
	}
}


// InternalisationDataRate1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct InternalisationDataRate1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "VolPctg") )]
	pub vol_pctg: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val") )]
	pub val: f64,
}

impl InternalisationDataRate1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// InternalisationDataVolume1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct InternalisationDataVolume1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Vol") )]
	pub vol: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val") )]
	pub val: f64,
}

impl InternalisationDataVolume1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.vol < 0.000000 {
			return Err(ValidationError::new(1003, "vol is less than the minimum value of 0.000000".to_string()));
		}
		if self.val < 0.000000 {
			return Err(ValidationError::new(1003, "val is less than the minimum value of 0.000000".to_string()));
		}
		Ok(())
	}
}


// InteroperabilityCCP1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct InteroperabilityCCP1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: GenericIdentification168,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlInitlMrgn") )]
	pub ttl_initl_mrgn: Vec<ActiveCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TrdsClrd", skip_serializing_if = "Option::is_none") )]
	pub trds_clrd: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GrssNtnlAmt") )]
	pub grss_ntnl_amt: Vec<ActiveCurrencyAnd24Amount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AsstHldg") )]
	pub asst_hldg: Vec<AssetHolding3>,
}

impl InteroperabilityCCP1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.id.validate()?;
		for item in &self.ttl_initl_mrgn { item.validate()? }
		if let Some(ref val) = self.trds_clrd {
			if *val < 0.000000 {
				return Err(ValidationError::new(1003, "trds_clrd is less than the minimum value of 0.000000".to_string()));
			}
		}
		for item in &self.grss_ntnl_amt { item.validate()? }
		for item in &self.asst_hldg { item.validate()? }
		Ok(())
	}
}


// IntraDayMarginCall1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct IntraDayMarginCall1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MrgnAcctId") )]
	pub mrgn_acct_id: GenericIdentification165,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntraDayCall") )]
	pub intra_day_call: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TmStmp") )]
	pub tm_stmp: String,
}

impl IntraDayMarginCall1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.mrgn_acct_id.validate()?;
		self.intra_day_call.validate()?;
		Ok(())
	}
}


// IntraDayRequirement1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct IntraDayRequirement1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntraDayMrgnCall") )]
	pub intra_day_mrgn_call: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PeakInitlMrgnLblty") )]
	pub peak_initl_mrgn_lblty: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PeakVartnMrgnLblty") )]
	pub peak_vartn_mrgn_lblty: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AggtPeakLblty") )]
	pub aggt_peak_lblty: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MrgnAcctId") )]
	pub mrgn_acct_id: GenericIdentification165,
}

impl IntraDayRequirement1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.intra_day_mrgn_call.validate()?;
		self.peak_initl_mrgn_lblty.validate()?;
		self.peak_vartn_mrgn_lblty.validate()?;
		self.aggt_peak_lblty.validate()?;
		self.mrgn_acct_id.validate()?;
		Ok(())
	}
}


// InvestigatedParties1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct InvestigatedParties1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<InvestigatedParties1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl InvestigatedParties1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// InvestigatedParties1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum InvestigatedParties1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ALLP") )]
	CodeALLP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OWNE") )]
	CodeOWNE,
}

impl InvestigatedParties1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// InvestigationResult1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct InvestigationResult1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rslt", skip_serializing_if = "Option::is_none") )]
	pub rslt: Option<SupplementaryDataEnvelope1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InvstgtnSts", skip_serializing_if = "Option::is_none") )]
	pub invstgtn_sts: Option<InvestigationStatus1Code>,
}

impl InvestigationResult1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.rslt { val.validate()? }
		if let Some(ref val) = self.invstgtn_sts { val.validate()? }
		Ok(())
	}
}


// InvestigationStatus1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum InvestigationStatus1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "FOUN") )]
	CodeFOUN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NFOU") )]
	CodeNFOU,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NOAP") )]
	CodeNOAP,
}

impl InvestigationStatus1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// Investment1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Investment1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "UscrdCshDpst", skip_serializing_if = "Option::is_none") )]
	pub uscrd_csh_dpst: Option<Deposit1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CntrlBkDpst", skip_serializing_if = "Option::is_none") )]
	pub cntrl_bk_dpst: Option<Deposit1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RpAgrmt", skip_serializing_if = "Option::is_none") )]
	pub rp_agrmt: Option<RepurchaseAgreement2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrInvstmts", skip_serializing_if = "Option::is_none") )]
	pub othr_invstmts: Option<OtherInvestment1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OutrghtInvstmt", skip_serializing_if = "Option::is_none") )]
	pub outrght_invstmt: Option<SecurityIdentificationAndAmount1>,
}

impl Investment1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.uscrd_csh_dpst { val.validate()? }
		if let Some(ref val) = self.cntrl_bk_dpst { val.validate()? }
		if let Some(ref val) = self.rp_agrmt { val.validate()? }
		if let Some(ref val) = self.othr_invstmts { val.validate()? }
		if let Some(ref val) = self.outrght_invstmt { val.validate()? }
		Ok(())
	}
}


// InvestmentParty1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct InvestmentParty1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prsn", skip_serializing_if = "Option::is_none") )]
	pub prsn: Option<PersonIdentification12>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Algo", skip_serializing_if = "Option::is_none") )]
	pub algo: Option<String>,
}

impl InvestmentParty1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.prsn { val.validate()? }
		if let Some(ref val) = self.algo {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "algo is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 50 {
				return Err(ValidationError::new(1002, "algo exceeds the maximum length of 50".to_string()));
			}
		}
		Ok(())
	}
}


// InvoiceTaxReportTransactionStatus1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct InvoiceTaxReportTransactionStatus1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TaxRptId") )]
	pub tax_rpt_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sts") )]
	pub sts: TaxReportingStatus2Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VldtnRule", skip_serializing_if = "Option::is_none") )]
	pub vldtn_rule: Option<Vec<GenericValidationRuleIdentification1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl InvoiceTaxReportTransactionStatus1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.tax_rpt_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "tax_rpt_id is shorter than the minimum length of 1".to_string()));
		}
		if self.tax_rpt_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "tax_rpt_id exceeds the maximum length of 35".to_string()));
		}
		self.sts.validate()?;
		if let Some(ref vec) = self.vldtn_rule { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// InvoiceTaxStatusReportHeader1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct InvoiceTaxStatusReportHeader1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TaxAuthrty", skip_serializing_if = "Option::is_none") )]
	pub tax_authrty: Option<TaxOrganisationIdentification1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgId") )]
	pub msg_id: MessageIdentification1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlMsgId") )]
	pub orgnl_msg_id: MessageIdentification1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptSts") )]
	pub rpt_sts: TaxReportingStatus1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VldtnRule", skip_serializing_if = "Option::is_none") )]
	pub vldtn_rule: Option<Vec<GenericValidationRuleIdentification1>>,
}

impl InvoiceTaxStatusReportHeader1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tax_authrty { val.validate()? }
		self.msg_id.validate()?;
		self.orgnl_msg_id.validate()?;
		self.rpt_sts.validate()?;
		if let Some(ref vec) = self.vldtn_rule { for item in vec { item.validate()? } }
		Ok(())
	}
}


// IssuerCSDIdentification1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct IssuerCSDIdentification1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "LEI", skip_serializing_if = "Option::is_none") )]
	pub lei: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrstTwoCharsInstrmId") )]
	pub frst_two_chars_instrm_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ctry", skip_serializing_if = "Option::is_none") )]
	pub ctry: Option<String>,
}

impl IssuerCSDIdentification1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.lei {
			let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "lei does not match the required pattern".to_string()));
			}
		}
		let pattern = Regex::new("[A-Z]{2}").unwrap();
		if !pattern.is_match(&self.frst_two_chars_instrm_id) {
			return Err(ValidationError::new(1005, "frst_two_chars_instrm_id does not match the required pattern".to_string()));
		}
		if let Some(ref val) = self.ctry {
			let pattern = Regex::new("[A-Z]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ctry does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// IssuerCSDReport1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct IssuerCSDReport1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: IssuerCSDIdentification1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OvrllTtl") )]
	pub ovrll_ttl: InternalisationData1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FinInstrm") )]
	pub fin_instrm: SettlementInternaliserFinancialInstrument1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxTp") )]
	pub tx_tp: SettlementInternaliserTransactionType1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClntTp") )]
	pub clnt_tp: SettlementInternaliserClientType1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlCshTrf") )]
	pub ttl_csh_trf: InternalisationData1,
}

impl IssuerCSDReport1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.id.validate()?;
		self.ovrll_ttl.validate()?;
		self.fin_instrm.validate()?;
		self.tx_tp.validate()?;
		self.clnt_tp.validate()?;
		self.ttl_csh_trf.validate()?;
		Ok(())
	}
}


// IssuerJurisdiction1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct IssuerJurisdiction1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtryCd", skip_serializing_if = "Option::is_none") )]
	pub ctry_cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<String>,
}

impl IssuerJurisdiction1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ctry_cd {
			let pattern = Regex::new("[A-Z]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ctry_cd does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.othr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "othr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "othr exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// LegalMandate1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct LegalMandate1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prgrph") )]
	pub prgrph: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dsclmr", skip_serializing_if = "Option::is_none") )]
	pub dsclmr: Option<String>,
}

impl LegalMandate1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.prgrph.chars().count() < 1 {
			return Err(ValidationError::new(1001, "prgrph is shorter than the minimum length of 1".to_string()));
		}
		if self.prgrph.chars().count() > 35 {
			return Err(ValidationError::new(1002, "prgrph exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.dsclmr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "dsclmr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 350 {
				return Err(ValidationError::new(1002, "dsclmr exceeds the maximum length of 350".to_string()));
			}
		}
		Ok(())
	}
}


// LegalOrganisation1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct LegalOrganisation1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm", skip_serializing_if = "Option::is_none") )]
	pub nm: Option<String>,
}

impl LegalOrganisation1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "nm exceeds the maximum length of 140".to_string()));
			}
		}
		Ok(())
	}
}


// LegalOrganisation2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct LegalOrganisation2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm", skip_serializing_if = "Option::is_none") )]
	pub nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EstblishmtDt", skip_serializing_if = "Option::is_none") )]
	pub estblishmt_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RegnDt", skip_serializing_if = "Option::is_none") )]
	pub regn_dt: Option<String>,
}

impl LegalOrganisation2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "nm exceeds the maximum length of 140".to_string()));
			}
		}
		Ok(())
	}
}


// LegalPersonIdentification1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct LegalPersonIdentification1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: OrganisationIdentification15Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ctry", skip_serializing_if = "Option::is_none") )]
	pub ctry: Option<String>,
}

impl LegalPersonIdentification1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.id.validate()?;
		if let Some(ref val) = self.ctry {
			let pattern = Regex::new("[A-Z]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ctry does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// LiquidResourceInformation1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct LiquidResourceInformation1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CntrPtyId", skip_serializing_if = "Option::is_none") )]
	pub cntr_pty_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LqdRsrcVal") )]
	pub lqd_rsrc_val: AmountAndDirection102,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MktVal", skip_serializing_if = "Option::is_none") )]
	pub mkt_val: Option<AmountAndDirection102>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Scrd") )]
	pub scrd: bool,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AsstNcmbrd") )]
	pub asst_ncmbrd: bool,
	#[cfg_attr( feature = "derive_serde", serde(rename = "QlfygRsrc") )]
	pub qlfyg_rsrc: bool,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AgcyArrgmnts") )]
	pub agcy_arrgmnts: bool,
}

impl LiquidResourceInformation1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cntr_pty_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cntr_pty_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "cntr_pty_id exceeds the maximum length of 35".to_string()));
			}
		}
		self.lqd_rsrc_val.validate()?;
		if let Some(ref val) = self.mkt_val { val.validate()? }
		Ok(())
	}
}


// LiquidResources1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct LiquidResources1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshDue") )]
	pub csh_due: Vec<LiquidResourceInformation1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FcltiesCmmtdLinesOfCdt", skip_serializing_if = "Option::is_none") )]
	pub fclties_cmmtd_lines_of_cdt: Option<Vec<LiquidResourceInformation1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FcltiesCmmtdRpAgrmts", skip_serializing_if = "Option::is_none") )]
	pub fclties_cmmtd_rp_agrmts: Option<Vec<LiquidResourceInformation1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FcltiesCmmtdFxSwps", skip_serializing_if = "Option::is_none") )]
	pub fclties_cmmtd_fx_swps: Option<Vec<LiquidResourceInformation1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FcltiesOthrCmmtd", skip_serializing_if = "Option::is_none") )]
	pub fclties_othr_cmmtd: Option<Vec<LiquidResourceInformation1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FcltiesUcmmtd", skip_serializing_if = "Option::is_none") )]
	pub fclties_ucmmtd: Option<Vec<LiquidResourceInformation1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FinInstrmsCCP", skip_serializing_if = "Option::is_none") )]
	pub fin_instrms_ccp: Option<Vec<LiquidResourceInformation1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FinInstrmsTrsrInvstmts", skip_serializing_if = "Option::is_none") )]
	pub fin_instrms_trsr_invstmts: Option<Vec<LiquidResourceInformation1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FinInstrmsDfltrsSttlmColl", skip_serializing_if = "Option::is_none") )]
	pub fin_instrms_dfltrs_sttlm_coll: Option<Vec<LiquidResourceInformation1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FinInstrmsDfltrsNonCshColl", skip_serializing_if = "Option::is_none") )]
	pub fin_instrms_dfltrs_non_csh_coll: Option<Vec<LiquidResourceInformation1>>,
}

impl LiquidResources1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		for item in &self.csh_due { item.validate()? }
		if let Some(ref vec) = self.fclties_cmmtd_lines_of_cdt { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.fclties_cmmtd_rp_agrmts { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.fclties_cmmtd_fx_swps { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.fclties_othr_cmmtd { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.fclties_ucmmtd { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.fin_instrms_ccp { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.fin_instrms_trsr_invstmts { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.fin_instrms_dfltrs_sttlm_coll { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.fin_instrms_dfltrs_non_csh_coll { for item in vec { item.validate()? } }
		Ok(())
	}
}


// LiquidityRequiredAndAvailable1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct LiquidityRequiredAndAvailable1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "LqdRsrcs") )]
	pub lqd_rsrcs: LiquidResources1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LqdtyHrzn") )]
	pub lqdty_hrzn: SettlementDate6Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StrssLqdRsrcRqrmnt") )]
	pub strss_lqd_rsrc_rqrmnt: StressLiquidResourceRequirement1,
}

impl LiquidityRequiredAndAvailable1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.lqd_rsrcs.validate()?;
		self.lqdty_hrzn.validate()?;
		self.strss_lqd_rsrc_rqrmnt.validate()?;
		Ok(())
	}
}


// LiquidityStressScenarioDefinition1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct LiquidityStressScenarioDefinition1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: GenericIdentification168,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Desc") )]
	pub desc: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StrssCcy") )]
	pub strss_ccy: String,
}

impl LiquidityStressScenarioDefinition1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.id.validate()?;
		if self.desc.chars().count() < 1 {
			return Err(ValidationError::new(1001, "desc is shorter than the minimum length of 1".to_string()));
		}
		if self.desc.chars().count() > 2000 {
			return Err(ValidationError::new(1002, "desc exceeds the maximum length of 2000".to_string()));
		}
		if let Some(ref val) = self.tp {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tp is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "tp exceeds the maximum length of 35".to_string()));
			}
		}
		let pattern = Regex::new("[A-Z]{3,3}").unwrap();
		if !pattern.is_match(&self.strss_ccy) {
			return Err(ValidationError::new(1005, "strss_ccy does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// LiquidityStressTestResult1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct LiquidityStressTestResult1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ScnroDfltrs") )]
	pub scnro_dfltrs: CoverTwoDefaulters1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LqdtyReqrdAndAvlbl") )]
	pub lqdty_reqrd_and_avlbl: Vec<LiquidityRequiredAndAvailable1>,
}

impl LiquidityStressTestResult1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 256 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 256".to_string()));
		}
		self.scnro_dfltrs.validate()?;
		for item in &self.lqdty_reqrd_and_avlbl { item.validate()? }
		Ok(())
	}
}


// LoanContract4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct LoanContract4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrctDocId") )]
	pub ctrct_doc_id: DocumentIdentification22,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LnTpId", skip_serializing_if = "Option::is_none") )]
	pub ln_tp_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Buyr") )]
	pub buyr: Vec<TradeParty6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sellr") )]
	pub sellr: Vec<TradeParty6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt", skip_serializing_if = "Option::is_none") )]
	pub amt: Option<ActiveCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MtrtyDt", skip_serializing_if = "Option::is_none") )]
	pub mtrty_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrlngtnFlg", skip_serializing_if = "Option::is_none") )]
	pub prlngtn_flg: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StartDt", skip_serializing_if = "Option::is_none") )]
	pub start_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttlmCcy", skip_serializing_if = "Option::is_none") )]
	pub sttlm_ccy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SpclConds", skip_serializing_if = "Option::is_none") )]
	pub spcl_conds: Option<SpecialCondition1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DrtnCd", skip_serializing_if = "Option::is_none") )]
	pub drtn_cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstRate", skip_serializing_if = "Option::is_none") )]
	pub intrst_rate: Option<InterestRate2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Trch", skip_serializing_if = "Option::is_none") )]
	pub trch: Option<Vec<LoanContractTranche1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtSchdl", skip_serializing_if = "Option::is_none") )]
	pub pmt_schdl: Option<Vec<PaymentSchedule1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstSchdl", skip_serializing_if = "Option::is_none") )]
	pub intrst_schdl: Option<Vec<InterestPaymentSchedule1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntraCpnyLn") )]
	pub intra_cpny_ln: bool,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Coll", skip_serializing_if = "Option::is_none") )]
	pub coll: Option<ContractCollateral1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SndctdLn", skip_serializing_if = "Option::is_none") )]
	pub sndctd_ln: Option<Vec<SyndicatedLoan3>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Attchmnt", skip_serializing_if = "Option::is_none") )]
	pub attchmnt: Option<Vec<DocumentGeneralInformation5>>,
}

impl LoanContract4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.ctrct_doc_id.validate()?;
		if let Some(ref val) = self.ln_tp_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "ln_tp_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "ln_tp_id exceeds the maximum length of 35".to_string()));
			}
		}
		for item in &self.buyr { item.validate()? }
		for item in &self.sellr { item.validate()? }
		if let Some(ref val) = self.amt { val.validate()? }
		if let Some(ref val) = self.sttlm_ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "sttlm_ccy does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.spcl_conds { val.validate()? }
		if let Some(ref val) = self.drtn_cd {
			let pattern = Regex::new("[0-9]").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "drtn_cd does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.intrst_rate { val.validate()? }
		if let Some(ref vec) = self.trch { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.pmt_schdl { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.intrst_schdl { for item in vec { item.validate()? } }
		if let Some(ref val) = self.coll { val.validate()? }
		if let Some(ref vec) = self.sndctd_ln { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.attchmnt { for item in vec { item.validate()? } }
		Ok(())
	}
}


// LoanContractTranche1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct LoanContractTranche1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TrchNb") )]
	pub trch_nb: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XpctdDt") )]
	pub xpctd_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DueDt", skip_serializing_if = "Option::is_none") )]
	pub due_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DrtnCd", skip_serializing_if = "Option::is_none") )]
	pub drtn_cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LastTrchInd", skip_serializing_if = "Option::is_none") )]
	pub last_trch_ind: Option<bool>,
}

impl LoanContractTranche1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.amt.validate()?;
		if let Some(ref val) = self.drtn_cd {
			let pattern = Regex::new("[0-9]").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "drtn_cd does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// LoanData113 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct LoanData113 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnqTradIdr") )]
	pub unq_trad_idr: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EvtDt") )]
	pub evt_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MktVal") )]
	pub mkt_val: AmountAndDirection53,
}

impl LoanData113 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.unq_trad_idr.chars().count() < 1 {
			return Err(ValidationError::new(1001, "unq_trad_idr is shorter than the minimum length of 1".to_string()));
		}
		if self.unq_trad_idr.chars().count() > 52 {
			return Err(ValidationError::new(1002, "unq_trad_idr exceeds the maximum length of 52".to_string()));
		}
		self.mkt_val.validate()?;
		Ok(())
	}
}


// LoanData120 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct LoanData120 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "EvtDt") )]
	pub evt_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnqTradIdr", skip_serializing_if = "Option::is_none") )]
	pub unq_trad_idr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MstrAgrmt", skip_serializing_if = "Option::is_none") )]
	pub mstr_agrmt: Option<MasterAgreement7>,
}

impl LoanData120 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.unq_trad_idr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "unq_trad_idr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 52 {
				return Err(ValidationError::new(1002, "unq_trad_idr exceeds the maximum length of 52".to_string()));
			}
		}
		if let Some(ref val) = self.mstr_agrmt { val.validate()? }
		Ok(())
	}
}


// LoanData134 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct LoanData134 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrctTp", skip_serializing_if = "Option::is_none") )]
	pub ctrct_tp: Option<ExposureType10Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Clrd", skip_serializing_if = "Option::is_none") )]
	pub clrd: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrtflCd", skip_serializing_if = "Option::is_none") )]
	pub prtfl_cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradgVn", skip_serializing_if = "Option::is_none") )]
	pub tradg_vn: Option<TradingVenueType1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MstrAgrmtTp", skip_serializing_if = "Option::is_none") )]
	pub mstr_agrmt_tp: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MtrtyDt", skip_serializing_if = "Option::is_none") )]
	pub mtrty_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GnlColl", skip_serializing_if = "Option::is_none") )]
	pub gnl_coll: Option<SpecialCollateral1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Term", skip_serializing_if = "Option::is_none") )]
	pub term: Option<ContractTerm6Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rates", skip_serializing_if = "Option::is_none") )]
	pub rates: Option<Rates1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrncplAmtCcy", skip_serializing_if = "Option::is_none") )]
	pub prncpl_amt_ccy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PricCcy", skip_serializing_if = "Option::is_none") )]
	pub pric_ccy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Scty", skip_serializing_if = "Option::is_none") )]
	pub scty: Option<Security49>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OutsdngMrgnLnCcy", skip_serializing_if = "Option::is_none") )]
	pub outsdng_mrgn_ln_ccy: Option<String>,
}

impl LoanData134 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ctrct_tp { val.validate()? }
		if let Some(ref val) = self.prtfl_cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtfl_cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 52 {
				return Err(ValidationError::new(1002, "prtfl_cd exceeds the maximum length of 52".to_string()));
			}
		}
		if let Some(ref val) = self.tradg_vn { val.validate()? }
		if let Some(ref val) = self.mstr_agrmt_tp {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "mstr_agrmt_tp is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "mstr_agrmt_tp exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.gnl_coll { val.validate()? }
		if let Some(ref val) = self.term { val.validate()? }
		if let Some(ref val) = self.rates { val.validate()? }
		if let Some(ref val) = self.prncpl_amt_ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "prncpl_amt_ccy does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.pric_ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "pric_ccy does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.scty { val.validate()? }
		if let Some(ref val) = self.outsdng_mrgn_ln_ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "outsdng_mrgn_ln_ccy does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// LoanData135 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct LoanData135 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnqTradIdr") )]
	pub unq_trad_idr: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EvtDt") )]
	pub evt_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ExctnDtTm") )]
	pub exctn_dt_tm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrSts", skip_serializing_if = "Option::is_none") )]
	pub clr_sts: Option<Cleared16Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradgVn", skip_serializing_if = "Option::is_none") )]
	pub tradg_vn: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MstrAgrmt", skip_serializing_if = "Option::is_none") )]
	pub mstr_agrmt: Option<MasterAgreement7>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ValDt", skip_serializing_if = "Option::is_none") )]
	pub val_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MinNtcePrd", skip_serializing_if = "Option::is_none") )]
	pub min_ntce_prd: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EarlstCallBckDt", skip_serializing_if = "Option::is_none") )]
	pub earlst_call_bck_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GnlColl", skip_serializing_if = "Option::is_none") )]
	pub gnl_coll: Option<SpecialCollateral1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DlvryByVal", skip_serializing_if = "Option::is_none") )]
	pub dlvry_by_val: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollDlvryMtd", skip_serializing_if = "Option::is_none") )]
	pub coll_dlvry_mtd: Option<CollateralDeliveryMethod1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Term", skip_serializing_if = "Option::is_none") )]
	pub term: Option<Vec<ContractTerm7Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstRate", skip_serializing_if = "Option::is_none") )]
	pub intrst_rate: Option<InterestRate27Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrncplAmt", skip_serializing_if = "Option::is_none") )]
	pub prncpl_amt: Option<PrincipalAmount3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TermntnDt", skip_serializing_if = "Option::is_none") )]
	pub termntn_dt: Option<String>,
}

impl LoanData135 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.unq_trad_idr.chars().count() < 1 {
			return Err(ValidationError::new(1001, "unq_trad_idr is shorter than the minimum length of 1".to_string()));
		}
		if self.unq_trad_idr.chars().count() > 52 {
			return Err(ValidationError::new(1002, "unq_trad_idr exceeds the maximum length of 52".to_string()));
		}
		if let Some(ref val) = self.clr_sts { val.validate()? }
		if let Some(ref val) = self.tradg_vn {
			let pattern = Regex::new("[A-Z0-9]{4,4}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "tradg_vn does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.mstr_agrmt { val.validate()? }
		if let Some(ref val) = self.min_ntce_prd {
			if *val < 0.000000 {
				return Err(ValidationError::new(1003, "min_ntce_prd is less than the minimum value of 0.000000".to_string()));
			}
		}
		if let Some(ref val) = self.gnl_coll { val.validate()? }
		if let Some(ref val) = self.coll_dlvry_mtd { val.validate()? }
		if let Some(ref vec) = self.term { for item in vec { item.validate()? } }
		if let Some(ref val) = self.intrst_rate { val.validate()? }
		if let Some(ref val) = self.prncpl_amt { val.validate()? }
		Ok(())
	}
}


// LoanData136 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct LoanData136 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnqTradIdr") )]
	pub unq_trad_idr: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EvtDt") )]
	pub evt_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ExctnDtTm") )]
	pub exctn_dt_tm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrSts", skip_serializing_if = "Option::is_none") )]
	pub clr_sts: Option<Cleared16Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradgVn", skip_serializing_if = "Option::is_none") )]
	pub tradg_vn: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MstrAgrmt", skip_serializing_if = "Option::is_none") )]
	pub mstr_agrmt: Option<MasterAgreement7>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ValDt", skip_serializing_if = "Option::is_none") )]
	pub val_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MtrtyDt", skip_serializing_if = "Option::is_none") )]
	pub mtrty_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GnlColl", skip_serializing_if = "Option::is_none") )]
	pub gnl_coll: Option<SpecialCollateral1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrncplAmt", skip_serializing_if = "Option::is_none") )]
	pub prncpl_amt: Option<PrincipalAmount3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnitPric", skip_serializing_if = "Option::is_none") )]
	pub unit_pric: Option<SecuritiesTransactionPrice19Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TermntnDt", skip_serializing_if = "Option::is_none") )]
	pub termntn_dt: Option<String>,
}

impl LoanData136 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.unq_trad_idr.chars().count() < 1 {
			return Err(ValidationError::new(1001, "unq_trad_idr is shorter than the minimum length of 1".to_string()));
		}
		if self.unq_trad_idr.chars().count() > 52 {
			return Err(ValidationError::new(1002, "unq_trad_idr exceeds the maximum length of 52".to_string()));
		}
		if let Some(ref val) = self.clr_sts { val.validate()? }
		if let Some(ref val) = self.tradg_vn {
			let pattern = Regex::new("[A-Z0-9]{4,4}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "tradg_vn does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.mstr_agrmt { val.validate()? }
		if let Some(ref val) = self.gnl_coll { val.validate()? }
		if let Some(ref val) = self.prncpl_amt { val.validate()? }
		if let Some(ref val) = self.unit_pric { val.validate()? }
		Ok(())
	}
}


// LoanData137 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct LoanData137 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnqTradIdr") )]
	pub unq_trad_idr: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EvtDt") )]
	pub evt_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ExctnDtTm") )]
	pub exctn_dt_tm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrSts", skip_serializing_if = "Option::is_none") )]
	pub clr_sts: Option<Cleared16Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradgVn", skip_serializing_if = "Option::is_none") )]
	pub tradg_vn: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MstrAgrmt", skip_serializing_if = "Option::is_none") )]
	pub mstr_agrmt: Option<MasterAgreement7>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ValDt", skip_serializing_if = "Option::is_none") )]
	pub val_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GnlColl", skip_serializing_if = "Option::is_none") )]
	pub gnl_coll: Option<SpecialCollateral1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DlvryByVal", skip_serializing_if = "Option::is_none") )]
	pub dlvry_by_val: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollDlvryMtd", skip_serializing_if = "Option::is_none") )]
	pub coll_dlvry_mtd: Option<CollateralDeliveryMethod1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Term", skip_serializing_if = "Option::is_none") )]
	pub term: Option<Vec<ContractTerm7Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AsstTp", skip_serializing_if = "Option::is_none") )]
	pub asst_tp: Option<SecurityCommodity9>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LnVal", skip_serializing_if = "Option::is_none") )]
	pub ln_val: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RbtRate", skip_serializing_if = "Option::is_none") )]
	pub rbt_rate: Option<InterestRate27Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LndgFee", skip_serializing_if = "Option::is_none") )]
	pub lndg_fee: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TermntnDt", skip_serializing_if = "Option::is_none") )]
	pub termntn_dt: Option<String>,
}

impl LoanData137 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.unq_trad_idr.chars().count() < 1 {
			return Err(ValidationError::new(1001, "unq_trad_idr is shorter than the minimum length of 1".to_string()));
		}
		if self.unq_trad_idr.chars().count() > 52 {
			return Err(ValidationError::new(1002, "unq_trad_idr exceeds the maximum length of 52".to_string()));
		}
		if let Some(ref val) = self.clr_sts { val.validate()? }
		if let Some(ref val) = self.tradg_vn {
			let pattern = Regex::new("[A-Z0-9]{4,4}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "tradg_vn does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.mstr_agrmt { val.validate()? }
		if let Some(ref val) = self.gnl_coll { val.validate()? }
		if let Some(ref val) = self.coll_dlvry_mtd { val.validate()? }
		if let Some(ref vec) = self.term { for item in vec { item.validate()? } }
		if let Some(ref val) = self.asst_tp { val.validate()? }
		if let Some(ref val) = self.ln_val { val.validate()? }
		if let Some(ref val) = self.rbt_rate { val.validate()? }
		Ok(())
	}
}


// LoanData138 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct LoanData138 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnqTradIdr") )]
	pub unq_trad_idr: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EvtDt") )]
	pub evt_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ExctnDtTm") )]
	pub exctn_dt_tm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradgVn", skip_serializing_if = "Option::is_none") )]
	pub tradg_vn: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollDlvryMtd", skip_serializing_if = "Option::is_none") )]
	pub coll_dlvry_mtd: Option<CollateralDeliveryMethod1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OutsdngMrgnLnAmt", skip_serializing_if = "Option::is_none") )]
	pub outsdng_mrgn_ln_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ShrtMktValAmt", skip_serializing_if = "Option::is_none") )]
	pub shrt_mkt_val_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MrgnLnAttr", skip_serializing_if = "Option::is_none") )]
	pub mrgn_ln_attr: Option<Vec<InterestRate6>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TermntnDt", skip_serializing_if = "Option::is_none") )]
	pub termntn_dt: Option<String>,
}

impl LoanData138 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.unq_trad_idr.chars().count() < 1 {
			return Err(ValidationError::new(1001, "unq_trad_idr is shorter than the minimum length of 1".to_string()));
		}
		if self.unq_trad_idr.chars().count() > 52 {
			return Err(ValidationError::new(1002, "unq_trad_idr exceeds the maximum length of 52".to_string()));
		}
		if let Some(ref val) = self.tradg_vn {
			let pattern = Regex::new("[A-Z0-9]{4,4}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "tradg_vn does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.coll_dlvry_mtd { val.validate()? }
		if let Some(ref val) = self.outsdng_mrgn_ln_amt { val.validate()? }
		if let Some(ref val) = self.shrt_mkt_val_amt { val.validate()? }
		if let Some(ref vec) = self.mrgn_ln_attr { for item in vec { item.validate()? } }
		Ok(())
	}
}


// LoanData139 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct LoanData139 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnqTradIdr", skip_serializing_if = "Option::is_none") )]
	pub unq_trad_idr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EvtDt", skip_serializing_if = "Option::is_none") )]
	pub evt_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ExctnDtTm", skip_serializing_if = "Option::is_none") )]
	pub exctn_dt_tm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrSts", skip_serializing_if = "Option::is_none") )]
	pub clr_sts: Option<Cleared16Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradgVn", skip_serializing_if = "Option::is_none") )]
	pub tradg_vn: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MstrAgrmt", skip_serializing_if = "Option::is_none") )]
	pub mstr_agrmt: Option<MasterAgreement7>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ValDt", skip_serializing_if = "Option::is_none") )]
	pub val_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MinNtcePrd", skip_serializing_if = "Option::is_none") )]
	pub min_ntce_prd: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EarlstCallBckDt", skip_serializing_if = "Option::is_none") )]
	pub earlst_call_bck_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GnlColl", skip_serializing_if = "Option::is_none") )]
	pub gnl_coll: Option<SpecialCollateral1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DlvryByVal", skip_serializing_if = "Option::is_none") )]
	pub dlvry_by_val: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollDlvryMtd", skip_serializing_if = "Option::is_none") )]
	pub coll_dlvry_mtd: Option<CollateralDeliveryMethod1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Term", skip_serializing_if = "Option::is_none") )]
	pub term: Option<Vec<ContractTerm7Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstRate", skip_serializing_if = "Option::is_none") )]
	pub intrst_rate: Option<InterestRate27Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrncplAmt", skip_serializing_if = "Option::is_none") )]
	pub prncpl_amt: Option<PrincipalAmount3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TermntnDt", skip_serializing_if = "Option::is_none") )]
	pub termntn_dt: Option<String>,
}

impl LoanData139 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.unq_trad_idr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "unq_trad_idr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 52 {
				return Err(ValidationError::new(1002, "unq_trad_idr exceeds the maximum length of 52".to_string()));
			}
		}
		if let Some(ref val) = self.clr_sts { val.validate()? }
		if let Some(ref val) = self.tradg_vn {
			let pattern = Regex::new("[A-Z0-9]{4,4}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "tradg_vn does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.mstr_agrmt { val.validate()? }
		if let Some(ref val) = self.min_ntce_prd {
			if *val < 0.000000 {
				return Err(ValidationError::new(1003, "min_ntce_prd is less than the minimum value of 0.000000".to_string()));
			}
		}
		if let Some(ref val) = self.gnl_coll { val.validate()? }
		if let Some(ref val) = self.coll_dlvry_mtd { val.validate()? }
		if let Some(ref vec) = self.term { for item in vec { item.validate()? } }
		if let Some(ref val) = self.intrst_rate { val.validate()? }
		if let Some(ref val) = self.prncpl_amt { val.validate()? }
		Ok(())
	}
}


// LoanData140 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct LoanData140 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnqTradIdr", skip_serializing_if = "Option::is_none") )]
	pub unq_trad_idr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EvtDt") )]
	pub evt_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ExctnDtTm", skip_serializing_if = "Option::is_none") )]
	pub exctn_dt_tm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrSts", skip_serializing_if = "Option::is_none") )]
	pub clr_sts: Option<Cleared16Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradgVn", skip_serializing_if = "Option::is_none") )]
	pub tradg_vn: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MstrAgrmt", skip_serializing_if = "Option::is_none") )]
	pub mstr_agrmt: Option<MasterAgreement7>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ValDt", skip_serializing_if = "Option::is_none") )]
	pub val_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MtrtyDt", skip_serializing_if = "Option::is_none") )]
	pub mtrty_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GnlColl", skip_serializing_if = "Option::is_none") )]
	pub gnl_coll: Option<SpecialCollateral1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrncplAmt", skip_serializing_if = "Option::is_none") )]
	pub prncpl_amt: Option<PrincipalAmount3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnitPric", skip_serializing_if = "Option::is_none") )]
	pub unit_pric: Option<SecuritiesTransactionPrice19Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TermntnDt", skip_serializing_if = "Option::is_none") )]
	pub termntn_dt: Option<String>,
}

impl LoanData140 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.unq_trad_idr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "unq_trad_idr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 52 {
				return Err(ValidationError::new(1002, "unq_trad_idr exceeds the maximum length of 52".to_string()));
			}
		}
		if let Some(ref val) = self.clr_sts { val.validate()? }
		if let Some(ref val) = self.tradg_vn {
			let pattern = Regex::new("[A-Z0-9]{4,4}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "tradg_vn does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.mstr_agrmt { val.validate()? }
		if let Some(ref val) = self.gnl_coll { val.validate()? }
		if let Some(ref val) = self.prncpl_amt { val.validate()? }
		if let Some(ref val) = self.unit_pric { val.validate()? }
		Ok(())
	}
}


// LoanData141 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct LoanData141 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnqTradIdr", skip_serializing_if = "Option::is_none") )]
	pub unq_trad_idr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EvtDt") )]
	pub evt_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ExctnDtTm", skip_serializing_if = "Option::is_none") )]
	pub exctn_dt_tm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrSts", skip_serializing_if = "Option::is_none") )]
	pub clr_sts: Option<Cleared16Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradgVn", skip_serializing_if = "Option::is_none") )]
	pub tradg_vn: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MstrAgrmt", skip_serializing_if = "Option::is_none") )]
	pub mstr_agrmt: Option<MasterAgreement7>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ValDt", skip_serializing_if = "Option::is_none") )]
	pub val_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GnlColl", skip_serializing_if = "Option::is_none") )]
	pub gnl_coll: Option<SpecialCollateral1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DlvryByVal", skip_serializing_if = "Option::is_none") )]
	pub dlvry_by_val: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollDlvryMtd", skip_serializing_if = "Option::is_none") )]
	pub coll_dlvry_mtd: Option<CollateralDeliveryMethod1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Term", skip_serializing_if = "Option::is_none") )]
	pub term: Option<Vec<ContractTerm7Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AsstTp", skip_serializing_if = "Option::is_none") )]
	pub asst_tp: Option<SecurityCommodity9>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LnVal", skip_serializing_if = "Option::is_none") )]
	pub ln_val: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RbtRate", skip_serializing_if = "Option::is_none") )]
	pub rbt_rate: Option<InterestRate27Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LndgFee", skip_serializing_if = "Option::is_none") )]
	pub lndg_fee: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TermntnDt", skip_serializing_if = "Option::is_none") )]
	pub termntn_dt: Option<String>,
}

impl LoanData141 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.unq_trad_idr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "unq_trad_idr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 52 {
				return Err(ValidationError::new(1002, "unq_trad_idr exceeds the maximum length of 52".to_string()));
			}
		}
		if let Some(ref val) = self.clr_sts { val.validate()? }
		if let Some(ref val) = self.tradg_vn {
			let pattern = Regex::new("[A-Z0-9]{4,4}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "tradg_vn does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.mstr_agrmt { val.validate()? }
		if let Some(ref val) = self.gnl_coll { val.validate()? }
		if let Some(ref val) = self.coll_dlvry_mtd { val.validate()? }
		if let Some(ref vec) = self.term { for item in vec { item.validate()? } }
		if let Some(ref val) = self.asst_tp { val.validate()? }
		if let Some(ref val) = self.ln_val { val.validate()? }
		if let Some(ref val) = self.rbt_rate { val.validate()? }
		Ok(())
	}
}


// LoanData142 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct LoanData142 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnqTradIdr", skip_serializing_if = "Option::is_none") )]
	pub unq_trad_idr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EvtDt") )]
	pub evt_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ExctnDtTm", skip_serializing_if = "Option::is_none") )]
	pub exctn_dt_tm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradgVn", skip_serializing_if = "Option::is_none") )]
	pub tradg_vn: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollDlvryMtd", skip_serializing_if = "Option::is_none") )]
	pub coll_dlvry_mtd: Option<CollateralDeliveryMethod1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OutsdngMrgnLnAmt", skip_serializing_if = "Option::is_none") )]
	pub outsdng_mrgn_ln_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ShrtMktValAmt", skip_serializing_if = "Option::is_none") )]
	pub shrt_mkt_val_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MrgnLnAttr", skip_serializing_if = "Option::is_none") )]
	pub mrgn_ln_attr: Option<Vec<InterestRate6>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TermntnDt", skip_serializing_if = "Option::is_none") )]
	pub termntn_dt: Option<String>,
}

impl LoanData142 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.unq_trad_idr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "unq_trad_idr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 52 {
				return Err(ValidationError::new(1002, "unq_trad_idr exceeds the maximum length of 52".to_string()));
			}
		}
		if let Some(ref val) = self.tradg_vn {
			let pattern = Regex::new("[A-Z0-9]{4,4}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "tradg_vn does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.coll_dlvry_mtd { val.validate()? }
		if let Some(ref val) = self.outsdng_mrgn_ln_amt { val.validate()? }
		if let Some(ref val) = self.shrt_mkt_val_amt { val.validate()? }
		if let Some(ref vec) = self.mrgn_ln_attr { for item in vec { item.validate()? } }
		Ok(())
	}
}


// LoanData143 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct LoanData143 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnqTradIdr") )]
	pub unq_trad_idr: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EvtDt") )]
	pub evt_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ExctnDtTm") )]
	pub exctn_dt_tm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrSts") )]
	pub clr_sts: Cleared16Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradgVn") )]
	pub tradg_vn: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MstrAgrmt", skip_serializing_if = "Option::is_none") )]
	pub mstr_agrmt: Option<MasterAgreement7>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ValDt") )]
	pub val_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GnlColl", skip_serializing_if = "Option::is_none") )]
	pub gnl_coll: Option<SpecialCollateral1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DlvryByVal") )]
	pub dlvry_by_val: bool,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollDlvryMtd") )]
	pub coll_dlvry_mtd: CollateralDeliveryMethod1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Term", skip_serializing_if = "Option::is_none") )]
	pub term: Option<Vec<ContractTerm7Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstRate", skip_serializing_if = "Option::is_none") )]
	pub intrst_rate: Option<InterestRate27Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrncplAmt", skip_serializing_if = "Option::is_none") )]
	pub prncpl_amt: Option<PrincipalAmount3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TermntnDt", skip_serializing_if = "Option::is_none") )]
	pub termntn_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnitPric", skip_serializing_if = "Option::is_none") )]
	pub unit_pric: Option<SecuritiesTransactionPrice19Choice>,
}

impl LoanData143 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.unq_trad_idr.chars().count() < 1 {
			return Err(ValidationError::new(1001, "unq_trad_idr is shorter than the minimum length of 1".to_string()));
		}
		if self.unq_trad_idr.chars().count() > 52 {
			return Err(ValidationError::new(1002, "unq_trad_idr exceeds the maximum length of 52".to_string()));
		}
		self.clr_sts.validate()?;
		let pattern = Regex::new("[A-Z0-9]{4,4}").unwrap();
		if !pattern.is_match(&self.tradg_vn) {
			return Err(ValidationError::new(1005, "tradg_vn does not match the required pattern".to_string()));
		}
		if let Some(ref val) = self.mstr_agrmt { val.validate()? }
		if let Some(ref val) = self.gnl_coll { val.validate()? }
		self.coll_dlvry_mtd.validate()?;
		if let Some(ref vec) = self.term { for item in vec { item.validate()? } }
		if let Some(ref val) = self.intrst_rate { val.validate()? }
		if let Some(ref val) = self.prncpl_amt { val.validate()? }
		if let Some(ref val) = self.unit_pric { val.validate()? }
		Ok(())
	}
}


// LoanData144 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct LoanData144 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrncplAmt", skip_serializing_if = "Option::is_none") )]
	pub prncpl_amt: Option<PrincipalAmount3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MtrtyDt") )]
	pub mtrty_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnqTradIdr") )]
	pub unq_trad_idr: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EvtDt") )]
	pub evt_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrSts") )]
	pub clr_sts: Cleared16Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradgVn") )]
	pub tradg_vn: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MstrAgrmt", skip_serializing_if = "Option::is_none") )]
	pub mstr_agrmt: Option<MasterAgreement7>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ExctnDtTm") )]
	pub exctn_dt_tm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ValDt") )]
	pub val_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TermntnDt", skip_serializing_if = "Option::is_none") )]
	pub termntn_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GnlColl", skip_serializing_if = "Option::is_none") )]
	pub gnl_coll: Option<SpecialCollateral1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnitPric", skip_serializing_if = "Option::is_none") )]
	pub unit_pric: Option<SecuritiesTransactionPrice19Choice>,
}

impl LoanData144 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.prncpl_amt { val.validate()? }
		if self.unq_trad_idr.chars().count() < 1 {
			return Err(ValidationError::new(1001, "unq_trad_idr is shorter than the minimum length of 1".to_string()));
		}
		if self.unq_trad_idr.chars().count() > 52 {
			return Err(ValidationError::new(1002, "unq_trad_idr exceeds the maximum length of 52".to_string()));
		}
		self.clr_sts.validate()?;
		let pattern = Regex::new("[A-Z0-9]{4,4}").unwrap();
		if !pattern.is_match(&self.tradg_vn) {
			return Err(ValidationError::new(1005, "tradg_vn does not match the required pattern".to_string()));
		}
		if let Some(ref val) = self.mstr_agrmt { val.validate()? }
		if let Some(ref val) = self.gnl_coll { val.validate()? }
		if let Some(ref val) = self.unit_pric { val.validate()? }
		Ok(())
	}
}


// LoanData145 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct LoanData145 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DlvryByVal") )]
	pub dlvry_by_val: bool,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollDlvryMtd", skip_serializing_if = "Option::is_none") )]
	pub coll_dlvry_mtd: Option<CollateralDeliveryMethod1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Term", skip_serializing_if = "Option::is_none") )]
	pub term: Option<Vec<ContractTerm7Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AsstTp") )]
	pub asst_tp: SecurityCommodity9,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RbtRate", skip_serializing_if = "Option::is_none") )]
	pub rbt_rate: Option<InterestRate27Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LnVal") )]
	pub ln_val: ActiveOrHistoricCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LndgFee", skip_serializing_if = "Option::is_none") )]
	pub lndg_fee: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnqTradIdr") )]
	pub unq_trad_idr: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EvtDt") )]
	pub evt_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrSts") )]
	pub clr_sts: Cleared16Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradgVn") )]
	pub tradg_vn: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MstrAgrmt", skip_serializing_if = "Option::is_none") )]
	pub mstr_agrmt: Option<MasterAgreement7>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ExctnDtTm") )]
	pub exctn_dt_tm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ValDt") )]
	pub val_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TermntnDt", skip_serializing_if = "Option::is_none") )]
	pub termntn_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GnlColl", skip_serializing_if = "Option::is_none") )]
	pub gnl_coll: Option<SpecialCollateral1Code>,
}

impl LoanData145 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.coll_dlvry_mtd { val.validate()? }
		if let Some(ref vec) = self.term { for item in vec { item.validate()? } }
		self.asst_tp.validate()?;
		if let Some(ref val) = self.rbt_rate { val.validate()? }
		self.ln_val.validate()?;
		if self.unq_trad_idr.chars().count() < 1 {
			return Err(ValidationError::new(1001, "unq_trad_idr is shorter than the minimum length of 1".to_string()));
		}
		if self.unq_trad_idr.chars().count() > 52 {
			return Err(ValidationError::new(1002, "unq_trad_idr exceeds the maximum length of 52".to_string()));
		}
		self.clr_sts.validate()?;
		let pattern = Regex::new("[A-Z0-9]{4,4}").unwrap();
		if !pattern.is_match(&self.tradg_vn) {
			return Err(ValidationError::new(1005, "tradg_vn does not match the required pattern".to_string()));
		}
		if let Some(ref val) = self.mstr_agrmt { val.validate()? }
		if let Some(ref val) = self.gnl_coll { val.validate()? }
		Ok(())
	}
}


// LoanData86 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct LoanData86 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnqTradIdr") )]
	pub unq_trad_idr: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EvtDt", skip_serializing_if = "Option::is_none") )]
	pub evt_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TermntnDt", skip_serializing_if = "Option::is_none") )]
	pub termntn_dt: Option<String>,
}

impl LoanData86 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.unq_trad_idr.chars().count() < 1 {
			return Err(ValidationError::new(1001, "unq_trad_idr is shorter than the minimum length of 1".to_string()));
		}
		if self.unq_trad_idr.chars().count() > 52 {
			return Err(ValidationError::new(1002, "unq_trad_idr exceeds the maximum length of 52".to_string()));
		}
		Ok(())
	}
}


// LoanMatchingCriteria9 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct LoanMatchingCriteria9 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnqTradIdr", skip_serializing_if = "Option::is_none") )]
	pub unq_trad_idr: Option<CompareText2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TermntnDt", skip_serializing_if = "Option::is_none") )]
	pub termntn_dt: Option<CompareDate3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrctTp", skip_serializing_if = "Option::is_none") )]
	pub ctrct_tp: Option<CompareExposureType3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrSts", skip_serializing_if = "Option::is_none") )]
	pub clr_sts: Option<CompareClearingStatus3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrDtTm", skip_serializing_if = "Option::is_none") )]
	pub clr_dt_tm: Option<CompareDateTime3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CCP", skip_serializing_if = "Option::is_none") )]
	pub ccp: Option<CompareOrganisationIdentification6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradgVn", skip_serializing_if = "Option::is_none") )]
	pub tradg_vn: Option<CompareMICIdentifier3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MstrAgrmtTp", skip_serializing_if = "Option::is_none") )]
	pub mstr_agrmt_tp: Option<CompareAgreementType2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ExctnDtTm", skip_serializing_if = "Option::is_none") )]
	pub exctn_dt_tm: Option<CompareDateTime3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ValDt", skip_serializing_if = "Option::is_none") )]
	pub val_dt: Option<CompareDate3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MtrtyDt", skip_serializing_if = "Option::is_none") )]
	pub mtrty_dt: Option<CompareDate3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MinNtcePrd", skip_serializing_if = "Option::is_none") )]
	pub min_ntce_prd: Option<CompareNumber5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EarlstCallBckDt", skip_serializing_if = "Option::is_none") )]
	pub earlst_call_bck_dt: Option<CompareDate3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GnlColl", skip_serializing_if = "Option::is_none") )]
	pub gnl_coll: Option<CompareSpecialCollateral3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DlvryByVal", skip_serializing_if = "Option::is_none") )]
	pub dlvry_by_val: Option<CompareTrueFalseIndicator3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollDlvryMtd", skip_serializing_if = "Option::is_none") )]
	pub coll_dlvry_mtd: Option<CompareDeliveryMethod3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OpnTerm", skip_serializing_if = "Option::is_none") )]
	pub opn_term: Option<CompareTrueFalseIndicator3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TermntnOptn", skip_serializing_if = "Option::is_none") )]
	pub termntn_optn: Option<CompareTerminationOption3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FxdIntrstRate", skip_serializing_if = "Option::is_none") )]
	pub fxd_intrst_rate: Option<ComparePercentageRate3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DayCntBsis", skip_serializing_if = "Option::is_none") )]
	pub day_cnt_bsis: Option<CompareInterestComputationMethod3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FltgIntrstRefRate", skip_serializing_if = "Option::is_none") )]
	pub fltg_intrst_ref_rate: Option<CompareBenchmarkCurveName3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FltgIntrstRateTermUnit", skip_serializing_if = "Option::is_none") )]
	pub fltg_intrst_rate_term_unit: Option<CompareRateBasis3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FltgIntrstRateTermVal", skip_serializing_if = "Option::is_none") )]
	pub fltg_intrst_rate_term_val: Option<CompareNumber5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FltgIntrstRatePmtFrqcyUnit", skip_serializing_if = "Option::is_none") )]
	pub fltg_intrst_rate_pmt_frqcy_unit: Option<CompareRateBasis3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FltgIntrstRatePmtFrqcyVal", skip_serializing_if = "Option::is_none") )]
	pub fltg_intrst_rate_pmt_frqcy_val: Option<CompareNumber5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FltgIntrstRateRstFrqcyUnit", skip_serializing_if = "Option::is_none") )]
	pub fltg_intrst_rate_rst_frqcy_unit: Option<CompareRateBasis3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FltgIntrstRateRstFrqcyVal", skip_serializing_if = "Option::is_none") )]
	pub fltg_intrst_rate_rst_frqcy_val: Option<CompareNumber6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BsisPtSprd", skip_serializing_if = "Option::is_none") )]
	pub bsis_pt_sprd: Option<CompareDecimalNumber3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MrgnLnAttr", skip_serializing_if = "Option::is_none") )]
	pub mrgn_ln_attr: Option<Vec<CompareInterestRate1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrncplAmtValDtAmt", skip_serializing_if = "Option::is_none") )]
	pub prncpl_amt_val_dt_amt: Option<CompareActiveOrHistoricCurrencyAndAmount3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrncplAmtMtrtyDtAmt", skip_serializing_if = "Option::is_none") )]
	pub prncpl_amt_mtrty_dt_amt: Option<CompareActiveOrHistoricCurrencyAndAmount3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AsstTp", skip_serializing_if = "Option::is_none") )]
	pub asst_tp: Option<SecurityCommodity7Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LnVal", skip_serializing_if = "Option::is_none") )]
	pub ln_val: Option<CompareActiveOrHistoricCurrencyAndAmount3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FxdRbtRefRate", skip_serializing_if = "Option::is_none") )]
	pub fxd_rbt_ref_rate: Option<ComparePercentageRate3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FltgRbtRefRate", skip_serializing_if = "Option::is_none") )]
	pub fltg_rbt_ref_rate: Option<CompareBenchmarkCurveName3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FltgRbtRateTermUnit", skip_serializing_if = "Option::is_none") )]
	pub fltg_rbt_rate_term_unit: Option<CompareRateBasis3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FltgRbtRateTermVal", skip_serializing_if = "Option::is_none") )]
	pub fltg_rbt_rate_term_val: Option<CompareNumber6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FltgRbtRatePmtFrqcyUnit", skip_serializing_if = "Option::is_none") )]
	pub fltg_rbt_rate_pmt_frqcy_unit: Option<CompareRateBasis3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FltgRbtRatePmtFrqcyVal", skip_serializing_if = "Option::is_none") )]
	pub fltg_rbt_rate_pmt_frqcy_val: Option<CompareNumber6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FltgRbtRateRstFrqcyUnit", skip_serializing_if = "Option::is_none") )]
	pub fltg_rbt_rate_rst_frqcy_unit: Option<CompareRateBasis3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FltgRbtRateRstFrqcyVal", skip_serializing_if = "Option::is_none") )]
	pub fltg_rbt_rate_rst_frqcy_val: Option<CompareNumber6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RbtRateBsisPtSprd", skip_serializing_if = "Option::is_none") )]
	pub rbt_rate_bsis_pt_sprd: Option<CompareDecimalNumber3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FltgRateAdjstmnt", skip_serializing_if = "Option::is_none") )]
	pub fltg_rate_adjstmnt: Option<Vec<ComparePercentageRate3>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FltgRateAdjstmntDt", skip_serializing_if = "Option::is_none") )]
	pub fltg_rate_adjstmnt_dt: Option<Vec<CompareDate3>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LndgFee", skip_serializing_if = "Option::is_none") )]
	pub lndg_fee: Option<ComparePercentageRate3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OutsdngMrgnLnAmt", skip_serializing_if = "Option::is_none") )]
	pub outsdng_mrgn_ln_amt: Option<CompareActiveOrHistoricCurrencyAndAmount3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ShrtMktValAmt", skip_serializing_if = "Option::is_none") )]
	pub shrt_mkt_val_amt: Option<CompareActiveOrHistoricCurrencyAndAmount3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LvlTp", skip_serializing_if = "Option::is_none") )]
	pub lvl_tp: Option<CompareReportingLevelType3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnitOfMeasr", skip_serializing_if = "Option::is_none") )]
	pub unit_of_measr: Option<CompareUnitOfMeasure3>,
}

impl LoanMatchingCriteria9 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.unq_trad_idr { val.validate()? }
		if let Some(ref val) = self.termntn_dt { val.validate()? }
		if let Some(ref val) = self.ctrct_tp { val.validate()? }
		if let Some(ref val) = self.clr_sts { val.validate()? }
		if let Some(ref val) = self.clr_dt_tm { val.validate()? }
		if let Some(ref val) = self.ccp { val.validate()? }
		if let Some(ref val) = self.tradg_vn { val.validate()? }
		if let Some(ref val) = self.mstr_agrmt_tp { val.validate()? }
		if let Some(ref val) = self.exctn_dt_tm { val.validate()? }
		if let Some(ref val) = self.val_dt { val.validate()? }
		if let Some(ref val) = self.mtrty_dt { val.validate()? }
		if let Some(ref val) = self.min_ntce_prd { val.validate()? }
		if let Some(ref val) = self.earlst_call_bck_dt { val.validate()? }
		if let Some(ref val) = self.gnl_coll { val.validate()? }
		if let Some(ref val) = self.dlvry_by_val { val.validate()? }
		if let Some(ref val) = self.coll_dlvry_mtd { val.validate()? }
		if let Some(ref val) = self.opn_term { val.validate()? }
		if let Some(ref val) = self.termntn_optn { val.validate()? }
		if let Some(ref val) = self.fxd_intrst_rate { val.validate()? }
		if let Some(ref val) = self.day_cnt_bsis { val.validate()? }
		if let Some(ref val) = self.fltg_intrst_ref_rate { val.validate()? }
		if let Some(ref val) = self.fltg_intrst_rate_term_unit { val.validate()? }
		if let Some(ref val) = self.fltg_intrst_rate_term_val { val.validate()? }
		if let Some(ref val) = self.fltg_intrst_rate_pmt_frqcy_unit { val.validate()? }
		if let Some(ref val) = self.fltg_intrst_rate_pmt_frqcy_val { val.validate()? }
		if let Some(ref val) = self.fltg_intrst_rate_rst_frqcy_unit { val.validate()? }
		if let Some(ref val) = self.fltg_intrst_rate_rst_frqcy_val { val.validate()? }
		if let Some(ref val) = self.bsis_pt_sprd { val.validate()? }
		if let Some(ref vec) = self.mrgn_ln_attr { for item in vec { item.validate()? } }
		if let Some(ref val) = self.prncpl_amt_val_dt_amt { val.validate()? }
		if let Some(ref val) = self.prncpl_amt_mtrty_dt_amt { val.validate()? }
		if let Some(ref val) = self.asst_tp { val.validate()? }
		if let Some(ref val) = self.ln_val { val.validate()? }
		if let Some(ref val) = self.fxd_rbt_ref_rate { val.validate()? }
		if let Some(ref val) = self.fltg_rbt_ref_rate { val.validate()? }
		if let Some(ref val) = self.fltg_rbt_rate_term_unit { val.validate()? }
		if let Some(ref val) = self.fltg_rbt_rate_term_val { val.validate()? }
		if let Some(ref val) = self.fltg_rbt_rate_pmt_frqcy_unit { val.validate()? }
		if let Some(ref val) = self.fltg_rbt_rate_pmt_frqcy_val { val.validate()? }
		if let Some(ref val) = self.fltg_rbt_rate_rst_frqcy_unit { val.validate()? }
		if let Some(ref val) = self.fltg_rbt_rate_rst_frqcy_val { val.validate()? }
		if let Some(ref val) = self.rbt_rate_bsis_pt_sprd { val.validate()? }
		if let Some(ref vec) = self.fltg_rate_adjstmnt { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.fltg_rate_adjstmnt_dt { for item in vec { item.validate()? } }
		if let Some(ref val) = self.lndg_fee { val.validate()? }
		if let Some(ref val) = self.outsdng_mrgn_ln_amt { val.validate()? }
		if let Some(ref val) = self.shrt_mkt_val_amt { val.validate()? }
		if let Some(ref val) = self.lvl_tp { val.validate()? }
		if let Some(ref val) = self.unit_of_measr { val.validate()? }
		Ok(())
	}
}


// MICEntityType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum MICEntityType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "APPA") )]
	CodeAPPA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CTPS") )]
	CodeCTPS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MLTF") )]
	CodeMLTF,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTFS") )]
	CodeOTFS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RMKT") )]
	CodeRMKT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SINT") )]
	CodeSINT,
}

impl MICEntityType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// MarginAccount1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct MarginAccount1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: PartyIdentification118Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PosAcct") )]
	pub pos_acct: Vec<PositionAccount1>,
}

impl MarginAccount1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.id.validate()?;
		for item in &self.pos_acct { item.validate()? }
		Ok(())
	}
}


// MarginCollateralReport4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct MarginCollateralReport4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollPrtflCd") )]
	pub coll_prtfl_cd: CollateralPortfolioCode5Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollstnCtgy") )]
	pub collstn_ctgy: CollateralisationType3Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TmStmp", skip_serializing_if = "Option::is_none") )]
	pub tm_stmp: Option<String>,
}

impl MarginCollateralReport4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.coll_prtfl_cd.validate()?;
		self.collstn_ctgy.validate()?;
		Ok(())
	}
}


// MarginCollateralReport5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct MarginCollateralReport5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollPrtflCd") )]
	pub coll_prtfl_cd: CollateralPortfolioCode6Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollstnCtgy") )]
	pub collstn_ctgy: CollateralisationType3Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TmStmp", skip_serializing_if = "Option::is_none") )]
	pub tm_stmp: Option<String>,
}

impl MarginCollateralReport5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.coll_prtfl_cd.validate()?;
		self.collstn_ctgy.validate()?;
		Ok(())
	}
}


// MarginPortfolio3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct MarginPortfolio3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "InitlMrgnPrtflCd") )]
	pub initl_mrgn_prtfl_cd: PortfolioCode5Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VartnMrgnPrtflCd", skip_serializing_if = "Option::is_none") )]
	pub vartn_mrgn_prtfl_cd: Option<PortfolioCode5Choice>,
}

impl MarginPortfolio3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.initl_mrgn_prtfl_cd.validate()?;
		if let Some(ref val) = self.vartn_mrgn_prtfl_cd { val.validate()? }
		Ok(())
	}
}


// MarginPortfolio4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct MarginPortfolio4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "InitlMrgnPrtflCd", skip_serializing_if = "Option::is_none") )]
	pub initl_mrgn_prtfl_cd: Option<PortfolioCode5Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VartnMrgnPrtflCd", skip_serializing_if = "Option::is_none") )]
	pub vartn_mrgn_prtfl_cd: Option<PortfolioCode5Choice>,
}

impl MarginPortfolio4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.initl_mrgn_prtfl_cd { val.validate()? }
		if let Some(ref val) = self.vartn_mrgn_prtfl_cd { val.validate()? }
		Ok(())
	}
}


// MarginReportData10 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct MarginReportData10 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgTmStmp", skip_serializing_if = "Option::is_none") )]
	pub rptg_tm_stmp: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPtyId") )]
	pub ctr_pty_id: TradeCounterpartyReport20,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EvtDt", skip_serializing_if = "Option::is_none") )]
	pub evt_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxId", skip_serializing_if = "Option::is_none") )]
	pub tx_id: Option<UniqueTransactionIdentifier2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Coll") )]
	pub coll: MarginCollateralReport5,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstdMrgnOrColl", skip_serializing_if = "Option::is_none") )]
	pub pstd_mrgn_or_coll: Option<PostedMarginOrCollateral6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RcvdMrgnOrColl", skip_serializing_if = "Option::is_none") )]
	pub rcvd_mrgn_or_coll: Option<ReceivedMarginOrCollateral6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPtyRatgTrggrInd", skip_serializing_if = "Option::is_none") )]
	pub ctr_pty_ratg_trggr_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPtyRatgThrshldInd", skip_serializing_if = "Option::is_none") )]
	pub ctr_pty_ratg_thrshld_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrctMod", skip_serializing_if = "Option::is_none") )]
	pub ctrct_mod: Option<ContractModification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechAttrbts", skip_serializing_if = "Option::is_none") )]
	pub tech_attrbts: Option<TechnicalAttributes6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl MarginReportData10 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.ctr_pty_id.validate()?;
		if let Some(ref val) = self.tx_id { val.validate()? }
		self.coll.validate()?;
		if let Some(ref val) = self.pstd_mrgn_or_coll { val.validate()? }
		if let Some(ref val) = self.rcvd_mrgn_or_coll { val.validate()? }
		if let Some(ref val) = self.ctrct_mod { val.validate()? }
		if let Some(ref val) = self.tech_attrbts { val.validate()? }
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// MarginReportData9 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct MarginReportData9 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgTmStmp", skip_serializing_if = "Option::is_none") )]
	pub rptg_tm_stmp: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPtyId") )]
	pub ctr_pty_id: TradeCounterpartyReport20,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EvtDt", skip_serializing_if = "Option::is_none") )]
	pub evt_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxId", skip_serializing_if = "Option::is_none") )]
	pub tx_id: Option<UniqueTransactionIdentifier2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Coll") )]
	pub coll: MarginCollateralReport5,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstdMrgnOrColl", skip_serializing_if = "Option::is_none") )]
	pub pstd_mrgn_or_coll: Option<PostedMarginOrCollateral6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RcvdMrgnOrColl", skip_serializing_if = "Option::is_none") )]
	pub rcvd_mrgn_or_coll: Option<ReceivedMarginOrCollateral6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPtyRatgTrggrInd", skip_serializing_if = "Option::is_none") )]
	pub ctr_pty_ratg_trggr_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPtyRatgThrshldInd", skip_serializing_if = "Option::is_none") )]
	pub ctr_pty_ratg_thrshld_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechAttrbts", skip_serializing_if = "Option::is_none") )]
	pub tech_attrbts: Option<TechnicalAttributes6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl MarginReportData9 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.ctr_pty_id.validate()?;
		if let Some(ref val) = self.tx_id { val.validate()? }
		self.coll.validate()?;
		if let Some(ref val) = self.pstd_mrgn_or_coll { val.validate()? }
		if let Some(ref val) = self.rcvd_mrgn_or_coll { val.validate()? }
		if let Some(ref val) = self.tech_attrbts { val.validate()? }
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// MarginType2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct MarginType2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<MarginType2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification36>,
}

impl MarginType2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// MarginType2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum MarginType2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ADFM") )]
	CodeADFM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "COMA") )]
	CodeCOMA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CEMA") )]
	CodeCEMA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SEMA") )]
	CodeSEMA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SCMA") )]
	CodeSCMA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UFMA") )]
	CodeUFMA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MARM") )]
	CodeMARM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SORM") )]
	CodeSORM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "WWRM") )]
	CodeWWRM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BARM") )]
	CodeBARM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LIRM") )]
	CodeLIRM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CRAM") )]
	CodeCRAM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CVMA") )]
	CodeCVMA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SPMA") )]
	CodeSPMA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "JTDR") )]
	CodeJTDR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DRAO") )]
	CodeDRAO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
}

impl MarginType2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// MarketDetail2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct MarketDetail2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AvrgDalyNbOfTxs", skip_serializing_if = "Option::is_none") )]
	pub avrg_daly_nb_of_txs: Option<f64>,
}

impl MarketDetail2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z0-9]{4,4}").unwrap();
		if !pattern.is_match(&self.id) {
			return Err(ValidationError::new(1005, "id does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// MarketIdentification1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum MarketIdentification1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "SGMT") )]
	CodeSGMT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OPRT") )]
	CodeOPRT,
}

impl MarketIdentification1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// MarketIdentification95 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct MarketIdentification95 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Oprg") )]
	pub oprg: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sgmt") )]
	pub sgmt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: MarketIdentification1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ctgy", skip_serializing_if = "Option::is_none") )]
	pub ctgy: Option<MICEntityType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstnNm") )]
	pub instn_nm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Acrnm", skip_serializing_if = "Option::is_none") )]
	pub acrnm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "City", skip_serializing_if = "Option::is_none") )]
	pub city: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ctry") )]
	pub ctry: CountryCodeAndName3,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AuthrtyNm", skip_serializing_if = "Option::is_none") )]
	pub authrty_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "WebSite", skip_serializing_if = "Option::is_none") )]
	pub web_site: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Note", skip_serializing_if = "Option::is_none") )]
	pub note: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Mod", skip_serializing_if = "Option::is_none") )]
	pub mod_attr: Option<Modification1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CreDt", skip_serializing_if = "Option::is_none") )]
	pub cre_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VldtyPrd") )]
	pub vldty_prd: Period4Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StsDt", skip_serializing_if = "Option::is_none") )]
	pub sts_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LastUpdtdDt", skip_serializing_if = "Option::is_none") )]
	pub last_updtd_dt: Option<String>,
}

impl MarketIdentification95 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z0-9]{4,4}").unwrap();
		if !pattern.is_match(&self.oprg) {
			return Err(ValidationError::new(1005, "oprg does not match the required pattern".to_string()));
		}
		let pattern = Regex::new("[A-Z0-9]{4,4}").unwrap();
		if !pattern.is_match(&self.sgmt) {
			return Err(ValidationError::new(1005, "sgmt does not match the required pattern".to_string()));
		}
		self.tp.validate()?;
		if let Some(ref val) = self.ctgy { val.validate()? }
		if self.instn_nm.chars().count() < 1 {
			return Err(ValidationError::new(1001, "instn_nm is shorter than the minimum length of 1".to_string()));
		}
		if self.instn_nm.chars().count() > 450 {
			return Err(ValidationError::new(1002, "instn_nm exceeds the maximum length of 450".to_string()));
		}
		if let Some(ref val) = self.acrnm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "acrnm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "acrnm exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.city {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "city is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "city exceeds the maximum length of 35".to_string()));
			}
		}
		self.ctry.validate()?;
		if let Some(ref val) = self.authrty_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "authrty_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 450 {
				return Err(ValidationError::new(1002, "authrty_nm exceeds the maximum length of 450".to_string()));
			}
		}
		if let Some(ref val) = self.web_site {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "web_site is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 210 {
				return Err(ValidationError::new(1002, "web_site exceeds the maximum length of 210".to_string()));
			}
		}
		if let Some(ref val) = self.note {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "note is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 450 {
				return Err(ValidationError::new(1002, "note exceeds the maximum length of 450".to_string()));
			}
		}
		if let Some(ref val) = self.mod_attr { val.validate()? }
		self.vldty_prd.validate()?;
		Ok(())
	}
}


// MasterAgreement7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct MasterAgreement7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: AgreementType2Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Vrsn", skip_serializing_if = "Option::is_none") )]
	pub vrsn: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrMstrAgrmtDtls", skip_serializing_if = "Option::is_none") )]
	pub othr_mstr_agrmt_dtls: Option<String>,
}

impl MasterAgreement7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.tp.validate()?;
		if let Some(ref val) = self.vrsn {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "vrsn is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 50 {
				return Err(ValidationError::new(1002, "vrsn exceeds the maximum length of 50".to_string()));
			}
		}
		if let Some(ref val) = self.othr_mstr_agrmt_dtls {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "othr_mstr_agrmt_dtls is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 350 {
				return Err(ValidationError::new(1002, "othr_mstr_agrmt_dtls exceeds the maximum length of 350".to_string()));
			}
		}
		Ok(())
	}
}


// MasterAgreement8 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct MasterAgreement8 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<AgreementType2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Vrsn", skip_serializing_if = "Option::is_none") )]
	pub vrsn: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrMstrAgrmtDtls", skip_serializing_if = "Option::is_none") )]
	pub othr_mstr_agrmt_dtls: Option<String>,
}

impl MasterAgreement8 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tp { val.validate()? }
		if let Some(ref val) = self.vrsn {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "vrsn is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 50 {
				return Err(ValidationError::new(1002, "vrsn exceeds the maximum length of 50".to_string()));
			}
		}
		if let Some(ref val) = self.othr_mstr_agrmt_dtls {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "othr_mstr_agrmt_dtls is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 350 {
				return Err(ValidationError::new(1002, "othr_mstr_agrmt_dtls exceeds the maximum length of 350".to_string()));
			}
		}
		Ok(())
	}
}


// MatchingCriteria10 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct MatchingCriteria10 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPtyMtchgCrit", skip_serializing_if = "Option::is_none") )]
	pub ctr_pty_mtchg_crit: Option<CounterpartyMatchingCriteria4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LnMtchgCrit", skip_serializing_if = "Option::is_none") )]
	pub ln_mtchg_crit: Option<LoanMatchingCriteria9>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollMtchgCrit", skip_serializing_if = "Option::is_none") )]
	pub coll_mtchg_crit: Option<CollateralMatchingCriteria6>,
}

impl MatchingCriteria10 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ctr_pty_mtchg_crit { val.validate()? }
		if let Some(ref val) = self.ln_mtchg_crit { val.validate()? }
		if let Some(ref val) = self.coll_mtchg_crit { val.validate()? }
		Ok(())
	}
}


// MatchingCriteria17 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct MatchingCriteria17 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPtyMtchgCrit", skip_serializing_if = "Option::is_none") )]
	pub ctr_pty_mtchg_crit: Option<CounterpartyMatchingCriteria6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ValtnMtchgCrit", skip_serializing_if = "Option::is_none") )]
	pub valtn_mtchg_crit: Option<ValuationMatchingCriteria1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrctMtchgCrit", skip_serializing_if = "Option::is_none") )]
	pub ctrct_mtchg_crit: Option<ContractMatchingCriteria3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxMtchgCrit", skip_serializing_if = "Option::is_none") )]
	pub tx_mtchg_crit: Option<TransactionMatchingCriteria7>,
}

impl MatchingCriteria17 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ctr_pty_mtchg_crit { val.validate()? }
		if let Some(ref val) = self.valtn_mtchg_crit { val.validate()? }
		if let Some(ref val) = self.ctrct_mtchg_crit { val.validate()? }
		if let Some(ref val) = self.tx_mtchg_crit { val.validate()? }
		Ok(())
	}
}


// MaturityTerm2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct MaturityTerm2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Unit") )]
	pub unit: RateBasis1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val") )]
	pub val: f64,
}

impl MaturityTerm2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.unit.validate()?;
		Ok(())
	}
}


// MessageIdentification1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct MessageIdentification1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CreDtTm") )]
	pub cre_dt_tm: String,
}

impl MessageIdentification1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
		}
		Ok(())
	}
}


// MessageReportHeader4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct MessageReportHeader4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgRptIdr", skip_serializing_if = "Option::is_none") )]
	pub msg_rpt_idr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgSts", skip_serializing_if = "Option::is_none") )]
	pub msg_sts: Option<StatusAdviceReport3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RcrdSts", skip_serializing_if = "Option::is_none") )]
	pub rcrd_sts: Option<Vec<StatusReportRecord3>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl MessageReportHeader4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.msg_rpt_idr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "msg_rpt_idr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "msg_rpt_idr exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.msg_sts { val.validate()? }
		if let Some(ref vec) = self.rcrd_sts { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// MetalCommodityNonPrecious1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct MetalCommodityNonPrecious1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType7Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct") )]
	pub sub_pdct: AssetClassSubProductType15Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlSubPdct") )]
	pub addtl_sub_pdct: AssetClassDetailedSubProductType10Code,
}

impl MetalCommodityNonPrecious1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		self.sub_pdct.validate()?;
		self.addtl_sub_pdct.validate()?;
		Ok(())
	}
}


// MetalCommodityNonPrecious2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct MetalCommodityNonPrecious2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType7Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType15Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlSubPdct", skip_serializing_if = "Option::is_none") )]
	pub addtl_sub_pdct: Option<AssetClassDetailedSubProductType10Code>,
}

impl MetalCommodityNonPrecious2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		if let Some(ref val) = self.addtl_sub_pdct { val.validate()? }
		Ok(())
	}
}


// MetalCommodityPrecious1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct MetalCommodityPrecious1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType7Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct") )]
	pub sub_pdct: AssetClassSubProductType16Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlSubPdct") )]
	pub addtl_sub_pdct: AssetClassDetailedSubProductType11Code,
}

impl MetalCommodityPrecious1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		self.sub_pdct.validate()?;
		self.addtl_sub_pdct.validate()?;
		Ok(())
	}
}


// MetalCommodityPrecious2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct MetalCommodityPrecious2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType7Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType16Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlSubPdct", skip_serializing_if = "Option::is_none") )]
	pub addtl_sub_pdct: Option<AssetClassDetailedSubProductType11Code>,
}

impl MetalCommodityPrecious2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		if let Some(ref val) = self.addtl_sub_pdct { val.validate()? }
		Ok(())
	}
}


// MinimumExecutable1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct MinimumExecutable1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sz", skip_serializing_if = "Option::is_none") )]
	pub sz: Option<FinancialInstrumentQuantity25Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrstExctnOnly", skip_serializing_if = "Option::is_none") )]
	pub frst_exctn_only: Option<bool>,
}

impl MinimumExecutable1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.sz { val.validate()? }
		Ok(())
	}
}


// MissingMarginData2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct MissingMarginData2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPtyId") )]
	pub ctr_pty_id: CounterpartyData92,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfOutsdngDerivs") )]
	pub nb_of_outsdng_derivs: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfOutsdngDerivsWthNoMrgnInf") )]
	pub nb_of_outsdng_derivs_wth_no_mrgn_inf: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfOutsdngDerivsWthOutdtdMrgnInf") )]
	pub nb_of_outsdng_derivs_wth_outdtd_mrgn_inf: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxDtls", skip_serializing_if = "Option::is_none") )]
	pub tx_dtls: Option<Vec<MissingMarginTransactionData2>>,
}

impl MissingMarginData2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.ctr_pty_id.validate()?;
		if let Some(ref vec) = self.tx_dtls { for item in vec { item.validate()? } }
		Ok(())
	}
}


// MissingMarginTransactionData2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct MissingMarginTransactionData2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxId") )]
	pub tx_id: TradeTransactionIdentification24,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollTmStmp", skip_serializing_if = "Option::is_none") )]
	pub coll_tm_stmp: Option<String>,
}

impl MissingMarginTransactionData2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.tx_id.validate()?;
		Ok(())
	}
}


// MissingValuationsData2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct MissingValuationsData2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPtyId") )]
	pub ctr_pty_id: CounterpartyData92,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfOutsdngDerivs") )]
	pub nb_of_outsdng_derivs: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfOutsdngDerivsWthNoValtn") )]
	pub nb_of_outsdng_derivs_wth_no_valtn: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfOutsdngDerivsWthOutdtdValtn") )]
	pub nb_of_outsdng_derivs_wth_outdtd_valtn: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxDtls", skip_serializing_if = "Option::is_none") )]
	pub tx_dtls: Option<Vec<MissingValuationsTransactionData2>>,
}

impl MissingValuationsData2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.ctr_pty_id.validate()?;
		if let Some(ref vec) = self.tx_dtls { for item in vec { item.validate()? } }
		Ok(())
	}
}


// MissingValuationsTransactionData2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct MissingValuationsTransactionData2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxId") )]
	pub tx_id: TradeTransactionIdentification24,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ValtnAmt", skip_serializing_if = "Option::is_none") )]
	pub valtn_amt: Option<AmountAndDirection106>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ValtnTmStmp", skip_serializing_if = "Option::is_none") )]
	pub valtn_tm_stmp: Option<DateAndDateTime2Choice>,
}

impl MissingValuationsTransactionData2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.tx_id.validate()?;
		if let Some(ref val) = self.valtn_amt { val.validate()? }
		if let Some(ref val) = self.valtn_tm_stmp { val.validate()? }
		Ok(())
	}
}


// ModelType1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ModelType1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<ModelType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification36>,
}

impl ModelType1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// ModelType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum ModelType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "EXPS") )]
	CodeEXPS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ORIA") )]
	CodeORIA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SPAN") )]
	CodeSPAN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VARI") )]
	CodeVARI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SAMO") )]
	CodeSAMO,
}

impl ModelType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// Modification1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum Modification1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "NOCH") )]
	CodeNOCH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MODI") )]
	CodeMODI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DELE") )]
	CodeDELE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ADDD") )]
	CodeADDD,
}

impl Modification1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ModificationLevel1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum ModificationLevel1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "PSTN") )]
	CodePSTN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TCTN") )]
	CodeTCTN,
}

impl ModificationLevel1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// MoneyMarketReportHeader1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct MoneyMarketReportHeader1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgAgt") )]
	pub rptg_agt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RefPrd") )]
	pub ref_prd: DateTimePeriod1,
}

impl MoneyMarketReportHeader1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
		if !pattern.is_match(&self.rptg_agt) {
			return Err(ValidationError::new(1005, "rptg_agt does not match the required pattern".to_string()));
		}
		self.ref_prd.validate()?;
		Ok(())
	}
}


// MoneyMarketStatusReportHeader1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct MoneyMarketStatusReportHeader1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgAgt") )]
	pub rptg_agt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgPrd") )]
	pub rptg_prd: DateTimePeriod1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptSts") )]
	pub rpt_sts: StatisticalReportingStatus1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VldtnRule", skip_serializing_if = "Option::is_none") )]
	pub vldtn_rule: Option<Vec<GenericValidationRuleIdentification1>>,
}

impl MoneyMarketStatusReportHeader1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
		if !pattern.is_match(&self.rptg_agt) {
			return Err(ValidationError::new(1005, "rptg_agt does not match the required pattern".to_string()));
		}
		self.rptg_prd.validate()?;
		self.rpt_sts.validate()?;
		if let Some(ref vec) = self.vldtn_rule { for item in vec { item.validate()? } }
		Ok(())
	}
}


// MoneyMarketTransactionStatus2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct MoneyMarketTransactionStatus2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnqTxIdr", skip_serializing_if = "Option::is_none") )]
	pub unq_tx_idr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrtryTxId") )]
	pub prtry_tx_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BrnchId", skip_serializing_if = "Option::is_none") )]
	pub brnch_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sts") )]
	pub sts: StatisticalReportingStatus2Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VldtnRule", skip_serializing_if = "Option::is_none") )]
	pub vldtn_rule: Option<Vec<GenericValidationRuleIdentification1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl MoneyMarketTransactionStatus2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.unq_tx_idr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "unq_tx_idr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 105 {
				return Err(ValidationError::new(1002, "unq_tx_idr exceeds the maximum length of 105".to_string()));
			}
		}
		if self.prtry_tx_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "prtry_tx_id is shorter than the minimum length of 1".to_string()));
		}
		if self.prtry_tx_id.chars().count() > 105 {
			return Err(ValidationError::new(1002, "prtry_tx_id exceeds the maximum length of 105".to_string()));
		}
		if let Some(ref val) = self.brnch_id {
			let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "brnch_id does not match the required pattern".to_string()));
			}
		}
		self.sts.validate()?;
		if let Some(ref vec) = self.vldtn_rule { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// MoneyMarketTransactionType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum MoneyMarketTransactionType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "BORR") )]
	CodeBORR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LEND") )]
	CodeLEND,
}

impl MoneyMarketTransactionType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// MonthlyResult1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct MonthlyResult1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfObsrvtns") )]
	pub nb_of_obsrvtns: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfXcptns") )]
	pub nb_of_xcptns: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cvrg") )]
	pub cvrg: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LrgstXcptn") )]
	pub lrgst_xcptn: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AvrgXcptn") )]
	pub avrg_xcptn: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LrgstXcptnId", skip_serializing_if = "Option::is_none") )]
	pub lrgst_xcptn_id: Option<GenericIdentification165>,
}

impl MonthlyResult1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.nb_of_obsrvtns < 1.000000 {
			return Err(ValidationError::new(1003, "nb_of_obsrvtns is less than the minimum value of 1.000000".to_string()));
		}
		if self.nb_of_xcptns < 0.000000 {
			return Err(ValidationError::new(1003, "nb_of_xcptns is less than the minimum value of 0.000000".to_string()));
		}
		self.lrgst_xcptn.validate()?;
		self.avrg_xcptn.validate()?;
		if let Some(ref val) = self.lrgst_xcptn_id { val.validate()? }
		Ok(())
	}
}


// NameAndAddress5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct NameAndAddress5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm") )]
	pub nm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Adr", skip_serializing_if = "Option::is_none") )]
	pub adr: Option<PostalAddress1>,
}

impl NameAndAddress5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.nm.chars().count() < 1 {
			return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
		}
		if self.nm.chars().count() > 350 {
			return Err(ValidationError::new(1002, "nm exceeds the maximum length of 350".to_string()));
		}
		if let Some(ref val) = self.adr { val.validate()? }
		Ok(())
	}
}


// NameAndLocation1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct NameAndLocation1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm") )]
	pub nm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Lctn") )]
	pub lctn: String,
}

impl NameAndLocation1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.nm.chars().count() < 1 {
			return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
		}
		if self.nm.chars().count() > 70 {
			return Err(ValidationError::new(1002, "nm exceeds the maximum length of 70".to_string()));
		}
		let pattern = Regex::new("[A-Z]{2,2}").unwrap();
		if !pattern.is_match(&self.lctn) {
			return Err(ValidationError::new(1005, "lctn does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// NamePrefix1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum NamePrefix1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "DOCT") )]
	CodeDOCT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MIST") )]
	CodeMIST,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MISS") )]
	CodeMISS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MADM") )]
	CodeMADM,
}

impl NamePrefix1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// NamePrefix2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum NamePrefix2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "DOCT") )]
	CodeDOCT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MADM") )]
	CodeMADM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MISS") )]
	CodeMISS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MIST") )]
	CodeMIST,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MIKS") )]
	CodeMIKS,
}

impl NamePrefix2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// NamedPosition3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct NamedPosition3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RefDt") )]
	pub ref_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GnlInf", skip_serializing_if = "Option::is_none") )]
	pub gnl_inf: Option<Vec<PositionSet16>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ln", skip_serializing_if = "Option::is_none") )]
	pub ln: Option<Vec<PositionSet17>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Coll", skip_serializing_if = "Option::is_none") )]
	pub coll: Option<Vec<PositionSet18>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Mrgn", skip_serializing_if = "Option::is_none") )]
	pub mrgn: Option<Vec<PositionSet20>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Reuse", skip_serializing_if = "Option::is_none") )]
	pub reuse: Option<Vec<PositionSet19>>,
}

impl NamedPosition3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.gnl_inf { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.ln { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.coll { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.mrgn { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.reuse { for item in vec { item.validate()? } }
		Ok(())
	}
}


// NaturalPersonIdentification2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct NaturalPersonIdentification2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: GenericIdentification175,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm", skip_serializing_if = "Option::is_none") )]
	pub nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dmcl", skip_serializing_if = "Option::is_none") )]
	pub dmcl: Option<String>,
}

impl NaturalPersonIdentification2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.id.validate()?;
		if let Some(ref val) = self.nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 105 {
				return Err(ValidationError::new(1002, "nm exceeds the maximum length of 105".to_string()));
			}
		}
		if let Some(ref val) = self.dmcl {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "dmcl is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 500 {
				return Err(ValidationError::new(1002, "dmcl exceeds the maximum length of 500".to_string()));
			}
		}
		Ok(())
	}
}


// NaturalPersonIdentification3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct NaturalPersonIdentification3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: NaturalPersonIdentification2,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ctry", skip_serializing_if = "Option::is_none") )]
	pub ctry: Option<String>,
}

impl NaturalPersonIdentification3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.id.validate()?;
		if let Some(ref val) = self.ctry {
			let pattern = Regex::new("[A-Z]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ctry does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// NewOrderReport2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct NewOrderReport2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptId") )]
	pub rpt_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ordr") )]
	pub ordr: Vec<OrderData3>,
}

impl NewOrderReport2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.rpt_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "rpt_id is shorter than the minimum length of 1".to_string()));
		}
		if self.rpt_id.chars().count() > 140 {
			return Err(ValidationError::new(1002, "rpt_id exceeds the maximum length of 140".to_string()));
		}
		for item in &self.ordr { item.validate()? }
		Ok(())
	}
}


// NoReasonCode ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum NoReasonCode {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "NORE") )]
	CodeNORE,
}

impl NoReasonCode {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// NonClearingReason2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct NonClearingReason2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrXmptnXcptn") )]
	pub clr_xmptn_xcptn: Vec<ClearingExemptionException1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NonClrRsnInf", skip_serializing_if = "Option::is_none") )]
	pub non_clr_rsn_inf: Option<String>,
}

impl NonClearingReason2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		for item in &self.clr_xmptn_xcptn { item.validate()? }
		if let Some(ref val) = self.non_clr_rsn_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "non_clr_rsn_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 350 {
				return Err(ValidationError::new(1002, "non_clr_rsn_inf exceeds the maximum length of 350".to_string()));
			}
		}
		Ok(())
	}
}


// NonEquityAssetClass1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum NonEquityAssetClass1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "SDRV") )]
	CodeSDRV,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IRDV") )]
	CodeIRDV,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FEXD") )]
	CodeFEXD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EQDV") )]
	CodeEQDV,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EADV") )]
	CodeEADV,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EMAL") )]
	CodeEMAL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CRDV") )]
	CodeCRDV,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CFDS") )]
	CodeCFDS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "COMD") )]
	CodeCOMD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "C10D") )]
	CodeC10D,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BOND") )]
	CodeBOND,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ETCS") )]
	CodeETCS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ETNS") )]
	CodeETNS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SFPS") )]
	CodeSFPS,
}

impl NonEquityAssetClass1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// NonEquityInstrumentReportingClassification1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum NonEquityInstrumentReportingClassification1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "SFPS") )]
	CodeSFPS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SDRV") )]
	CodeSDRV,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DERV") )]
	CodeDERV,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EMAL") )]
	CodeEMAL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BOND") )]
	CodeBOND,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ETCS") )]
	CodeETCS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ETNS") )]
	CodeETNS,
}

impl NonEquityInstrumentReportingClassification1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// NonEquitySubClass1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct NonEquitySubClass1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Desc", skip_serializing_if = "Option::is_none") )]
	pub desc: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SgmttnCrit") )]
	pub sgmttn_crit: Vec<NonEquitySubClassSegmentationCriterion1>,
}

impl NonEquitySubClass1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.desc {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "desc is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 1000 {
				return Err(ValidationError::new(1002, "desc exceeds the maximum length of 1000".to_string()));
			}
		}
		for item in &self.sgmttn_crit { item.validate()? }
		Ok(())
	}
}


// NonEquitySubClassSegmentationCriteria1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum NonEquitySubClassSegmentationCriteria1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ASCL") )]
	CodeASCL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BSPD") )]
	CodeBSPD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CNC1") )]
	CodeCNC1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CNC2") )]
	CodeCNC2,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NCCO") )]
	CodeNCCO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CTYP") )]
	CodeCTYP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NCCR") )]
	CodeNCCR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DCSL") )]
	CodeDCSL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DTYP") )]
	CodeDTYP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EQUT") )]
	CodeEQUT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FNC1") )]
	CodeFNC1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FNC2") )]
	CodeFNC2,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FSPD") )]
	CodeFSPD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IIND") )]
	CodeIIND,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IRTC") )]
	CodeIRTC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INC1") )]
	CodeINC1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INC2") )]
	CodeINC2,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ISIN") )]
	CodeISIN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TTMO") )]
	CodeTTMO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PRMT") )]
	CodePRMT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SSRF") )]
	CodeSSRF,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ISPT") )]
	CodeISPT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SRTC") )]
	CodeSRTC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SACL") )]
	CodeSACL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SBPD") )]
	CodeSBPD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TTMS") )]
	CodeTTMS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NCSW") )]
	CodeNCSW,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TTMB") )]
	CodeTTMB,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IOUB") )]
	CodeIOUB,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TOUB") )]
	CodeTOUB,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UISC") )]
	CodeUISC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UIDX") )]
	CodeUIDX,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UINS") )]
	CodeUINS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UIRT") )]
	CodeUIRT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "REOU") )]
	CodeREOU,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UTYP") )]
	CodeUTYP,
}

impl NonEquitySubClassSegmentationCriteria1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// NonEquitySubClassSegmentationCriterion1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct NonEquitySubClassSegmentationCriterion1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CritNm") )]
	pub crit_nm: NonEquitySubClassSegmentationCriteria1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CritVal") )]
	pub crit_val: String,
}

impl NonEquitySubClassSegmentationCriterion1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.crit_nm.validate()?;
		if self.crit_val.chars().count() < 1 {
			return Err(ValidationError::new(1001, "crit_val is shorter than the minimum length of 1".to_string()));
		}
		if self.crit_val.chars().count() > 1000 {
			return Err(ValidationError::new(1002, "crit_val exceeds the maximum length of 1000".to_string()));
		}
		Ok(())
	}
}


// NonFinancialInstitutionSector10 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct NonFinancialInstitutionSector10 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sctr") )]
	pub sctr: Vec<GenericIdentification175>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrThrshld", skip_serializing_if = "Option::is_none") )]
	pub clr_thrshld: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DrctlyLkdActvty", skip_serializing_if = "Option::is_none") )]
	pub drctly_lkd_actvty: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FdrlInstn", skip_serializing_if = "Option::is_none") )]
	pub fdrl_instn: Option<bool>,
}

impl NonFinancialInstitutionSector10 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		for item in &self.sctr { item.validate()? }
		Ok(())
	}
}


// NonFinancialPartySector1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum NonFinancialPartySector1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "WTER") )]
	CodeWTER,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MING") )]
	CodeMING,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MAFG") )]
	CodeMAFG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SPLY") )]
	CodeSPLY,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CSTR") )]
	CodeCSTR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AGRI") )]
	CodeAGRI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ACAF") )]
	CodeACAF,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EDUC") )]
	CodeEDUC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AEAR") )]
	CodeAEAR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FINA") )]
	CodeFINA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "HHSW") )]
	CodeHHSW,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INCO") )]
	CodeINCO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "WRRM") )]
	CodeWRRM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTSA") )]
	CodeOTSA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PSTA") )]
	CodePSTA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PADS") )]
	CodePADS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RESA") )]
	CodeRESA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TRAS") )]
	CodeTRAS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ASSA") )]
	CodeASSA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AHAE") )]
	CodeAHAE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AEOB") )]
	CodeAEOB,
}

impl NonFinancialPartySector1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// NonTradingDayReason1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum NonTradingDayReason1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "THOL") )]
	CodeTHOL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "HALF") )]
	CodeHALF,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PHOL") )]
	CodePHOL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BHOL") )]
	CodeBHOL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "WKND") )]
	CodeWKND,
}

impl NonTradingDayReason1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// NotApplicable1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum NotApplicable1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "NOAP") )]
	CodeNOAP,
}

impl NotApplicable1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// NotAvailable1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum NotAvailable1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "NTAV") )]
	CodeNTAV,
}

impl NotAvailable1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// NotReported1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum NotReported1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "NORP") )]
	CodeNORP,
}

impl NotReported1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// NotionalAmount5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct NotionalAmount5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt", skip_serializing_if = "Option::is_none") )]
	pub amt: Option<AmountAndDirection106>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SchdlPrd", skip_serializing_if = "Option::is_none") )]
	pub schdl_prd: Option<Vec<Schedule11>>,
}

impl NotionalAmount5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.amt { val.validate()? }
		if let Some(ref vec) = self.schdl_prd { for item in vec { item.validate()? } }
		Ok(())
	}
}


// NotionalAmount6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct NotionalAmount6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt", skip_serializing_if = "Option::is_none") )]
	pub amt: Option<AmountAndDirection106>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SchdlPrd", skip_serializing_if = "Option::is_none") )]
	pub schdl_prd: Option<Vec<Schedule11>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ccy", skip_serializing_if = "Option::is_none") )]
	pub ccy: Option<String>,
}

impl NotionalAmount6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.amt { val.validate()? }
		if let Some(ref vec) = self.schdl_prd { for item in vec { item.validate()? } }
		if let Some(ref val) = self.ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ccy does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// NotionalAmount7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct NotionalAmount7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt", skip_serializing_if = "Option::is_none") )]
	pub amt: Option<ActiveOrHistoricCurrencyAnd19DecimalAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AmtInFct", skip_serializing_if = "Option::is_none") )]
	pub amt_in_fct: Option<Vec<ActiveOrHistoricCurrencyAnd19DecimalAmount>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "WghtdAvrgDlta", skip_serializing_if = "Option::is_none") )]
	pub wghtd_avrg_dlta: Option<f64>,
}

impl NotionalAmount7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.amt { val.validate()? }
		if let Some(ref vec) = self.amt_in_fct { for item in vec { item.validate()? } }
		Ok(())
	}
}


// NotionalAmountLegs5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct NotionalAmountLegs5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrstLeg", skip_serializing_if = "Option::is_none") )]
	pub frst_leg: Option<NotionalAmount5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ScndLeg", skip_serializing_if = "Option::is_none") )]
	pub scnd_leg: Option<NotionalAmount6>,
}

impl NotionalAmountLegs5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.frst_leg { val.validate()? }
		if let Some(ref val) = self.scnd_leg { val.validate()? }
		Ok(())
	}
}


// NotionalAmountLegs6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct NotionalAmountLegs6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrstLeg", skip_serializing_if = "Option::is_none") )]
	pub frst_leg: Option<NotionalAmount7>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ScndLeg", skip_serializing_if = "Option::is_none") )]
	pub scnd_leg: Option<NotionalAmount7>,
}

impl NotionalAmountLegs6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.frst_leg { val.validate()? }
		if let Some(ref val) = self.scnd_leg { val.validate()? }
		Ok(())
	}
}


// NotionalQuantity9 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct NotionalQuantity9 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlQty", skip_serializing_if = "Option::is_none") )]
	pub ttl_qty: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnitOfMeasr", skip_serializing_if = "Option::is_none") )]
	pub unit_of_measr: Option<UnitOfMeasure8Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dtls", skip_serializing_if = "Option::is_none") )]
	pub dtls: Option<QuantityOrTerm1Choice>,
}

impl NotionalQuantity9 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.unit_of_measr { val.validate()? }
		if let Some(ref val) = self.dtls { val.validate()? }
		Ok(())
	}
}


// NotionalQuantityLegs5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct NotionalQuantityLegs5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrstLeg", skip_serializing_if = "Option::is_none") )]
	pub frst_leg: Option<NotionalQuantity9>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ScndLeg", skip_serializing_if = "Option::is_none") )]
	pub scnd_leg: Option<NotionalQuantity9>,
}

impl NotionalQuantityLegs5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.frst_leg { val.validate()? }
		if let Some(ref val) = self.scnd_leg { val.validate()? }
		Ok(())
	}
}


// NovationStatus1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum NovationStatus1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "NONO") )]
	CodeNONO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NOVA") )]
	CodeNOVA,
}

impl NovationStatus1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// NumberAndVolume2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct NumberAndVolume2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nb") )]
	pub nb: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Vol") )]
	pub vol: ActiveOrHistoricCurrencyAndAmount,
}

impl NumberAndVolume2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.vol.validate()?;
		Ok(())
	}
}


// NumberOfRecordsPerStatus1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct NumberOfRecordsPerStatus1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtldNbOfRcrds") )]
	pub dtld_nb_of_rcrds: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtldSts") )]
	pub dtld_sts: ReportingRecordStatus1Code,
}

impl NumberOfRecordsPerStatus1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[0-9]{1,15}").unwrap();
		if !pattern.is_match(&self.dtld_nb_of_rcrds) {
			return Err(ValidationError::new(1005, "dtld_nb_of_rcrds does not match the required pattern".to_string()));
		}
		self.dtld_sts.validate()?;
		Ok(())
	}
}


// NumberOfReportsPerStatus4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct NumberOfReportsPerStatus4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtldNbOfRpts") )]
	pub dtld_nb_of_rpts: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtldSts") )]
	pub dtld_sts: PairedReconciled3Code,
}

impl NumberOfReportsPerStatus4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[0-9]{1,15}").unwrap();
		if !pattern.is_match(&self.dtld_nb_of_rpts) {
			return Err(ValidationError::new(1005, "dtld_nb_of_rpts does not match the required pattern".to_string()));
		}
		self.dtld_sts.validate()?;
		Ok(())
	}
}


// NumberOfTransactionsPerValidationRule5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct NumberOfTransactionsPerValidationRule5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtldNb") )]
	pub dtld_nb: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptSts") )]
	pub rpt_sts: Vec<RejectionReason45>,
}

impl NumberOfTransactionsPerValidationRule5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[0-9]{1,15}").unwrap();
		if !pattern.is_match(&self.dtld_nb) {
			return Err(ValidationError::new(1005, "dtld_nb does not match the required pattern".to_string()));
		}
		for item in &self.rpt_sts { item.validate()? }
		Ok(())
	}
}


// NumberOfTransactionsPerValidationRule6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct NumberOfTransactionsPerValidationRule6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtldNb") )]
	pub dtld_nb: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptSts") )]
	pub rpt_sts: Vec<RejectionReason70>,
}

impl NumberOfTransactionsPerValidationRule6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[0-9]{1,15}").unwrap();
		if !pattern.is_match(&self.dtld_nb) {
			return Err(ValidationError::new(1005, "dtld_nb does not match the required pattern".to_string()));
		}
		for item in &self.rpt_sts { item.validate()? }
		Ok(())
	}
}


// OpenInterest1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct OpenInterest1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "GrssNtnlAmt") )]
	pub grss_ntnl_amt: ActiveCurrencyAnd24Amount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfLots", skip_serializing_if = "Option::is_none") )]
	pub nb_of_lots: Option<f64>,
}

impl OpenInterest1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.grss_ntnl_amt.validate()?;
		if let Some(ref val) = self.nb_of_lots {
			if *val < 1.000000 {
				return Err(ValidationError::new(1003, "nb_of_lots is less than the minimum value of 1.000000".to_string()));
			}
		}
		Ok(())
	}
}


// Operation3Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum Operation3Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ANDD") )]
	CodeANDD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ORRR") )]
	CodeORRR,
}

impl Operation3Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// Option12 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Option12 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: OptionType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtOrPrd") )]
	pub dt_or_prd: OptionDateOrPeriod1Choice,
}

impl Option12 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.tp.validate()?;
		self.dt_or_prd.validate()?;
		Ok(())
	}
}


// Option14 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Option14 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "XprtnStyle") )]
	pub xprtn_style: Vec<OptionStyle5Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OptnStyle", skip_serializing_if = "Option::is_none") )]
	pub optn_style: Option<ExoticOptionStyle1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OptnTp", skip_serializing_if = "Option::is_none") )]
	pub optn_tp: Option<OptionType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BrrrInd", skip_serializing_if = "Option::is_none") )]
	pub brrr_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EvtTp", skip_serializing_if = "Option::is_none") )]
	pub evt_tp: Option<OptionEvent2>,
}

impl Option14 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		for item in &self.xprtn_style { item.validate()? }
		if let Some(ref val) = self.optn_style { val.validate()? }
		if let Some(ref val) = self.optn_tp { val.validate()? }
		if let Some(ref val) = self.evt_tp { val.validate()? }
		Ok(())
	}
}


// OptionBarrierLevel1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct OptionBarrierLevel1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sngl", skip_serializing_if = "Option::is_none") )]
	pub sngl: Option<SecuritiesTransactionPrice23Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Mltpl", skip_serializing_if = "Option::is_none") )]
	pub mltpl: Option<OptionMultipleBarrierLevels1>,
}

impl OptionBarrierLevel1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.sngl { val.validate()? }
		if let Some(ref val) = self.mltpl { val.validate()? }
		Ok(())
	}
}


// OptionDateOrPeriod1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct OptionDateOrPeriod1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "EarlstExrcDt", skip_serializing_if = "Option::is_none") )]
	pub earlst_exrc_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtcePrd", skip_serializing_if = "Option::is_none") )]
	pub ntce_prd: Option<f64>,
}

impl OptionDateOrPeriod1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// OptionEvent2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct OptionEvent2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: OptionEventType1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Desc") )]
	pub desc: String,
}

impl OptionEvent2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.tp.validate()?;
		if self.desc.chars().count() < 1 {
			return Err(ValidationError::new(1001, "desc is shorter than the minimum length of 1".to_string()));
		}
		if self.desc.chars().count() > 35 {
			return Err(ValidationError::new(1002, "desc exceeds the maximum length of 35".to_string()));
		}
		Ok(())
	}
}


// OptionEventType1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct OptionEventType1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<OptionEventType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification36>,
}

impl OptionEventType1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// OptionEventType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum OptionEventType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "CLST") )]
	CodeCLST,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CONF") )]
	CodeCONF,
	#[cfg_attr( feature = "derive_serde", serde(rename = "KNIN") )]
	CodeKNIN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "KNOC") )]
	CodeKNOC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TRIG") )]
	CodeTRIG,
}

impl OptionEventType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// OptionMultipleBarrierLevels1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct OptionMultipleBarrierLevels1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "LwrLvl") )]
	pub lwr_lvl: SecuritiesTransactionPrice23Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UpperLvl") )]
	pub upper_lvl: SecuritiesTransactionPrice23Choice,
}

impl OptionMultipleBarrierLevels1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.lwr_lvl.validate()?;
		self.upper_lvl.validate()?;
		Ok(())
	}
}


// OptionOrSwaption11 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct OptionOrSwaption11 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<OptionType2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MbddTp", skip_serializing_if = "Option::is_none") )]
	pub mbdd_tp: Option<EmbeddedType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ExrcStyle", skip_serializing_if = "Option::is_none") )]
	pub exrc_style: Option<Vec<OptionStyle6Code>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ExrcDt", skip_serializing_if = "Option::is_none") )]
	pub exrc_dt: Option<ExerciseDate1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StrkPric", skip_serializing_if = "Option::is_none") )]
	pub strk_pric: Option<SecuritiesTransactionPrice17Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StrkPricSchdl", skip_serializing_if = "Option::is_none") )]
	pub strk_pric_schdl: Option<Vec<Schedule4>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CallAmt", skip_serializing_if = "Option::is_none") )]
	pub call_amt: Option<ActiveOrHistoricCurrencyAnd19DecimalAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PutAmt", skip_serializing_if = "Option::is_none") )]
	pub put_amt: Option<ActiveOrHistoricCurrencyAnd19DecimalAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrmAmt", skip_serializing_if = "Option::is_none") )]
	pub prm_amt: Option<ActiveOrHistoricCurrencyAnd19DecimalAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrmPmtDt", skip_serializing_if = "Option::is_none") )]
	pub prm_pmt_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MtrtyDtOfUndrlyg", skip_serializing_if = "Option::is_none") )]
	pub mtrty_dt_of_undrlyg: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BrrrLvls", skip_serializing_if = "Option::is_none") )]
	pub brrr_lvls: Option<OptionBarrierLevel1Choice>,
}

impl OptionOrSwaption11 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tp { val.validate()? }
		if let Some(ref val) = self.mbdd_tp { val.validate()? }
		if let Some(ref vec) = self.exrc_style { for item in vec { item.validate()? } }
		if let Some(ref val) = self.exrc_dt { val.validate()? }
		if let Some(ref val) = self.strk_pric { val.validate()? }
		if let Some(ref vec) = self.strk_pric_schdl { for item in vec { item.validate()? } }
		if let Some(ref val) = self.call_amt { val.validate()? }
		if let Some(ref val) = self.put_amt { val.validate()? }
		if let Some(ref val) = self.prm_amt { val.validate()? }
		if let Some(ref val) = self.brrr_lvls { val.validate()? }
		Ok(())
	}
}


// OptionParty1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum OptionParty1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "SLLR") )]
	CodeSLLR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BYER") )]
	CodeBYER,
}

impl OptionParty1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// OptionParty3Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum OptionParty3Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "MAKE") )]
	CodeMAKE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TAKE") )]
	CodeTAKE,
}

impl OptionParty3Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// OptionStyle5Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum OptionStyle5Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "AMER") )]
	CodeAMER,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ASIA") )]
	CodeASIA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BERM") )]
	CodeBERM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EURO") )]
	CodeEURO,
}

impl OptionStyle5Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// OptionStyle6Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum OptionStyle6Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "EURO") )]
	CodeEURO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BERM") )]
	CodeBERM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ASIA") )]
	CodeASIA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AMER") )]
	CodeAMER,
}

impl OptionStyle6Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// OptionStyle7Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum OptionStyle7Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "AMER") )]
	CodeAMER,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ASIA") )]
	CodeASIA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BERM") )]
	CodeBERM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EURO") )]
	CodeEURO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
}

impl OptionStyle7Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// OptionType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum OptionType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "CALL") )]
	CodeCALL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PUTO") )]
	CodePUTO,
}

impl OptionType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// OptionType2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum OptionType2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "CALL") )]
	CodeCALL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PUTO") )]
	CodePUTO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
}

impl OptionType2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// OrderClassification2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct OrderClassification2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrdrTp", skip_serializing_if = "Option::is_none") )]
	pub ordr_tp: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrdrTpClssfctn", skip_serializing_if = "Option::is_none") )]
	pub ordr_tp_clssfctn: Option<OrderType3Code>,
}

impl OrderClassification2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ordr_tp {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "ordr_tp is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 50 {
				return Err(ValidationError::new(1002, "ordr_tp exceeds the maximum length of 50".to_string()));
			}
		}
		if let Some(ref val) = self.ordr_tp_clssfctn { val.validate()? }
		Ok(())
	}
}


// OrderData3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct OrderData3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrdrIdData") )]
	pub ordr_id_data: OrderIdentification2,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AuctnData", skip_serializing_if = "Option::is_none") )]
	pub auctn_data: Option<AuctionData2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrdrData", skip_serializing_if = "Option::is_none") )]
	pub ordr_data: Option<OrderData4>,
}

impl OrderData3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.ordr_id_data.validate()?;
		if let Some(ref val) = self.auctn_data { val.validate()? }
		if let Some(ref val) = self.ordr_data { val.validate()? }
		Ok(())
	}
}


// OrderData4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct OrderData4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubmitgNtty", skip_serializing_if = "Option::is_none") )]
	pub submitg_ntty: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DrctElctrncAccs", skip_serializing_if = "Option::is_none") )]
	pub drct_elctrnc_accs: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClntId", skip_serializing_if = "Option::is_none") )]
	pub clnt_id: Option<PersonOrOrganisation4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InvstmtDcsnPrsn", skip_serializing_if = "Option::is_none") )]
	pub invstmt_dcsn_prsn: Option<ExecutingParty2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ExctgPrsn", skip_serializing_if = "Option::is_none") )]
	pub exctg_prsn: Option<ExecutingParty2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NonExctgBrkr", skip_serializing_if = "Option::is_none") )]
	pub non_exctg_brkr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradgCpcty", skip_serializing_if = "Option::is_none") )]
	pub tradg_cpcty: Option<RegulatoryTradingCapacity1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LqdtyPrvsnActvty", skip_serializing_if = "Option::is_none") )]
	pub lqdty_prvsn_actvty: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrdrClssfctn", skip_serializing_if = "Option::is_none") )]
	pub ordr_clssfctn: Option<OrderClassification2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrdrPrics", skip_serializing_if = "Option::is_none") )]
	pub ordr_prics: Option<OrderPriceData2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstrData", skip_serializing_if = "Option::is_none") )]
	pub instr_data: Option<OrderInstructionData2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxData", skip_serializing_if = "Option::is_none") )]
	pub tx_data: Option<TransactionData3>,
}

impl OrderData4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.submitg_ntty {
			let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "submitg_ntty does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.clnt_id { val.validate()? }
		if let Some(ref val) = self.invstmt_dcsn_prsn { val.validate()? }
		if let Some(ref val) = self.exctg_prsn { val.validate()? }
		if let Some(ref val) = self.non_exctg_brkr {
			let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "non_exctg_brkr does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.tradg_cpcty { val.validate()? }
		if let Some(ref val) = self.ordr_clssfctn { val.validate()? }
		if let Some(ref val) = self.ordr_prics { val.validate()? }
		if let Some(ref val) = self.instr_data { val.validate()? }
		if let Some(ref val) = self.tx_data { val.validate()? }
		Ok(())
	}
}


// OrderEventType1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct OrderEventType1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<OrderEventType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification30>,
}

impl OrderEventType1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// OrderEventType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum OrderEventType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "CAME") )]
	CodeCAME,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CAMO") )]
	CodeCAMO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CHME") )]
	CodeCHME,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CHMO") )]
	CodeCHMO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EXPI") )]
	CodeEXPI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FILL") )]
	CodeFILL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NEWO") )]
	CodeNEWO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PARF") )]
	CodePARF,
	#[cfg_attr( feature = "derive_serde", serde(rename = "REMA") )]
	CodeREMA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "REMO") )]
	CodeREMO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "REMH") )]
	CodeREMH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "REME") )]
	CodeREME,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TRIG") )]
	CodeTRIG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RFQS") )]
	CodeRFQS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RFQR") )]
	CodeRFQR,
}

impl OrderEventType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// OrderIdentification2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct OrderIdentification2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrdrBookId") )]
	pub ordr_book_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SeqNb") )]
	pub seq_nb: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prty", skip_serializing_if = "Option::is_none") )]
	pub prty: Option<OrderPriority1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TmStmp") )]
	pub tm_stmp: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradVn") )]
	pub trad_vn: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FinInstrm") )]
	pub fin_instrm: FinancialInstrument99Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrdrId", skip_serializing_if = "Option::is_none") )]
	pub ordr_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtOfRct", skip_serializing_if = "Option::is_none") )]
	pub dt_of_rct: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VldtyPrd", skip_serializing_if = "Option::is_none") )]
	pub vldty_prd: Option<ValidityPeriod1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrdrRstrctn", skip_serializing_if = "Option::is_none") )]
	pub ordr_rstrctn: Option<Vec<OrderRestriction1Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VldtyDtTm", skip_serializing_if = "Option::is_none") )]
	pub vldty_dt_tm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EvtTp", skip_serializing_if = "Option::is_none") )]
	pub evt_tp: Option<OrderEventType1Choice>,
}

impl OrderIdentification2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.ordr_book_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "ordr_book_id is shorter than the minimum length of 1".to_string()));
		}
		if self.ordr_book_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "ordr_book_id exceeds the maximum length of 35".to_string()));
		}
		if self.seq_nb < 1.000000 {
			return Err(ValidationError::new(1003, "seq_nb is less than the minimum value of 1.000000".to_string()));
		}
		if let Some(ref val) = self.prty { val.validate()? }
		let pattern = Regex::new("[A-Z0-9]{4,4}").unwrap();
		if !pattern.is_match(&self.trad_vn) {
			return Err(ValidationError::new(1005, "trad_vn does not match the required pattern".to_string()));
		}
		self.fin_instrm.validate()?;
		if let Some(ref val) = self.ordr_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "ordr_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 50 {
				return Err(ValidationError::new(1002, "ordr_id exceeds the maximum length of 50".to_string()));
			}
		}
		if let Some(ref val) = self.vldty_prd { val.validate()? }
		if let Some(ref vec) = self.ordr_rstrctn { for item in vec { item.validate()? } }
		if let Some(ref val) = self.evt_tp { val.validate()? }
		Ok(())
	}
}


// OrderInstructionData2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct OrderInstructionData2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BuySellInd", skip_serializing_if = "Option::is_none") )]
	pub buy_sell_ind: Option<Side6Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrdrVldtySts", skip_serializing_if = "Option::is_none") )]
	pub ordr_vldty_sts: Option<OrderStatus10Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrdrSts", skip_serializing_if = "Option::is_none") )]
	pub ordr_sts: Option<Vec<OrderStatus11Code>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InitlQty", skip_serializing_if = "Option::is_none") )]
	pub initl_qty: Option<FinancialInstrumentQuantity25Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RmngQty", skip_serializing_if = "Option::is_none") )]
	pub rmng_qty: Option<FinancialInstrumentQuantity25Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DispdQty", skip_serializing_if = "Option::is_none") )]
	pub dispd_qty: Option<FinancialInstrumentQuantity25Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MinAccptblQty", skip_serializing_if = "Option::is_none") )]
	pub min_accptbl_qty: Option<FinancialInstrumentQuantity25Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MinExctbl", skip_serializing_if = "Option::is_none") )]
	pub min_exctbl: Option<MinimumExecutable1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PssvOnlyInd", skip_serializing_if = "Option::is_none") )]
	pub pssv_only_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SlfExctnPrvntn", skip_serializing_if = "Option::is_none") )]
	pub slf_exctn_prvntn: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RtgStrtgy", skip_serializing_if = "Option::is_none") )]
	pub rtg_strtgy: Option<String>,
}

impl OrderInstructionData2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.buy_sell_ind { val.validate()? }
		if let Some(ref val) = self.ordr_vldty_sts { val.validate()? }
		if let Some(ref vec) = self.ordr_sts { for item in vec { item.validate()? } }
		if let Some(ref val) = self.initl_qty { val.validate()? }
		if let Some(ref val) = self.rmng_qty { val.validate()? }
		if let Some(ref val) = self.dispd_qty { val.validate()? }
		if let Some(ref val) = self.min_accptbl_qty { val.validate()? }
		if let Some(ref val) = self.min_exctbl { val.validate()? }
		if let Some(ref val) = self.rtg_strtgy {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "rtg_strtgy is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 50 {
				return Err(ValidationError::new(1002, "rtg_strtgy exceeds the maximum length of 50".to_string()));
			}
		}
		Ok(())
	}
}


// OrderPriceData2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct OrderPriceData2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "LmtPric", skip_serializing_if = "Option::is_none") )]
	pub lmt_pric: Option<SecuritiesTransactionPrice2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StopPric", skip_serializing_if = "Option::is_none") )]
	pub stop_pric: Option<SecuritiesTransactionPrice2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlLmtPric", skip_serializing_if = "Option::is_none") )]
	pub addtl_lmt_pric: Option<SecuritiesTransactionPrice2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PggdPric", skip_serializing_if = "Option::is_none") )]
	pub pggd_pric: Option<SecuritiesTransactionPrice2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CcyScndLeg", skip_serializing_if = "Option::is_none") )]
	pub ccy_scnd_leg: Option<String>,
}

impl OrderPriceData2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.lmt_pric { val.validate()? }
		if let Some(ref val) = self.stop_pric { val.validate()? }
		if let Some(ref val) = self.addtl_lmt_pric { val.validate()? }
		if let Some(ref val) = self.pggd_pric { val.validate()? }
		if let Some(ref val) = self.ccy_scnd_leg {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ccy_scnd_leg does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// OrderPriority1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct OrderPriority1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TmStmp", skip_serializing_if = "Option::is_none") )]
	pub tm_stmp: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sz", skip_serializing_if = "Option::is_none") )]
	pub sz: Option<f64>,
}

impl OrderPriority1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.sz {
			if *val < 1.000000 {
				return Err(ValidationError::new(1003, "sz is less than the minimum value of 1.000000".to_string()));
			}
		}
		Ok(())
	}
}


// OrderReport2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct OrderReport2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "New", skip_serializing_if = "Option::is_none") )]
	pub new: Option<NewOrderReport2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cxl", skip_serializing_if = "Option::is_none") )]
	pub cxl: Option<CancelOrderReport1>,
}

impl OrderReport2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.new { val.validate()? }
		if let Some(ref val) = self.cxl { val.validate()? }
		Ok(())
	}
}


// OrderRestriction1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct OrderRestriction1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrdrRstrctnCd", skip_serializing_if = "Option::is_none") )]
	pub ordr_rstrctn_cd: Option<OrderRestrictionType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification30>,
}

impl OrderRestriction1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ordr_rstrctn_cd { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// OrderRestrictionType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum OrderRestrictionType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "SESR") )]
	CodeSESR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VFAR") )]
	CodeVFAR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VFCR") )]
	CodeVFCR,
}

impl OrderRestrictionType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// OrderStatus10Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum OrderStatus10Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ACTI") )]
	CodeACTI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INAC") )]
	CodeINAC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SUSP") )]
	CodeSUSP,
}

impl OrderStatus10Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// OrderStatus11Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum OrderStatus11Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "FIRM") )]
	CodeFIRM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IMPL") )]
	CodeIMPL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INDI") )]
	CodeINDI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ROUT") )]
	CodeROUT,
}

impl OrderStatus11Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// OrderType3Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum OrderType3Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "LMTO") )]
	CodeLMTO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "STOP") )]
	CodeSTOP,
}

impl OrderType3Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// OrganisationIdentification15Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct OrganisationIdentification15Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "LEI", skip_serializing_if = "Option::is_none") )]
	pub lei: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<OrganisationIdentification38>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AnyBIC", skip_serializing_if = "Option::is_none") )]
	pub any_bic: Option<String>,
}

impl OrganisationIdentification15Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.lei {
			let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "lei does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.othr { val.validate()? }
		if let Some(ref val) = self.any_bic {
			let pattern = Regex::new("[A-Z0-9]{4,4}[A-Z]{2,2}[A-Z0-9]{2,2}([A-Z0-9]{3,3}){0,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "any_bic does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// OrganisationIdentification28 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct OrganisationIdentification28 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm", skip_serializing_if = "Option::is_none") )]
	pub nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstlAdr", skip_serializing_if = "Option::is_none") )]
	pub pstl_adr: Option<PostalAddress6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<OrganisationIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtryOfRes", skip_serializing_if = "Option::is_none") )]
	pub ctry_of_res: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtctDtls") )]
	pub ctct_dtls: ContactDetails2,
}

impl OrganisationIdentification28 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "nm exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.pstl_adr { val.validate()? }
		if let Some(ref val) = self.id { val.validate()? }
		if let Some(ref val) = self.ctry_of_res {
			let pattern = Regex::new("[A-Z]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ctry_of_res does not match the required pattern".to_string()));
			}
		}
		self.ctct_dtls.validate()?;
		Ok(())
	}
}


// OrganisationIdentification38 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct OrganisationIdentification38 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: GenericIdentification175,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm", skip_serializing_if = "Option::is_none") )]
	pub nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dmcl", skip_serializing_if = "Option::is_none") )]
	pub dmcl: Option<String>,
}

impl OrganisationIdentification38 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.id.validate()?;
		if let Some(ref val) = self.nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 105 {
				return Err(ValidationError::new(1002, "nm exceeds the maximum length of 105".to_string()));
			}
		}
		if let Some(ref val) = self.dmcl {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "dmcl is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 500 {
				return Err(ValidationError::new(1002, "dmcl exceeds the maximum length of 500".to_string()));
			}
		}
		Ok(())
	}
}


// OrganisationIdentification39 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct OrganisationIdentification39 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AnyBIC", skip_serializing_if = "Option::is_none") )]
	pub any_bic: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LEI", skip_serializing_if = "Option::is_none") )]
	pub lei: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<Vec<GenericOrganisationIdentification3>>,
}

impl OrganisationIdentification39 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.any_bic {
			let pattern = Regex::new("[A-Z0-9]{4,4}[A-Z]{2,2}[A-Z0-9]{2,2}([A-Z0-9]{3,3}){0,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "any_bic does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.lei {
			let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "lei does not match the required pattern".to_string()));
			}
		}
		if let Some(ref vec) = self.othr { for item in vec { item.validate()? } }
		Ok(())
	}
}


// OrganisationIdentification8 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct OrganisationIdentification8 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AnyBIC", skip_serializing_if = "Option::is_none") )]
	pub any_bic: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<Vec<GenericOrganisationIdentification1>>,
}

impl OrganisationIdentification8 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.any_bic {
			let pattern = Regex::new("[A-Z]{6,6}[A-Z2-9][A-NP-Z0-9]([A-Z0-9]{3,3}){0,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "any_bic does not match the required pattern".to_string()));
			}
		}
		if let Some(ref vec) = self.othr { for item in vec { item.validate()? } }
		Ok(())
	}
}


// OrganisationIdentificationSchemeName1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct OrganisationIdentificationSchemeName1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl OrganisationIdentificationSchemeName1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// OriginalMessage6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct OriginalMessage6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlSndr", skip_serializing_if = "Option::is_none") )]
	pub orgnl_sndr: Option<Party50Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlMsgId") )]
	pub orgnl_msg_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlMsgNmId") )]
	pub orgnl_msg_nm_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlCreDtTm", skip_serializing_if = "Option::is_none") )]
	pub orgnl_cre_dt_tm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlPackgId", skip_serializing_if = "Option::is_none") )]
	pub orgnl_packg_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlRcrdId") )]
	pub orgnl_rcrd_id: String,
}

impl OriginalMessage6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.orgnl_sndr { val.validate()? }
		if self.orgnl_msg_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "orgnl_msg_id is shorter than the minimum length of 1".to_string()));
		}
		if self.orgnl_msg_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "orgnl_msg_id exceeds the maximum length of 35".to_string()));
		}
		if self.orgnl_msg_nm_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "orgnl_msg_nm_id is shorter than the minimum length of 1".to_string()));
		}
		if self.orgnl_msg_nm_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "orgnl_msg_nm_id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.orgnl_packg_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_packg_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_packg_id exceeds the maximum length of 35".to_string()));
			}
		}
		if self.orgnl_rcrd_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "orgnl_rcrd_id is shorter than the minimum length of 1".to_string()));
		}
		if self.orgnl_rcrd_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "orgnl_rcrd_id exceeds the maximum length of 35".to_string()));
		}
		Ok(())
	}
}


// OriginalMessage7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct OriginalMessage7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlSndr", skip_serializing_if = "Option::is_none") )]
	pub orgnl_sndr: Option<Party50Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlMsgId") )]
	pub orgnl_msg_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlMsgNmId") )]
	pub orgnl_msg_nm_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlCreDtTm", skip_serializing_if = "Option::is_none") )]
	pub orgnl_cre_dt_tm: Option<String>,
}

impl OriginalMessage7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.orgnl_sndr { val.validate()? }
		if self.orgnl_msg_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "orgnl_msg_id is shorter than the minimum length of 1".to_string()));
		}
		if self.orgnl_msg_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "orgnl_msg_id exceeds the maximum length of 35".to_string()));
		}
		if self.orgnl_msg_nm_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "orgnl_msg_nm_id is shorter than the minimum length of 1".to_string()));
		}
		if self.orgnl_msg_nm_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "orgnl_msg_nm_id exceeds the maximum length of 35".to_string()));
		}
		Ok(())
	}
}


// OriginalReportStatistics3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct OriginalReportStatistics3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlNbOfRcrds") )]
	pub ttl_nb_of_rcrds: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfRcrdsPerSts") )]
	pub nb_of_rcrds_per_sts: Vec<NumberOfRecordsPerStatus1>,
}

impl OriginalReportStatistics3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[0-9]{1,15}").unwrap();
		if !pattern.is_match(&self.ttl_nb_of_rcrds) {
			return Err(ValidationError::new(1005, "ttl_nb_of_rcrds does not match the required pattern".to_string()));
		}
		for item in &self.nb_of_rcrds_per_sts { item.validate()? }
		Ok(())
	}
}


// OtherC10CommodityDeliverable2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct OtherC10CommodityDeliverable2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType11Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType47Code>,
}

impl OtherC10CommodityDeliverable2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		Ok(())
	}
}


// OtherC10CommodityNonDeliverable2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct OtherC10CommodityNonDeliverable2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType11Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType48Code>,
}

impl OtherC10CommodityNonDeliverable2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		Ok(())
	}
}


// OtherContact1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct OtherContact1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChanlTp") )]
	pub chanl_tp: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<String>,
}

impl OtherContact1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.chanl_tp.chars().count() < 1 {
			return Err(ValidationError::new(1001, "chanl_tp is shorter than the minimum length of 1".to_string()));
		}
		if self.chanl_tp.chars().count() > 4 {
			return Err(ValidationError::new(1002, "chanl_tp exceeds the maximum length of 4".to_string()));
		}
		if let Some(ref val) = self.id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 128 {
				return Err(ValidationError::new(1002, "id exceeds the maximum length of 128".to_string()));
			}
		}
		Ok(())
	}
}


// OtherIdentification1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct OtherIdentification1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sfx", skip_serializing_if = "Option::is_none") )]
	pub sfx: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: IdentificationSource3Choice,
}

impl OtherIdentification1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.sfx {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "sfx is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 16 {
				return Err(ValidationError::new(1002, "sfx exceeds the maximum length of 16".to_string()));
			}
		}
		self.tp.validate()?;
		Ok(())
	}
}


// OtherInvestment1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct OtherInvestment1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Desc") )]
	pub desc: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveCurrencyAndAmount,
}

impl OtherInvestment1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.desc.chars().count() < 1 {
			return Err(ValidationError::new(1001, "desc is shorter than the minimum length of 1".to_string()));
		}
		if self.desc.chars().count() > 140 {
			return Err(ValidationError::new(1002, "desc exceeds the maximum length of 140".to_string()));
		}
		self.amt.validate()?;
		Ok(())
	}
}


// OtherPayment5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct OtherPayment5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtAmt", skip_serializing_if = "Option::is_none") )]
	pub pmt_amt: Option<AmountAndDirection106>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtTp", skip_serializing_if = "Option::is_none") )]
	pub pmt_tp: Option<PaymentType5Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtDt", skip_serializing_if = "Option::is_none") )]
	pub pmt_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtPyer", skip_serializing_if = "Option::is_none") )]
	pub pmt_pyer: Option<PartyIdentification236Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtRcvr", skip_serializing_if = "Option::is_none") )]
	pub pmt_rcvr: Option<PartyIdentification236Choice>,
}

impl OtherPayment5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.pmt_amt { val.validate()? }
		if let Some(ref val) = self.pmt_tp { val.validate()? }
		if let Some(ref val) = self.pmt_pyer { val.validate()? }
		if let Some(ref val) = self.pmt_rcvr { val.validate()? }
		Ok(())
	}
}


// OtherPayment6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct OtherPayment6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtCcy", skip_serializing_if = "Option::is_none") )]
	pub pmt_ccy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtTp", skip_serializing_if = "Option::is_none") )]
	pub pmt_tp: Option<PaymentType5Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtDt", skip_serializing_if = "Option::is_none") )]
	pub pmt_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtPyer", skip_serializing_if = "Option::is_none") )]
	pub pmt_pyer: Option<PartyIdentification236Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtRcvr", skip_serializing_if = "Option::is_none") )]
	pub pmt_rcvr: Option<PartyIdentification236Choice>,
}

impl OtherPayment6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.pmt_ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "pmt_ccy does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.pmt_tp { val.validate()? }
		if let Some(ref val) = self.pmt_pyer { val.validate()? }
		if let Some(ref val) = self.pmt_rcvr { val.validate()? }
		Ok(())
	}
}


// OvernightIndexSwap4Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct OvernightIndexSwap4Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DataSetActn", skip_serializing_if = "Option::is_none") )]
	pub data_set_actn: Option<ReportPeriodActivity3Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tx", skip_serializing_if = "Option::is_none") )]
	pub tx: Option<Vec<OvernightIndexSwapTransaction4>>,
}

impl OvernightIndexSwap4Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.data_set_actn { val.validate()? }
		if let Some(ref vec) = self.tx { for item in vec { item.validate()? } }
		Ok(())
	}
}


// OvernightIndexSwapTransaction4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct OvernightIndexSwapTransaction4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptdTxSts") )]
	pub rptd_tx_sts: TransactionOperationType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NvtnSts", skip_serializing_if = "Option::is_none") )]
	pub nvtn_sts: Option<NovationStatus1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BrnchId", skip_serializing_if = "Option::is_none") )]
	pub brnch_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnqTxIdr", skip_serializing_if = "Option::is_none") )]
	pub unq_tx_idr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrtryTxId") )]
	pub prtry_tx_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RltdPrtryTxId", skip_serializing_if = "Option::is_none") )]
	pub rltd_prtry_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPtyPrtryTxId", skip_serializing_if = "Option::is_none") )]
	pub ctr_pty_prtry_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPtyId") )]
	pub ctr_pty_id: CounterpartyIdentification3Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradDt") )]
	pub trad_dt: DateAndDateTimeChoice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StartDt") )]
	pub start_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MtrtyDt") )]
	pub mtrty_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FxdIntrstRate") )]
	pub fxd_intrst_rate: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxTp") )]
	pub tx_tp: OvernightIndexSwapType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxNmnlAmt") )]
	pub tx_nmnl_amt: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl OvernightIndexSwapTransaction4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.rptd_tx_sts.validate()?;
		if let Some(ref val) = self.nvtn_sts { val.validate()? }
		if let Some(ref val) = self.brnch_id {
			let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "brnch_id does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.unq_tx_idr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "unq_tx_idr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 105 {
				return Err(ValidationError::new(1002, "unq_tx_idr exceeds the maximum length of 105".to_string()));
			}
		}
		if self.prtry_tx_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "prtry_tx_id is shorter than the minimum length of 1".to_string()));
		}
		if self.prtry_tx_id.chars().count() > 105 {
			return Err(ValidationError::new(1002, "prtry_tx_id exceeds the maximum length of 105".to_string()));
		}
		if let Some(ref val) = self.rltd_prtry_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "rltd_prtry_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 105 {
				return Err(ValidationError::new(1002, "rltd_prtry_tx_id exceeds the maximum length of 105".to_string()));
			}
		}
		if let Some(ref val) = self.ctr_pty_prtry_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "ctr_pty_prtry_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 105 {
				return Err(ValidationError::new(1002, "ctr_pty_prtry_tx_id exceeds the maximum length of 105".to_string()));
			}
		}
		self.ctr_pty_id.validate()?;
		self.trad_dt.validate()?;
		self.tx_tp.validate()?;
		self.tx_nmnl_amt.validate()?;
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// OvernightIndexSwapType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum OvernightIndexSwapType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "PAID") )]
	CodePAID,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RECE") )]
	CodeRECE,
}

impl OvernightIndexSwapType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// PTRREvent2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PTRREvent2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tchnq") )]
	pub tchnq: RiskReductionService1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SvcPrvdr", skip_serializing_if = "Option::is_none") )]
	pub svc_prvdr: Option<OrganisationIdentification15Choice>,
}

impl PTRREvent2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.tchnq.validate()?;
		if let Some(ref val) = self.svc_prvdr { val.validate()? }
		Ok(())
	}
}


// PTRREvent3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PTRREvent3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tchnq", skip_serializing_if = "Option::is_none") )]
	pub tchnq: Option<RiskReductionService1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SvcPrvdr", skip_serializing_if = "Option::is_none") )]
	pub svc_prvdr: Option<OrganisationIdentification15Choice>,
}

impl PTRREvent3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tchnq { val.validate()? }
		if let Some(ref val) = self.svc_prvdr { val.validate()? }
		Ok(())
	}
}


// Package4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Package4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CmplxTradId", skip_serializing_if = "Option::is_none") )]
	pub cmplx_trad_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FxSwpLkId", skip_serializing_if = "Option::is_none") )]
	pub fx_swp_lk_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pric", skip_serializing_if = "Option::is_none") )]
	pub pric: Option<SecuritiesTransactionPrice17Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sprd", skip_serializing_if = "Option::is_none") )]
	pub sprd: Option<SecuritiesTransactionPrice20Choice>,
}

impl Package4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cmplx_trad_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cmplx_trad_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 100 {
				return Err(ValidationError::new(1002, "cmplx_trad_id exceeds the maximum length of 100".to_string()));
			}
		}
		if let Some(ref val) = self.fx_swp_lk_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "fx_swp_lk_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 100 {
				return Err(ValidationError::new(1002, "fx_swp_lk_id exceeds the maximum length of 100".to_string()));
			}
		}
		if let Some(ref val) = self.pric { val.validate()? }
		if let Some(ref val) = self.sprd { val.validate()? }
		Ok(())
	}
}


// Pagination1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Pagination1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PgNb") )]
	pub pg_nb: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LastPgInd") )]
	pub last_pg_ind: bool,
}

impl Pagination1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[0-9]{1,5}").unwrap();
		if !pattern.is_match(&self.pg_nb) {
			return Err(ValidationError::new(1005, "pg_nb does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// PairedReconciled3Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum PairedReconciled3Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "CLRC") )]
	CodeCLRC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LNRC") )]
	CodeLNRC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PARD") )]
	CodePARD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RECO") )]
	CodeRECO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UNPR") )]
	CodeUNPR,
}

impl PairedReconciled3Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// PairingStatus1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum PairingStatus1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "PARD") )]
	CodePARD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UNPR") )]
	CodeUNPR,
}

impl PairingStatus1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// PaperCommodityContainerBoard1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PaperCommodityContainerBoard1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType8Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType35Code>,
}

impl PaperCommodityContainerBoard1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		Ok(())
	}
}


// PaperCommodityContainerBoard2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PaperCommodityContainerBoard2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType8Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType35Code>,
}

impl PaperCommodityContainerBoard2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		Ok(())
	}
}


// PaperCommodityNewsprint1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PaperCommodityNewsprint1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType8Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType36Code>,
}

impl PaperCommodityNewsprint1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		Ok(())
	}
}


// PaperCommodityNewsprint2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PaperCommodityNewsprint2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType8Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType36Code>,
}

impl PaperCommodityNewsprint2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		Ok(())
	}
}


// PaperCommodityOther1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PaperCommodityOther1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType8Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType49Code>,
}

impl PaperCommodityOther1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		Ok(())
	}
}


// PaperCommodityPulp1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PaperCommodityPulp1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType8Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType37Code>,
}

impl PaperCommodityPulp1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		Ok(())
	}
}


// PaperCommodityPulp2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PaperCommodityPulp2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType8Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType37Code>,
}

impl PaperCommodityPulp2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		Ok(())
	}
}


// PaperCommodityRecoveredPaper1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PaperCommodityRecoveredPaper1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType8Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType38Code>,
}

impl PaperCommodityRecoveredPaper1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		Ok(())
	}
}


// PaperCommodityRecoveredPaper2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PaperCommodityRecoveredPaper2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType8Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType49Code>,
}

impl PaperCommodityRecoveredPaper2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		Ok(())
	}
}


// PaperCommodityRecoveredPaper3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PaperCommodityRecoveredPaper3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType8Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType50Code>,
}

impl PaperCommodityRecoveredPaper3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		Ok(())
	}
}


// Party11Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Party11Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgId", skip_serializing_if = "Option::is_none") )]
	pub org_id: Option<OrganisationIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrvtId", skip_serializing_if = "Option::is_none") )]
	pub prvt_id: Option<PersonIdentification5>,
}

impl Party11Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.org_id { val.validate()? }
		if let Some(ref val) = self.prvt_id { val.validate()? }
		Ok(())
	}
}


// Party50Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Party50Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pty", skip_serializing_if = "Option::is_none") )]
	pub pty: Option<PartyIdentification272>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Agt", skip_serializing_if = "Option::is_none") )]
	pub agt: Option<BranchAndFinancialInstitutionIdentification8>,
}

impl Party50Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.pty { val.validate()? }
		if let Some(ref val) = self.agt { val.validate()? }
		Ok(())
	}
}


// Party52Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Party52Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgId", skip_serializing_if = "Option::is_none") )]
	pub org_id: Option<OrganisationIdentification39>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrvtId", skip_serializing_if = "Option::is_none") )]
	pub prvt_id: Option<PersonIdentification18>,
}

impl Party52Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.org_id { val.validate()? }
		if let Some(ref val) = self.prvt_id { val.validate()? }
		Ok(())
	}
}


// PartyCancellation1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PartyCancellation1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechRcrdId", skip_serializing_if = "Option::is_none") )]
	pub tech_rcrd_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: PartyIdentification136,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl PartyCancellation1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tech_rcrd_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tech_rcrd_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "tech_rcrd_id exceeds the maximum length of 35".to_string()));
			}
		}
		self.id.validate()?;
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// PartyDetail1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PartyDetail1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FullNm", skip_serializing_if = "Option::is_none") )]
	pub full_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ctry", skip_serializing_if = "Option::is_none") )]
	pub ctry: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PtyTp") )]
	pub pty_tp: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SprvsgAuthrty") )]
	pub sprvsg_authrty: SupervisingAuthorityIdentification1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstlAdr", skip_serializing_if = "Option::is_none") )]
	pub pstl_adr: Option<PostalAddress6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ctct", skip_serializing_if = "Option::is_none") )]
	pub ctct: Option<CommunicationAddress7>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cmnt", skip_serializing_if = "Option::is_none") )]
	pub cmnt: Option<String>,
}

impl PartyDetail1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.full_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "full_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 350 {
				return Err(ValidationError::new(1002, "full_nm exceeds the maximum length of 350".to_string()));
			}
		}
		if let Some(ref val) = self.ctry {
			let pattern = Regex::new("[A-Z]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ctry does not match the required pattern".to_string()));
			}
		}
		if self.pty_tp.chars().count() < 1 {
			return Err(ValidationError::new(1001, "pty_tp is shorter than the minimum length of 1".to_string()));
		}
		if self.pty_tp.chars().count() > 10 {
			return Err(ValidationError::new(1002, "pty_tp exceeds the maximum length of 10".to_string()));
		}
		self.sprvsg_authrty.validate()?;
		if let Some(ref val) = self.pstl_adr { val.validate()? }
		if let Some(ref val) = self.ctct { val.validate()? }
		if let Some(ref val) = self.cmnt {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cmnt is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 20000 {
				return Err(ValidationError::new(1002, "cmnt exceeds the maximum length of 20000".to_string()));
			}
		}
		Ok(())
	}
}


// PartyExceptionType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum PartyExceptionType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "AGGR") )]
	CodeAGGR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PNAL") )]
	CodePNAL,
}

impl PartyExceptionType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// PartyIdentification116 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PartyIdentification116 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PtyId") )]
	pub pty_id: OrganisationIdentification28,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LglOrg", skip_serializing_if = "Option::is_none") )]
	pub lgl_org: Option<LegalOrganisation1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TaxPty", skip_serializing_if = "Option::is_none") )]
	pub tax_pty: Option<TaxParty1>,
}

impl PartyIdentification116 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.pty_id.validate()?;
		if let Some(ref val) = self.lgl_org { val.validate()? }
		if let Some(ref val) = self.tax_pty { val.validate()? }
		Ok(())
	}
}


// PartyIdentification118Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PartyIdentification118Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "LEI", skip_serializing_if = "Option::is_none") )]
	pub lei: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification168>,
}

impl PartyIdentification118Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.lei {
			let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "lei does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// PartyIdentification120Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PartyIdentification120Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AnyBIC", skip_serializing_if = "Option::is_none") )]
	pub any_bic: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrtryId", skip_serializing_if = "Option::is_none") )]
	pub prtry_id: Option<GenericIdentification36>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NmAndAdr", skip_serializing_if = "Option::is_none") )]
	pub nm_and_adr: Option<NameAndAddress5>,
}

impl PartyIdentification120Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.any_bic {
			let pattern = Regex::new("[A-Z0-9]{4,4}[A-Z]{2,2}[A-Z0-9]{2,2}([A-Z0-9]{3,3}){0,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "any_bic does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.prtry_id { val.validate()? }
		if let Some(ref val) = self.nm_and_adr { val.validate()? }
		Ok(())
	}
}


// PartyIdentification121Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PartyIdentification121Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AnyBIC", skip_serializing_if = "Option::is_none") )]
	pub any_bic: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LglNttyIdr", skip_serializing_if = "Option::is_none") )]
	pub lgl_ntty_idr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NmAndAdr", skip_serializing_if = "Option::is_none") )]
	pub nm_and_adr: Option<NameAndAddress5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrtryId", skip_serializing_if = "Option::is_none") )]
	pub prtry_id: Option<GenericIdentification1>,
}

impl PartyIdentification121Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.any_bic {
			let pattern = Regex::new("[A-Z0-9]{4,4}[A-Z]{2,2}[A-Z0-9]{2,2}([A-Z0-9]{3,3}){0,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "any_bic does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.lgl_ntty_idr {
			let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "lgl_ntty_idr does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.nm_and_adr { val.validate()? }
		if let Some(ref val) = self.prtry_id { val.validate()? }
		Ok(())
	}
}


// PartyIdentification136 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PartyIdentification136 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: PartyIdentification120Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LEI", skip_serializing_if = "Option::is_none") )]
	pub lei: Option<String>,
}

impl PartyIdentification136 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.id.validate()?;
		if let Some(ref val) = self.lei {
			let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "lei does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// PartyIdentification236Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PartyIdentification236Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Lgl", skip_serializing_if = "Option::is_none") )]
	pub lgl: Option<OrganisationIdentification15Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ntrl", skip_serializing_if = "Option::is_none") )]
	pub ntrl: Option<NaturalPersonIdentification2>,
}

impl PartyIdentification236Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.lgl { val.validate()? }
		if let Some(ref val) = self.ntrl { val.validate()? }
		Ok(())
	}
}


// PartyIdentification248Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PartyIdentification248Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Lgl", skip_serializing_if = "Option::is_none") )]
	pub lgl: Option<LegalPersonIdentification1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ntrl", skip_serializing_if = "Option::is_none") )]
	pub ntrl: Option<NaturalPersonIdentification3>,
}

impl PartyIdentification248Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.lgl { val.validate()? }
		if let Some(ref val) = self.ntrl { val.validate()? }
		Ok(())
	}
}


// PartyIdentification272 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PartyIdentification272 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm", skip_serializing_if = "Option::is_none") )]
	pub nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstlAdr", skip_serializing_if = "Option::is_none") )]
	pub pstl_adr: Option<PostalAddress27>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<Party52Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtryOfRes", skip_serializing_if = "Option::is_none") )]
	pub ctry_of_res: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtctDtls", skip_serializing_if = "Option::is_none") )]
	pub ctct_dtls: Option<Contact13>,
}

impl PartyIdentification272 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "nm exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.pstl_adr { val.validate()? }
		if let Some(ref val) = self.id { val.validate()? }
		if let Some(ref val) = self.ctry_of_res {
			let pattern = Regex::new("[A-Z]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ctry_of_res does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.ctct_dtls { val.validate()? }
		Ok(())
	}
}


// PartyIdentification43 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PartyIdentification43 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm", skip_serializing_if = "Option::is_none") )]
	pub nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstlAdr", skip_serializing_if = "Option::is_none") )]
	pub pstl_adr: Option<PostalAddress6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<Party11Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtryOfRes", skip_serializing_if = "Option::is_none") )]
	pub ctry_of_res: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtctDtls", skip_serializing_if = "Option::is_none") )]
	pub ctct_dtls: Option<ContactDetails2>,
}

impl PartyIdentification43 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "nm exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.pstl_adr { val.validate()? }
		if let Some(ref val) = self.id { val.validate()? }
		if let Some(ref val) = self.ctry_of_res {
			let pattern = Regex::new("[A-Z]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ctry_of_res does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.ctct_dtls { val.validate()? }
		Ok(())
	}
}


// PartyIdentification72 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PartyIdentification72 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PtyId") )]
	pub pty_id: PartyIdentification43,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LglOrg", skip_serializing_if = "Option::is_none") )]
	pub lgl_org: Option<LegalOrganisation1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TaxPty", skip_serializing_if = "Option::is_none") )]
	pub tax_pty: Option<TaxParty1>,
}

impl PartyIdentification72 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.pty_id.validate()?;
		if let Some(ref val) = self.lgl_org { val.validate()? }
		if let Some(ref val) = self.tax_pty { val.validate()? }
		Ok(())
	}
}


// PartyIdentification76 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PartyIdentification76 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: PersonOrOrganisation1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtryOfBrnch", skip_serializing_if = "Option::is_none") )]
	pub ctry_of_brnch: Option<String>,
}

impl PartyIdentification76 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.id.validate()?;
		if let Some(ref val) = self.ctry_of_brnch {
			let pattern = Regex::new("[A-Z]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ctry_of_brnch does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// PartyIdentification79 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PartyIdentification79 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctOwnr") )]
	pub acct_ownr: Vec<PartyIdentification76>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DcsnMakr", skip_serializing_if = "Option::is_none") )]
	pub dcsn_makr: Option<Vec<PersonOrOrganisation2Choice>>,
}

impl PartyIdentification79 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		for item in &self.acct_ownr { item.validate()? }
		if let Some(ref vec) = self.dcsn_makr { for item in vec { item.validate()? } }
		Ok(())
	}
}


// PartyNatureType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum PartyNatureType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NFIN") )]
	CodeNFIN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FIIN") )]
	CodeFIIN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CCPS") )]
	CodeCCPS,
}

impl PartyNatureType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// PartyReport1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PartyReport1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Upd", skip_serializing_if = "Option::is_none") )]
	pub upd: Option<PartyUpdate1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cxl", skip_serializing_if = "Option::is_none") )]
	pub cxl: Option<PartyCancellation1>,
}

impl PartyReport1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.upd { val.validate()? }
		if let Some(ref val) = self.cxl { val.validate()? }
		Ok(())
	}
}


// PartyUpdate1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PartyUpdate1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechRcrdId", skip_serializing_if = "Option::is_none") )]
	pub tech_rcrd_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: PartyIdentification136,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrvsId", skip_serializing_if = "Option::is_none") )]
	pub prvs_id: Option<PartyIdentification136>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr") )]
	pub othr: PartyDetail1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sts") )]
	pub sts: Vec<StatusDetail1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechVldtyPrd", skip_serializing_if = "Option::is_none") )]
	pub tech_vldty_prd: Option<Period4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl PartyUpdate1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tech_rcrd_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tech_rcrd_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "tech_rcrd_id exceeds the maximum length of 35".to_string()));
			}
		}
		self.id.validate()?;
		if let Some(ref val) = self.prvs_id { val.validate()? }
		self.othr.validate()?;
		for item in &self.sts { item.validate()? }
		if let Some(ref val) = self.tech_vldty_prd { val.validate()? }
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// PassiveOrAgressiveType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum PassiveOrAgressiveType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "AGRE") )]
	CodeAGRE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PASV") )]
	CodePASV,
}

impl PassiveOrAgressiveType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// PaymentAccount4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PaymentAccount4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ccy") )]
	pub ccy: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NetPmt") )]
	pub net_pmt: AmountAndDirection86,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GrssCdts") )]
	pub grss_cdts: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GrssDbts") )]
	pub grss_dbts: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LatePmtConf") )]
	pub late_pmt_conf: String,
}

impl PaymentAccount4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z]{3,3}").unwrap();
		if !pattern.is_match(&self.ccy) {
			return Err(ValidationError::new(1005, "ccy does not match the required pattern".to_string()));
		}
		self.net_pmt.validate()?;
		let pattern = Regex::new("[0-9]{1,10}").unwrap();
		if !pattern.is_match(&self.late_pmt_conf) {
			return Err(ValidationError::new(1005, "late_pmt_conf does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// PaymentInstrumentType1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PaymentInstrumentType1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CardNb") )]
	pub card_nb: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AuthrtyReqTp") )]
	pub authrty_req_tp: Vec<AuthorityRequestType1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_inf: Option<String>,
}

impl PaymentInstrumentType1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[0-9]{8,28}").unwrap();
		if !pattern.is_match(&self.card_nb) {
			return Err(ValidationError::new(1005, "card_nb does not match the required pattern".to_string()));
		}
		for item in &self.authrty_req_tp { item.validate()? }
		if let Some(ref val) = self.addtl_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 500 {
				return Err(ValidationError::new(1002, "addtl_inf exceeds the maximum length of 500".to_string()));
			}
		}
		Ok(())
	}
}


// PaymentSchedule1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PaymentSchedule1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtSchdlId", skip_serializing_if = "Option::is_none") )]
	pub pmt_schdl_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt", skip_serializing_if = "Option::is_none") )]
	pub amt: Option<ActiveCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XpctdDt", skip_serializing_if = "Option::is_none") )]
	pub xpctd_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DueDt", skip_serializing_if = "Option::is_none") )]
	pub due_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_inf: Option<String>,
}

impl PaymentSchedule1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.pmt_schdl_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "pmt_schdl_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "pmt_schdl_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.amt { val.validate()? }
		if let Some(ref val) = self.addtl_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 1025 {
				return Err(ValidationError::new(1002, "addtl_inf exceeds the maximum length of 1025".to_string()));
			}
		}
		Ok(())
	}
}


// PaymentScheduleType2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PaymentScheduleType2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<PaymentScheduleType2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl PaymentScheduleType2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// PaymentScheduleType2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum PaymentScheduleType2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "CNTR") )]
	CodeCNTR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ESTM") )]
	CodeESTM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BOTH") )]
	CodeBOTH,
}

impl PaymentScheduleType2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// PaymentType4Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum PaymentType4Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "UFRO") )]
	CodeUFRO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UWIN") )]
	CodeUWIN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PEXH") )]
	CodePEXH,
}

impl PaymentType4Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// PaymentType5Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PaymentType5Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<PaymentType4Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrtryTp", skip_serializing_if = "Option::is_none") )]
	pub prtry_tp: Option<String>,
}

impl PaymentType5Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tp { val.validate()? }
		if let Some(ref val) = self.prtry_tp {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry_tp is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "prtry_tp exceeds the maximum length of 4".to_string()));
			}
			let pattern = Regex::new("[a-zA-Z0-9]{1,4}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "prtry_tp does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// Period11Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Period11Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dt", skip_serializing_if = "Option::is_none") )]
	pub dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrDt", skip_serializing_if = "Option::is_none") )]
	pub fr_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ToDt", skip_serializing_if = "Option::is_none") )]
	pub to_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrToDt", skip_serializing_if = "Option::is_none") )]
	pub fr_to_dt: Option<Period2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrToDtTm", skip_serializing_if = "Option::is_none") )]
	pub fr_to_dt_tm: Option<DateTimePeriod1>,
}

impl Period11Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.fr_to_dt { val.validate()? }
		if let Some(ref val) = self.fr_to_dt_tm { val.validate()? }
		Ok(())
	}
}


// Period2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Period2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrDt") )]
	pub fr_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ToDt") )]
	pub to_dt: String,
}

impl Period2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// Period4Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Period4Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dt", skip_serializing_if = "Option::is_none") )]
	pub dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrDt", skip_serializing_if = "Option::is_none") )]
	pub fr_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ToDt", skip_serializing_if = "Option::is_none") )]
	pub to_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrDtToDt", skip_serializing_if = "Option::is_none") )]
	pub fr_dt_to_dt: Option<Period2>,
}

impl Period4Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.fr_dt_to_dt { val.validate()? }
		Ok(())
	}
}


// PersonIdentification10 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PersonIdentification10 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrstNm") )]
	pub frst_nm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm") )]
	pub nm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BirthDt") )]
	pub birth_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr") )]
	pub othr: GenericPersonIdentification1,
}

impl PersonIdentification10 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.frst_nm.chars().count() < 1 {
			return Err(ValidationError::new(1001, "frst_nm is shorter than the minimum length of 1".to_string()));
		}
		if self.frst_nm.chars().count() > 140 {
			return Err(ValidationError::new(1002, "frst_nm exceeds the maximum length of 140".to_string()));
		}
		if self.nm.chars().count() < 1 {
			return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
		}
		if self.nm.chars().count() > 140 {
			return Err(ValidationError::new(1002, "nm exceeds the maximum length of 140".to_string()));
		}
		self.othr.validate()?;
		Ok(())
	}
}


// PersonIdentification12 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PersonIdentification12 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtryOfBrnch") )]
	pub ctry_of_brnch: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr") )]
	pub othr: GenericPersonIdentification1,
}

impl PersonIdentification12 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z]{2,2}").unwrap();
		if !pattern.is_match(&self.ctry_of_brnch) {
			return Err(ValidationError::new(1005, "ctry_of_brnch does not match the required pattern".to_string()));
		}
		self.othr.validate()?;
		Ok(())
	}
}


// PersonIdentification18 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PersonIdentification18 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtAndPlcOfBirth", skip_serializing_if = "Option::is_none") )]
	pub dt_and_plc_of_birth: Option<DateAndPlaceOfBirth1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<Vec<GenericPersonIdentification2>>,
}

impl PersonIdentification18 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.dt_and_plc_of_birth { val.validate()? }
		if let Some(ref vec) = self.othr { for item in vec { item.validate()? } }
		Ok(())
	}
}


// PersonIdentification5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PersonIdentification5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtAndPlcOfBirth", skip_serializing_if = "Option::is_none") )]
	pub dt_and_plc_of_birth: Option<DateAndPlaceOfBirth>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<Vec<GenericPersonIdentification1>>,
}

impl PersonIdentification5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.dt_and_plc_of_birth { val.validate()? }
		if let Some(ref vec) = self.othr { for item in vec { item.validate()? } }
		Ok(())
	}
}


// PersonIdentificationSchemeName1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PersonIdentificationSchemeName1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl PersonIdentificationSchemeName1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// PersonOrOrganisation1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PersonOrOrganisation1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "LEI", skip_serializing_if = "Option::is_none") )]
	pub lei: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MIC", skip_serializing_if = "Option::is_none") )]
	pub mic: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prsn", skip_serializing_if = "Option::is_none") )]
	pub prsn: Option<PersonIdentification10>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Intl", skip_serializing_if = "Option::is_none") )]
	pub intl: Option<InternalPartyRole1Code>,
}

impl PersonOrOrganisation1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.lei {
			let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "lei does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.mic {
			let pattern = Regex::new("[A-Z0-9]{4,4}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "mic does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.prsn { val.validate()? }
		if let Some(ref val) = self.intl { val.validate()? }
		Ok(())
	}
}


// PersonOrOrganisation2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PersonOrOrganisation2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "LEI", skip_serializing_if = "Option::is_none") )]
	pub lei: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prsn", skip_serializing_if = "Option::is_none") )]
	pub prsn: Option<PersonIdentification10>,
}

impl PersonOrOrganisation2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.lei {
			let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "lei does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.prsn { val.validate()? }
		Ok(())
	}
}


// PersonOrOrganisation4Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PersonOrOrganisation4Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "LEI", skip_serializing_if = "Option::is_none") )]
	pub lei: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prsn", skip_serializing_if = "Option::is_none") )]
	pub prsn: Option<GenericPersonIdentification1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XcptnId", skip_serializing_if = "Option::is_none") )]
	pub xcptn_id: Option<PartyExceptionType1Code>,
}

impl PersonOrOrganisation4Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.lei {
			let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "lei does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.prsn { val.validate()? }
		if let Some(ref val) = self.xcptn_id { val.validate()? }
		Ok(())
	}
}


// PhysicalTransferType4Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum PhysicalTransferType4Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "PHYS") )]
	CodePHYS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OPTL") )]
	CodeOPTL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CASH") )]
	CodeCASH,
}

impl PhysicalTransferType4Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// PolypropyleneCommodityOther1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PolypropyleneCommodityOther1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType9Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct") )]
	pub sub_pdct: AssetClassSubProductType49Code,
}

impl PolypropyleneCommodityOther1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		self.sub_pdct.validate()?;
		Ok(())
	}
}


// PolypropyleneCommodityOther2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PolypropyleneCommodityOther2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType9Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType49Code>,
}

impl PolypropyleneCommodityOther2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		Ok(())
	}
}


// PolypropyleneCommodityPlastic1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PolypropyleneCommodityPlastic1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType9Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType18Code>,
}

impl PolypropyleneCommodityPlastic1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		Ok(())
	}
}


// PolypropyleneCommodityPlastic2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PolypropyleneCommodityPlastic2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct") )]
	pub base_pdct: AssetClassProductType9Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<AssetClassSubProductType18Code>,
}

impl PolypropyleneCommodityPlastic2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_pdct.validate()?;
		if let Some(ref val) = self.sub_pdct { val.validate()? }
		Ok(())
	}
}


// PortfolioCode3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PortfolioCode3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NoPrtfl", skip_serializing_if = "Option::is_none") )]
	pub no_prtfl: Option<NotApplicable1Code>,
}

impl PortfolioCode3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 52 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 52".to_string()));
			}
		}
		if let Some(ref val) = self.no_prtfl { val.validate()? }
		Ok(())
	}
}


// PortfolioCode5Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PortfolioCode5Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtfl", skip_serializing_if = "Option::is_none") )]
	pub prtfl: Option<PortfolioIdentification3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NoPrtfl", skip_serializing_if = "Option::is_none") )]
	pub no_prtfl: Option<NotApplicable1Code>,
}

impl PortfolioCode5Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.prtfl { val.validate()? }
		if let Some(ref val) = self.no_prtfl { val.validate()? }
		Ok(())
	}
}


// PortfolioIdentification3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PortfolioIdentification3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd") )]
	pub cd: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrtflTxXmptn", skip_serializing_if = "Option::is_none") )]
	pub prtfl_tx_xmptn: Option<bool>,
}

impl PortfolioIdentification3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.cd.chars().count() < 1 {
			return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
		}
		if self.cd.chars().count() > 52 {
			return Err(ValidationError::new(1002, "cd exceeds the maximum length of 52".to_string()));
		}
		Ok(())
	}
}


// PortfolioStressTestResult1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PortfolioStressTestResult1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrtflId") )]
	pub prtfl_id: GenericIdentification165,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StrssLoss") )]
	pub strss_loss: AmountAndDirection102,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RawStrssLoss", skip_serializing_if = "Option::is_none") )]
	pub raw_strss_loss: Option<AmountAndDirection102>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cover1Flg") )]
	pub cover1_flg: bool,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cover2Flg") )]
	pub cover2_flg: bool,
}

impl PortfolioStressTestResult1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.prtfl_id.validate()?;
		self.strss_loss.validate()?;
		if let Some(ref val) = self.raw_strss_loss { val.validate()? }
		Ok(())
	}
}


// Position1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Position1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PdctId") )]
	pub pdct_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RskRqrmnt", skip_serializing_if = "Option::is_none") )]
	pub rsk_rqrmnt: Option<EndOfDayRequirement1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GrssNtnl") )]
	pub grss_ntnl: ActiveCurrencyAnd24Amount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NetNtnl") )]
	pub net_ntnl: AmountAndDirection102,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GrssDltaEqvtVal", skip_serializing_if = "Option::is_none") )]
	pub grss_dlta_eqvt_val: Option<ActiveCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NetDltaEqvtVal", skip_serializing_if = "Option::is_none") )]
	pub net_dlta_eqvt_val: Option<AmountAndDirection102>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GrssDltaEqvtQty", skip_serializing_if = "Option::is_none") )]
	pub grss_dlta_eqvt_qty: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NetDltaEqvtQty", skip_serializing_if = "Option::is_none") )]
	pub net_dlta_eqvt_qty: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GrssMktVal") )]
	pub grss_mkt_val: ActiveCurrencyAndAmount,
}

impl Position1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.pdct_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "pdct_id is shorter than the minimum length of 1".to_string()));
		}
		if self.pdct_id.chars().count() > 256 {
			return Err(ValidationError::new(1002, "pdct_id exceeds the maximum length of 256".to_string()));
		}
		if let Some(ref val) = self.rsk_rqrmnt { val.validate()? }
		self.grss_ntnl.validate()?;
		self.net_ntnl.validate()?;
		if let Some(ref val) = self.grss_dlta_eqvt_val { val.validate()? }
		if let Some(ref val) = self.net_dlta_eqvt_val { val.validate()? }
		self.grss_mkt_val.validate()?;
		Ok(())
	}
}


// PositionAccount1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PositionAccount1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: PartyIdentification118Choice,
}

impl PositionAccount1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.id.validate()?;
		Ok(())
	}
}


// PositionAccount2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PositionAccount2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: GenericIdentification165,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pos") )]
	pub pos: Vec<Position1>,
}

impl PositionAccount2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.id.validate()?;
		for item in &self.pos { item.validate()? }
		Ok(())
	}
}


// PositionSet16 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PositionSet16 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dmnsns") )]
	pub dmnsns: PositionSetDimensions14,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Mtrcs") )]
	pub mtrcs: PositionSetMetrics7,
}

impl PositionSet16 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.dmnsns.validate()?;
		self.mtrcs.validate()?;
		Ok(())
	}
}


// PositionSet17 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PositionSet17 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dmnsns") )]
	pub dmnsns: PositionSetDimensions14,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Mtrcs") )]
	pub mtrcs: PositionSetMetrics13,
}

impl PositionSet17 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.dmnsns.validate()?;
		self.mtrcs.validate()?;
		Ok(())
	}
}


// PositionSet18 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PositionSet18 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dmnsns") )]
	pub dmnsns: PositionSetDimensions14,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Mtrcs") )]
	pub mtrcs: PositionSetMetrics12,
}

impl PositionSet18 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.dmnsns.validate()?;
		self.mtrcs.validate()?;
		Ok(())
	}
}


// PositionSet19 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PositionSet19 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dmnsns") )]
	pub dmnsns: PositionSetDimensions12,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Mtrcs") )]
	pub mtrcs: PositionSetMetrics11,
}

impl PositionSet19 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.dmnsns.validate()?;
		self.mtrcs.validate()?;
		Ok(())
	}
}


// PositionSet20 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PositionSet20 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dmnsns") )]
	pub dmnsns: PositionSetDimensions15,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Mtrcs") )]
	pub mtrcs: PositionSetMetrics10,
}

impl PositionSet20 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.dmnsns.validate()?;
		self.mtrcs.validate()?;
		Ok(())
	}
}


// PositionSet21 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PositionSet21 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dmnsns") )]
	pub dmnsns: PositionSetDimensions16,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Mtrcs") )]
	pub mtrcs: PositionSetMetrics14,
}

impl PositionSet21 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.dmnsns.validate()?;
		self.mtrcs.validate()?;
		Ok(())
	}
}


// PositionSet22 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PositionSet22 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dmnsns") )]
	pub dmnsns: PositionSetCollateralDimensions3,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Mtrcs") )]
	pub mtrcs: PositionSetCollateralMetrics2,
}

impl PositionSet22 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.dmnsns.validate()?;
		self.mtrcs.validate()?;
		Ok(())
	}
}


// PositionSetAggregated2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PositionSetAggregated2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DataSetActn", skip_serializing_if = "Option::is_none") )]
	pub data_set_actn: Option<ReportPeriodActivity1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rpt", skip_serializing_if = "Option::is_none") )]
	pub rpt: Option<PositionSetAggregated4>,
}

impl PositionSetAggregated2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.data_set_actn { val.validate()? }
		if let Some(ref val) = self.rpt { val.validate()? }
		Ok(())
	}
}


// PositionSetAggregated4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PositionSetAggregated4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RefDt") )]
	pub ref_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PosSet", skip_serializing_if = "Option::is_none") )]
	pub pos_set: Option<Vec<PositionSet21>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CcyPosSet", skip_serializing_if = "Option::is_none") )]
	pub ccy_pos_set: Option<Vec<PositionSet21>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollPosSet", skip_serializing_if = "Option::is_none") )]
	pub coll_pos_set: Option<Vec<PositionSet22>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CcyCollPosSet", skip_serializing_if = "Option::is_none") )]
	pub ccy_coll_pos_set: Option<Vec<PositionSet22>>,
}

impl PositionSetAggregated4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.pos_set { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.ccy_pos_set { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.coll_pos_set { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.ccy_coll_pos_set { for item in vec { item.validate()? } }
		Ok(())
	}
}


// PositionSetBuyerAndSeller2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PositionSetBuyerAndSeller2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Buyr", skip_serializing_if = "Option::is_none") )]
	pub buyr: Option<PositionSetTotal2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sellr", skip_serializing_if = "Option::is_none") )]
	pub sellr: Option<PositionSetTotal2>,
}

impl PositionSetBuyerAndSeller2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.buyr { val.validate()? }
		if let Some(ref val) = self.sellr { val.validate()? }
		Ok(())
	}
}


// PositionSetCollateralDimensions3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PositionSetCollateralDimensions3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPtyId", skip_serializing_if = "Option::is_none") )]
	pub ctr_pty_id: Option<TradeCounterpartyReport20>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Coll", skip_serializing_if = "Option::is_none") )]
	pub coll: Option<MarginCollateralReport4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InitlMrgnPstdCcy", skip_serializing_if = "Option::is_none") )]
	pub initl_mrgn_pstd_ccy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VartnMrgnPstdCcy", skip_serializing_if = "Option::is_none") )]
	pub vartn_mrgn_pstd_ccy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InitlMrgnRcvdCcy", skip_serializing_if = "Option::is_none") )]
	pub initl_mrgn_rcvd_ccy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VartnMrgnRcvdCcy", skip_serializing_if = "Option::is_none") )]
	pub vartn_mrgn_rcvd_ccy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XcssCollPstdCcy", skip_serializing_if = "Option::is_none") )]
	pub xcss_coll_pstd_ccy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XcssCollRcvdCcy", skip_serializing_if = "Option::is_none") )]
	pub xcss_coll_rcvd_ccy: Option<String>,
}

impl PositionSetCollateralDimensions3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ctr_pty_id { val.validate()? }
		if let Some(ref val) = self.coll { val.validate()? }
		if let Some(ref val) = self.initl_mrgn_pstd_ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "initl_mrgn_pstd_ccy does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.vartn_mrgn_pstd_ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "vartn_mrgn_pstd_ccy does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.initl_mrgn_rcvd_ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "initl_mrgn_rcvd_ccy does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.vartn_mrgn_rcvd_ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "vartn_mrgn_rcvd_ccy does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.xcss_coll_pstd_ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "xcss_coll_pstd_ccy does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.xcss_coll_rcvd_ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "xcss_coll_rcvd_ccy does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// PositionSetCollateralMetrics2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PositionSetCollateralMetrics2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ttl", skip_serializing_if = "Option::is_none") )]
	pub ttl: Option<PositionSetCollateralTotal2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Clean", skip_serializing_if = "Option::is_none") )]
	pub clean: Option<PositionSetCollateralTotal2>,
}

impl PositionSetCollateralMetrics2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ttl { val.validate()? }
		if let Some(ref val) = self.clean { val.validate()? }
		Ok(())
	}
}


// PositionSetCollateralTotal2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PositionSetCollateralTotal2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfRpts", skip_serializing_if = "Option::is_none") )]
	pub nb_of_rpts: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstdMrgnOrColl", skip_serializing_if = "Option::is_none") )]
	pub pstd_mrgn_or_coll: Option<PostedMarginOrCollateral6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RcvdMrgnOrColl", skip_serializing_if = "Option::is_none") )]
	pub rcvd_mrgn_or_coll: Option<ReceivedMarginOrCollateral6>,
}

impl PositionSetCollateralTotal2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.pstd_mrgn_or_coll { val.validate()? }
		if let Some(ref val) = self.rcvd_mrgn_or_coll { val.validate()? }
		Ok(())
	}
}


// PositionSetDimensions12 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PositionSetDimensions12 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgCtrPty", skip_serializing_if = "Option::is_none") )]
	pub rptg_ctr_pty: Option<OrganisationIdentification15Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollData", skip_serializing_if = "Option::is_none") )]
	pub coll_data: Option<CollateralData33>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OtlrsIncl", skip_serializing_if = "Option::is_none") )]
	pub otlrs_incl: Option<bool>,
}

impl PositionSetDimensions12 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.rptg_ctr_pty { val.validate()? }
		if let Some(ref val) = self.coll_data { val.validate()? }
		Ok(())
	}
}


// PositionSetDimensions14 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PositionSetDimensions14 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPtyData", skip_serializing_if = "Option::is_none") )]
	pub ctr_pty_data: Option<CounterpartyData86>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LnData", skip_serializing_if = "Option::is_none") )]
	pub ln_data: Option<LoanData134>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollData", skip_serializing_if = "Option::is_none") )]
	pub coll_data: Option<CollateralData33>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OtlrsIncl", skip_serializing_if = "Option::is_none") )]
	pub otlrs_incl: Option<bool>,
}

impl PositionSetDimensions14 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ctr_pty_data { val.validate()? }
		if let Some(ref val) = self.ln_data { val.validate()? }
		if let Some(ref val) = self.coll_data { val.validate()? }
		Ok(())
	}
}


// PositionSetDimensions15 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PositionSetDimensions15 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgCtrPty", skip_serializing_if = "Option::is_none") )]
	pub rptg_ctr_pty: Option<OrganisationIdentification15Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrCtrPty", skip_serializing_if = "Option::is_none") )]
	pub othr_ctr_pty: Option<OrganisationIdentification15Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollPrtflId", skip_serializing_if = "Option::is_none") )]
	pub coll_prtfl_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OtlrsIncl", skip_serializing_if = "Option::is_none") )]
	pub otlrs_incl: Option<bool>,
}

impl PositionSetDimensions15 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.rptg_ctr_pty { val.validate()? }
		if let Some(ref val) = self.othr_ctr_pty { val.validate()? }
		if let Some(ref val) = self.coll_prtfl_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "coll_prtfl_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 52 {
				return Err(ValidationError::new(1002, "coll_prtfl_id exceeds the maximum length of 52".to_string()));
			}
		}
		Ok(())
	}
}


// PositionSetDimensions16 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PositionSetDimensions16 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPtyId", skip_serializing_if = "Option::is_none") )]
	pub ctr_pty_id: Option<TradeCounterpartyReport20>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ValCcy", skip_serializing_if = "Option::is_none") )]
	pub val_ccy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Coll", skip_serializing_if = "Option::is_none") )]
	pub coll: Option<MarginCollateralReport4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrctTp", skip_serializing_if = "Option::is_none") )]
	pub ctrct_tp: Option<FinancialInstrumentContractType2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AsstClss", skip_serializing_if = "Option::is_none") )]
	pub asst_clss: Option<ProductType4Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UndrlygInstrm", skip_serializing_if = "Option::is_none") )]
	pub undrlyg_instrm: Option<SecurityIdentification41Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtnlCcy", skip_serializing_if = "Option::is_none") )]
	pub ntnl_ccy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtnlCcyScndLeg", skip_serializing_if = "Option::is_none") )]
	pub ntnl_ccy_scnd_leg: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttlmCcy", skip_serializing_if = "Option::is_none") )]
	pub sttlm_ccy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttlmCcyScndLeg", skip_serializing_if = "Option::is_none") )]
	pub sttlm_ccy_scnd_leg: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MstrAgrmt", skip_serializing_if = "Option::is_none") )]
	pub mstr_agrmt: Option<MasterAgreement8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Clrd", skip_serializing_if = "Option::is_none") )]
	pub clrd: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntraGrp", skip_serializing_if = "Option::is_none") )]
	pub intra_grp: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XchgRateBsis", skip_serializing_if = "Option::is_none") )]
	pub xchg_rate_bsis: Option<ExchangeRateBasis1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OptnTp", skip_serializing_if = "Option::is_none") )]
	pub optn_tp: Option<OptionType2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TmToMtrty", skip_serializing_if = "Option::is_none") )]
	pub tm_to_mtrty: Option<TimeToMaturity1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IRSTp", skip_serializing_if = "Option::is_none") )]
	pub irs_tp: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cdt", skip_serializing_if = "Option::is_none") )]
	pub cdt: Option<CreditDerivative7>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cmmdty", skip_serializing_if = "Option::is_none") )]
	pub cmmdty: Option<AssetClassCommodity6Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrPmt", skip_serializing_if = "Option::is_none") )]
	pub othr_pmt: Option<OtherPayment6>,
}

impl PositionSetDimensions16 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ctr_pty_id { val.validate()? }
		if let Some(ref val) = self.val_ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "val_ccy does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.coll { val.validate()? }
		if let Some(ref val) = self.ctrct_tp { val.validate()? }
		if let Some(ref val) = self.asst_clss { val.validate()? }
		if let Some(ref val) = self.undrlyg_instrm { val.validate()? }
		if let Some(ref val) = self.ntnl_ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ntnl_ccy does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.ntnl_ccy_scnd_leg {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ntnl_ccy_scnd_leg does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.sttlm_ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "sttlm_ccy does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.sttlm_ccy_scnd_leg {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "sttlm_ccy_scnd_leg does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.mstr_agrmt { val.validate()? }
		if let Some(ref val) = self.xchg_rate_bsis { val.validate()? }
		if let Some(ref val) = self.optn_tp { val.validate()? }
		if let Some(ref val) = self.tm_to_mtrty { val.validate()? }
		if let Some(ref val) = self.irs_tp {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "irs_tp is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 52 {
				return Err(ValidationError::new(1002, "irs_tp exceeds the maximum length of 52".to_string()));
			}
		}
		if let Some(ref val) = self.cdt { val.validate()? }
		if let Some(ref val) = self.cmmdty { val.validate()? }
		if let Some(ref val) = self.othr_pmt { val.validate()? }
		Ok(())
	}
}


// PositionSetMetrics10 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PositionSetMetrics10 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "VolMtrcs", skip_serializing_if = "Option::is_none") )]
	pub vol_mtrcs: Option<ExposureMetrics6>,
}

impl PositionSetMetrics10 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.vol_mtrcs { val.validate()? }
		Ok(())
	}
}


// PositionSetMetrics11 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PositionSetMetrics11 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "VolMtrcs", skip_serializing_if = "Option::is_none") )]
	pub vol_mtrcs: Option<VolumeMetrics4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshRinvstmtRate", skip_serializing_if = "Option::is_none") )]
	pub csh_rinvstmt_rate: Option<f64>,
}

impl PositionSetMetrics11 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.vol_mtrcs { val.validate()? }
		Ok(())
	}
}


// PositionSetMetrics12 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PositionSetMetrics12 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "VolMtrcs", skip_serializing_if = "Option::is_none") )]
	pub vol_mtrcs: Option<VolumeMetrics6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "HrcutOrMrgn", skip_serializing_if = "Option::is_none") )]
	pub hrcut_or_mrgn: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "QtyOrNmnlAmt", skip_serializing_if = "Option::is_none") )]
	pub qty_or_nmnl_amt: Option<QuantityNominalValue2Choice>,
}

impl PositionSetMetrics12 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.vol_mtrcs { val.validate()? }
		if let Some(ref val) = self.qty_or_nmnl_amt { val.validate()? }
		Ok(())
	}
}


// PositionSetMetrics13 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PositionSetMetrics13 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "VolMtrcs") )]
	pub vol_mtrcs: VolumeMetrics5,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PricMtrcs", skip_serializing_if = "Option::is_none") )]
	pub pric_mtrcs: Option<PriceMetrics3>,
}

impl PositionSetMetrics13 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.vol_mtrcs.validate()?;
		if let Some(ref val) = self.pric_mtrcs { val.validate()? }
		Ok(())
	}
}


// PositionSetMetrics14 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PositionSetMetrics14 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ttl", skip_serializing_if = "Option::is_none") )]
	pub ttl: Option<PositionSetBuyerAndSeller2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Clean", skip_serializing_if = "Option::is_none") )]
	pub clean: Option<PositionSetBuyerAndSeller2>,
}

impl PositionSetMetrics14 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ttl { val.validate()? }
		if let Some(ref val) = self.clean { val.validate()? }
		Ok(())
	}
}


// PositionSetMetrics7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PositionSetMetrics7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "VolMtrcs") )]
	pub vol_mtrcs: VolumeMetrics5,
}

impl PositionSetMetrics7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.vol_mtrcs.validate()?;
		Ok(())
	}
}


// PositionSetReport3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PositionSetReport3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DataSetActn", skip_serializing_if = "Option::is_none") )]
	pub data_set_actn: Option<ReportPeriodActivity1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rpt", skip_serializing_if = "Option::is_none") )]
	pub rpt: Option<NamedPosition3>,
}

impl PositionSetReport3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.data_set_actn { val.validate()? }
		if let Some(ref val) = self.rpt { val.validate()? }
		Ok(())
	}
}


// PositionSetTotal2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PositionSetTotal2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfTrds", skip_serializing_if = "Option::is_none") )]
	pub nb_of_trds: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PostvVal", skip_serializing_if = "Option::is_none") )]
	pub postv_val: Option<ActiveOrHistoricCurrencyAnd19DecimalAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NegVal", skip_serializing_if = "Option::is_none") )]
	pub neg_val: Option<ActiveOrHistoricCurrencyAnd19DecimalAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ntnl", skip_serializing_if = "Option::is_none") )]
	pub ntnl: Option<NotionalAmountLegs6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrPmtAmt", skip_serializing_if = "Option::is_none") )]
	pub othr_pmt_amt: Option<Vec<ActiveOrHistoricCurrencyAnd19DecimalAmount>>,
}

impl PositionSetTotal2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.postv_val { val.validate()? }
		if let Some(ref val) = self.neg_val { val.validate()? }
		if let Some(ref val) = self.ntnl { val.validate()? }
		if let Some(ref vec) = self.othr_pmt_amt { for item in vec { item.validate()? } }
		Ok(())
	}
}


// PostTradeRiskReductionIdentifier1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PostTradeRiskReductionIdentifier1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Strr") )]
	pub strr: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
}

impl PostTradeRiskReductionIdentifier1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
		if !pattern.is_match(&self.strr) {
			return Err(ValidationError::new(1005, "strr does not match the required pattern".to_string()));
		}
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 52 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 52".to_string()));
		}
		Ok(())
	}
}


// PostalAddress1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PostalAddress1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AdrTp", skip_serializing_if = "Option::is_none") )]
	pub adr_tp: Option<AddressType2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AdrLine", skip_serializing_if = "Option::is_none") )]
	pub adr_line: Option<Vec<String>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StrtNm", skip_serializing_if = "Option::is_none") )]
	pub strt_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BldgNb", skip_serializing_if = "Option::is_none") )]
	pub bldg_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstCd", skip_serializing_if = "Option::is_none") )]
	pub pst_cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TwnNm", skip_serializing_if = "Option::is_none") )]
	pub twn_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrySubDvsn", skip_serializing_if = "Option::is_none") )]
	pub ctry_sub_dvsn: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ctry") )]
	pub ctry: String,
}

impl PostalAddress1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.adr_tp { val.validate()? }
		if let Some(ref vec) = self.adr_line {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "adr_line is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 70 {
					return Err(ValidationError::new(1002, "adr_line exceeds the maximum length of 70".to_string()));
				}
			}
		}
		if let Some(ref val) = self.strt_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "strt_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 70 {
				return Err(ValidationError::new(1002, "strt_nm exceeds the maximum length of 70".to_string()));
			}
		}
		if let Some(ref val) = self.bldg_nb {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "bldg_nb is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 16 {
				return Err(ValidationError::new(1002, "bldg_nb exceeds the maximum length of 16".to_string()));
			}
		}
		if let Some(ref val) = self.pst_cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "pst_cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 16 {
				return Err(ValidationError::new(1002, "pst_cd exceeds the maximum length of 16".to_string()));
			}
		}
		if let Some(ref val) = self.twn_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "twn_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "twn_nm exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.ctry_sub_dvsn {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "ctry_sub_dvsn is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "ctry_sub_dvsn exceeds the maximum length of 35".to_string()));
			}
		}
		let pattern = Regex::new("[A-Z]{2,2}").unwrap();
		if !pattern.is_match(&self.ctry) {
			return Err(ValidationError::new(1005, "ctry does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// PostalAddress27 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PostalAddress27 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AdrTp", skip_serializing_if = "Option::is_none") )]
	pub adr_tp: Option<AddressType3Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CareOf", skip_serializing_if = "Option::is_none") )]
	pub care_of: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dept", skip_serializing_if = "Option::is_none") )]
	pub dept: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubDept", skip_serializing_if = "Option::is_none") )]
	pub sub_dept: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StrtNm", skip_serializing_if = "Option::is_none") )]
	pub strt_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BldgNb", skip_serializing_if = "Option::is_none") )]
	pub bldg_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BldgNm", skip_serializing_if = "Option::is_none") )]
	pub bldg_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Flr", skip_serializing_if = "Option::is_none") )]
	pub flr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnitNb", skip_serializing_if = "Option::is_none") )]
	pub unit_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstBx", skip_serializing_if = "Option::is_none") )]
	pub pst_bx: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Room", skip_serializing_if = "Option::is_none") )]
	pub room: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstCd", skip_serializing_if = "Option::is_none") )]
	pub pst_cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TwnNm", skip_serializing_if = "Option::is_none") )]
	pub twn_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TwnLctnNm", skip_serializing_if = "Option::is_none") )]
	pub twn_lctn_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DstrctNm", skip_serializing_if = "Option::is_none") )]
	pub dstrct_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrySubDvsn", skip_serializing_if = "Option::is_none") )]
	pub ctry_sub_dvsn: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ctry", skip_serializing_if = "Option::is_none") )]
	pub ctry: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AdrLine", skip_serializing_if = "Option::is_none") )]
	pub adr_line: Option<Vec<String>>,
}

impl PostalAddress27 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.adr_tp { val.validate()? }
		if let Some(ref val) = self.care_of {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "care_of is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "care_of exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.dept {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "dept is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 70 {
				return Err(ValidationError::new(1002, "dept exceeds the maximum length of 70".to_string()));
			}
		}
		if let Some(ref val) = self.sub_dept {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "sub_dept is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 70 {
				return Err(ValidationError::new(1002, "sub_dept exceeds the maximum length of 70".to_string()));
			}
		}
		if let Some(ref val) = self.strt_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "strt_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "strt_nm exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.bldg_nb {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "bldg_nb is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 16 {
				return Err(ValidationError::new(1002, "bldg_nb exceeds the maximum length of 16".to_string()));
			}
		}
		if let Some(ref val) = self.bldg_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "bldg_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "bldg_nm exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.flr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "flr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 70 {
				return Err(ValidationError::new(1002, "flr exceeds the maximum length of 70".to_string()));
			}
		}
		if let Some(ref val) = self.unit_nb {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "unit_nb is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 16 {
				return Err(ValidationError::new(1002, "unit_nb exceeds the maximum length of 16".to_string()));
			}
		}
		if let Some(ref val) = self.pst_bx {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "pst_bx is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 16 {
				return Err(ValidationError::new(1002, "pst_bx exceeds the maximum length of 16".to_string()));
			}
		}
		if let Some(ref val) = self.room {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "room is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 70 {
				return Err(ValidationError::new(1002, "room exceeds the maximum length of 70".to_string()));
			}
		}
		if let Some(ref val) = self.pst_cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "pst_cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 16 {
				return Err(ValidationError::new(1002, "pst_cd exceeds the maximum length of 16".to_string()));
			}
		}
		if let Some(ref val) = self.twn_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "twn_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "twn_nm exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.twn_lctn_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "twn_lctn_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "twn_lctn_nm exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.dstrct_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "dstrct_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "dstrct_nm exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.ctry_sub_dvsn {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "ctry_sub_dvsn is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "ctry_sub_dvsn exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.ctry {
			let pattern = Regex::new("[A-Z]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ctry does not match the required pattern".to_string()));
			}
		}
		if let Some(ref vec) = self.adr_line {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "adr_line is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 70 {
					return Err(ValidationError::new(1002, "adr_line exceeds the maximum length of 70".to_string()));
				}
			}
		}
		Ok(())
	}
}


// PostalAddress6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PostalAddress6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AdrTp", skip_serializing_if = "Option::is_none") )]
	pub adr_tp: Option<AddressType2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dept", skip_serializing_if = "Option::is_none") )]
	pub dept: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubDept", skip_serializing_if = "Option::is_none") )]
	pub sub_dept: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StrtNm", skip_serializing_if = "Option::is_none") )]
	pub strt_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BldgNb", skip_serializing_if = "Option::is_none") )]
	pub bldg_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstCd", skip_serializing_if = "Option::is_none") )]
	pub pst_cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TwnNm", skip_serializing_if = "Option::is_none") )]
	pub twn_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrySubDvsn", skip_serializing_if = "Option::is_none") )]
	pub ctry_sub_dvsn: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ctry", skip_serializing_if = "Option::is_none") )]
	pub ctry: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AdrLine", skip_serializing_if = "Option::is_none") )]
	pub adr_line: Option<Vec<String>>,
}

impl PostalAddress6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.adr_tp { val.validate()? }
		if let Some(ref val) = self.dept {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "dept is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 70 {
				return Err(ValidationError::new(1002, "dept exceeds the maximum length of 70".to_string()));
			}
		}
		if let Some(ref val) = self.sub_dept {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "sub_dept is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 70 {
				return Err(ValidationError::new(1002, "sub_dept exceeds the maximum length of 70".to_string()));
			}
		}
		if let Some(ref val) = self.strt_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "strt_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 70 {
				return Err(ValidationError::new(1002, "strt_nm exceeds the maximum length of 70".to_string()));
			}
		}
		if let Some(ref val) = self.bldg_nb {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "bldg_nb is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 16 {
				return Err(ValidationError::new(1002, "bldg_nb exceeds the maximum length of 16".to_string()));
			}
		}
		if let Some(ref val) = self.pst_cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "pst_cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 16 {
				return Err(ValidationError::new(1002, "pst_cd exceeds the maximum length of 16".to_string()));
			}
		}
		if let Some(ref val) = self.twn_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "twn_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "twn_nm exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.ctry_sub_dvsn {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "ctry_sub_dvsn is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "ctry_sub_dvsn exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.ctry {
			let pattern = Regex::new("[A-Z]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ctry does not match the required pattern".to_string()));
			}
		}
		if let Some(ref vec) = self.adr_line {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "adr_line is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 70 {
					return Err(ValidationError::new(1002, "adr_line exceeds the maximum length of 70".to_string()));
				}
			}
		}
		Ok(())
	}
}


// PostedMarginOrCollateral4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PostedMarginOrCollateral4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "InitlMrgnPstd", skip_serializing_if = "Option::is_none") )]
	pub initl_mrgn_pstd: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VartnMrgnPstd", skip_serializing_if = "Option::is_none") )]
	pub vartn_mrgn_pstd: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XcssCollPstd", skip_serializing_if = "Option::is_none") )]
	pub xcss_coll_pstd: Option<ActiveOrHistoricCurrencyAndAmount>,
}

impl PostedMarginOrCollateral4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.initl_mrgn_pstd { val.validate()? }
		if let Some(ref val) = self.vartn_mrgn_pstd { val.validate()? }
		if let Some(ref val) = self.xcss_coll_pstd { val.validate()? }
		Ok(())
	}
}


// PostedMarginOrCollateral6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PostedMarginOrCollateral6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "InitlMrgnPstdPreHrcut", skip_serializing_if = "Option::is_none") )]
	pub initl_mrgn_pstd_pre_hrcut: Option<ActiveOrHistoricCurrencyAnd20DecimalAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InitlMrgnPstdPstHrcut", skip_serializing_if = "Option::is_none") )]
	pub initl_mrgn_pstd_pst_hrcut: Option<ActiveOrHistoricCurrencyAnd20DecimalAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VartnMrgnPstdPreHrcut", skip_serializing_if = "Option::is_none") )]
	pub vartn_mrgn_pstd_pre_hrcut: Option<ActiveOrHistoricCurrencyAnd20DecimalAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VartnMrgnPstdPstHrcut", skip_serializing_if = "Option::is_none") )]
	pub vartn_mrgn_pstd_pst_hrcut: Option<ActiveOrHistoricCurrencyAnd20DecimalAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XcssCollPstd", skip_serializing_if = "Option::is_none") )]
	pub xcss_coll_pstd: Option<ActiveOrHistoricCurrencyAnd20DecimalAmount>,
}

impl PostedMarginOrCollateral6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.initl_mrgn_pstd_pre_hrcut { val.validate()? }
		if let Some(ref val) = self.initl_mrgn_pstd_pst_hrcut { val.validate()? }
		if let Some(ref val) = self.vartn_mrgn_pstd_pre_hrcut { val.validate()? }
		if let Some(ref val) = self.vartn_mrgn_pstd_pst_hrcut { val.validate()? }
		if let Some(ref val) = self.xcss_coll_pstd { val.validate()? }
		Ok(())
	}
}


// PreferredContactMethod2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum PreferredContactMethod2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "MAIL") )]
	CodeMAIL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FAXX") )]
	CodeFAXX,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LETT") )]
	CodeLETT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CELL") )]
	CodeCELL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ONLI") )]
	CodeONLI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PHON") )]
	CodePHON,
}

impl PreferredContactMethod2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// PriceData2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PriceData2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pric", skip_serializing_if = "Option::is_none") )]
	pub pric: Option<SecuritiesTransactionPrice17Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SchdlPrd", skip_serializing_if = "Option::is_none") )]
	pub schdl_prd: Option<Vec<Schedule1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnitOfMeasr", skip_serializing_if = "Option::is_none") )]
	pub unit_of_measr: Option<UnitOfMeasure8Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PricMltplr", skip_serializing_if = "Option::is_none") )]
	pub pric_mltplr: Option<f64>,
}

impl PriceData2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.pric { val.validate()? }
		if let Some(ref vec) = self.schdl_prd { for item in vec { item.validate()? } }
		if let Some(ref val) = self.unit_of_measr { val.validate()? }
		Ok(())
	}
}


// PriceMetrics3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PriceMetrics3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rates", skip_serializing_if = "Option::is_none") )]
	pub rates: Option<Rates3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LndgFee", skip_serializing_if = "Option::is_none") )]
	pub lndg_fee: Option<f64>,
}

impl PriceMetrics3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.rates { val.validate()? }
		Ok(())
	}
}


// PriceStatus1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum PriceStatus1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "PNDG") )]
	CodePNDG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NOAP") )]
	CodeNOAP,
}

impl PriceStatus1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// PriceStatus2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum PriceStatus2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "PNDG") )]
	CodePNDG,
}

impl PriceStatus2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// PrincipalAmount3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct PrincipalAmount3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ValDtAmt", skip_serializing_if = "Option::is_none") )]
	pub val_dt_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MtrtyDtAmt", skip_serializing_if = "Option::is_none") )]
	pub mtrty_dt_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
}

impl PrincipalAmount3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val_dt_amt { val.validate()? }
		if let Some(ref val) = self.mtrty_dt_amt { val.validate()? }
		Ok(())
	}
}


// Priority2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum Priority2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "HIGH") )]
	CodeHIGH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NORM") )]
	CodeNORM,
}

impl Priority2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// Product1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Product1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Deriv", skip_serializing_if = "Option::is_none") )]
	pub deriv: Option<Derivative3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SctiesFincgTx", skip_serializing_if = "Option::is_none") )]
	pub scties_fincg_tx: Option<RepurchaseAgreement3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Scty", skip_serializing_if = "Option::is_none") )]
	pub scty: Option<FinancialInstrument59>,
}

impl Product1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.deriv { val.validate()? }
		if let Some(ref val) = self.scties_fincg_tx { val.validate()? }
		if let Some(ref val) = self.scty { val.validate()? }
		Ok(())
	}
}


// ProductClassification1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ProductClassification1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AsstClss") )]
	pub asst_clss: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BasePdct", skip_serializing_if = "Option::is_none") )]
	pub base_pdct: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubPdct", skip_serializing_if = "Option::is_none") )]
	pub sub_pdct: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubCmmdty", skip_serializing_if = "Option::is_none") )]
	pub sub_cmmdty: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxTp", skip_serializing_if = "Option::is_none") )]
	pub tx_tp: Option<String>,
}

impl ProductClassification1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.asst_clss.chars().count() < 1 {
			return Err(ValidationError::new(1001, "asst_clss is shorter than the minimum length of 1".to_string()));
		}
		if self.asst_clss.chars().count() > 35 {
			return Err(ValidationError::new(1002, "asst_clss exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.base_pdct {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "base_pdct is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "base_pdct exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.sub_pdct {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "sub_pdct is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "sub_pdct exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.sub_cmmdty {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "sub_cmmdty is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "sub_cmmdty exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.tx_tp {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tx_tp is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "tx_tp exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// ProductClassificationCriteria1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ProductClassificationCriteria1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClssfctnFinInstrm", skip_serializing_if = "Option::is_none") )]
	pub clssfctn_fin_instrm: Option<Vec<String>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnqPdctIdr", skip_serializing_if = "Option::is_none") )]
	pub unq_pdct_idr: Option<Vec<String>>,
}

impl ProductClassificationCriteria1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.clssfctn_fin_instrm {
			for item in vec {
				let pattern = Regex::new("[A-Z]{6,6}").unwrap();
				if !pattern.is_match(&item) {
					return Err(ValidationError::new(1005, "clssfctn_fin_instrm does not match the required pattern".to_string()));
				}
			}
		}
		if let Some(ref vec) = self.unq_pdct_idr {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "unq_pdct_idr is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 52 {
					return Err(ValidationError::new(1002, "unq_pdct_idr exceeds the maximum length of 52".to_string()));
				}
			}
		}
		Ok(())
	}
}


// ProductType4Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum ProductType4Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "CRDT") )]
	CodeCRDT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CURR") )]
	CodeCURR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EQUI") )]
	CodeEQUI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INTR") )]
	CodeINTR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "COMM") )]
	CodeCOMM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
}

impl ProductType4Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ProductType6Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum ProductType6Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "BOND") )]
	CodeBOND,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CASH") )]
	CodeCASH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EQUI") )]
	CodeEQUI,
}

impl ProductType6Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ProductType7Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum ProductType7Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "SVGN") )]
	CodeSVGN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EQUI") )]
	CodeEQUI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
}

impl ProductType7Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ProprietaryReference1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ProprietaryReference1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ref") )]
	pub ref_attr: String,
}

impl ProprietaryReference1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.tp.chars().count() < 1 {
			return Err(ValidationError::new(1001, "tp is shorter than the minimum length of 1".to_string()));
		}
		if self.tp.chars().count() > 35 {
			return Err(ValidationError::new(1002, "tp exceeds the maximum length of 35".to_string()));
		}
		if self.ref_attr.chars().count() < 1 {
			return Err(ValidationError::new(1001, "ref_attr is shorter than the minimum length of 1".to_string()));
		}
		if self.ref_attr.chars().count() > 35 {
			return Err(ValidationError::new(1002, "ref_attr exceeds the maximum length of 35".to_string()));
		}
		Ok(())
	}
}


// ProxyAccountIdentification1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ProxyAccountIdentification1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<ProxyAccountType1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
}

impl ProxyAccountIdentification1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tp { val.validate()? }
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 2048 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 2048".to_string()));
		}
		Ok(())
	}
}


// ProxyAccountType1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ProxyAccountType1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl ProxyAccountType1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// Quantity17 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Quantity17 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val") )]
	pub val: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnitOfMeasr") )]
	pub unit_of_measr: UnitOfMeasure11Code,
}

impl Quantity17 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.unit_of_measr.validate()?;
		Ok(())
	}
}


// Quantity47Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Quantity47Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Qty", skip_serializing_if = "Option::is_none") )]
	pub qty: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Desc", skip_serializing_if = "Option::is_none") )]
	pub desc: Option<String>,
}

impl Quantity47Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.desc {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "desc is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 52 {
				return Err(ValidationError::new(1002, "desc exceeds the maximum length of 52".to_string()));
			}
		}
		Ok(())
	}
}


// QuantityNominalValue2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct QuantityNominalValue2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Qty", skip_serializing_if = "Option::is_none") )]
	pub qty: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NmnlVal", skip_serializing_if = "Option::is_none") )]
	pub nmnl_val: Option<AmountAndDirection53>,
}

impl QuantityNominalValue2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.nmnl_val { val.validate()? }
		Ok(())
	}
}


// QuantityOrTerm1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct QuantityOrTerm1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SchdlPrd", skip_serializing_if = "Option::is_none") )]
	pub schdl_prd: Option<Vec<Schedule10>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Term", skip_serializing_if = "Option::is_none") )]
	pub term: Option<QuantityTerm1>,
}

impl QuantityOrTerm1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.schdl_prd { for item in vec { item.validate()? } }
		if let Some(ref val) = self.term { val.validate()? }
		Ok(())
	}
}


// QuantityTerm1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct QuantityTerm1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Qty", skip_serializing_if = "Option::is_none") )]
	pub qty: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnitOfMeasr", skip_serializing_if = "Option::is_none") )]
	pub unit_of_measr: Option<UnitOfMeasure8Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val", skip_serializing_if = "Option::is_none") )]
	pub val: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TmUnit", skip_serializing_if = "Option::is_none") )]
	pub tm_unit: Option<Frequency19Code>,
}

impl QuantityTerm1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.unit_of_measr { val.validate()? }
		if let Some(ref val) = self.tm_unit { val.validate()? }
		Ok(())
	}
}


// QueryType3Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum QueryType3Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ALLL") )]
	CodeALLL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CHNG") )]
	CodeCHNG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MODF") )]
	CodeMODF,
}

impl QueryType3Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// RateAdjustment1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct RateAdjustment1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rate") )]
	pub rate: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AdjstmntDt") )]
	pub adjstmnt_dt: String,
}

impl RateAdjustment1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// RateBasis1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum RateBasis1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "DAYS") )]
	CodeDAYS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MNTH") )]
	CodeMNTH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "WEEK") )]
	CodeWEEK,
	#[cfg_attr( feature = "derive_serde", serde(rename = "YEAR") )]
	CodeYEAR,
}

impl RateBasis1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// Rates1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Rates1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Fxd", skip_serializing_if = "Option::is_none") )]
	pub fxd: Option<NoReasonCode>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Fltg", skip_serializing_if = "Option::is_none") )]
	pub fltg: Option<String>,
}

impl Rates1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.fxd { val.validate()? }
		if let Some(ref val) = self.fltg {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "fltg is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "fltg exceeds the maximum length of 4".to_string()));
			}
		}
		Ok(())
	}
}


// Rates3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Rates3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Fxd", skip_serializing_if = "Option::is_none") )]
	pub fxd: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Fltg", skip_serializing_if = "Option::is_none") )]
	pub fltg: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BuySellBck", skip_serializing_if = "Option::is_none") )]
	pub buy_sell_bck: Option<SecuritiesTransactionPrice18Choice>,
}

impl Rates3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.buy_sell_bck { val.validate()? }
		Ok(())
	}
}


// ReceivedMarginOrCollateral4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ReceivedMarginOrCollateral4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "InitlMrgnRcvd", skip_serializing_if = "Option::is_none") )]
	pub initl_mrgn_rcvd: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VartnMrgnRcvd", skip_serializing_if = "Option::is_none") )]
	pub vartn_mrgn_rcvd: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XcssCollRcvd", skip_serializing_if = "Option::is_none") )]
	pub xcss_coll_rcvd: Option<ActiveOrHistoricCurrencyAndAmount>,
}

impl ReceivedMarginOrCollateral4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.initl_mrgn_rcvd { val.validate()? }
		if let Some(ref val) = self.vartn_mrgn_rcvd { val.validate()? }
		if let Some(ref val) = self.xcss_coll_rcvd { val.validate()? }
		Ok(())
	}
}


// ReceivedMarginOrCollateral6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ReceivedMarginOrCollateral6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "InitlMrgnRcvdPreHrcut", skip_serializing_if = "Option::is_none") )]
	pub initl_mrgn_rcvd_pre_hrcut: Option<ActiveOrHistoricCurrencyAnd20DecimalAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InitlMrgnRcvdPstHrcut", skip_serializing_if = "Option::is_none") )]
	pub initl_mrgn_rcvd_pst_hrcut: Option<ActiveOrHistoricCurrencyAnd20DecimalAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VartnMrgnRcvdPreHrcut", skip_serializing_if = "Option::is_none") )]
	pub vartn_mrgn_rcvd_pre_hrcut: Option<ActiveOrHistoricCurrencyAnd20DecimalAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VartnMrgnRcvdPstHrcut", skip_serializing_if = "Option::is_none") )]
	pub vartn_mrgn_rcvd_pst_hrcut: Option<ActiveOrHistoricCurrencyAnd20DecimalAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XcssCollRcvd", skip_serializing_if = "Option::is_none") )]
	pub xcss_coll_rcvd: Option<ActiveOrHistoricCurrencyAnd20DecimalAmount>,
}

impl ReceivedMarginOrCollateral6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.initl_mrgn_rcvd_pre_hrcut { val.validate()? }
		if let Some(ref val) = self.initl_mrgn_rcvd_pst_hrcut { val.validate()? }
		if let Some(ref val) = self.vartn_mrgn_rcvd_pre_hrcut { val.validate()? }
		if let Some(ref val) = self.vartn_mrgn_rcvd_pst_hrcut { val.validate()? }
		if let Some(ref val) = self.xcss_coll_rcvd { val.validate()? }
		Ok(())
	}
}


// Reconciliation3Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum Reconciliation3Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "DPRW") )]
	CodeDPRW,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DPRV") )]
	CodeDPRV,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DSMA") )]
	CodeDSMA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DSNM") )]
	CodeDSNM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NORE") )]
	CodeNORE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SSMA") )]
	CodeSSMA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SSPA") )]
	CodeSSPA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SPRW") )]
	CodeSPRW,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SPRV") )]
	CodeSPRV,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SSUN") )]
	CodeSSUN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SSNE") )]
	CodeSSNE,
}

impl Reconciliation3Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ReconciliationCategory4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ReconciliationCategory4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rvvd") )]
	pub rvvd: bool,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrthrMod") )]
	pub frthr_mod: bool,
}

impl ReconciliationCategory4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ReconciliationCategory5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ReconciliationCategory5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgTp") )]
	pub rptg_tp: TradeRepositoryReportingType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pairg") )]
	pub pairg: PairingStatus1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rcncltn") )]
	pub rcncltn: ReconciliationStatus1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ValtnRcncltn") )]
	pub valtn_rcncltn: ReconciliationStatus2Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rvvd") )]
	pub rvvd: bool,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrthrMod") )]
	pub frthr_mod: bool,
}

impl ReconciliationCategory5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.rptg_tp.validate()?;
		self.pairg.validate()?;
		self.rcncltn.validate()?;
		self.valtn_rcncltn.validate()?;
		Ok(())
	}
}


// ReconciliationCounterpartyPairStatistics7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ReconciliationCounterpartyPairStatistics7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPtyId") )]
	pub ctr_pty_id: CounterpartyData91,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlNbOfTxs") )]
	pub ttl_nb_of_txs: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RcncltnRpt") )]
	pub rcncltn_rpt: Vec<ReconciliationReport15>,
}

impl ReconciliationCounterpartyPairStatistics7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.ctr_pty_id.validate()?;
		for item in &self.rcncltn_rpt { item.validate()? }
		Ok(())
	}
}


// ReconciliationFlag2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ReconciliationFlag2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptTp", skip_serializing_if = "Option::is_none") )]
	pub rpt_tp: Option<TradeRepositoryReportingType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BothCtrPtiesRptg", skip_serializing_if = "Option::is_none") )]
	pub both_ctr_pties_rptg: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PairdSts", skip_serializing_if = "Option::is_none") )]
	pub paird_sts: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LnRcncltnSts", skip_serializing_if = "Option::is_none") )]
	pub ln_rcncltn_sts: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollRcncltnSts", skip_serializing_if = "Option::is_none") )]
	pub coll_rcncltn_sts: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ModSts", skip_serializing_if = "Option::is_none") )]
	pub mod_sts: Option<bool>,
}

impl ReconciliationFlag2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.rpt_tp { val.validate()? }
		Ok(())
	}
}


// ReconciliationMatchedStatus9Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ReconciliationMatchedStatus9Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Mtchd", skip_serializing_if = "Option::is_none") )]
	pub mtchd: Option<NoReasonCode>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NotMtchd", skip_serializing_if = "Option::is_none") )]
	pub not_mtchd: Option<ReconciliationResult10>,
}

impl ReconciliationMatchedStatus9Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.mtchd { val.validate()? }
		if let Some(ref val) = self.not_mtchd { val.validate()? }
		Ok(())
	}
}


// ReconciliationReport15 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ReconciliationReport15 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxId") )]
	pub tx_id: TradeTransactionIdentification24,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MtchgCrit") )]
	pub mtchg_crit: MatchingCriteria17,
}

impl ReconciliationReport15 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.tx_id.validate()?;
		self.mtchg_crit.validate()?;
		Ok(())
	}
}


// ReconciliationReport8 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ReconciliationReport8 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechRcrdId", skip_serializing_if = "Option::is_none") )]
	pub tech_rcrd_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxId") )]
	pub tx_id: TradeTransactionIdentification19,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Modfd") )]
	pub modfd: bool,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RcncltnSts") )]
	pub rcncltn_sts: ReconciliationStatus8Choice,
}

impl ReconciliationReport8 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tech_rcrd_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tech_rcrd_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "tech_rcrd_id exceeds the maximum length of 140".to_string()));
			}
		}
		self.tx_id.validate()?;
		self.rcncltn_sts.validate()?;
		Ok(())
	}
}


// ReconciliationResult10 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ReconciliationResult10 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPty1") )]
	pub ctr_pty1: OrganisationIdentification15Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPty2") )]
	pub ctr_pty2: OrganisationIdentification15Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MtchgCrit") )]
	pub mtchg_crit: MatchingCriteria10,
}

impl ReconciliationResult10 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.ctr_pty1.validate()?;
		self.ctr_pty2.validate()?;
		self.mtchg_crit.validate()?;
		Ok(())
	}
}


// ReconciliationStatisticsPerCounterparty4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ReconciliationStatisticsPerCounterparty4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RefDt") )]
	pub ref_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RcncltnCtgrs") )]
	pub rcncltn_ctgrs: ReportingRequirement3Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlNbOfTxs", skip_serializing_if = "Option::is_none") )]
	pub ttl_nb_of_txs: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxDtls", skip_serializing_if = "Option::is_none") )]
	pub tx_dtls: Option<Vec<ReconciliationCounterpartyPairStatistics7>>,
}

impl ReconciliationStatisticsPerCounterparty4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.rcncltn_ctgrs.validate()?;
		if let Some(ref vec) = self.tx_dtls { for item in vec { item.validate()? } }
		Ok(())
	}
}


// ReconciliationStatus1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum ReconciliationStatus1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "NREC") )]
	CodeNREC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RECO") )]
	CodeRECO,
}

impl ReconciliationStatus1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ReconciliationStatus2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum ReconciliationStatus2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "NREC") )]
	CodeNREC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RECO") )]
	CodeRECO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NOAP") )]
	CodeNOAP,
}

impl ReconciliationStatus2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ReconciliationStatus8Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ReconciliationStatus8Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NoRcncltnReqrd", skip_serializing_if = "Option::is_none") )]
	pub no_rcncltn_reqrd: Option<NoReasonCode>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgData", skip_serializing_if = "Option::is_none") )]
	pub rptg_data: Option<ReconciliationMatchedStatus9Choice>,
}

impl ReconciliationStatus8Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.no_rcncltn_reqrd { val.validate()? }
		if let Some(ref val) = self.rptg_data { val.validate()? }
		Ok(())
	}
}


// RecordTechnicalData2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct RecordTechnicalData2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RctDtTm") )]
	pub rct_dt_tm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CxlRsn") )]
	pub cxl_rsn: CancelledStatusReason15Code,
}

impl RecordTechnicalData2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.cxl_rsn.validate()?;
		Ok(())
	}
}


// RecordTechnicalData4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct RecordTechnicalData4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "IncnsstncyInd", skip_serializing_if = "Option::is_none") )]
	pub incnsstncy_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LastUpd", skip_serializing_if = "Option::is_none") )]
	pub last_upd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubmissnDtTm", skip_serializing_if = "Option::is_none") )]
	pub submissn_dt_tm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RlvntCmptntAuthrty", skip_serializing_if = "Option::is_none") )]
	pub rlvnt_cmptnt_authrty: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PblctnPrd", skip_serializing_if = "Option::is_none") )]
	pub pblctn_prd: Option<Period4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NvrPblshd", skip_serializing_if = "Option::is_none") )]
	pub nvr_pblshd: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RlvntTradgVn", skip_serializing_if = "Option::is_none") )]
	pub rlvnt_tradg_vn: Option<String>,
}

impl RecordTechnicalData4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.rlvnt_cmptnt_authrty {
			let pattern = Regex::new("[A-Z]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "rlvnt_cmptnt_authrty does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.pblctn_prd { val.validate()? }
		if let Some(ref val) = self.rlvnt_tradg_vn {
			let pattern = Regex::new("[A-Z0-9]{4,4}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "rlvnt_tradg_vn does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// RecordTechnicalData5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct RecordTechnicalData5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RctDtTm") )]
	pub rct_dt_tm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XchgRsn") )]
	pub xchg_rsn: Vec<String>,
}

impl RecordTechnicalData5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		for item in &self.xchg_rsn {
			if item.chars().count() < 1 {
				return Err(ValidationError::new(1001, "xchg_rsn is shorter than the minimum length of 1".to_string()));
			}
			if item.chars().count() > 4 {
				return Err(ValidationError::new(1002, "xchg_rsn exceeds the maximum length of 4".to_string()));
			}
		}
		Ok(())
	}
}


// RegisteredContract16 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct RegisteredContract16 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrctRegnAmdmntId") )]
	pub ctrct_regn_amdmnt_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgPty") )]
	pub rptg_pty: TradeParty6,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RegnAgt") )]
	pub regn_agt: BranchAndFinancialInstitutionIdentification8,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RegdCtrctAmdmnt") )]
	pub regd_ctrct_amdmnt: Vec<RegisteredContract17>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl RegisteredContract16 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.ctrct_regn_amdmnt_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "ctrct_regn_amdmnt_id is shorter than the minimum length of 1".to_string()));
		}
		if self.ctrct_regn_amdmnt_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "ctrct_regn_amdmnt_id exceeds the maximum length of 35".to_string()));
		}
		self.rptg_pty.validate()?;
		self.regn_agt.validate()?;
		for item in &self.regd_ctrct_amdmnt { item.validate()? }
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// RegisteredContract17 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct RegisteredContract17 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RegdCtrctAmdmntId") )]
	pub regd_ctrct_amdmnt_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlRegdCtrctId") )]
	pub orgnl_regd_ctrct_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prty") )]
	pub prty: Priority2Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ctrct") )]
	pub ctrct: UnderlyingContract4Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrctBal", skip_serializing_if = "Option::is_none") )]
	pub ctrct_bal: Option<Vec<ContractBalance1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtSchdlTp", skip_serializing_if = "Option::is_none") )]
	pub pmt_schdl_tp: Option<PaymentScheduleType2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_inf: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Attchmnt", skip_serializing_if = "Option::is_none") )]
	pub attchmnt: Option<Vec<DocumentGeneralInformation5>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl RegisteredContract17 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.regd_ctrct_amdmnt_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "regd_ctrct_amdmnt_id is shorter than the minimum length of 1".to_string()));
		}
		if self.regd_ctrct_amdmnt_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "regd_ctrct_amdmnt_id exceeds the maximum length of 35".to_string()));
		}
		if self.orgnl_regd_ctrct_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "orgnl_regd_ctrct_id is shorter than the minimum length of 1".to_string()));
		}
		if self.orgnl_regd_ctrct_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "orgnl_regd_ctrct_id exceeds the maximum length of 35".to_string()));
		}
		self.prty.validate()?;
		self.ctrct.validate()?;
		if let Some(ref vec) = self.ctrct_bal { for item in vec { item.validate()? } }
		if let Some(ref val) = self.pmt_schdl_tp { val.validate()? }
		if let Some(ref val) = self.addtl_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 1025 {
				return Err(ValidationError::new(1002, "addtl_inf exceeds the maximum length of 1025".to_string()));
			}
		}
		if let Some(ref vec) = self.attchmnt { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// RegisteredContract18 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct RegisteredContract18 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlCtrctRegnReq", skip_serializing_if = "Option::is_none") )]
	pub orgnl_ctrct_regn_req: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IssrFI") )]
	pub issr_fi: BranchAndFinancialInstitutionIdentification8,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ctrct") )]
	pub ctrct: UnderlyingContract4Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrctBal", skip_serializing_if = "Option::is_none") )]
	pub ctrct_bal: Option<Vec<ContractBalance1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtSchdlTp", skip_serializing_if = "Option::is_none") )]
	pub pmt_schdl_tp: Option<PaymentScheduleType2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RegdCtrctId") )]
	pub regd_ctrct_id: DocumentIdentification29,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrvsRegdCtrctId", skip_serializing_if = "Option::is_none") )]
	pub prvs_regd_ctrct_id: Option<DocumentIdentification22>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RegdCtrctJrnl", skip_serializing_if = "Option::is_none") )]
	pub regd_ctrct_jrnl: Option<Vec<RegisteredContractJournal3>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amdmnt", skip_serializing_if = "Option::is_none") )]
	pub amdmnt: Option<Vec<RegisteredContractAmendment1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Submissn") )]
	pub submissn: RegisteredContractCommunication1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dlvry") )]
	pub dlvry: RegisteredContractCommunication1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LnPrncplAmt", skip_serializing_if = "Option::is_none") )]
	pub ln_prncpl_amt: Option<ActiveCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EstmtdDtInd") )]
	pub estmtd_dt_ind: bool,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrCpnyLn") )]
	pub intr_cpny_ln: bool,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_inf: Option<String>,
}

impl RegisteredContract18 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.orgnl_ctrct_regn_req {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_ctrct_regn_req is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_ctrct_regn_req exceeds the maximum length of 35".to_string()));
			}
		}
		self.issr_fi.validate()?;
		self.ctrct.validate()?;
		if let Some(ref vec) = self.ctrct_bal { for item in vec { item.validate()? } }
		if let Some(ref val) = self.pmt_schdl_tp { val.validate()? }
		self.regd_ctrct_id.validate()?;
		if let Some(ref val) = self.prvs_regd_ctrct_id { val.validate()? }
		if let Some(ref vec) = self.regd_ctrct_jrnl { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.amdmnt { for item in vec { item.validate()? } }
		self.submissn.validate()?;
		self.dlvry.validate()?;
		if let Some(ref val) = self.ln_prncpl_amt { val.validate()? }
		if let Some(ref val) = self.addtl_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 1025 {
				return Err(ValidationError::new(1002, "addtl_inf exceeds the maximum length of 1025".to_string()));
			}
		}
		Ok(())
	}
}


// RegisteredContract19 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct RegisteredContract19 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RegdCtrctClsrId") )]
	pub regd_ctrct_clsr_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgPty") )]
	pub rptg_pty: TradeParty6,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RegnAgt") )]
	pub regn_agt: BranchAndFinancialInstitutionIdentification8,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlRegdCtrct") )]
	pub orgnl_regd_ctrct: DocumentIdentification29,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prty") )]
	pub prty: Priority2Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClsrRsn") )]
	pub clsr_rsn: ContractClosureReason1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cssn", skip_serializing_if = "Option::is_none") )]
	pub cssn: Option<ContractCessionData2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Attchmnt", skip_serializing_if = "Option::is_none") )]
	pub attchmnt: Option<Vec<DocumentGeneralInformation5>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl RegisteredContract19 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.regd_ctrct_clsr_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "regd_ctrct_clsr_id is shorter than the minimum length of 1".to_string()));
		}
		if self.regd_ctrct_clsr_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "regd_ctrct_clsr_id exceeds the maximum length of 35".to_string()));
		}
		self.rptg_pty.validate()?;
		self.regn_agt.validate()?;
		self.orgnl_regd_ctrct.validate()?;
		self.prty.validate()?;
		self.clsr_rsn.validate()?;
		if let Some(ref val) = self.cssn { val.validate()? }
		if let Some(ref vec) = self.attchmnt { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// RegisteredContract20 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct RegisteredContract20 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlCtrctRegnReq", skip_serializing_if = "Option::is_none") )]
	pub orgnl_ctrct_regn_req: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgPty") )]
	pub rptg_pty: TradeParty6,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RegnAgt") )]
	pub regn_agt: BranchAndFinancialInstitutionIdentification8,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IssrFI") )]
	pub issr_fi: BranchAndFinancialInstitutionIdentification8,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ctrct") )]
	pub ctrct: UnderlyingContract4Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrctBal", skip_serializing_if = "Option::is_none") )]
	pub ctrct_bal: Option<Vec<ContractBalance1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtSchdlTp", skip_serializing_if = "Option::is_none") )]
	pub pmt_schdl_tp: Option<PaymentScheduleType2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RegdCtrctId") )]
	pub regd_ctrct_id: DocumentIdentification29,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrvsRegdCtrctId", skip_serializing_if = "Option::is_none") )]
	pub prvs_regd_ctrct_id: Option<DocumentIdentification22>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RegdCtrctJrnl", skip_serializing_if = "Option::is_none") )]
	pub regd_ctrct_jrnl: Option<Vec<RegisteredContractJournal3>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amdmnt", skip_serializing_if = "Option::is_none") )]
	pub amdmnt: Option<Vec<RegisteredContractAmendment1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Submissn") )]
	pub submissn: RegisteredContractCommunication1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dlvry") )]
	pub dlvry: RegisteredContractCommunication1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LnPrncplAmt", skip_serializing_if = "Option::is_none") )]
	pub ln_prncpl_amt: Option<ActiveCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EstmtdDtInd") )]
	pub estmtd_dt_ind: bool,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrCpnyLn") )]
	pub intr_cpny_ln: bool,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_inf: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl RegisteredContract20 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.orgnl_ctrct_regn_req {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_ctrct_regn_req is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_ctrct_regn_req exceeds the maximum length of 35".to_string()));
			}
		}
		self.rptg_pty.validate()?;
		self.regn_agt.validate()?;
		self.issr_fi.validate()?;
		self.ctrct.validate()?;
		if let Some(ref vec) = self.ctrct_bal { for item in vec { item.validate()? } }
		if let Some(ref val) = self.pmt_schdl_tp { val.validate()? }
		self.regd_ctrct_id.validate()?;
		if let Some(ref val) = self.prvs_regd_ctrct_id { val.validate()? }
		if let Some(ref vec) = self.regd_ctrct_jrnl { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.amdmnt { for item in vec { item.validate()? } }
		self.submissn.validate()?;
		self.dlvry.validate()?;
		if let Some(ref val) = self.ln_prncpl_amt { val.validate()? }
		if let Some(ref val) = self.addtl_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 1025 {
				return Err(ValidationError::new(1002, "addtl_inf exceeds the maximum length of 1025".to_string()));
			}
		}
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// RegisteredContractAmendment1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct RegisteredContractAmendment1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AmdmntDt") )]
	pub amdmnt_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Doc") )]
	pub doc: DocumentIdentification28,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StartDt", skip_serializing_if = "Option::is_none") )]
	pub start_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AmdmntRsn", skip_serializing_if = "Option::is_none") )]
	pub amdmnt_rsn: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_inf: Option<String>,
}

impl RegisteredContractAmendment1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.doc.validate()?;
		if let Some(ref val) = self.amdmnt_rsn {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "amdmnt_rsn is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "amdmnt_rsn exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.addtl_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 1025 {
				return Err(ValidationError::new(1002, "addtl_inf exceeds the maximum length of 1025".to_string()));
			}
		}
		Ok(())
	}
}


// RegisteredContractCommunication1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct RegisteredContractCommunication1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Mtd") )]
	pub mtd: CommunicationMethod4Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dt") )]
	pub dt: String,
}

impl RegisteredContractCommunication1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.mtd.validate()?;
		Ok(())
	}
}


// RegisteredContractJournal3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct RegisteredContractJournal3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RegnAgt") )]
	pub regn_agt: BranchAndFinancialInstitutionIdentification8,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnqId", skip_serializing_if = "Option::is_none") )]
	pub unq_id: Option<DocumentIdentification28>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClsrDt") )]
	pub clsr_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClsrRsn") )]
	pub clsr_rsn: ContractClosureReason1Choice,
}

impl RegisteredContractJournal3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.regn_agt.validate()?;
		if let Some(ref val) = self.unq_id { val.validate()? }
		self.clsr_rsn.validate()?;
		Ok(())
	}
}


// RegulatoryReportingNotification4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct RegulatoryReportingNotification4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxNtfctnId") )]
	pub tx_ntfctn_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctOwnr") )]
	pub acct_ownr: PartyIdentification272,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctSvcr") )]
	pub acct_svcr: BranchAndFinancialInstitutionIdentification8,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxCert") )]
	pub tx_cert: Vec<TransactionCertificate4>,
}

impl RegulatoryReportingNotification4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.tx_ntfctn_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "tx_ntfctn_id is shorter than the minimum length of 1".to_string()));
		}
		if self.tx_ntfctn_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "tx_ntfctn_id exceeds the maximum length of 35".to_string()));
		}
		self.acct_ownr.validate()?;
		self.acct_svcr.validate()?;
		for item in &self.tx_cert { item.validate()? }
		Ok(())
	}
}


// RegulatoryTradingCapacity1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum RegulatoryTradingCapacity1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "MTCH") )]
	CodeMTCH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DEAL") )]
	CodeDEAL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AOTC") )]
	CodeAOTC,
}

impl RegulatoryTradingCapacity1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ReinvestedCashTypeAndAmount1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ReinvestedCashTypeAndAmount1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: ReinvestmentType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RinvstdCshAmt") )]
	pub rinvstd_csh_amt: ActiveOrHistoricCurrencyAndAmount,
}

impl ReinvestedCashTypeAndAmount1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.tp.validate()?;
		self.rinvstd_csh_amt.validate()?;
		Ok(())
	}
}


// ReinvestedCashTypeAndAmount2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ReinvestedCashTypeAndAmount2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: ReinvestmentType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RinvstdCshCcy") )]
	pub rinvstd_csh_ccy: String,
}

impl ReinvestedCashTypeAndAmount2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.tp.validate()?;
		let pattern = Regex::new("[A-Z]{3,3}").unwrap();
		if !pattern.is_match(&self.rinvstd_csh_ccy) {
			return Err(ValidationError::new(1005, "rinvstd_csh_ccy does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// ReinvestmentType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum ReinvestmentType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OCMP") )]
	CodeOCMP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MMFT") )]
	CodeMMFT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "REPM") )]
	CodeREPM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SDPU") )]
	CodeSDPU,
}

impl ReinvestmentType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// RejectionReason45 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct RejectionReason45 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgRptId") )]
	pub msg_rpt_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sts") )]
	pub sts: ReportingMessageStatus1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtldVldtnRule", skip_serializing_if = "Option::is_none") )]
	pub dtld_vldtn_rule: Option<GenericValidationRuleIdentification1>,
}

impl RejectionReason45 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.msg_rpt_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "msg_rpt_id is shorter than the minimum length of 1".to_string()));
		}
		if self.msg_rpt_id.chars().count() > 140 {
			return Err(ValidationError::new(1002, "msg_rpt_id exceeds the maximum length of 140".to_string()));
		}
		self.sts.validate()?;
		if let Some(ref val) = self.dtld_vldtn_rule { val.validate()? }
		Ok(())
	}
}


// RejectionReason53 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct RejectionReason53 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxId") )]
	pub tx_id: TransactionIdentification3Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sts") )]
	pub sts: ReportingMessageStatus1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtldVldtnRule", skip_serializing_if = "Option::is_none") )]
	pub dtld_vldtn_rule: Option<Vec<GenericValidationRuleIdentification1>>,
}

impl RejectionReason53 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.tx_id.validate()?;
		self.sts.validate()?;
		if let Some(ref vec) = self.dtld_vldtn_rule { for item in vec { item.validate()? } }
		Ok(())
	}
}


// RejectionReason70 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct RejectionReason70 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgRptId") )]
	pub msg_rpt_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sts") )]
	pub sts: ReportingMessageStatus2Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtldVldtnRule", skip_serializing_if = "Option::is_none") )]
	pub dtld_vldtn_rule: Option<GenericValidationRuleIdentification1>,
}

impl RejectionReason70 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.msg_rpt_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "msg_rpt_id is shorter than the minimum length of 1".to_string()));
		}
		if self.msg_rpt_id.chars().count() > 140 {
			return Err(ValidationError::new(1002, "msg_rpt_id exceeds the maximum length of 140".to_string()));
		}
		self.sts.validate()?;
		if let Some(ref val) = self.dtld_vldtn_rule { val.validate()? }
		Ok(())
	}
}


// RejectionReason71 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct RejectionReason71 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxId") )]
	pub tx_id: TradeTransactionIdentification24,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sts") )]
	pub sts: ReportingMessageStatus2Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtldVldtnRule", skip_serializing_if = "Option::is_none") )]
	pub dtld_vldtn_rule: Option<Vec<GenericValidationRuleIdentification1>>,
}

impl RejectionReason71 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.tx_id.validate()?;
		self.sts.validate()?;
		if let Some(ref vec) = self.dtld_vldtn_rule { for item in vec { item.validate()? } }
		Ok(())
	}
}


// RejectionStatistics9 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct RejectionStatistics9 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPtyId") )]
	pub ctr_pty_id: CounterpartyData92,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptSttstcs") )]
	pub rpt_sttstcs: DetailedReportStatistics7,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DerivSttstcs") )]
	pub deriv_sttstcs: DetailedTransactionStatistics7Choice,
}

impl RejectionStatistics9 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.ctr_pty_id.validate()?;
		self.rpt_sttstcs.validate()?;
		self.deriv_sttstcs.validate()?;
		Ok(())
	}
}


// RepoTerminationOption2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum RepoTerminationOption2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "EGRN") )]
	CodeEGRN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EGAE") )]
	CodeEGAE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ETSB") )]
	CodeETSB,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NOAP") )]
	CodeNOAP,
}

impl RepoTerminationOption2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ReportPeriodActivity1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum ReportPeriodActivity1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "NOTX") )]
	CodeNOTX,
}

impl ReportPeriodActivity1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ReportPeriodActivity3Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum ReportPeriodActivity3Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "NOTX") )]
	CodeNOTX,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NORA") )]
	CodeNORA,
}

impl ReportPeriodActivity3Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ReportingAssetBreakdown1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ReportingAssetBreakdown1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgAsstTp") )]
	pub rptg_asst_tp: ProductType6Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveCurrencyAndAmount,
}

impl ReportingAssetBreakdown1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.rptg_asst_tp.validate()?;
		if let Some(ref val) = self.id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 350 {
				return Err(ValidationError::new(1002, "id exceeds the maximum length of 350".to_string()));
			}
		}
		self.amt.validate()?;
		Ok(())
	}
}


// ReportingExemption1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ReportingExemption1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn") )]
	pub rsn: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Desc", skip_serializing_if = "Option::is_none") )]
	pub desc: Option<String>,
}

impl ReportingExemption1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.rsn.chars().count() < 1 {
			return Err(ValidationError::new(1001, "rsn is shorter than the minimum length of 1".to_string()));
		}
		if self.rsn.chars().count() > 4 {
			return Err(ValidationError::new(1002, "rsn exceeds the maximum length of 4".to_string()));
		}
		if let Some(ref val) = self.desc {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "desc is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 1000 {
				return Err(ValidationError::new(1002, "desc exceeds the maximum length of 1000".to_string()));
			}
		}
		Ok(())
	}
}


// ReportingMessageStatus1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum ReportingMessageStatus1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ACPT") )]
	CodeACPT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ACTC") )]
	CodeACTC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PART") )]
	CodePART,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RCVD") )]
	CodeRCVD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RJCT") )]
	CodeRJCT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RMDR") )]
	CodeRMDR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "WARN") )]
	CodeWARN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INCF") )]
	CodeINCF,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CRPT") )]
	CodeCRPT,
}

impl ReportingMessageStatus1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ReportingMessageStatus2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum ReportingMessageStatus2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ACPT") )]
	CodeACPT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RJCT") )]
	CodeRJCT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INCF") )]
	CodeINCF,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CRPT") )]
	CodeCRPT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NAUT") )]
	CodeNAUT,
}

impl ReportingMessageStatus2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ReportingPeriod4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ReportingPeriod4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrToDt") )]
	pub fr_to_dt: DatePeriod3,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrToTm") )]
	pub fr_to_tm: TimePeriod2,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: QueryType3Code,
}

impl ReportingPeriod4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.fr_to_dt.validate()?;
		self.fr_to_tm.validate()?;
		self.tp.validate()?;
		Ok(())
	}
}


// ReportingRecordStatus1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum ReportingRecordStatus1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ACPT") )]
	CodeACPT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ACPD") )]
	CodeACPD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PDNG") )]
	CodePDNG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RCVD") )]
	CodeRCVD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RJCT") )]
	CodeRJCT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RJPD") )]
	CodeRJPD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "WARN") )]
	CodeWARN,
}

impl ReportingRecordStatus1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ReportingRequirement3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ReportingRequirement3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgRqrmnt", skip_serializing_if = "Option::is_none") )]
	pub rptg_rqrmnt: Option<ReconciliationCategory5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NoRptgRqrmnt", skip_serializing_if = "Option::is_none") )]
	pub no_rptg_rqrmnt: Option<ReconciliationCategory4>,
}

impl ReportingRequirement3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.rptg_rqrmnt { val.validate()? }
		if let Some(ref val) = self.no_rptg_rqrmnt { val.validate()? }
		Ok(())
	}
}


// ReportingTransactionType3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ReportingTransactionType3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "New", skip_serializing_if = "Option::is_none") )]
	pub new: Option<SecuritiesTransactionReport7>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cxl", skip_serializing_if = "Option::is_none") )]
	pub cxl: Option<SecuritiesTransactionReport2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl ReportingTransactionType3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.new { val.validate()? }
		if let Some(ref val) = self.cxl { val.validate()? }
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// ReportingWaiverType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum ReportingWaiverType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "OILQ") )]
	CodeOILQ,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NLIQ") )]
	CodeNLIQ,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PRIC") )]
	CodePRIC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ILQD") )]
	CodeILQD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RFPT") )]
	CodeRFPT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SIZE") )]
	CodeSIZE,
}

impl ReportingWaiverType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ReportingWaiverType3Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum ReportingWaiverType3Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "BENC") )]
	CodeBENC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ACTX") )]
	CodeACTX,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ILQD") )]
	CodeILQD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SIZE") )]
	CodeSIZE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CANC") )]
	CodeCANC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AMND") )]
	CodeAMND,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SDIV") )]
	CodeSDIV,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RPRI") )]
	CodeRPRI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DUPL") )]
	CodeDUPL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LRGS") )]
	CodeLRGS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TNCP") )]
	CodeTNCP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TPAC") )]
	CodeTPAC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XFPH") )]
	CodeXFPH,
}

impl ReportingWaiverType3Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// RepurchaseAgreement2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct RepurchaseAgreement2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MtrtyDt") )]
	pub mtrty_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ScndLegPric") )]
	pub scnd_leg_pric: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollMktVal") )]
	pub coll_mkt_val: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPty") )]
	pub ctr_pty: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RpAgrmtTp") )]
	pub rp_agrmt_tp: RepurchaseAgreementType3Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TrptyAgtId", skip_serializing_if = "Option::is_none") )]
	pub trpty_agt_id: Option<String>,
}

impl RepurchaseAgreement2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.scnd_leg_pric.validate()?;
		self.coll_mkt_val.validate()?;
		let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
		if !pattern.is_match(&self.ctr_pty) {
			return Err(ValidationError::new(1005, "ctr_pty does not match the required pattern".to_string()));
		}
		self.rp_agrmt_tp.validate()?;
		if let Some(ref val) = self.trpty_agt_id {
			let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "trpty_agt_id does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// RepurchaseAgreement3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct RepurchaseAgreement3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PdctClssfctn") )]
	pub pdct_clssfctn: ProductClassification1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RpAgrmtTp") )]
	pub rp_agrmt_tp: RepurchaseAgreementType1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TrptyAgt", skip_serializing_if = "Option::is_none") )]
	pub trpty_agt: Option<String>,
}

impl RepurchaseAgreement3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.pdct_clssfctn.validate()?;
		self.rp_agrmt_tp.validate()?;
		if let Some(ref val) = self.trpty_agt {
			let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "trpty_agt does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// RepurchaseAgreementType1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct RepurchaseAgreementType1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SpcfcColl", skip_serializing_if = "Option::is_none") )]
	pub spcfc_coll: Option<SpecificCollateral2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GnlColl", skip_serializing_if = "Option::is_none") )]
	pub gnl_coll: Option<GeneralCollateral2>,
}

impl RepurchaseAgreementType1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.spcfc_coll { val.validate()? }
		if let Some(ref val) = self.gnl_coll { val.validate()? }
		Ok(())
	}
}


// RepurchaseAgreementType3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct RepurchaseAgreementType3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SpcfcColl", skip_serializing_if = "Option::is_none") )]
	pub spcfc_coll: Option<SpecificCollateral2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GnlColl", skip_serializing_if = "Option::is_none") )]
	pub gnl_coll: Option<GeneralCollateral3>,
}

impl RepurchaseAgreementType3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.spcfc_coll { val.validate()? }
		if let Some(ref val) = self.gnl_coll { val.validate()? }
		Ok(())
	}
}


// RequestType1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct RequestType1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nb") )]
	pub nb: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: Vec<TransactionRequestType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_inf: Option<String>,
}

impl RequestType1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.nb.chars().count() < 1 {
			return Err(ValidationError::new(1001, "nb is shorter than the minimum length of 1".to_string()));
		}
		if self.nb.chars().count() > 35 {
			return Err(ValidationError::new(1002, "nb exceeds the maximum length of 35".to_string()));
		}
		for item in &self.tp { item.validate()? }
		if let Some(ref val) = self.addtl_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 500 {
				return Err(ValidationError::new(1002, "addtl_inf exceeds the maximum length of 500".to_string()));
			}
		}
		Ok(())
	}
}


// ResetDateAndValue1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ResetDateAndValue1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dt") )]
	pub dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val", skip_serializing_if = "Option::is_none") )]
	pub val: Option<f64>,
}

impl ResetDateAndValue1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ReturnIndicator2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ReturnIndicator2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RspnPrd", skip_serializing_if = "Option::is_none") )]
	pub rspn_prd: Option<DateOrDateTimePeriod1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AuthrtyReqTp") )]
	pub authrty_req_tp: AuthorityRequestType1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InvstgtnRslt") )]
	pub invstgtn_rslt: InvestigationResult1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_inf: Option<String>,
}

impl ReturnIndicator2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.rspn_prd { val.validate()? }
		self.authrty_req_tp.validate()?;
		self.invstgtn_rslt.validate()?;
		if let Some(ref val) = self.addtl_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 500 {
				return Err(ValidationError::new(1002, "addtl_inf exceeds the maximum length of 500".to_string()));
			}
		}
		Ok(())
	}
}


// ReuseDataReport6Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ReuseDataReport6Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "New", skip_serializing_if = "Option::is_none") )]
	pub new: Option<ReuseDataReportNew6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Err", skip_serializing_if = "Option::is_none") )]
	pub err: Option<ReuseDataReportError5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Crrctn", skip_serializing_if = "Option::is_none") )]
	pub crrctn: Option<ReuseDataReportCorrection14>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollReuseUpd", skip_serializing_if = "Option::is_none") )]
	pub coll_reuse_upd: Option<ReuseDataReportCorrection14>,
}

impl ReuseDataReport6Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.new { val.validate()? }
		if let Some(ref val) = self.err { val.validate()? }
		if let Some(ref val) = self.crrctn { val.validate()? }
		if let Some(ref val) = self.coll_reuse_upd { val.validate()? }
		Ok(())
	}
}


// ReuseDataReportCorrection14 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ReuseDataReportCorrection14 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechRcrdId", skip_serializing_if = "Option::is_none") )]
	pub tech_rcrd_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgDtTm") )]
	pub rptg_dt_tm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPty") )]
	pub ctr_pty: CounterpartyData87,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollCmpnt", skip_serializing_if = "Option::is_none") )]
	pub coll_cmpnt: Option<Vec<CollateralType19>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EvtDay") )]
	pub evt_day: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FndgSrc", skip_serializing_if = "Option::is_none") )]
	pub fndg_src: Option<Vec<FundingSource3>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl ReuseDataReportCorrection14 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tech_rcrd_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tech_rcrd_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "tech_rcrd_id exceeds the maximum length of 140".to_string()));
			}
		}
		self.ctr_pty.validate()?;
		if let Some(ref vec) = self.coll_cmpnt { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.fndg_src { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// ReuseDataReportCorrection15 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ReuseDataReportCorrection15 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechRcrdId", skip_serializing_if = "Option::is_none") )]
	pub tech_rcrd_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPty") )]
	pub ctr_pty: CounterpartyData87,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollCmpnt", skip_serializing_if = "Option::is_none") )]
	pub coll_cmpnt: Option<Vec<CollateralType19>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EvtDay") )]
	pub evt_day: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgDtTm") )]
	pub rptg_dt_tm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FndgSrc", skip_serializing_if = "Option::is_none") )]
	pub fndg_src: Option<Vec<FundingSource3>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RcncltnFlg", skip_serializing_if = "Option::is_none") )]
	pub rcncltn_flg: Option<ReconciliationFlag2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrctMod") )]
	pub ctrct_mod: ContractModification3,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl ReuseDataReportCorrection15 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tech_rcrd_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tech_rcrd_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "tech_rcrd_id exceeds the maximum length of 140".to_string()));
			}
		}
		self.ctr_pty.validate()?;
		if let Some(ref vec) = self.coll_cmpnt { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.fndg_src { for item in vec { item.validate()? } }
		if let Some(ref val) = self.rcncltn_flg { val.validate()? }
		self.ctrct_mod.validate()?;
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// ReuseDataReportError5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ReuseDataReportError5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechRcrdId", skip_serializing_if = "Option::is_none") )]
	pub tech_rcrd_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgDtTm") )]
	pub rptg_dt_tm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPty") )]
	pub ctr_pty: CounterpartyData87,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl ReuseDataReportError5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tech_rcrd_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tech_rcrd_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "tech_rcrd_id exceeds the maximum length of 140".to_string()));
			}
		}
		self.ctr_pty.validate()?;
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// ReuseDataReportNew6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ReuseDataReportNew6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechRcrdId", skip_serializing_if = "Option::is_none") )]
	pub tech_rcrd_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgDtTm") )]
	pub rptg_dt_tm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPty") )]
	pub ctr_pty: CounterpartyData87,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollCmpnt", skip_serializing_if = "Option::is_none") )]
	pub coll_cmpnt: Option<Vec<CollateralType19>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EvtDay") )]
	pub evt_day: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FndgSrc", skip_serializing_if = "Option::is_none") )]
	pub fndg_src: Option<Vec<FundingSource3>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl ReuseDataReportNew6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tech_rcrd_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tech_rcrd_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "tech_rcrd_id exceeds the maximum length of 140".to_string()));
			}
		}
		self.ctr_pty.validate()?;
		if let Some(ref vec) = self.coll_cmpnt { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.fndg_src { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// ReuseValue1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ReuseValue1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Actl", skip_serializing_if = "Option::is_none") )]
	pub actl: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Estmtd", skip_serializing_if = "Option::is_none") )]
	pub estmtd: Option<ActiveOrHistoricCurrencyAndAmount>,
}

impl ReuseValue1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.actl { val.validate()? }
		if let Some(ref val) = self.estmtd { val.validate()? }
		Ok(())
	}
}


// RiskFactor1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct RiskFactor1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StrssSz") )]
	pub strss_sz: StressSize1Choice,
}

impl RiskFactor1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
		}
		self.strss_sz.validate()?;
		Ok(())
	}
}


// RiskReductionService1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum RiskReductionService1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "NORR") )]
	CodeNORR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PWOS") )]
	CodePWOS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PRBM") )]
	CodePRBM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PWAS") )]
	CodePWAS,
}

impl RiskReductionService1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ScenarioDefinition2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ScenarioDefinition2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: GenericIdentification165,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ScnroTp") )]
	pub scnro_tp: ScenarioType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StrtgyStrssTp") )]
	pub strtgy_strss_tp: StrategyStressType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StrssItm") )]
	pub strss_itm: Vec<StressItem1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Desc", skip_serializing_if = "Option::is_none") )]
	pub desc: Option<String>,
}

impl ScenarioDefinition2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.id.validate()?;
		self.scnro_tp.validate()?;
		self.strtgy_strss_tp.validate()?;
		for item in &self.strss_itm { item.validate()? }
		if let Some(ref val) = self.desc {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "desc is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 2000 {
				return Err(ValidationError::new(1002, "desc exceeds the maximum length of 2000".to_string()));
			}
		}
		Ok(())
	}
}


// ScenarioStressTestResult1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ScenarioStressTestResult1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: GenericIdentification168,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrtflStrssTstRslt") )]
	pub prtfl_strss_tst_rslt: Vec<PortfolioStressTestResult1>,
}

impl ScenarioStressTestResult1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.id.validate()?;
		for item in &self.prtfl_strss_tst_rslt { item.validate()? }
		Ok(())
	}
}


// ScenarioType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum ScenarioType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "HIST") )]
	CodeHIST,
	#[cfg_attr( feature = "derive_serde", serde(rename = "HYPT") )]
	CodeHYPT,
}

impl ScenarioType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// Schedule1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Schedule1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "UadjstdFctvDt") )]
	pub uadjstd_fctv_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UadjstdEndDt", skip_serializing_if = "Option::is_none") )]
	pub uadjstd_end_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pric") )]
	pub pric: SecuritiesTransactionPrice17Choice,
}

impl Schedule1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.pric.validate()?;
		Ok(())
	}
}


// Schedule10 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Schedule10 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Qty") )]
	pub qty: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnitOfMeasr", skip_serializing_if = "Option::is_none") )]
	pub unit_of_measr: Option<UnitOfMeasure8Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UadjstdFctvDt") )]
	pub uadjstd_fctv_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UadjstdEndDt", skip_serializing_if = "Option::is_none") )]
	pub uadjstd_end_dt: Option<String>,
}

impl Schedule10 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.unit_of_measr { val.validate()? }
		Ok(())
	}
}


// Schedule11 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Schedule11 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "UadjstdFctvDt") )]
	pub uadjstd_fctv_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UadjstdEndDt", skip_serializing_if = "Option::is_none") )]
	pub uadjstd_end_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: AmountAndDirection106,
}

impl Schedule11 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.amt.validate()?;
		Ok(())
	}
}


// Schedule4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Schedule4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "UadjstdFctvDt") )]
	pub uadjstd_fctv_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UadjstdEndDt", skip_serializing_if = "Option::is_none") )]
	pub uadjstd_end_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pric") )]
	pub pric: SecuritiesTransactionPrice17Choice,
}

impl Schedule4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.pric.validate()?;
		Ok(())
	}
}


// SchemeIdentificationType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum SchemeIdentificationType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "MARG") )]
	CodeMARG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "COLL") )]
	CodeCOLL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "POSI") )]
	CodePOSI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CLIM") )]
	CodeCLIM,
}

impl SchemeIdentificationType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// SearchCriteria2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SearchCriteria2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Acct", skip_serializing_if = "Option::is_none") )]
	pub acct: Option<AccountAndParties3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CstmrId", skip_serializing_if = "Option::is_none") )]
	pub cstmr_id: Option<CustomerIdentification2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtInstrm", skip_serializing_if = "Option::is_none") )]
	pub pmt_instrm: Option<PaymentInstrumentType1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlTxNb", skip_serializing_if = "Option::is_none") )]
	pub orgnl_tx_nb: Option<Vec<RequestType1>>,
}

impl SearchCriteria2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.acct { val.validate()? }
		if let Some(ref val) = self.cstmr_id { val.validate()? }
		if let Some(ref val) = self.pmt_instrm { val.validate()? }
		if let Some(ref vec) = self.orgnl_tx_nb { for item in vec { item.validate()? } }
		Ok(())
	}
}


// SectorAndLocation1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SectorAndLocation1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sctr") )]
	pub sctr: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Lctn") )]
	pub lctn: String,
}

impl SectorAndLocation1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z]{2,2}").unwrap();
		if !pattern.is_match(&self.lctn) {
			return Err(ValidationError::new(1005, "lctn does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// SecuredCollateral2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecuredCollateral2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SnglColl", skip_serializing_if = "Option::is_none") )]
	pub sngl_coll: Option<CollateralValuation6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MltplColl", skip_serializing_if = "Option::is_none") )]
	pub mltpl_coll: Option<Vec<CollateralValuation6>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PoolColl", skip_serializing_if = "Option::is_none") )]
	pub pool_coll: Option<CollateralValuation6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrColl", skip_serializing_if = "Option::is_none") )]
	pub othr_coll: Option<Vec<CollateralValuation7>>,
}

impl SecuredCollateral2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.sngl_coll { val.validate()? }
		if let Some(ref vec) = self.mltpl_coll { for item in vec { item.validate()? } }
		if let Some(ref val) = self.pool_coll { val.validate()? }
		if let Some(ref vec) = self.othr_coll { for item in vec { item.validate()? } }
		Ok(())
	}
}


// SecuredMarketReport4Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecuredMarketReport4Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DataSetActn", skip_serializing_if = "Option::is_none") )]
	pub data_set_actn: Option<ReportPeriodActivity3Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tx", skip_serializing_if = "Option::is_none") )]
	pub tx: Option<Vec<SecuredMarketTransaction4>>,
}

impl SecuredMarketReport4Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.data_set_actn { val.validate()? }
		if let Some(ref vec) = self.tx { for item in vec { item.validate()? } }
		Ok(())
	}
}


// SecuredMarketTransaction4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecuredMarketTransaction4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptdTxSts") )]
	pub rptd_tx_sts: TransactionOperationType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NvtnSts", skip_serializing_if = "Option::is_none") )]
	pub nvtn_sts: Option<NovationStatus1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BrnchId", skip_serializing_if = "Option::is_none") )]
	pub brnch_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnqTxIdr", skip_serializing_if = "Option::is_none") )]
	pub unq_tx_idr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrtryTxId") )]
	pub prtry_tx_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RltdPrtryTxId", skip_serializing_if = "Option::is_none") )]
	pub rltd_prtry_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPtyPrtryTxId", skip_serializing_if = "Option::is_none") )]
	pub ctr_pty_prtry_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPtyId") )]
	pub ctr_pty_id: CounterpartyIdentification3Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TrptyAgtId", skip_serializing_if = "Option::is_none") )]
	pub trpty_agt_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradDt") )]
	pub trad_dt: DateAndDateTimeChoice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttlmDt") )]
	pub sttlm_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MtrtyDt") )]
	pub mtrty_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxTp") )]
	pub tx_tp: MoneyMarketTransactionType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxNmnlAmt") )]
	pub tx_nmnl_amt: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RateTp") )]
	pub rate_tp: InterestRateType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DealRate", skip_serializing_if = "Option::is_none") )]
	pub deal_rate: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FltgRateRpAgrmt", skip_serializing_if = "Option::is_none") )]
	pub fltg_rate_rp_agrmt: Option<FloatingRateNote2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BrkrdDeal", skip_serializing_if = "Option::is_none") )]
	pub brkrd_deal: Option<BrokeredDeal1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Coll") )]
	pub coll: Collateral18,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl SecuredMarketTransaction4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.rptd_tx_sts.validate()?;
		if let Some(ref val) = self.nvtn_sts { val.validate()? }
		if let Some(ref val) = self.brnch_id {
			let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "brnch_id does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.unq_tx_idr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "unq_tx_idr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 105 {
				return Err(ValidationError::new(1002, "unq_tx_idr exceeds the maximum length of 105".to_string()));
			}
		}
		if self.prtry_tx_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "prtry_tx_id is shorter than the minimum length of 1".to_string()));
		}
		if self.prtry_tx_id.chars().count() > 105 {
			return Err(ValidationError::new(1002, "prtry_tx_id exceeds the maximum length of 105".to_string()));
		}
		if let Some(ref val) = self.rltd_prtry_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "rltd_prtry_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 105 {
				return Err(ValidationError::new(1002, "rltd_prtry_tx_id exceeds the maximum length of 105".to_string()));
			}
		}
		if let Some(ref val) = self.ctr_pty_prtry_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "ctr_pty_prtry_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 105 {
				return Err(ValidationError::new(1002, "ctr_pty_prtry_tx_id exceeds the maximum length of 105".to_string()));
			}
		}
		self.ctr_pty_id.validate()?;
		if let Some(ref val) = self.trpty_agt_id {
			let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "trpty_agt_id does not match the required pattern".to_string()));
			}
		}
		self.trad_dt.validate()?;
		self.tx_tp.validate()?;
		self.tx_nmnl_amt.validate()?;
		self.rate_tp.validate()?;
		if let Some(ref val) = self.fltg_rate_rp_agrmt { val.validate()? }
		if let Some(ref val) = self.brkrd_deal { val.validate()? }
		self.coll.validate()?;
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// SecuritiesCountryIdentification2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecuritiesCountryIdentification2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ctry") )]
	pub ctry: CountryCodeAndName3,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EEACtry") )]
	pub eea_ctry: bool,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Mod", skip_serializing_if = "Option::is_none") )]
	pub mod_attr: Option<Modification1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VldtyPrd") )]
	pub vldty_prd: Period4Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LastUpdtd", skip_serializing_if = "Option::is_none") )]
	pub last_updtd: Option<String>,
}

impl SecuritiesCountryIdentification2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.ctry.validate()?;
		if let Some(ref val) = self.mod_attr { val.validate()? }
		self.vldty_prd.validate()?;
		Ok(())
	}
}


// SecuritiesCurrencyIdentification2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecuritiesCurrencyIdentification2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ccy") )]
	pub ccy: CurrencyCodeAndName1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrctnlDgt", skip_serializing_if = "Option::is_none") )]
	pub frctnl_dgt: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtryDtls") )]
	pub ctry_dtls: CountryCodeAndName3,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PreEuro") )]
	pub pre_euro: bool,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Mod", skip_serializing_if = "Option::is_none") )]
	pub mod_attr: Option<Modification1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VldtyPrd") )]
	pub vldty_prd: Period4Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LastUpdtd", skip_serializing_if = "Option::is_none") )]
	pub last_updtd: Option<String>,
}

impl SecuritiesCurrencyIdentification2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.ccy.validate()?;
		self.ctry_dtls.validate()?;
		if let Some(ref val) = self.mod_attr { val.validate()? }
		self.vldty_prd.validate()?;
		Ok(())
	}
}


// SecuritiesIndexReport1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecuritiesIndexReport1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechRcrdId", skip_serializing_if = "Option::is_none") )]
	pub tech_rcrd_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RqstngNtty", skip_serializing_if = "Option::is_none") )]
	pub rqstng_ntty: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Indx") )]
	pub indx: FinancialInstrument46Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VldtyPrd", skip_serializing_if = "Option::is_none") )]
	pub vldty_prd: Option<Period4Choice>,
}

impl SecuritiesIndexReport1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tech_rcrd_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tech_rcrd_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "tech_rcrd_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.rqstng_ntty {
			let pattern = Regex::new("[A-Z]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "rqstng_ntty does not match the required pattern".to_string()));
			}
		}
		self.indx.validate()?;
		if let Some(ref val) = self.vldty_prd { val.validate()? }
		Ok(())
	}
}


// SecuritiesInstrumentClassification2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecuritiesInstrumentClassification2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Idr") )]
	pub idr: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Mod", skip_serializing_if = "Option::is_none") )]
	pub mod_attr: Option<Modification1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VldtyPrd") )]
	pub vldty_prd: Period4Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LastUpdtd", skip_serializing_if = "Option::is_none") )]
	pub last_updtd: Option<String>,
}

impl SecuritiesInstrumentClassification2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z]{6,6}").unwrap();
		if !pattern.is_match(&self.idr) {
			return Err(ValidationError::new(1005, "idr does not match the required pattern".to_string()));
		}
		if let Some(ref val) = self.mod_attr { val.validate()? }
		self.vldty_prd.validate()?;
		Ok(())
	}
}


// SecuritiesInvalidReferenceDataReport4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecuritiesInvalidReferenceDataReport4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FinInstrm") )]
	pub fin_instrm: SecuritiesReferenceDataReport6,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl SecuritiesInvalidReferenceDataReport4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.fin_instrm.validate()?;
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// SecuritiesLendingType3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecuritiesLendingType3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl SecuritiesLendingType3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// SecuritiesMarketReportHeader1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecuritiesMarketReportHeader1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgNtty") )]
	pub rptg_ntty: TradingVenueIdentification1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgPrd") )]
	pub rptg_prd: Period4Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubmissnDtTm", skip_serializing_if = "Option::is_none") )]
	pub submissn_dt_tm: Option<String>,
}

impl SecuritiesMarketReportHeader1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.rptg_ntty.validate()?;
		self.rptg_prd.validate()?;
		Ok(())
	}
}


// SecuritiesMarketReportHeader3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecuritiesMarketReportHeader3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgNtty") )]
	pub rptg_ntty: TradingVenueIdentification1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgPrd") )]
	pub rptg_prd: Period11Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ISIN", skip_serializing_if = "Option::is_none") )]
	pub isin: Option<Vec<String>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubmissnDtTm", skip_serializing_if = "Option::is_none") )]
	pub submissn_dt_tm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgPgntn", skip_serializing_if = "Option::is_none") )]
	pub msg_pgntn: Option<Pagination1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbRcrds", skip_serializing_if = "Option::is_none") )]
	pub nb_rcrds: Option<f64>,
}

impl SecuritiesMarketReportHeader3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.rptg_ntty.validate()?;
		self.rptg_prd.validate()?;
		if let Some(ref vec) = self.isin {
			for item in vec {
				let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
				if !pattern.is_match(&item) {
					return Err(ValidationError::new(1005, "isin does not match the required pattern".to_string()));
				}
			}
		}
		if let Some(ref val) = self.msg_pgntn { val.validate()? }
		Ok(())
	}
}


// SecuritiesNonTradingDay1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecuritiesNonTradingDay1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechRcrdId", skip_serializing_if = "Option::is_none") )]
	pub tech_rcrd_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dt") )]
	pub dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn", skip_serializing_if = "Option::is_none") )]
	pub rsn: Option<NonTradingDayReason1Code>,
}

impl SecuritiesNonTradingDay1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tech_rcrd_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tech_rcrd_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "tech_rcrd_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.rsn { val.validate()? }
		Ok(())
	}
}


// SecuritiesNonTradingDayReport1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecuritiesNonTradingDayReport1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: TradingVenueIdentification1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NonWorkgDay") )]
	pub non_workg_day: Vec<SecuritiesNonTradingDay1>,
}

impl SecuritiesNonTradingDayReport1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.id.validate()?;
		for item in &self.non_workg_day { item.validate()? }
		Ok(())
	}
}


// SecuritiesReferenceDataReport6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecuritiesReferenceDataReport6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechRcrdId", skip_serializing_if = "Option::is_none") )]
	pub tech_rcrd_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FinInstrmGnlAttrbts") )]
	pub fin_instrm_gnl_attrbts: SecurityInstrumentDescription9,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr") )]
	pub issr: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradgVnRltdAttrbts") )]
	pub tradg_vn_rltd_attrbts: Vec<TradingVenueAttributes1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DebtInstrmAttrbts", skip_serializing_if = "Option::is_none") )]
	pub debt_instrm_attrbts: Option<DebtInstrument2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DerivInstrmAttrbts", skip_serializing_if = "Option::is_none") )]
	pub deriv_instrm_attrbts: Option<DerivativeInstrument5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechAttrbts", skip_serializing_if = "Option::is_none") )]
	pub tech_attrbts: Option<RecordTechnicalData4>,
}

impl SecuritiesReferenceDataReport6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tech_rcrd_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tech_rcrd_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "tech_rcrd_id exceeds the maximum length of 35".to_string()));
			}
		}
		self.fin_instrm_gnl_attrbts.validate()?;
		let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
		if !pattern.is_match(&self.issr) {
			return Err(ValidationError::new(1005, "issr does not match the required pattern".to_string()));
		}
		for item in &self.tradg_vn_rltd_attrbts { item.validate()? }
		if let Some(ref val) = self.debt_instrm_attrbts { val.validate()? }
		if let Some(ref val) = self.deriv_instrm_attrbts { val.validate()? }
		if let Some(ref val) = self.tech_attrbts { val.validate()? }
		Ok(())
	}
}


// SecuritiesReferenceDataReport7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecuritiesReferenceDataReport7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechRcrdId", skip_serializing_if = "Option::is_none") )]
	pub tech_rcrd_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FinInstrmGnlAttrbts") )]
	pub fin_instrm_gnl_attrbts: SecurityInstrumentDescription17,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr", skip_serializing_if = "Option::is_none") )]
	pub issr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradgVnRltdAttrbts") )]
	pub tradg_vn_rltd_attrbts: Vec<TradingVenueAttributes2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DebtInstrmAttrbts", skip_serializing_if = "Option::is_none") )]
	pub debt_instrm_attrbts: Option<DebtInstrument2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DerivInstrmAttrbts", skip_serializing_if = "Option::is_none") )]
	pub deriv_instrm_attrbts: Option<DerivativeInstrument5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechAttrbts", skip_serializing_if = "Option::is_none") )]
	pub tech_attrbts: Option<RecordTechnicalData4>,
}

impl SecuritiesReferenceDataReport7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tech_rcrd_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tech_rcrd_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "tech_rcrd_id exceeds the maximum length of 35".to_string()));
			}
		}
		self.fin_instrm_gnl_attrbts.validate()?;
		if let Some(ref val) = self.issr {
			let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "issr does not match the required pattern".to_string()));
			}
		}
		for item in &self.tradg_vn_rltd_attrbts { item.validate()? }
		if let Some(ref val) = self.debt_instrm_attrbts { val.validate()? }
		if let Some(ref val) = self.deriv_instrm_attrbts { val.validate()? }
		if let Some(ref val) = self.tech_attrbts { val.validate()? }
		Ok(())
	}
}


// SecuritiesReferenceDeltaStatusReport5Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecuritiesReferenceDeltaStatusReport5Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ModfdRcrd", skip_serializing_if = "Option::is_none") )]
	pub modfd_rcrd: Option<SecuritiesReferenceDataReport6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NewRcrd", skip_serializing_if = "Option::is_none") )]
	pub new_rcrd: Option<SecuritiesReferenceDataReport6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TermntdRcrd", skip_serializing_if = "Option::is_none") )]
	pub termntd_rcrd: Option<SecuritiesReferenceDataReport6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CancRcrd", skip_serializing_if = "Option::is_none") )]
	pub canc_rcrd: Option<SecuritiesReferenceDataReport7>,
}

impl SecuritiesReferenceDeltaStatusReport5Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.modfd_rcrd { val.validate()? }
		if let Some(ref val) = self.new_rcrd { val.validate()? }
		if let Some(ref val) = self.termntd_rcrd { val.validate()? }
		if let Some(ref val) = self.canc_rcrd { val.validate()? }
		Ok(())
	}
}


// SecuritiesSettlementSystemIdentification2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecuritiesSettlementSystemIdentification2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SysId") )]
	pub sys_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SysNm", skip_serializing_if = "Option::is_none") )]
	pub sys_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtryOfJursdctn", skip_serializing_if = "Option::is_none") )]
	pub ctry_of_jursdctn: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CSDLglNm", skip_serializing_if = "Option::is_none") )]
	pub csd_lgl_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LEI", skip_serializing_if = "Option::is_none") )]
	pub lei: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RspnsblPty", skip_serializing_if = "Option::is_none") )]
	pub rspnsbl_pty: Option<Vec<Contact9>>,
}

impl SecuritiesSettlementSystemIdentification2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.sys_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "sys_id is shorter than the minimum length of 1".to_string()));
		}
		if self.sys_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "sys_id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.sys_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "sys_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "sys_nm exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.ctry_of_jursdctn {
			let pattern = Regex::new("[A-Z]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ctry_of_jursdctn does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.csd_lgl_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "csd_lgl_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "csd_lgl_nm exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.lei {
			let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "lei does not match the required pattern".to_string()));
			}
		}
		if let Some(ref vec) = self.rspnsbl_pty { for item in vec { item.validate()? } }
		Ok(())
	}
}


// SecuritiesTradeVenueCriteria1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecuritiesTradeVenueCriteria1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MIC", skip_serializing_if = "Option::is_none") )]
	pub mic: Option<Vec<String>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AnyMIC", skip_serializing_if = "Option::is_none") )]
	pub any_mic: Option<AnyMIC1Code>,
}

impl SecuritiesTradeVenueCriteria1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.mic {
			for item in vec {
				let pattern = Regex::new("[A-Z0-9]{4,4}").unwrap();
				if !pattern.is_match(&item) {
					return Err(ValidationError::new(1005, "mic does not match the required pattern".to_string()));
				}
			}
		}
		if let Some(ref val) = self.any_mic { val.validate()? }
		Ok(())
	}
}


// SecuritiesTransaction3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecuritiesTransaction3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradDt") )]
	pub trad_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradgCpcty") )]
	pub tradg_cpcty: RegulatoryTradingCapacity1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Qty") )]
	pub qty: FinancialInstrumentQuantity25Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DgtlTknQty", skip_serializing_if = "Option::is_none") )]
	pub dgtl_tkn_qty: Option<Vec<DigitalTokenAmount2>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DerivNtnlChng", skip_serializing_if = "Option::is_none") )]
	pub deriv_ntnl_chng: Option<VariationType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pric") )]
	pub pric: SecuritiesTransactionPrice22Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NetAmt", skip_serializing_if = "Option::is_none") )]
	pub net_amt: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradVn") )]
	pub trad_vn: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtryOfBrnch", skip_serializing_if = "Option::is_none") )]
	pub ctry_of_brnch: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UpFrntPmt", skip_serializing_if = "Option::is_none") )]
	pub up_frnt_pmt: Option<AmountAndDirection53>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradPlcMtchgId", skip_serializing_if = "Option::is_none") )]
	pub trad_plc_mtchg_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CmplxTradCmpntId", skip_serializing_if = "Option::is_none") )]
	pub cmplx_trad_cmpnt_id: Option<String>,
}

impl SecuritiesTransaction3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.tradg_cpcty.validate()?;
		self.qty.validate()?;
		if let Some(ref vec) = self.dgtl_tkn_qty { for item in vec { item.validate()? } }
		if let Some(ref val) = self.deriv_ntnl_chng { val.validate()? }
		self.pric.validate()?;
		let pattern = Regex::new("[A-Z0-9]{4,4}").unwrap();
		if !pattern.is_match(&self.trad_vn) {
			return Err(ValidationError::new(1005, "trad_vn does not match the required pattern".to_string()));
		}
		if let Some(ref val) = self.ctry_of_brnch {
			let pattern = Regex::new("[A-Z]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ctry_of_brnch does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.up_frnt_pmt { val.validate()? }
		if let Some(ref val) = self.trad_plc_mtchg_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "trad_plc_mtchg_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 52 {
				return Err(ValidationError::new(1002, "trad_plc_mtchg_id exceeds the maximum length of 52".to_string()));
			}
		}
		if let Some(ref val) = self.cmplx_trad_cmpnt_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cmplx_trad_cmpnt_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "cmplx_trad_cmpnt_id exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// SecuritiesTransactionIndicator2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecuritiesTransactionIndicator2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "WvrInd", skip_serializing_if = "Option::is_none") )]
	pub wvr_ind: Option<Vec<ReportingWaiverType1Code>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ShrtSellgInd", skip_serializing_if = "Option::is_none") )]
	pub shrt_sellg_ind: Option<Side5Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTCPstTradInd", skip_serializing_if = "Option::is_none") )]
	pub otc_pst_trad_ind: Option<Vec<ReportingWaiverType3Code>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RskRdcgTx", skip_serializing_if = "Option::is_none") )]
	pub rsk_rdcg_tx: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SctiesFincgTxInd") )]
	pub scties_fincg_tx_ind: bool,
}

impl SecuritiesTransactionIndicator2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.wvr_ind { for item in vec { item.validate()? } }
		if let Some(ref val) = self.shrt_sellg_ind { val.validate()? }
		if let Some(ref vec) = self.otc_pst_trad_ind { for item in vec { item.validate()? } }
		Ok(())
	}
}


// SecuritiesTransactionPrice1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecuritiesTransactionPrice1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pdg") )]
	pub pdg: PriceStatus1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ccy", skip_serializing_if = "Option::is_none") )]
	pub ccy: Option<String>,
}

impl SecuritiesTransactionPrice1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.pdg.validate()?;
		if let Some(ref val) = self.ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ccy does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// SecuritiesTransactionPrice13Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecuritiesTransactionPrice13Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MntryVal", skip_serializing_if = "Option::is_none") )]
	pub mntry_val: Option<AmountAndDirection106>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pctg", skip_serializing_if = "Option::is_none") )]
	pub pctg: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dcml", skip_serializing_if = "Option::is_none") )]
	pub dcml: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BsisPtSprd", skip_serializing_if = "Option::is_none") )]
	pub bsis_pt_sprd: Option<f64>,
}

impl SecuritiesTransactionPrice13Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.mntry_val { val.validate()? }
		Ok(())
	}
}


// SecuritiesTransactionPrice14Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecuritiesTransactionPrice14Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rate", skip_serializing_if = "Option::is_none") )]
	pub rate: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dcml", skip_serializing_if = "Option::is_none") )]
	pub dcml: Option<f64>,
}

impl SecuritiesTransactionPrice14Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// SecuritiesTransactionPrice17Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecuritiesTransactionPrice17Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MntryVal", skip_serializing_if = "Option::is_none") )]
	pub mntry_val: Option<AmountAndDirection106>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Unit", skip_serializing_if = "Option::is_none") )]
	pub unit: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pctg", skip_serializing_if = "Option::is_none") )]
	pub pctg: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Yld", skip_serializing_if = "Option::is_none") )]
	pub yld: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dcml", skip_serializing_if = "Option::is_none") )]
	pub dcml: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PdgPric", skip_serializing_if = "Option::is_none") )]
	pub pdg_pric: Option<PriceStatus1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<SecuritiesTransactionPrice5>,
}

impl SecuritiesTransactionPrice17Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.mntry_val { val.validate()? }
		if let Some(ref val) = self.pdg_pric { val.validate()? }
		if let Some(ref val) = self.othr { val.validate()? }
		Ok(())
	}
}


// SecuritiesTransactionPrice18Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecuritiesTransactionPrice18Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MntryVal", skip_serializing_if = "Option::is_none") )]
	pub mntry_val: Option<AmountAndDirection107>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pctg", skip_serializing_if = "Option::is_none") )]
	pub pctg: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dcml", skip_serializing_if = "Option::is_none") )]
	pub dcml: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BsisPts", skip_serializing_if = "Option::is_none") )]
	pub bsis_pts: Option<f64>,
}

impl SecuritiesTransactionPrice18Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.mntry_val { val.validate()? }
		Ok(())
	}
}


// SecuritiesTransactionPrice19Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecuritiesTransactionPrice19Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MntryVal", skip_serializing_if = "Option::is_none") )]
	pub mntry_val: Option<AmountAndDirection107>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Unit", skip_serializing_if = "Option::is_none") )]
	pub unit: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pctg", skip_serializing_if = "Option::is_none") )]
	pub pctg: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Yld", skip_serializing_if = "Option::is_none") )]
	pub yld: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dcml", skip_serializing_if = "Option::is_none") )]
	pub dcml: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PdgPric", skip_serializing_if = "Option::is_none") )]
	pub pdg_pric: Option<PriceStatus1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<SecuritiesTransactionPrice5>,
}

impl SecuritiesTransactionPrice19Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.mntry_val { val.validate()? }
		if let Some(ref val) = self.pdg_pric { val.validate()? }
		if let Some(ref val) = self.othr { val.validate()? }
		Ok(())
	}
}


// SecuritiesTransactionPrice20Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecuritiesTransactionPrice20Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MntryVal", skip_serializing_if = "Option::is_none") )]
	pub mntry_val: Option<AmountAndDirection106>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pctg", skip_serializing_if = "Option::is_none") )]
	pub pctg: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dcml", skip_serializing_if = "Option::is_none") )]
	pub dcml: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BsisPtSprd", skip_serializing_if = "Option::is_none") )]
	pub bsis_pt_sprd: Option<f64>,
}

impl SecuritiesTransactionPrice20Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.mntry_val { val.validate()? }
		Ok(())
	}
}


// SecuritiesTransactionPrice21Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecuritiesTransactionPrice21Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MntryVal", skip_serializing_if = "Option::is_none") )]
	pub mntry_val: Option<AmountAndDirection53>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pctg", skip_serializing_if = "Option::is_none") )]
	pub pctg: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Yld", skip_serializing_if = "Option::is_none") )]
	pub yld: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BsisPts", skip_serializing_if = "Option::is_none") )]
	pub bsis_pts: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NmnlVal", skip_serializing_if = "Option::is_none") )]
	pub nmnl_val: Option<ActiveOrHistoricCurrencyAndAmount>,
}

impl SecuritiesTransactionPrice21Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.mntry_val { val.validate()? }
		if let Some(ref val) = self.nmnl_val { val.validate()? }
		Ok(())
	}
}


// SecuritiesTransactionPrice22Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecuritiesTransactionPrice22Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pric", skip_serializing_if = "Option::is_none") )]
	pub pric: Option<SecuritiesTransactionPrice2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DgtlTknPric", skip_serializing_if = "Option::is_none") )]
	pub dgtl_tkn_pric: Option<SecuritiesTransactionPrice7>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NoPric", skip_serializing_if = "Option::is_none") )]
	pub no_pric: Option<SecuritiesTransactionPrice6>,
}

impl SecuritiesTransactionPrice22Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.pric { val.validate()? }
		if let Some(ref val) = self.dgtl_tkn_pric { val.validate()? }
		if let Some(ref val) = self.no_pric { val.validate()? }
		Ok(())
	}
}


// SecuritiesTransactionPrice23Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecuritiesTransactionPrice23Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MntryVal", skip_serializing_if = "Option::is_none") )]
	pub mntry_val: Option<AmountAndDirection106>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Unit", skip_serializing_if = "Option::is_none") )]
	pub unit: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pctg", skip_serializing_if = "Option::is_none") )]
	pub pctg: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Yld", skip_serializing_if = "Option::is_none") )]
	pub yld: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dcml", skip_serializing_if = "Option::is_none") )]
	pub dcml: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<SecuritiesTransactionPrice5>,
}

impl SecuritiesTransactionPrice23Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.mntry_val { val.validate()? }
		if let Some(ref val) = self.othr { val.validate()? }
		Ok(())
	}
}


// SecuritiesTransactionPrice2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecuritiesTransactionPrice2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MntryVal", skip_serializing_if = "Option::is_none") )]
	pub mntry_val: Option<AmountAndDirection61>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pctg", skip_serializing_if = "Option::is_none") )]
	pub pctg: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Yld", skip_serializing_if = "Option::is_none") )]
	pub yld: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BsisPts", skip_serializing_if = "Option::is_none") )]
	pub bsis_pts: Option<f64>,
}

impl SecuritiesTransactionPrice2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.mntry_val { val.validate()? }
		Ok(())
	}
}


// SecuritiesTransactionPrice4Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecuritiesTransactionPrice4Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pric", skip_serializing_if = "Option::is_none") )]
	pub pric: Option<SecuritiesTransactionPrice2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NoPric", skip_serializing_if = "Option::is_none") )]
	pub no_pric: Option<SecuritiesTransactionPrice1>,
}

impl SecuritiesTransactionPrice4Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.pric { val.validate()? }
		if let Some(ref val) = self.no_pric { val.validate()? }
		Ok(())
	}
}


// SecuritiesTransactionPrice5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecuritiesTransactionPrice5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val", skip_serializing_if = "Option::is_none") )]
	pub val: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<String>,
}

impl SecuritiesTransactionPrice5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tp {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tp is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "tp exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// SecuritiesTransactionPrice6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecuritiesTransactionPrice6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pdg") )]
	pub pdg: PriceStatus1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ccy", skip_serializing_if = "Option::is_none") )]
	pub ccy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DgtlTkn", skip_serializing_if = "Option::is_none") )]
	pub dgtl_tkn: Option<Vec<DigitalTokenAmount2>>,
}

impl SecuritiesTransactionPrice6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.pdg.validate()?;
		if let Some(ref val) = self.ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ccy does not match the required pattern".to_string()));
			}
		}
		if let Some(ref vec) = self.dgtl_tkn { for item in vec { item.validate()? } }
		Ok(())
	}
}


// SecuritiesTransactionPrice7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecuritiesTransactionPrice7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MntryVal") )]
	pub mntry_val: AmountAndDirection61,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DgtlTknQty") )]
	pub dgtl_tkn_qty: DigitalTokenAmount2,
}

impl SecuritiesTransactionPrice7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.mntry_val.validate()?;
		self.dgtl_tkn_qty.validate()?;
		Ok(())
	}
}


// SecuritiesTransactionReport2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecuritiesTransactionReport2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxId") )]
	pub tx_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ExctgPty") )]
	pub exctg_pty: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubmitgPty") )]
	pub submitg_pty: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechAttrbts", skip_serializing_if = "Option::is_none") )]
	pub tech_attrbts: Option<RecordTechnicalData2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl SecuritiesTransactionReport2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.tx_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "tx_id is shorter than the minimum length of 1".to_string()));
		}
		if self.tx_id.chars().count() > 52 {
			return Err(ValidationError::new(1002, "tx_id exceeds the maximum length of 52".to_string()));
		}
		let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
		if !pattern.is_match(&self.exctg_pty) {
			return Err(ValidationError::new(1005, "exctg_pty does not match the required pattern".to_string()));
		}
		let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
		if !pattern.is_match(&self.submitg_pty) {
			return Err(ValidationError::new(1005, "submitg_pty does not match the required pattern".to_string()));
		}
		if let Some(ref val) = self.tech_attrbts { val.validate()? }
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// SecuritiesTransactionReport7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecuritiesTransactionReport7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxId") )]
	pub tx_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ExctgPty") )]
	pub exctg_pty: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InvstmtPtyInd") )]
	pub invstmt_pty_ind: bool,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubmitgPty") )]
	pub submitg_pty: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Buyr") )]
	pub buyr: PartyIdentification79,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sellr") )]
	pub sellr: PartyIdentification79,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrdrTrnsmssn") )]
	pub ordr_trnsmssn: SecuritiesTransactionTransmission2,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tx") )]
	pub tx: SecuritiesTransaction3,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FinInstrm") )]
	pub fin_instrm: FinancialInstrumentAttributes5Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InvstmtDcsnPrsn", skip_serializing_if = "Option::is_none") )]
	pub invstmt_dcsn_prsn: Option<InvestmentParty1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ExctgPrsn") )]
	pub exctg_prsn: ExecutingParty1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlAttrbts") )]
	pub addtl_attrbts: SecuritiesTransactionIndicator2,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechAttrbts", skip_serializing_if = "Option::is_none") )]
	pub tech_attrbts: Option<RecordTechnicalData5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl SecuritiesTransactionReport7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.tx_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "tx_id is shorter than the minimum length of 1".to_string()));
		}
		if self.tx_id.chars().count() > 52 {
			return Err(ValidationError::new(1002, "tx_id exceeds the maximum length of 52".to_string()));
		}
		let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
		if !pattern.is_match(&self.exctg_pty) {
			return Err(ValidationError::new(1005, "exctg_pty does not match the required pattern".to_string()));
		}
		let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
		if !pattern.is_match(&self.submitg_pty) {
			return Err(ValidationError::new(1005, "submitg_pty does not match the required pattern".to_string()));
		}
		self.buyr.validate()?;
		self.sellr.validate()?;
		self.ordr_trnsmssn.validate()?;
		self.tx.validate()?;
		self.fin_instrm.validate()?;
		if let Some(ref val) = self.invstmt_dcsn_prsn { val.validate()? }
		self.exctg_prsn.validate()?;
		self.addtl_attrbts.validate()?;
		if let Some(ref val) = self.tech_attrbts { val.validate()? }
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// SecuritiesTransactionTransmission2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecuritiesTransactionTransmission2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TrnsmssnInd") )]
	pub trnsmssn_ind: bool,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TrnsmttgBuyr", skip_serializing_if = "Option::is_none") )]
	pub trnsmttg_buyr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TrnsmttgSellr", skip_serializing_if = "Option::is_none") )]
	pub trnsmttg_sellr: Option<String>,
}

impl SecuritiesTransactionTransmission2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.trnsmttg_buyr {
			let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "trnsmttg_buyr does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.trnsmttg_sellr {
			let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "trnsmttg_sellr does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// SecuritiesTransactionType15Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum SecuritiesTransactionType15Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "BUYI") )]
	CodeBUYI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SELL") )]
	CodeSELL,
}

impl SecuritiesTransactionType15Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// Security48 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Security48 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<CompareISINIdentifier4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClssfctnTp", skip_serializing_if = "Option::is_none") )]
	pub clssfctn_tp: Option<CompareCFIIdentifier3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Qty", skip_serializing_if = "Option::is_none") )]
	pub qty: Option<CompareDecimalNumber3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NmnlVal", skip_serializing_if = "Option::is_none") )]
	pub nmnl_val: Option<CompareAmountAndDirection2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Qlty", skip_serializing_if = "Option::is_none") )]
	pub qlty: Option<CompareCollateralQualityType3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Mtrty", skip_serializing_if = "Option::is_none") )]
	pub mtrty: Option<CompareDate3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IssrId", skip_serializing_if = "Option::is_none") )]
	pub issr_id: Option<CompareOrganisationIdentification6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IssrCtry", skip_serializing_if = "Option::is_none") )]
	pub issr_ctry: Option<CompareCountryCode3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<Vec<CompareSecuritiesLendingType3>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnitPric", skip_serializing_if = "Option::is_none") )]
	pub unit_pric: Option<CompareUnitPrice6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ExclsvArrgmnt", skip_serializing_if = "Option::is_none") )]
	pub exclsv_arrgmnt: Option<CompareTrueFalseIndicator3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MktVal", skip_serializing_if = "Option::is_none") )]
	pub mkt_val: Option<CompareAmountAndDirection2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AvlblForCollReuse", skip_serializing_if = "Option::is_none") )]
	pub avlbl_for_coll_reuse: Option<CompareTrueFalseIndicator3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "HrcutOrMrgn", skip_serializing_if = "Option::is_none") )]
	pub hrcut_or_mrgn: Option<ComparePercentageRate3>,
}

impl Security48 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.id { val.validate()? }
		if let Some(ref val) = self.clssfctn_tp { val.validate()? }
		if let Some(ref val) = self.qty { val.validate()? }
		if let Some(ref val) = self.nmnl_val { val.validate()? }
		if let Some(ref val) = self.qlty { val.validate()? }
		if let Some(ref val) = self.mtrty { val.validate()? }
		if let Some(ref val) = self.issr_id { val.validate()? }
		if let Some(ref val) = self.issr_ctry { val.validate()? }
		if let Some(ref vec) = self.tp { for item in vec { item.validate()? } }
		if let Some(ref val) = self.unit_pric { val.validate()? }
		if let Some(ref val) = self.exclsv_arrgmnt { val.validate()? }
		if let Some(ref val) = self.mkt_val { val.validate()? }
		if let Some(ref val) = self.avlbl_for_coll_reuse { val.validate()? }
		if let Some(ref val) = self.hrcut_or_mrgn { val.validate()? }
		Ok(())
	}
}


// Security49 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Security49 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClssfctnTp", skip_serializing_if = "Option::is_none") )]
	pub clssfctn_tp: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "QtyOrNmnlVal", skip_serializing_if = "Option::is_none") )]
	pub qty_or_nmnl_val: Option<QuantityNominalValue2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnitPric", skip_serializing_if = "Option::is_none") )]
	pub unit_pric: Option<SecuritiesTransactionPrice19Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MktVal", skip_serializing_if = "Option::is_none") )]
	pub mkt_val: Option<AmountAndDirection53>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Qlty", skip_serializing_if = "Option::is_none") )]
	pub qlty: Option<CollateralQualityType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Mtrty", skip_serializing_if = "Option::is_none") )]
	pub mtrty: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr", skip_serializing_if = "Option::is_none") )]
	pub issr: Option<SecurityIssuer4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<Vec<SecuritiesLendingType3Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ExclsvArrgmnt", skip_serializing_if = "Option::is_none") )]
	pub exclsv_arrgmnt: Option<bool>,
}

impl Security49 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.id {
			let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "id does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.clssfctn_tp {
			let pattern = Regex::new("[A-Z]{6,6}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "clssfctn_tp does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.qty_or_nmnl_val { val.validate()? }
		if let Some(ref val) = self.unit_pric { val.validate()? }
		if let Some(ref val) = self.mkt_val { val.validate()? }
		if let Some(ref val) = self.qlty { val.validate()? }
		if let Some(ref val) = self.issr { val.validate()? }
		if let Some(ref vec) = self.tp { for item in vec { item.validate()? } }
		Ok(())
	}
}


// Security51 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Security51 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClssfctnTp", skip_serializing_if = "Option::is_none") )]
	pub clssfctn_tp: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "QtyOrNmnlVal", skip_serializing_if = "Option::is_none") )]
	pub qty_or_nmnl_val: Option<QuantityNominalValue2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnitPric", skip_serializing_if = "Option::is_none") )]
	pub unit_pric: Option<SecuritiesTransactionPrice19Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MktVal", skip_serializing_if = "Option::is_none") )]
	pub mkt_val: Option<AmountAndDirection53>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Qlty", skip_serializing_if = "Option::is_none") )]
	pub qlty: Option<CollateralQualityType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Mtrty", skip_serializing_if = "Option::is_none") )]
	pub mtrty: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr", skip_serializing_if = "Option::is_none") )]
	pub issr: Option<SecurityIssuer4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<Vec<SecuritiesLendingType3Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ExclsvArrgmnt", skip_serializing_if = "Option::is_none") )]
	pub exclsv_arrgmnt: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AvlblForCollReuse", skip_serializing_if = "Option::is_none") )]
	pub avlbl_for_coll_reuse: Option<bool>,
}

impl Security51 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.id {
			let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "id does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.clssfctn_tp {
			let pattern = Regex::new("[A-Z]{6,6}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "clssfctn_tp does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.qty_or_nmnl_val { val.validate()? }
		if let Some(ref val) = self.unit_pric { val.validate()? }
		if let Some(ref val) = self.mkt_val { val.validate()? }
		if let Some(ref val) = self.qlty { val.validate()? }
		if let Some(ref val) = self.issr { val.validate()? }
		if let Some(ref vec) = self.tp { for item in vec { item.validate()? } }
		Ok(())
	}
}


// Security52 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Security52 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClssfctnTp", skip_serializing_if = "Option::is_none") )]
	pub clssfctn_tp: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "QtyOrNmnlVal", skip_serializing_if = "Option::is_none") )]
	pub qty_or_nmnl_val: Option<QuantityNominalValue2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnitPric", skip_serializing_if = "Option::is_none") )]
	pub unit_pric: Option<SecuritiesTransactionPrice19Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MktVal", skip_serializing_if = "Option::is_none") )]
	pub mkt_val: Option<AmountAndDirection53>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Qlty", skip_serializing_if = "Option::is_none") )]
	pub qlty: Option<CollateralQualityType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Mtrty", skip_serializing_if = "Option::is_none") )]
	pub mtrty: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr", skip_serializing_if = "Option::is_none") )]
	pub issr: Option<SecurityIssuer4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<Vec<SecuritiesLendingType3Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ExclsvArrgmnt", skip_serializing_if = "Option::is_none") )]
	pub exclsv_arrgmnt: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "HrcutOrMrgn", skip_serializing_if = "Option::is_none") )]
	pub hrcut_or_mrgn: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AvlblForCollReuse", skip_serializing_if = "Option::is_none") )]
	pub avlbl_for_coll_reuse: Option<bool>,
}

impl Security52 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.id {
			let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "id does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.clssfctn_tp {
			let pattern = Regex::new("[A-Z]{6,6}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "clssfctn_tp does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.qty_or_nmnl_val { val.validate()? }
		if let Some(ref val) = self.unit_pric { val.validate()? }
		if let Some(ref val) = self.mkt_val { val.validate()? }
		if let Some(ref val) = self.qlty { val.validate()? }
		if let Some(ref val) = self.issr { val.validate()? }
		if let Some(ref vec) = self.tp { for item in vec { item.validate()? } }
		Ok(())
	}
}


// Security55 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Security55 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClssfctnTp", skip_serializing_if = "Option::is_none") )]
	pub clssfctn_tp: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "QtyOrNmnlVal", skip_serializing_if = "Option::is_none") )]
	pub qty_or_nmnl_val: Option<QuantityNominalValue2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnitPric", skip_serializing_if = "Option::is_none") )]
	pub unit_pric: Option<SecuritiesTransactionPrice19Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MktVal", skip_serializing_if = "Option::is_none") )]
	pub mkt_val: Option<AmountAndDirection53>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Qlty", skip_serializing_if = "Option::is_none") )]
	pub qlty: Option<CollateralQualityType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Mtrty", skip_serializing_if = "Option::is_none") )]
	pub mtrty: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr", skip_serializing_if = "Option::is_none") )]
	pub issr: Option<SecurityIssuer4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<Vec<SecuritiesLendingType3Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ExclsvArrgmnt", skip_serializing_if = "Option::is_none") )]
	pub exclsv_arrgmnt: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AvlblForCollReuse", skip_serializing_if = "Option::is_none") )]
	pub avlbl_for_coll_reuse: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "HrcutOrMrgn", skip_serializing_if = "Option::is_none") )]
	pub hrcut_or_mrgn: Option<f64>,
}

impl Security55 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.id {
			let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "id does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.clssfctn_tp {
			let pattern = Regex::new("[A-Z]{6,6}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "clssfctn_tp does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.qty_or_nmnl_val { val.validate()? }
		if let Some(ref val) = self.unit_pric { val.validate()? }
		if let Some(ref val) = self.mkt_val { val.validate()? }
		if let Some(ref val) = self.qlty { val.validate()? }
		if let Some(ref val) = self.issr { val.validate()? }
		if let Some(ref vec) = self.tp { for item in vec { item.validate()? } }
		Ok(())
	}
}


// SecurityCommodity7Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecurityCommodity7Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Scty", skip_serializing_if = "Option::is_none") )]
	pub scty: Option<Vec<Security48>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cmmdty", skip_serializing_if = "Option::is_none") )]
	pub cmmdty: Option<Vec<Commodity42>>,
}

impl SecurityCommodity7Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.scty { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.cmmdty { for item in vec { item.validate()? } }
		Ok(())
	}
}


// SecurityCommodity9 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecurityCommodity9 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Scty", skip_serializing_if = "Option::is_none") )]
	pub scty: Option<Vec<Security51>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cmmdty", skip_serializing_if = "Option::is_none") )]
	pub cmmdty: Option<Vec<Commodity43>>,
}

impl SecurityCommodity9 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.scty { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.cmmdty { for item in vec { item.validate()? } }
		Ok(())
	}
}


// SecurityCommodityCash4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecurityCommodityCash4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Scty", skip_serializing_if = "Option::is_none") )]
	pub scty: Option<Vec<Security48>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cmmdty", skip_serializing_if = "Option::is_none") )]
	pub cmmdty: Option<Vec<Commodity42>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Csh", skip_serializing_if = "Option::is_none") )]
	pub csh: Option<Vec<CashCompare3>>,
}

impl SecurityCommodityCash4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.scty { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.cmmdty { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.csh { for item in vec { item.validate()? } }
		Ok(())
	}
}


// SecurityIdentification19 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecurityIdentification19 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ISIN", skip_serializing_if = "Option::is_none") )]
	pub isin: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrId", skip_serializing_if = "Option::is_none") )]
	pub othr_id: Option<Vec<OtherIdentification1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Desc", skip_serializing_if = "Option::is_none") )]
	pub desc: Option<String>,
}

impl SecurityIdentification19 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.isin {
			let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "isin does not match the required pattern".to_string()));
			}
		}
		if let Some(ref vec) = self.othr_id { for item in vec { item.validate()? } }
		if let Some(ref val) = self.desc {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "desc is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "desc exceeds the maximum length of 140".to_string()));
			}
		}
		Ok(())
	}
}


// SecurityIdentification20Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecurityIdentification20Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ISIN", skip_serializing_if = "Option::is_none") )]
	pub isin: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm", skip_serializing_if = "Option::is_none") )]
	pub nm: Option<String>,
}

impl SecurityIdentification20Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.isin {
			let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "isin does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 25 {
				return Err(ValidationError::new(1002, "nm exceeds the maximum length of 25".to_string()));
			}
		}
		Ok(())
	}
}


// SecurityIdentification26Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecurityIdentification26Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NotAvlbl", skip_serializing_if = "Option::is_none") )]
	pub not_avlbl: Option<NotAvailable1Code>,
}

impl SecurityIdentification26Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.id {
			let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "id does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.not_avlbl { val.validate()? }
		Ok(())
	}
}


// SecurityIdentification41Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecurityIdentification41Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ISIN", skip_serializing_if = "Option::is_none") )]
	pub isin: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AltrntvInstrmId", skip_serializing_if = "Option::is_none") )]
	pub altrntv_instrm_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnqPdctIdr", skip_serializing_if = "Option::is_none") )]
	pub unq_pdct_idr: Option<UniqueProductIdentifier2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Bskt", skip_serializing_if = "Option::is_none") )]
	pub bskt: Option<CustomBasket4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Indx", skip_serializing_if = "Option::is_none") )]
	pub indx: Option<IndexIdentification1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<GenericIdentification184>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IdNotAvlbl", skip_serializing_if = "Option::is_none") )]
	pub id_not_avlbl: Option<UnderlyingIdentification1Code>,
}

impl SecurityIdentification41Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.isin {
			let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "isin does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.altrntv_instrm_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "altrntv_instrm_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 52 {
				return Err(ValidationError::new(1002, "altrntv_instrm_id exceeds the maximum length of 52".to_string()));
			}
		}
		if let Some(ref val) = self.unq_pdct_idr { val.validate()? }
		if let Some(ref val) = self.bskt { val.validate()? }
		if let Some(ref val) = self.indx { val.validate()? }
		if let Some(ref val) = self.othr { val.validate()? }
		if let Some(ref val) = self.id_not_avlbl { val.validate()? }
		Ok(())
	}
}


// SecurityIdentification46 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecurityIdentification46 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ISIN", skip_serializing_if = "Option::is_none") )]
	pub isin: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnqPdctIdr", skip_serializing_if = "Option::is_none") )]
	pub unq_pdct_idr: Option<UniqueProductIdentifier2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AltrntvInstrmId", skip_serializing_if = "Option::is_none") )]
	pub altrntv_instrm_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PdctDesc", skip_serializing_if = "Option::is_none") )]
	pub pdct_desc: Option<String>,
}

impl SecurityIdentification46 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.isin {
			let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "isin does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.unq_pdct_idr { val.validate()? }
		if let Some(ref val) = self.altrntv_instrm_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "altrntv_instrm_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 105 {
				return Err(ValidationError::new(1002, "altrntv_instrm_id exceeds the maximum length of 105".to_string()));
			}
		}
		if let Some(ref val) = self.pdct_desc {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "pdct_desc is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 1000 {
				return Err(ValidationError::new(1002, "pdct_desc exceeds the maximum length of 1000".to_string()));
			}
		}
		Ok(())
	}
}


// SecurityIdentificationAndAmount1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecurityIdentificationAndAmount1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MktVal") )]
	pub mkt_val: ActiveCurrencyAnd24Amount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FinInstrmTp") )]
	pub fin_instrm_tp: ProductType7Code,
}

impl SecurityIdentificationAndAmount1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
		if !pattern.is_match(&self.id) {
			return Err(ValidationError::new(1005, "id does not match the required pattern".to_string()));
		}
		self.mkt_val.validate()?;
		self.fin_instrm_tp.validate()?;
		Ok(())
	}
}


// SecurityIdentificationQuery4Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecurityIdentificationQuery4Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ISIN", skip_serializing_if = "Option::is_none") )]
	pub isin: Option<Vec<String>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AltrntvInstrmId", skip_serializing_if = "Option::is_none") )]
	pub altrntv_instrm_id: Option<Vec<String>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NotAvlbl", skip_serializing_if = "Option::is_none") )]
	pub not_avlbl: Option<NotAvailable1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnqPdctIdr", skip_serializing_if = "Option::is_none") )]
	pub unq_pdct_idr: Option<Vec<String>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Indx", skip_serializing_if = "Option::is_none") )]
	pub indx: Option<Vec<SecurityIdentification20Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Bskt", skip_serializing_if = "Option::is_none") )]
	pub bskt: Option<Vec<BasketQuery1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NotRptd", skip_serializing_if = "Option::is_none") )]
	pub not_rptd: Option<NotReported1Code>,
}

impl SecurityIdentificationQuery4Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.isin {
			for item in vec {
				let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
				if !pattern.is_match(&item) {
					return Err(ValidationError::new(1005, "isin does not match the required pattern".to_string()));
				}
			}
		}
		if let Some(ref vec) = self.altrntv_instrm_id {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "altrntv_instrm_id is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 52 {
					return Err(ValidationError::new(1002, "altrntv_instrm_id exceeds the maximum length of 52".to_string()));
				}
			}
		}
		if let Some(ref val) = self.not_avlbl { val.validate()? }
		if let Some(ref vec) = self.unq_pdct_idr {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "unq_pdct_idr is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 52 {
					return Err(ValidationError::new(1002, "unq_pdct_idr exceeds the maximum length of 52".to_string()));
				}
			}
		}
		if let Some(ref vec) = self.indx { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.bskt { for item in vec { item.validate()? } }
		if let Some(ref val) = self.not_rptd { val.validate()? }
		Ok(())
	}
}


// SecurityIdentificationQueryCriteria1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecurityIdentificationQueryCriteria1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ISIN", skip_serializing_if = "Option::is_none") )]
	pub isin: Option<Vec<String>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AltrntvInstrmId", skip_serializing_if = "Option::is_none") )]
	pub altrntv_instrm_id: Option<Vec<String>>,
}

impl SecurityIdentificationQueryCriteria1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.isin {
			for item in vec {
				let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
				if !pattern.is_match(&item) {
					return Err(ValidationError::new(1005, "isin does not match the required pattern".to_string()));
				}
			}
		}
		if let Some(ref vec) = self.altrntv_instrm_id {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "altrntv_instrm_id is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 52 {
					return Err(ValidationError::new(1002, "altrntv_instrm_id exceeds the maximum length of 52".to_string()));
				}
			}
		}
		Ok(())
	}
}


// SecurityInstrumentDescription17 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecurityInstrumentDescription17 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FullNm", skip_serializing_if = "Option::is_none") )]
	pub full_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ShrtNm", skip_serializing_if = "Option::is_none") )]
	pub shrt_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClssfctnTp", skip_serializing_if = "Option::is_none") )]
	pub clssfctn_tp: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtnlCcy", skip_serializing_if = "Option::is_none") )]
	pub ntnl_ccy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CmmdtyDerivInd", skip_serializing_if = "Option::is_none") )]
	pub cmmdty_deriv_ind: Option<bool>,
}

impl SecurityInstrumentDescription17 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
		if !pattern.is_match(&self.id) {
			return Err(ValidationError::new(1005, "id does not match the required pattern".to_string()));
		}
		if let Some(ref val) = self.full_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "full_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 350 {
				return Err(ValidationError::new(1002, "full_nm exceeds the maximum length of 350".to_string()));
			}
		}
		if let Some(ref val) = self.shrt_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "shrt_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "shrt_nm exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.clssfctn_tp {
			let pattern = Regex::new("[A-Z]{6,6}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "clssfctn_tp does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.ntnl_ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ntnl_ccy does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// SecurityInstrumentDescription22 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecurityInstrumentDescription22 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FinInstrmGnlAttrbts") )]
	pub fin_instrm_gnl_attrbts: SecurityInstrumentDescription23,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DebtInstrmAttrbts", skip_serializing_if = "Option::is_none") )]
	pub debt_instrm_attrbts: Option<DebtInstrument4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DerivInstrmAttrbts") )]
	pub deriv_instrm_attrbts: DerivativeInstrument6,
}

impl SecurityInstrumentDescription22 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.fin_instrm_gnl_attrbts.validate()?;
		if let Some(ref val) = self.debt_instrm_attrbts { val.validate()? }
		self.deriv_instrm_attrbts.validate()?;
		Ok(())
	}
}


// SecurityInstrumentDescription23 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecurityInstrumentDescription23 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrId", skip_serializing_if = "Option::is_none") )]
	pub othr_id: Option<Vec<OtherIdentification1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FullNm") )]
	pub full_nm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClssfctnTp") )]
	pub clssfctn_tp: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtnlCcy", skip_serializing_if = "Option::is_none") )]
	pub ntnl_ccy: Option<String>,
}

impl SecurityInstrumentDescription23 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.id {
			let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "id does not match the required pattern".to_string()));
			}
		}
		if let Some(ref vec) = self.othr_id { for item in vec { item.validate()? } }
		if self.full_nm.chars().count() < 1 {
			return Err(ValidationError::new(1001, "full_nm is shorter than the minimum length of 1".to_string()));
		}
		if self.full_nm.chars().count() > 350 {
			return Err(ValidationError::new(1002, "full_nm exceeds the maximum length of 350".to_string()));
		}
		let pattern = Regex::new("[A-Z]{6,6}").unwrap();
		if !pattern.is_match(&self.clssfctn_tp) {
			return Err(ValidationError::new(1005, "clssfctn_tp does not match the required pattern".to_string()));
		}
		if let Some(ref val) = self.ntnl_ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ntnl_ccy does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// SecurityInstrumentDescription9 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecurityInstrumentDescription9 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FullNm") )]
	pub full_nm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ShrtNm", skip_serializing_if = "Option::is_none") )]
	pub shrt_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClssfctnTp") )]
	pub clssfctn_tp: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtnlCcy") )]
	pub ntnl_ccy: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CmmdtyDerivInd") )]
	pub cmmdty_deriv_ind: bool,
}

impl SecurityInstrumentDescription9 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
		if !pattern.is_match(&self.id) {
			return Err(ValidationError::new(1005, "id does not match the required pattern".to_string()));
		}
		if self.full_nm.chars().count() < 1 {
			return Err(ValidationError::new(1001, "full_nm is shorter than the minimum length of 1".to_string()));
		}
		if self.full_nm.chars().count() > 350 {
			return Err(ValidationError::new(1002, "full_nm exceeds the maximum length of 350".to_string()));
		}
		if let Some(ref val) = self.shrt_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "shrt_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "shrt_nm exceeds the maximum length of 35".to_string()));
			}
		}
		let pattern = Regex::new("[A-Z]{6,6}").unwrap();
		if !pattern.is_match(&self.clssfctn_tp) {
			return Err(ValidationError::new(1005, "clssfctn_tp does not match the required pattern".to_string()));
		}
		let pattern = Regex::new("[A-Z]{3,3}").unwrap();
		if !pattern.is_match(&self.ntnl_ccy) {
			return Err(ValidationError::new(1005, "ntnl_ccy does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// SecurityIssuer4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecurityIssuer4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<OrganisationIdentification15Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "JursdctnCtry") )]
	pub jursdctn_ctry: String,
}

impl SecurityIssuer4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.id { val.validate()? }
		let pattern = Regex::new("[A-Z]{2,2}").unwrap();
		if !pattern.is_match(&self.jursdctn_ctry) {
			return Err(ValidationError::new(1005, "jursdctn_ctry does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// SecurityReuseData1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SecurityReuseData1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ISIN") )]
	pub isin: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReuseVal") )]
	pub reuse_val: ReuseValue1Choice,
}

impl SecurityReuseData1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
		if !pattern.is_match(&self.isin) {
			return Err(ValidationError::new(1005, "isin does not match the required pattern".to_string()));
		}
		self.reuse_val.validate()?;
		Ok(())
	}
}


// SettlementAccount1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SettlementAccount1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: GenericIdentification165,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EndOfDayInitlMrgnClld") )]
	pub end_of_day_initl_mrgn_clld: AmountAndDirection102,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EndOfDayVartnMrgnClld") )]
	pub end_of_day_vartn_mrgn_clld: AmountAndDirection102,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EndOfDayDfltFndClld") )]
	pub end_of_day_dflt_fnd_clld: AmountAndDirection102,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EndOfDaySttlmClld") )]
	pub end_of_day_sttlm_clld: AmountAndDirection102,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EndOfDayOthrClld") )]
	pub end_of_day_othr_clld: AmountAndDirection102,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EndOfDayLqdtyClld") )]
	pub end_of_day_lqdty_clld: AmountAndDirection102,
}

impl SettlementAccount1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.id.validate()?;
		self.end_of_day_initl_mrgn_clld.validate()?;
		self.end_of_day_vartn_mrgn_clld.validate()?;
		self.end_of_day_dflt_fnd_clld.validate()?;
		self.end_of_day_sttlm_clld.validate()?;
		self.end_of_day_othr_clld.validate()?;
		self.end_of_day_lqdty_clld.validate()?;
		Ok(())
	}
}


// SettlementAgent2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SettlementAgent2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Acct") )]
	pub acct: Vec<PaymentAccount4>,
}

impl SettlementAgent2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
		if !pattern.is_match(&self.id) {
			return Err(ValidationError::new(1005, "id does not match the required pattern".to_string()));
		}
		for item in &self.acct { item.validate()? }
		Ok(())
	}
}


// SettlementDailyFailureReason1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SettlementDailyFailureReason1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DataSetActn", skip_serializing_if = "Option::is_none") )]
	pub data_set_actn: Option<ReportPeriodActivity1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Data", skip_serializing_if = "Option::is_none") )]
	pub data: Option<SettlementDailyFailureReason3>,
}

impl SettlementDailyFailureReason1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.data_set_actn { val.validate()? }
		if let Some(ref val) = self.data { val.validate()? }
		Ok(())
	}
}


// SettlementDailyFailureReason3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SettlementDailyFailureReason3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FaildScties") )]
	pub faild_scties: SettlementTotalData1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FaildCsh") )]
	pub faild_csh: SettlementTotalData1Choice,
}

impl SettlementDailyFailureReason3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.faild_scties.validate()?;
		self.faild_csh.validate()?;
		Ok(())
	}
}


// SettlementDataRate1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SettlementDataRate1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfInstrs", skip_serializing_if = "Option::is_none") )]
	pub nb_of_instrs: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ValOfInstrs", skip_serializing_if = "Option::is_none") )]
	pub val_of_instrs: Option<f64>,
}

impl SettlementDataRate1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// SettlementDataRate2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SettlementDataRate2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Vol") )]
	pub vol: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val") )]
	pub val: f64,
}

impl SettlementDataRate2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// SettlementDataVolume2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SettlementDataVolume2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Vol") )]
	pub vol: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val") )]
	pub val: f64,
}

impl SettlementDataVolume2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// SettlementDate6Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum SettlementDate6Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "TFIV") )]
	CodeTFIV,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TFOR") )]
	CodeTFOR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TONE") )]
	CodeTONE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TTRE") )]
	CodeTTRE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TTWO") )]
	CodeTTWO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SAMD") )]
	CodeSAMD,
}

impl SettlementDate6Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// SettlementFailsCurrency2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SettlementFailsCurrency2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ccy") )]
	pub ccy: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Data") )]
	pub data: SettlementTotalData1,
}

impl SettlementFailsCurrency2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z]{3,3}").unwrap();
		if !pattern.is_match(&self.ccy) {
			return Err(ValidationError::new(1005, "ccy does not match the required pattern".to_string()));
		}
		self.data.validate()?;
		Ok(())
	}
}


// SettlementFailsDailyCSD1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SettlementFailsDailyCSD1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DataSetActn", skip_serializing_if = "Option::is_none") )]
	pub data_set_actn: Option<ReportPeriodActivity1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Data", skip_serializing_if = "Option::is_none") )]
	pub data: Option<SettlementFailsDailyCSD3>,
}

impl SettlementFailsDailyCSD1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.data_set_actn { val.validate()? }
		if let Some(ref val) = self.data { val.validate()? }
		Ok(())
	}
}


// SettlementFailsDailyCSD3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SettlementFailsDailyCSD3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntraCSD") )]
	pub intra_csd: SettlementFailsDailyInstructionType1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CrossCSD") )]
	pub cross_csd: SettlementFailsDailyInstructionType1Choice,
}

impl SettlementFailsDailyCSD3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.intra_csd.validate()?;
		self.cross_csd.validate()?;
		Ok(())
	}
}


// SettlementFailsDailyData3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SettlementFailsDailyData3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgDt") )]
	pub rptg_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DalyRcrd") )]
	pub daly_rcrd: SettlementFailsDailyInstrument3,
}

impl SettlementFailsDailyData3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.daly_rcrd.validate()?;
		Ok(())
	}
}


// SettlementFailsDailyInstructionType1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SettlementFailsDailyInstructionType1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DataSetActn", skip_serializing_if = "Option::is_none") )]
	pub data_set_actn: Option<ReportPeriodActivity1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Data", skip_serializing_if = "Option::is_none") )]
	pub data: Option<SettlementFailsDailyInstructionType3>,
}

impl SettlementFailsDailyInstructionType1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.data_set_actn { val.validate()? }
		if let Some(ref val) = self.data { val.validate()? }
		Ok(())
	}
}


// SettlementFailsDailyInstructionType3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SettlementFailsDailyInstructionType3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DlvryVrssPmt") )]
	pub dlvry_vrss_pmt: SettlementDailyFailureReason1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DlvryWthPmt") )]
	pub dlvry_wth_pmt: SettlementDailyFailureReason1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtFreeOfDlvry") )]
	pub pmt_free_of_dlvry: SettlementDailyFailureReason1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FreeOfPmt") )]
	pub free_of_pmt: SettlementDailyFailureReason1Choice,
}

impl SettlementFailsDailyInstructionType3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.dlvry_vrss_pmt.validate()?;
		self.dlvry_wth_pmt.validate()?;
		self.pmt_free_of_dlvry.validate()?;
		self.free_of_pmt.validate()?;
		Ok(())
	}
}


// SettlementFailsDailyInstrument3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SettlementFailsDailyInstrument3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Eqty") )]
	pub eqty: SettlementFailsDailyTransactionType1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SvrgnDebt") )]
	pub svrgn_debt: SettlementFailsDailyTransactionType1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Bd") )]
	pub bd: SettlementFailsDailyTransactionType1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrTrfblScties") )]
	pub othr_trfbl_scties: SettlementFailsDailyTransactionType1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XchgTraddFnds") )]
	pub xchg_tradd_fnds: SettlementFailsDailyTransactionType1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CllctvInvstmtUdrtkgs") )]
	pub cllctv_invstmt_udrtkgs: SettlementFailsDailyTransactionType1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MnyMktInstrm") )]
	pub mny_mkt_instrm: SettlementFailsDailyTransactionType1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EmssnAllwnc") )]
	pub emssn_allwnc: SettlementFailsDailyTransactionType1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr") )]
	pub othr: SettlementFailsDailyTransactionType1Choice,
}

impl SettlementFailsDailyInstrument3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.eqty.validate()?;
		self.svrgn_debt.validate()?;
		self.bd.validate()?;
		self.othr_trfbl_scties.validate()?;
		self.xchg_tradd_fnds.validate()?;
		self.cllctv_invstmt_udrtkgs.validate()?;
		self.mny_mkt_instrm.validate()?;
		self.emssn_allwnc.validate()?;
		self.othr.validate()?;
		Ok(())
	}
}


// SettlementFailsDailyTransactionType1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SettlementFailsDailyTransactionType1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DataSetActn", skip_serializing_if = "Option::is_none") )]
	pub data_set_actn: Option<ReportPeriodActivity1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Data", skip_serializing_if = "Option::is_none") )]
	pub data: Option<SettlementFailsDailyTransactionType3>,
}

impl SettlementFailsDailyTransactionType1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.data_set_actn { val.validate()? }
		if let Some(ref val) = self.data { val.validate()? }
		Ok(())
	}
}


// SettlementFailsDailyTransactionType3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SettlementFailsDailyTransactionType3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SctiesBuyOrSell") )]
	pub scties_buy_or_sell: SettlementFailsDailyCSD1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollMgmtOpr") )]
	pub coll_mgmt_opr: SettlementFailsDailyCSD1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SctiesLndgOrBrrwg") )]
	pub scties_lndg_or_brrwg: SettlementFailsDailyCSD1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RpAgrmt") )]
	pub rp_agrmt: SettlementFailsDailyCSD1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr") )]
	pub othr: SettlementFailsDailyCSD1Choice,
}

impl SettlementFailsDailyTransactionType3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.scties_buy_or_sell.validate()?;
		self.coll_mgmt_opr.validate()?;
		self.scties_lndg_or_brrwg.validate()?;
		self.rp_agrmt.validate()?;
		self.othr.validate()?;
		Ok(())
	}
}


// SettlementFailsData3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SettlementFailsData3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ttl") )]
	pub ttl: SettlementTotalData1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PtcptInFail", skip_serializing_if = "Option::is_none") )]
	pub ptcpt_in_fail: Option<SettlementFailsParticipantRange1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FlsPerCcy", skip_serializing_if = "Option::is_none") )]
	pub fls_per_ccy: Option<Vec<SettlementFailsCurrency2>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FlsPerFinInstrmTp", skip_serializing_if = "Option::is_none") )]
	pub fls_per_fin_instrm_tp: Option<SettlementFailsInstrument2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SctiesInFail", skip_serializing_if = "Option::is_none") )]
	pub scties_in_fail: Option<SettlementFailsSecuritiesRange1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FlsPerTxTp", skip_serializing_if = "Option::is_none") )]
	pub fls_per_tx_tp: Option<SettlementFailsTransactionType2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlSttlmPnlties", skip_serializing_if = "Option::is_none") )]
	pub ttl_sttlm_pnlties: Option<SettlementDataVolume2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FailrRsn") )]
	pub failr_rsn: SettlementFailureReason3,
}

impl SettlementFailsData3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.ttl.validate()?;
		if let Some(ref val) = self.ptcpt_in_fail { val.validate()? }
		if let Some(ref vec) = self.fls_per_ccy { for item in vec { item.validate()? } }
		if let Some(ref val) = self.fls_per_fin_instrm_tp { val.validate()? }
		if let Some(ref val) = self.scties_in_fail { val.validate()? }
		if let Some(ref val) = self.fls_per_tx_tp { val.validate()? }
		if let Some(ref val) = self.ttl_sttlm_pnlties { val.validate()? }
		self.failr_rsn.validate()?;
		Ok(())
	}
}


// SettlementFailsData4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SettlementFailsData4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ttl") )]
	pub ttl: SettlementTotalData1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FailrRsn") )]
	pub failr_rsn: SettlementFailureReason3,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ElgblForDrgtn") )]
	pub elgbl_for_drgtn: SettlementFailsDerogation1,
}

impl SettlementFailsData4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.ttl.validate()?;
		self.failr_rsn.validate()?;
		self.elgbl_for_drgtn.validate()?;
		Ok(())
	}
}


// SettlementFailsDerogation1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SettlementFailsDerogation1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ElgbltyInd") )]
	pub elgblty_ind: bool,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Justfn", skip_serializing_if = "Option::is_none") )]
	pub justfn: Option<SettlementFailsJustification1>,
}

impl SettlementFailsDerogation1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.justfn { val.validate()? }
		Ok(())
	}
}


// SettlementFailsInstrument2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SettlementFailsInstrument2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Eqty") )]
	pub eqty: SettlementTotalData1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SvrgnDebt") )]
	pub svrgn_debt: SettlementTotalData1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Bd") )]
	pub bd: SettlementTotalData1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrTrfblScties") )]
	pub othr_trfbl_scties: SettlementTotalData1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XchgTraddFnds") )]
	pub xchg_tradd_fnds: SettlementTotalData1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CllctvInvstmtUdrtkgs") )]
	pub cllctv_invstmt_udrtkgs: SettlementTotalData1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MnyMktInstrm") )]
	pub mny_mkt_instrm: SettlementTotalData1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EmssnAllwnc") )]
	pub emssn_allwnc: SettlementTotalData1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr") )]
	pub othr: SettlementTotalData1Choice,
}

impl SettlementFailsInstrument2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.eqty.validate()?;
		self.svrgn_debt.validate()?;
		self.bd.validate()?;
		self.othr_trfbl_scties.validate()?;
		self.xchg_tradd_fnds.validate()?;
		self.cllctv_invstmt_udrtkgs.validate()?;
		self.mny_mkt_instrm.validate()?;
		self.emssn_allwnc.validate()?;
		self.othr.validate()?;
		Ok(())
	}
}


// SettlementFailsJustification1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SettlementFailsJustification1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val") )]
	pub val: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rate") )]
	pub rate: SettlementDataRate1Choice,
}

impl SettlementFailsJustification1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.rate.validate()?;
		Ok(())
	}
}


// SettlementFailsParticipant1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SettlementFailsParticipant1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "LEI") )]
	pub lei: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rank") )]
	pub rank: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Aggt") )]
	pub aggt: SettlementTotalData1,
}

impl SettlementFailsParticipant1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
		if !pattern.is_match(&self.lei) {
			return Err(ValidationError::new(1005, "lei does not match the required pattern".to_string()));
		}
		let pattern = Regex::new("[0-9]{1,2}").unwrap();
		if !pattern.is_match(&self.rank) {
			return Err(ValidationError::new(1005, "rank does not match the required pattern".to_string()));
		}
		self.aggt.validate()?;
		Ok(())
	}
}


// SettlementFailsParticipantRange1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SettlementFailsParticipantRange1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "HghstInVol") )]
	pub hghst_in_vol: Vec<SettlementFailsParticipant1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "HghstInVal") )]
	pub hghst_in_val: Vec<SettlementFailsParticipant1>,
}

impl SettlementFailsParticipantRange1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		for item in &self.hghst_in_vol { item.validate()? }
		for item in &self.hghst_in_val { item.validate()? }
		Ok(())
	}
}


// SettlementFailsReportHeader2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SettlementFailsReportHeader2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CreDtTm") )]
	pub cre_dt_tm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgPrd") )]
	pub rptg_prd: DatePeriod2,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ccy") )]
	pub ccy: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptSts") )]
	pub rpt_sts: TransactionOperationType4Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SctiesSttlmSys") )]
	pub scties_sttlm_sys: SecuritiesSettlementSystemIdentification2,
}

impl SettlementFailsReportHeader2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.rptg_prd.validate()?;
		let pattern = Regex::new("[A-Z]{3,3}").unwrap();
		if !pattern.is_match(&self.ccy) {
			return Err(ValidationError::new(1005, "ccy does not match the required pattern".to_string()));
		}
		self.rpt_sts.validate()?;
		self.scties_sttlm_sys.validate()?;
		Ok(())
	}
}


// SettlementFailsSecurities1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SettlementFailsSecurities1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FinInstrmId") )]
	pub fin_instrm_id: SecurityIdentification19,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rank") )]
	pub rank: String,
}

impl SettlementFailsSecurities1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.fin_instrm_id.validate()?;
		let pattern = Regex::new("[0-9]{1,2}").unwrap();
		if !pattern.is_match(&self.rank) {
			return Err(ValidationError::new(1005, "rank does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// SettlementFailsSecuritiesRange1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SettlementFailsSecuritiesRange1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "HghstInVol") )]
	pub hghst_in_vol: Vec<SettlementFailsSecurities1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "HghstInVal") )]
	pub hghst_in_val: Vec<SettlementFailsSecurities1>,
}

impl SettlementFailsSecuritiesRange1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		for item in &self.hghst_in_vol { item.validate()? }
		for item in &self.hghst_in_val { item.validate()? }
		Ok(())
	}
}


// SettlementFailsTransactionType2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SettlementFailsTransactionType2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SctiesBuyOrSell") )]
	pub scties_buy_or_sell: SettlementTotalData1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollMgmtOpr") )]
	pub coll_mgmt_opr: SettlementTotalData1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SctiesLndgOrBrrwg") )]
	pub scties_lndg_or_brrwg: SettlementTotalData1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RpAgrmt") )]
	pub rp_agrmt: SettlementTotalData1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr") )]
	pub othr: SettlementTotalData1Choice,
}

impl SettlementFailsTransactionType2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.scties_buy_or_sell.validate()?;
		self.coll_mgmt_opr.validate()?;
		self.scties_lndg_or_brrwg.validate()?;
		self.rp_agrmt.validate()?;
		self.othr.validate()?;
		Ok(())
	}
}


// SettlementFailureReason2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SettlementFailureReason2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MainRsns") )]
	pub main_rsns: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EffcncyImprvmt") )]
	pub effcncy_imprvmt: String,
}

impl SettlementFailureReason2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.main_rsns.chars().count() < 1 {
			return Err(ValidationError::new(1001, "main_rsns is shorter than the minimum length of 1".to_string()));
		}
		if self.main_rsns.chars().count() > 2048 {
			return Err(ValidationError::new(1002, "main_rsns exceeds the maximum length of 2048".to_string()));
		}
		if self.effcncy_imprvmt.chars().count() < 1 {
			return Err(ValidationError::new(1001, "effcncy_imprvmt is shorter than the minimum length of 1".to_string()));
		}
		if self.effcncy_imprvmt.chars().count() > 2048 {
			return Err(ValidationError::new(1002, "effcncy_imprvmt exceeds the maximum length of 2048".to_string()));
		}
		Ok(())
	}
}


// SettlementFailureReason3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SettlementFailureReason3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AvrgDrtn", skip_serializing_if = "Option::is_none") )]
	pub avrg_drtn: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Desc") )]
	pub desc: Vec<SettlementFailureReason2>,
}

impl SettlementFailureReason3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		for item in &self.desc { item.validate()? }
		Ok(())
	}
}


// SettlementInternaliser1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SettlementInternaliser1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: SettlementInternaliserIdentification1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OvrllTtl") )]
	pub ovrll_ttl: InternalisationData1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FinInstrm") )]
	pub fin_instrm: SettlementInternaliserFinancialInstrument1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxTp") )]
	pub tx_tp: SettlementInternaliserTransactionType1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClntTp") )]
	pub clnt_tp: SettlementInternaliserClientType1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlCshTrf") )]
	pub ttl_csh_trf: InternalisationData1,
}

impl SettlementInternaliser1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.id.validate()?;
		self.ovrll_ttl.validate()?;
		self.fin_instrm.validate()?;
		self.tx_tp.validate()?;
		self.clnt_tp.validate()?;
		self.ttl_csh_trf.validate()?;
		Ok(())
	}
}


// SettlementInternaliserClientType1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SettlementInternaliserClientType1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prfssnl") )]
	pub prfssnl: InternalisationData1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rtl") )]
	pub rtl: InternalisationData1,
}

impl SettlementInternaliserClientType1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.prfssnl.validate()?;
		self.rtl.validate()?;
		Ok(())
	}
}


// SettlementInternaliserFinancialInstrument1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SettlementInternaliserFinancialInstrument1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Eqty") )]
	pub eqty: InternalisationData1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SvrgnDebt") )]
	pub svrgn_debt: InternalisationData1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Bd") )]
	pub bd: InternalisationData1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrTrfblScties") )]
	pub othr_trfbl_scties: InternalisationData1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XchgTradgFnds") )]
	pub xchg_tradg_fnds: InternalisationData1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CllctvInvstmtUdrtkgs") )]
	pub cllctv_invstmt_udrtkgs: InternalisationData1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MnyMktInstrm") )]
	pub mny_mkt_instrm: InternalisationData1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EmssnAllwnc") )]
	pub emssn_allwnc: InternalisationData1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrFinInstrms") )]
	pub othr_fin_instrms: InternalisationData1,
}

impl SettlementInternaliserFinancialInstrument1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.eqty.validate()?;
		self.svrgn_debt.validate()?;
		self.bd.validate()?;
		self.othr_trfbl_scties.validate()?;
		self.xchg_tradg_fnds.validate()?;
		self.cllctv_invstmt_udrtkgs.validate()?;
		self.mny_mkt_instrm.validate()?;
		self.emssn_allwnc.validate()?;
		self.othr_fin_instrms.validate()?;
		Ok(())
	}
}


// SettlementInternaliserIdentification1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SettlementInternaliserIdentification1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "LEI") )]
	pub lei: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RspnsblPrsn") )]
	pub rspnsbl_prsn: ContactDetails4,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ctry") )]
	pub ctry: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BrnchId", skip_serializing_if = "Option::is_none") )]
	pub brnch_id: Option<String>,
}

impl SettlementInternaliserIdentification1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
		if !pattern.is_match(&self.lei) {
			return Err(ValidationError::new(1005, "lei does not match the required pattern".to_string()));
		}
		self.rspnsbl_prsn.validate()?;
		let pattern = Regex::new("[A-Z]{2,2}").unwrap();
		if !pattern.is_match(&self.ctry) {
			return Err(ValidationError::new(1005, "ctry does not match the required pattern".to_string()));
		}
		if let Some(ref val) = self.brnch_id {
			let pattern = Regex::new("[A-Z]{2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "brnch_id does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// SettlementInternaliserReportHeader1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SettlementInternaliserReportHeader1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CreDtTm") )]
	pub cre_dt_tm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgDt") )]
	pub rptg_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ccy") )]
	pub ccy: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptSts") )]
	pub rpt_sts: TransactionOperationType4Code,
}

impl SettlementInternaliserReportHeader1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z]{3,3}").unwrap();
		if !pattern.is_match(&self.ccy) {
			return Err(ValidationError::new(1005, "ccy does not match the required pattern".to_string()));
		}
		self.rpt_sts.validate()?;
		Ok(())
	}
}


// SettlementInternaliserTransactionType1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SettlementInternaliserTransactionType1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SctiesBuyOrSell") )]
	pub scties_buy_or_sell: InternalisationData1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollMgmtOpr") )]
	pub coll_mgmt_opr: InternalisationData1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SctiesLndgOrBrrwg") )]
	pub scties_lndg_or_brrwg: InternalisationData1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RpAgrmt") )]
	pub rp_agrmt: InternalisationData1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrTxs") )]
	pub othr_txs: InternalisationData1,
}

impl SettlementInternaliserTransactionType1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.scties_buy_or_sell.validate()?;
		self.coll_mgmt_opr.validate()?;
		self.scties_lndg_or_brrwg.validate()?;
		self.rp_agrmt.validate()?;
		self.othr_txs.validate()?;
		Ok(())
	}
}


// SettlementParties34Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SettlementParties34Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CntrlSctiesDpstryPtcpt", skip_serializing_if = "Option::is_none") )]
	pub cntrl_scties_dpstry_ptcpt: Option<OrganisationIdentification15Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IndrctPtcpt", skip_serializing_if = "Option::is_none") )]
	pub indrct_ptcpt: Option<OrganisationIdentification15Choice>,
}

impl SettlementParties34Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cntrl_scties_dpstry_ptcpt { val.validate()? }
		if let Some(ref val) = self.indrct_ptcpt { val.validate()? }
		Ok(())
	}
}


// SettlementSubTotalCalculatedTax2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SettlementSubTotalCalculatedTax2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TpCd", skip_serializing_if = "Option::is_none") )]
	pub tp_cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClctdRate", skip_serializing_if = "Option::is_none") )]
	pub clctd_rate: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BsisAmt", skip_serializing_if = "Option::is_none") )]
	pub bsis_amt: Option<Vec<CurrencyAndAmount>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClctdAmt", skip_serializing_if = "Option::is_none") )]
	pub clctd_amt: Option<Vec<CurrencyAndAmount>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XmptnRsnCd", skip_serializing_if = "Option::is_none") )]
	pub xmptn_rsn_cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XmptnRsnTxt", skip_serializing_if = "Option::is_none") )]
	pub xmptn_rsn_txt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TaxCcyXchg", skip_serializing_if = "Option::is_none") )]
	pub tax_ccy_xchg: Option<CurrencyReference3>,
}

impl SettlementSubTotalCalculatedTax2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tp_cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tp_cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "tp_cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref vec) = self.bsis_amt { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.clctd_amt { for item in vec { item.validate()? } }
		if let Some(ref val) = self.xmptn_rsn_cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "xmptn_rsn_cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "xmptn_rsn_cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.xmptn_rsn_txt {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "xmptn_rsn_txt is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 500 {
				return Err(ValidationError::new(1002, "xmptn_rsn_txt exceeds the maximum length of 500".to_string()));
			}
		}
		if let Some(ref val) = self.tax_ccy_xchg { val.validate()? }
		Ok(())
	}
}


// SettlementTotalData1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SettlementTotalData1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sttld") )]
	pub sttld: SettlementDataVolume2,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Faild") )]
	pub faild: SettlementDataVolume2,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ttl") )]
	pub ttl: SettlementDataVolume2,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FaildRate") )]
	pub faild_rate: SettlementDataRate2,
}

impl SettlementTotalData1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.sttld.validate()?;
		self.faild.validate()?;
		self.ttl.validate()?;
		self.faild_rate.validate()?;
		Ok(())
	}
}


// SettlementTotalData1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SettlementTotalData1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DataSetActn", skip_serializing_if = "Option::is_none") )]
	pub data_set_actn: Option<ReportPeriodActivity1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Data", skip_serializing_if = "Option::is_none") )]
	pub data: Option<SettlementTotalData1>,
}

impl SettlementTotalData1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.data_set_actn { val.validate()? }
		if let Some(ref val) = self.data { val.validate()? }
		Ok(())
	}
}


// ShipmentAttribute2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ShipmentAttribute2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Conds", skip_serializing_if = "Option::is_none") )]
	pub conds: Option<ShipmentCondition1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XpctdDt", skip_serializing_if = "Option::is_none") )]
	pub xpctd_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtryOfCntrPty", skip_serializing_if = "Option::is_none") )]
	pub ctry_of_cntr_pty: Option<String>,
}

impl ShipmentAttribute2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.conds { val.validate()? }
		if let Some(ref val) = self.ctry_of_cntr_pty {
			let pattern = Regex::new("[A-Z]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ctry_of_cntr_pty does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// ShipmentCondition1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ShipmentCondition1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl ShipmentCondition1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// ShipmentDateRange1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ShipmentDateRange1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "EarlstShipmntDt", skip_serializing_if = "Option::is_none") )]
	pub earlst_shipmnt_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LatstShipmntDt", skip_serializing_if = "Option::is_none") )]
	pub latst_shipmnt_dt: Option<String>,
}

impl ShipmentDateRange1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ShipmentDateRange2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ShipmentDateRange2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubQtyVal") )]
	pub sub_qty_val: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EarlstShipmntDt", skip_serializing_if = "Option::is_none") )]
	pub earlst_shipmnt_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LatstShipmntDt", skip_serializing_if = "Option::is_none") )]
	pub latst_shipmnt_dt: Option<String>,
}

impl ShipmentDateRange2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ShipmentSchedule2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ShipmentSchedule2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ShipmntDtRg", skip_serializing_if = "Option::is_none") )]
	pub shipmnt_dt_rg: Option<ShipmentDateRange1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ShipmntSubSchdl", skip_serializing_if = "Option::is_none") )]
	pub shipmnt_sub_schdl: Option<Vec<ShipmentDateRange2>>,
}

impl ShipmentSchedule2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.shipmnt_dt_rg { val.validate()? }
		if let Some(ref vec) = self.shipmnt_sub_schdl { for item in vec { item.validate()? } }
		Ok(())
	}
}


// Side5Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum Side5Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "SESH") )]
	CodeSESH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SELL") )]
	CodeSELL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SSEX") )]
	CodeSSEX,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UNDI") )]
	CodeUNDI,
}

impl Side5Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// Side6Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum Side6Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "BUYI") )]
	CodeBUYI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SELL") )]
	CodeSELL,
}

impl Side6Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// SignatureEnvelopeReference ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SignatureEnvelopeReference {
}

impl SignatureEnvelopeReference {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// SpecialCollateral1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum SpecialCollateral1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "GENE") )]
	CodeGENE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SPEC") )]
	CodeSPEC,
}

impl SpecialCollateral1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// SpecialCollateral2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum SpecialCollateral2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "GENE") )]
	CodeGENE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SPEC") )]
	CodeSPEC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MRRP") )]
	CodeMRRP,
}

impl SpecialCollateral2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// SpecialCondition1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SpecialCondition1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "IncmgAmt") )]
	pub incmg_amt: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OutgngAmt") )]
	pub outgng_amt: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IncmgAmtToOthrAcct", skip_serializing_if = "Option::is_none") )]
	pub incmg_amt_to_othr_acct: Option<ActiveCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtFrOthrAcct", skip_serializing_if = "Option::is_none") )]
	pub pmt_fr_othr_acct: Option<ActiveCurrencyAndAmount>,
}

impl SpecialCondition1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.incmg_amt.validate()?;
		self.outgng_amt.validate()?;
		if let Some(ref val) = self.incmg_amt_to_othr_acct { val.validate()? }
		if let Some(ref val) = self.pmt_fr_othr_acct { val.validate()? }
		Ok(())
	}
}


// SpecialPurpose2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum SpecialPurpose2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "BLNK") )]
	CodeBLNK,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NTAV") )]
	CodeNTAV,
}

impl SpecialPurpose2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// SpecificCollateral2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SpecificCollateral2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FinInstrmId") )]
	pub fin_instrm_id: FinancialInstrument59,
}

impl SpecificCollateral2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.fin_instrm_id.validate()?;
		Ok(())
	}
}


// SpecificCollateral3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SpecificCollateral3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FinInstrmId") )]
	pub fin_instrm_id: FinancialInstrument104,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MktVal") )]
	pub mkt_val: ActiveCurrencyAnd24Amount,
}

impl SpecificCollateral3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.fin_instrm_id.validate()?;
		self.mkt_val.validate()?;
		Ok(())
	}
}


// Standardisation1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum Standardisation1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "FLEX") )]
	CodeFLEX,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NSTA") )]
	CodeNSTA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "STAN") )]
	CodeSTAN,
}

impl Standardisation1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// StatisticalReportingStatus1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum StatisticalReportingStatus1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ACPT") )]
	CodeACPT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ACTC") )]
	CodeACTC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PART") )]
	CodePART,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PDNG") )]
	CodePDNG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RCVD") )]
	CodeRCVD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RJCT") )]
	CodeRJCT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RMDR") )]
	CodeRMDR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INCF") )]
	CodeINCF,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CRPT") )]
	CodeCRPT,
}

impl StatisticalReportingStatus1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// StatisticalReportingStatus2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum StatisticalReportingStatus2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ACPT") )]
	CodeACPT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RJCT") )]
	CodeRJCT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "WARN") )]
	CodeWARN,
}

impl StatisticalReportingStatus2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// StatisticsPerCounterparty16Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct StatisticsPerCounterparty16Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DataSetActn", skip_serializing_if = "Option::is_none") )]
	pub data_set_actn: Option<ReportPeriodActivity1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rpt", skip_serializing_if = "Option::is_none") )]
	pub rpt: Option<DetailedStatisticsPerCounterparty17>,
}

impl StatisticsPerCounterparty16Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.data_set_actn { val.validate()? }
		if let Some(ref val) = self.rpt { val.validate()? }
		Ok(())
	}
}


// StatisticsPerCounterparty18Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct StatisticsPerCounterparty18Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DataSetActn", skip_serializing_if = "Option::is_none") )]
	pub data_set_actn: Option<ReportPeriodActivity1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rpt", skip_serializing_if = "Option::is_none") )]
	pub rpt: Option<DetailedStatisticsPerCounterparty19>,
}

impl StatisticsPerCounterparty18Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.data_set_actn { val.validate()? }
		if let Some(ref val) = self.rpt { val.validate()? }
		Ok(())
	}
}


// StatisticsPerCounterparty19Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct StatisticsPerCounterparty19Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DataSetActn", skip_serializing_if = "Option::is_none") )]
	pub data_set_actn: Option<ReportPeriodActivity1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rpt", skip_serializing_if = "Option::is_none") )]
	pub rpt: Option<Vec<ReconciliationStatisticsPerCounterparty4>>,
}

impl StatisticsPerCounterparty19Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.data_set_actn { val.validate()? }
		if let Some(ref vec) = self.rpt { for item in vec { item.validate()? } }
		Ok(())
	}
}


// StatisticsTransparency2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct StatisticsTransparency2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlNbOfTxsExctd") )]
	pub ttl_nb_of_txs_exctd: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlVolOfTxsExctd") )]
	pub ttl_vol_of_txs_exctd: f64,
}

impl StatisticsTransparency2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// StatisticsTransparency3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct StatisticsTransparency3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AvrgDalyTrnvr", skip_serializing_if = "Option::is_none") )]
	pub avrg_daly_trnvr: Option<ActiveCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AvrgTxVal", skip_serializing_if = "Option::is_none") )]
	pub avrg_tx_val: Option<ActiveCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LrgInScale", skip_serializing_if = "Option::is_none") )]
	pub lrg_in_scale: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StdMktSz", skip_serializing_if = "Option::is_none") )]
	pub std_mkt_sz: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AvrgDalyNbOfTxs", skip_serializing_if = "Option::is_none") )]
	pub avrg_daly_nb_of_txs: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlNbOfTxsExctd", skip_serializing_if = "Option::is_none") )]
	pub ttl_nb_of_txs_exctd: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlVolOfTxsExctd", skip_serializing_if = "Option::is_none") )]
	pub ttl_vol_of_txs_exctd: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlNbOfTradgDays", skip_serializing_if = "Option::is_none") )]
	pub ttl_nb_of_tradg_days: Option<f64>,
}

impl StatisticsTransparency3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.avrg_daly_trnvr { val.validate()? }
		if let Some(ref val) = self.avrg_tx_val { val.validate()? }
		Ok(())
	}
}


// StatusAdviceReport3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct StatusAdviceReport3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sts") )]
	pub sts: ReportingMessageStatus1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VldtnRule", skip_serializing_if = "Option::is_none") )]
	pub vldtn_rule: Option<Vec<GenericValidationRuleIdentification1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgDt", skip_serializing_if = "Option::is_none") )]
	pub msg_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sttstcs", skip_serializing_if = "Option::is_none") )]
	pub sttstcs: Option<OriginalReportStatistics3>,
}

impl StatusAdviceReport3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.sts.validate()?;
		if let Some(ref vec) = self.vldtn_rule { for item in vec { item.validate()? } }
		if let Some(ref val) = self.sttstcs { val.validate()? }
		Ok(())
	}
}


// StatusDetail1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct StatusDetail1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ctry", skip_serializing_if = "Option::is_none") )]
	pub ctry: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CmptntAuthrty") )]
	pub cmptnt_authrty: SupervisingAuthorityIdentification1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sts", skip_serializing_if = "Option::is_none") )]
	pub sts: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StsRsn") )]
	pub sts_rsn: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ActvtyPrd", skip_serializing_if = "Option::is_none") )]
	pub actvty_prd: Option<Period4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cmnt", skip_serializing_if = "Option::is_none") )]
	pub cmnt: Option<String>,
}

impl StatusDetail1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ctry {
			let pattern = Regex::new("[A-Z]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ctry does not match the required pattern".to_string()));
			}
		}
		self.cmptnt_authrty.validate()?;
		if let Some(ref val) = self.sts {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "sts is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 10 {
				return Err(ValidationError::new(1002, "sts exceeds the maximum length of 10".to_string()));
			}
		}
		if self.sts_rsn.chars().count() < 1 {
			return Err(ValidationError::new(1001, "sts_rsn is shorter than the minimum length of 1".to_string()));
		}
		if self.sts_rsn.chars().count() > 10 {
			return Err(ValidationError::new(1002, "sts_rsn exceeds the maximum length of 10".to_string()));
		}
		if let Some(ref val) = self.actvty_prd { val.validate()? }
		if let Some(ref val) = self.cmnt {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cmnt is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 20000 {
				return Err(ValidationError::new(1002, "cmnt exceeds the maximum length of 20000".to_string()));
			}
		}
		Ok(())
	}
}


// StatusReason6Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct StatusReason6Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl StatusReason6Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// StatusReportRecord3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct StatusReportRecord3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlRcrdId") )]
	pub orgnl_rcrd_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sts") )]
	pub sts: ReportingRecordStatus1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VldtnRule", skip_serializing_if = "Option::is_none") )]
	pub vldtn_rule: Option<Vec<GenericValidationRuleIdentification1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl StatusReportRecord3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.orgnl_rcrd_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "orgnl_rcrd_id is shorter than the minimum length of 1".to_string()));
		}
		if self.orgnl_rcrd_id.chars().count() > 140 {
			return Err(ValidationError::new(1002, "orgnl_rcrd_id exceeds the maximum length of 140".to_string()));
		}
		self.sts.validate()?;
		if let Some(ref vec) = self.vldtn_rule { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// StatusResponse1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum StatusResponse1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "NRES") )]
	CodeNRES,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PART") )]
	CodePART,
	#[cfg_attr( feature = "derive_serde", serde(rename = "COMP") )]
	CodeCOMP,
}

impl StatusResponse1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// Strategy1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Strategy1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StrssSz") )]
	pub strss_sz: StressSize1Choice,
}

impl Strategy1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
		}
		self.strss_sz.validate()?;
		Ok(())
	}
}


// StrategyStressType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum StrategyStressType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "FLEX") )]
	CodeFLEX,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PRLL") )]
	CodePRLL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SPRD") )]
	CodeSPRD,
}

impl StrategyStressType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// StressItem1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct StressItem1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "StrssPdct") )]
	pub strss_pdct: StressItem1Choice,
}

impl StressItem1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.strss_pdct.validate()?;
		Ok(())
	}
}


// StressItem1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct StressItem1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pdct", skip_serializing_if = "Option::is_none") )]
	pub pdct: Option<StressedProduct1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Strtgy", skip_serializing_if = "Option::is_none") )]
	pub strtgy: Option<Strategy1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RskFctr", skip_serializing_if = "Option::is_none") )]
	pub rsk_fctr: Option<RiskFactor1>,
}

impl StressItem1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.pdct { val.validate()? }
		if let Some(ref val) = self.strtgy { val.validate()? }
		if let Some(ref val) = self.rsk_fctr { val.validate()? }
		Ok(())
	}
}


// StressLiquidResourceRequirement1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct StressLiquidResourceRequirement1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OprlOutflw") )]
	pub oprl_outflw: AmountAndDirection102,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VartnMrgnPmtOblgtn") )]
	pub vartn_mrgn_pmt_oblgtn: AmountAndDirection102,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttlmOrDlvry") )]
	pub sttlm_or_dlvry: AmountAndDirection102,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr") )]
	pub othr: AmountAndDirection102,
}

impl StressLiquidResourceRequirement1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.oprl_outflw.validate()?;
		self.vartn_mrgn_pmt_oblgtn.validate()?;
		self.sttlm_or_dlvry.validate()?;
		self.othr.validate()?;
		Ok(())
	}
}


// StressSize1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct StressSize1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rltv", skip_serializing_if = "Option::is_none") )]
	pub rltv: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Abs", skip_serializing_if = "Option::is_none") )]
	pub abs: Option<Absolute1>,
}

impl StressSize1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.abs { val.validate()? }
		Ok(())
	}
}


// StressedProduct1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct StressedProduct1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: GenericIdentification168,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MaxStrssSz") )]
	pub max_strss_sz: StressSize1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MinStrssSz") )]
	pub min_strss_sz: StressSize1Choice,
}

impl StressedProduct1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.id.validate()?;
		self.max_strss_sz.validate()?;
		self.min_strss_sz.validate()?;
		Ok(())
	}
}


// SupervisingAuthorityIdentification1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SupervisingAuthorityIdentification1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<SupervisingAuthorityIdentification1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LEI", skip_serializing_if = "Option::is_none") )]
	pub lei: Option<String>,
}

impl SupervisingAuthorityIdentification1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.id { val.validate()? }
		if let Some(ref val) = self.lei {
			let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "lei does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// SupervisingAuthorityIdentification1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SupervisingAuthorityIdentification1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrtryId", skip_serializing_if = "Option::is_none") )]
	pub prtry_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FullNm", skip_serializing_if = "Option::is_none") )]
	pub full_nm: Option<String>,
}

impl SupervisingAuthorityIdentification1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.prtry_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "prtry_id exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.full_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "full_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 350 {
				return Err(ValidationError::new(1002, "full_nm exceeds the maximum length of 350".to_string()));
			}
		}
		Ok(())
	}
}


// SupplementaryData1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SupplementaryData1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PlcAndNm", skip_serializing_if = "Option::is_none") )]
	pub plc_and_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Envlp") )]
	pub envlp: SupplementaryDataEnvelope1,
}

impl SupplementaryData1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.plc_and_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "plc_and_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 350 {
				return Err(ValidationError::new(1002, "plc_and_nm exceeds the maximum length of 350".to_string()));
			}
		}
		self.envlp.validate()?;
		Ok(())
	}
}


// SupplementaryDataEnvelope1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SupplementaryDataEnvelope1 {
}

impl SupplementaryDataEnvelope1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// SupportLetterType1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SupportLetterType1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl SupportLetterType1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// SupportingDocument4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SupportingDocument4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SpprtgDocId") )]
	pub spprtg_doc_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlReqId", skip_serializing_if = "Option::is_none") )]
	pub orgnl_req_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cert") )]
	pub cert: DocumentIdentification28,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctOwnr") )]
	pub acct_ownr: PartyIdentification272,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctSvcr") )]
	pub acct_svcr: BranchAndFinancialInstitutionIdentification8,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amdmnt", skip_serializing_if = "Option::is_none") )]
	pub amdmnt: Option<DocumentAmendment1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrctRef") )]
	pub ctrct_ref: ContractRegistrationReference2Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ntry") )]
	pub ntry: Vec<SupportingDocumentEntry2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl SupportingDocument4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.spprtg_doc_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "spprtg_doc_id is shorter than the minimum length of 1".to_string()));
		}
		if self.spprtg_doc_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "spprtg_doc_id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.orgnl_req_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_req_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_req_id exceeds the maximum length of 35".to_string()));
			}
		}
		self.cert.validate()?;
		self.acct_ownr.validate()?;
		self.acct_svcr.validate()?;
		if let Some(ref val) = self.amdmnt { val.validate()? }
		self.ctrct_ref.validate()?;
		for item in &self.ntry { item.validate()? }
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// SupportingDocumentEntry2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SupportingDocumentEntry2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtryId") )]
	pub ntry_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlDoc") )]
	pub orgnl_doc: DocumentIdentification22,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DocTp") )]
	pub doc_tp: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlAmt", skip_serializing_if = "Option::is_none") )]
	pub ttl_amt: Option<ActiveCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlAmtAftrShipmnt", skip_serializing_if = "Option::is_none") )]
	pub ttl_amt_aftr_shipmnt: Option<ActiveCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlAmtInCtrctCcy", skip_serializing_if = "Option::is_none") )]
	pub ttl_amt_in_ctrct_ccy: Option<ActiveCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlAmtAftrShipmntInCtrctCcy", skip_serializing_if = "Option::is_none") )]
	pub ttl_amt_aftr_shipmnt_in_ctrct_ccy: Option<ActiveCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ShipmntAttrbts") )]
	pub shipmnt_attrbts: ShipmentAttribute2,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtryAmdmntId", skip_serializing_if = "Option::is_none") )]
	pub ntry_amdmnt_id: Option<DocumentEntryAmendment1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MtrtyData", skip_serializing_if = "Option::is_none") )]
	pub mtrty_data: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_inf: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Attchmnt", skip_serializing_if = "Option::is_none") )]
	pub attchmnt: Option<Vec<DocumentGeneralInformation5>>,
}

impl SupportingDocumentEntry2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.ntry_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "ntry_id is shorter than the minimum length of 1".to_string()));
		}
		if self.ntry_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "ntry_id exceeds the maximum length of 35".to_string()));
		}
		self.orgnl_doc.validate()?;
		let pattern = Regex::new("[a-zA-Z0-9]{1}[a-zA-Z0-9_]{3}").unwrap();
		if !pattern.is_match(&self.doc_tp) {
			return Err(ValidationError::new(1005, "doc_tp does not match the required pattern".to_string()));
		}
		if let Some(ref val) = self.ttl_amt { val.validate()? }
		if let Some(ref val) = self.ttl_amt_aftr_shipmnt { val.validate()? }
		if let Some(ref val) = self.ttl_amt_in_ctrct_ccy { val.validate()? }
		if let Some(ref val) = self.ttl_amt_aftr_shipmnt_in_ctrct_ccy { val.validate()? }
		self.shipmnt_attrbts.validate()?;
		if let Some(ref val) = self.ntry_amdmnt_id { val.validate()? }
		if let Some(ref val) = self.mtrty_data {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "mtrty_data is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "mtrty_data exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.addtl_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 500 {
				return Err(ValidationError::new(1002, "addtl_inf exceeds the maximum length of 500".to_string()));
			}
		}
		if let Some(ref vec) = self.attchmnt { for item in vec { item.validate()? } }
		Ok(())
	}
}


// SupportingDocumentRequestOrLetter4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SupportingDocumentRequestOrLetter4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReqOrLttrId") )]
	pub req_or_lttr_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dt", skip_serializing_if = "Option::is_none") )]
	pub dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sndr", skip_serializing_if = "Option::is_none") )]
	pub sndr: Option<Party50Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rcvr", skip_serializing_if = "Option::is_none") )]
	pub rcvr: Option<Party50Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlRefs", skip_serializing_if = "Option::is_none") )]
	pub orgnl_refs: Option<Vec<OriginalMessage6>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sbjt") )]
	pub sbjt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: SupportLetterType1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Desc", skip_serializing_if = "Option::is_none") )]
	pub desc: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RspnReqrd") )]
	pub rspn_reqrd: bool,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DueDt", skip_serializing_if = "Option::is_none") )]
	pub due_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Attchmnt", skip_serializing_if = "Option::is_none") )]
	pub attchmnt: Option<Vec<DocumentGeneralInformation5>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl SupportingDocumentRequestOrLetter4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.req_or_lttr_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "req_or_lttr_id is shorter than the minimum length of 1".to_string()));
		}
		if self.req_or_lttr_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "req_or_lttr_id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.sndr { val.validate()? }
		if let Some(ref val) = self.rcvr { val.validate()? }
		if let Some(ref vec) = self.orgnl_refs { for item in vec { item.validate()? } }
		if self.sbjt.chars().count() < 1 {
			return Err(ValidationError::new(1001, "sbjt is shorter than the minimum length of 1".to_string()));
		}
		if self.sbjt.chars().count() > 140 {
			return Err(ValidationError::new(1002, "sbjt exceeds the maximum length of 140".to_string()));
		}
		self.tp.validate()?;
		if let Some(ref val) = self.desc {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "desc is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 1025 {
				return Err(ValidationError::new(1002, "desc exceeds the maximum length of 1025".to_string()));
			}
		}
		if let Some(ref vec) = self.attchmnt { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// SwapLegIdentification2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SwapLegIdentification2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SwpIn", skip_serializing_if = "Option::is_none") )]
	pub swp_in: Option<FinancialInstrumentIdentification7Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SwpOut", skip_serializing_if = "Option::is_none") )]
	pub swp_out: Option<FinancialInstrumentIdentification7Choice>,
}

impl SwapLegIdentification2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.swp_in { val.validate()? }
		if let Some(ref val) = self.swp_out { val.validate()? }
		Ok(())
	}
}


// SwapType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum SwapType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "OSSC") )]
	CodeOSSC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XFSC") )]
	CodeXFSC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XFMC") )]
	CodeXFMC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XXSC") )]
	CodeXXSC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XXMC") )]
	CodeXXMC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IFMC") )]
	CodeIFMC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FFSC") )]
	CodeFFSC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FFMC") )]
	CodeFFMC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IFSC") )]
	CodeIFSC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OSMC") )]
	CodeOSMC,
}

impl SwapType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// SyndicatedLoan3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct SyndicatedLoan3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Brrwr") )]
	pub brrwr: TradeParty6,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Lndr", skip_serializing_if = "Option::is_none") )]
	pub lndr: Option<TradeParty6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt", skip_serializing_if = "Option::is_none") )]
	pub amt: Option<ActiveCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Shr", skip_serializing_if = "Option::is_none") )]
	pub shr: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XchgRateInf", skip_serializing_if = "Option::is_none") )]
	pub xchg_rate_inf: Option<ExchangeRate1>,
}

impl SyndicatedLoan3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.brrwr.validate()?;
		if let Some(ref val) = self.lndr { val.validate()? }
		if let Some(ref val) = self.amt { val.validate()? }
		if let Some(ref val) = self.xchg_rate_inf { val.validate()? }
		Ok(())
	}
}


// TaxExemptReason1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum TaxExemptReason1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "NONE") )]
	CodeNONE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MASA") )]
	CodeMASA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MISA") )]
	CodeMISA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SISA") )]
	CodeSISA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IISA") )]
	CodeIISA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CUYP") )]
	CodeCUYP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PRYP") )]
	CodePRYP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ASTR") )]
	CodeASTR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EMPY") )]
	CodeEMPY,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EMCY") )]
	CodeEMCY,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EPRY") )]
	CodeEPRY,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ECYE") )]
	CodeECYE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NFPI") )]
	CodeNFPI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NFQP") )]
	CodeNFQP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DECP") )]
	CodeDECP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IRAC") )]
	CodeIRAC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IRAR") )]
	CodeIRAR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "KEOG") )]
	CodeKEOG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PFSP") )]
	CodePFSP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "401K") )]
	Code401K,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SIRA") )]
	CodeSIRA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "403B") )]
	Code403B,
	#[cfg_attr( feature = "derive_serde", serde(rename = "457X") )]
	Code457X,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RIRA") )]
	CodeRIRA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RIAN") )]
	CodeRIAN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RCRF") )]
	CodeRCRF,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RCIP") )]
	CodeRCIP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EIFP") )]
	CodeEIFP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EIOP") )]
	CodeEIOP,
}

impl TaxExemptReason1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// TaxExemptionReasonFormat1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TaxExemptionReasonFormat1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ustrd", skip_serializing_if = "Option::is_none") )]
	pub ustrd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Strd", skip_serializing_if = "Option::is_none") )]
	pub strd: Option<TaxExemptReason1Code>,
}

impl TaxExemptionReasonFormat1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ustrd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "ustrd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "ustrd exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.strd { val.validate()? }
		Ok(())
	}
}


// TaxOrganisationIdentification1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TaxOrganisationIdentification1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm") )]
	pub nm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstlAdr", skip_serializing_if = "Option::is_none") )]
	pub pstl_adr: Option<PostalAddress6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtctDtls", skip_serializing_if = "Option::is_none") )]
	pub ctct_dtls: Option<ContactDetails2>,
}

impl TaxOrganisationIdentification1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.nm.chars().count() < 1 {
			return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
		}
		if self.nm.chars().count() > 140 {
			return Err(ValidationError::new(1002, "nm exceeds the maximum length of 140".to_string()));
		}
		if let Some(ref val) = self.pstl_adr { val.validate()? }
		if let Some(ref val) = self.ctct_dtls { val.validate()? }
		Ok(())
	}
}


// TaxParty1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TaxParty1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TaxId", skip_serializing_if = "Option::is_none") )]
	pub tax_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RegnId", skip_serializing_if = "Option::is_none") )]
	pub regn_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TaxTp", skip_serializing_if = "Option::is_none") )]
	pub tax_tp: Option<String>,
}

impl TaxParty1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tax_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tax_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "tax_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.regn_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "regn_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "regn_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.tax_tp {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tax_tp is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "tax_tp exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// TaxParty4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TaxParty4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TaxId", skip_serializing_if = "Option::is_none") )]
	pub tax_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TaxTp", skip_serializing_if = "Option::is_none") )]
	pub tax_tp: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RegnId", skip_serializing_if = "Option::is_none") )]
	pub regn_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TaxXmptnRsn", skip_serializing_if = "Option::is_none") )]
	pub tax_xmptn_rsn: Option<Vec<TaxExemptionReasonFormat1Choice>>,
}

impl TaxParty4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tax_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tax_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "tax_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.tax_tp {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tax_tp is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "tax_tp exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.regn_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "regn_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "regn_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref vec) = self.tax_xmptn_rsn { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TaxReport1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TaxReport1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TaxRptHdr") )]
	pub tax_rpt_hdr: GroupHeader69,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sellr") )]
	pub sellr: PartyIdentification72,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Buyr", skip_serializing_if = "Option::is_none") )]
	pub buyr: Option<PartyIdentification72>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradSttlm") )]
	pub trad_sttlm: TradeSettlement2,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrPty", skip_serializing_if = "Option::is_none") )]
	pub othr_pty: Option<Vec<PartyIdentification72>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_inf: Option<Vec<AdditionalInformation1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlRef", skip_serializing_if = "Option::is_none") )]
	pub addtl_ref: Option<Vec<DocumentGeneralInformation2>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl TaxReport1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.tax_rpt_hdr.validate()?;
		self.sellr.validate()?;
		if let Some(ref val) = self.buyr { val.validate()? }
		self.trad_sttlm.validate()?;
		if let Some(ref vec) = self.othr_pty { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.addtl_inf { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.addtl_ref { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TaxReportHeader1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TaxReportHeader1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgId") )]
	pub msg_id: MessageIdentification1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfTaxRpts", skip_serializing_if = "Option::is_none") )]
	pub nb_of_tax_rpts: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TaxAuthrty", skip_serializing_if = "Option::is_none") )]
	pub tax_authrty: Option<Vec<TaxOrganisationIdentification1>>,
}

impl TaxReportHeader1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.msg_id.validate()?;
		if let Some(ref vec) = self.tax_authrty { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TaxReportingStatus1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum TaxReportingStatus1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ACPT") )]
	CodeACPT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RCVD") )]
	CodeRCVD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RJCT") )]
	CodeRJCT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INCF") )]
	CodeINCF,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CRPT") )]
	CodeCRPT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "WARN") )]
	CodeWARN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ACTC") )]
	CodeACTC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PART") )]
	CodePART,
}

impl TaxReportingStatus1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// TaxReportingStatus2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum TaxReportingStatus2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ACPT") )]
	CodeACPT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RJCT") )]
	CodeRJCT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "WARN") )]
	CodeWARN,
}

impl TaxReportingStatus2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// TechnicalAttributes5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TechnicalAttributes5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechRcrdId", skip_serializing_if = "Option::is_none") )]
	pub tech_rcrd_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RcncltnFlg", skip_serializing_if = "Option::is_none") )]
	pub rcncltn_flg: Option<Reconciliation3Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptRctTmStmp", skip_serializing_if = "Option::is_none") )]
	pub rpt_rct_tm_stmp: Option<String>,
}

impl TechnicalAttributes5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tech_rcrd_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tech_rcrd_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "tech_rcrd_id exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.rcncltn_flg { val.validate()? }
		Ok(())
	}
}


// TechnicalAttributes6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TechnicalAttributes6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechRcrdId", skip_serializing_if = "Option::is_none") )]
	pub tech_rcrd_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptRctTmStmp", skip_serializing_if = "Option::is_none") )]
	pub rpt_rct_tm_stmp: Option<String>,
}

impl TechnicalAttributes6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tech_rcrd_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tech_rcrd_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "tech_rcrd_id exceeds the maximum length of 140".to_string()));
			}
		}
		Ok(())
	}
}


// TimePeriod2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TimePeriod2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrTm") )]
	pub fr_tm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ToTm", skip_serializing_if = "Option::is_none") )]
	pub to_tm: Option<String>,
}

impl TimePeriod2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// TimePeriod3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TimePeriod3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrTm", skip_serializing_if = "Option::is_none") )]
	pub fr_tm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ToTm", skip_serializing_if = "Option::is_none") )]
	pub to_tm: Option<String>,
}

impl TimePeriod3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// TimePeriodDetails1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TimePeriodDetails1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrTm") )]
	pub fr_tm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ToTm", skip_serializing_if = "Option::is_none") )]
	pub to_tm: Option<String>,
}

impl TimePeriodDetails1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// TimeToMaturity1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TimeToMaturity1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prd", skip_serializing_if = "Option::is_none") )]
	pub prd: Option<TimeToMaturityPeriod1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Spcl", skip_serializing_if = "Option::is_none") )]
	pub spcl: Option<SpecialPurpose2Code>,
}

impl TimeToMaturity1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.prd { val.validate()? }
		if let Some(ref val) = self.spcl { val.validate()? }
		Ok(())
	}
}


// TimeToMaturity2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TimeToMaturity2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prd", skip_serializing_if = "Option::is_none") )]
	pub prd: Option<TimeToMaturityPeriod2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Spcl", skip_serializing_if = "Option::is_none") )]
	pub spcl: Option<SpecialPurpose2Code>,
}

impl TimeToMaturity2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.prd { val.validate()? }
		if let Some(ref val) = self.spcl { val.validate()? }
		Ok(())
	}
}


// TimeToMaturityPeriod1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TimeToMaturityPeriod1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Start", skip_serializing_if = "Option::is_none") )]
	pub start: Option<MaturityTerm2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "End", skip_serializing_if = "Option::is_none") )]
	pub end: Option<MaturityTerm2>,
}

impl TimeToMaturityPeriod1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.start { val.validate()? }
		if let Some(ref val) = self.end { val.validate()? }
		Ok(())
	}
}


// TimeToMaturityPeriod2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TimeToMaturityPeriod2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Start", skip_serializing_if = "Option::is_none") )]
	pub start: Option<MaturityTerm2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "End", skip_serializing_if = "Option::is_none") )]
	pub end: Option<MaturityTerm2>,
}

impl TimeToMaturityPeriod2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.start { val.validate()? }
		if let Some(ref val) = self.end { val.validate()? }
		Ok(())
	}
}


// TonsOrCurrency2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TonsOrCurrency2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nb", skip_serializing_if = "Option::is_none") )]
	pub nb: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt", skip_serializing_if = "Option::is_none") )]
	pub amt: Option<ActiveOrHistoricCurrencyAndAmount>,
}

impl TonsOrCurrency2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.amt { val.validate()? }
		Ok(())
	}
}


// TradeAdditionalQueryCriteria7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeAdditionalQueryCriteria7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ActnTp", skip_serializing_if = "Option::is_none") )]
	pub actn_tp: Option<Vec<TransactionOperationType6Code>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ExctnVn", skip_serializing_if = "Option::is_none") )]
	pub exctn_vn: Option<SecuritiesTradeVenueCriteria1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtrOfCtrPty", skip_serializing_if = "Option::is_none") )]
	pub ntr_of_ctr_pty: Option<Vec<PartyNatureType1Code>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CorpSctr", skip_serializing_if = "Option::is_none") )]
	pub corp_sctr: Option<Vec<CorporateSectorCriteria5>>,
}

impl TradeAdditionalQueryCriteria7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.actn_tp { for item in vec { item.validate()? } }
		if let Some(ref val) = self.exctn_vn { val.validate()? }
		if let Some(ref vec) = self.ntr_of_ctr_pty { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.corp_sctr { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TradeAdditionalQueryCriteria9 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeAdditionalQueryCriteria9 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ActnTp", skip_serializing_if = "Option::is_none") )]
	pub actn_tp: Option<Vec<TransactionOperationType8Code>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ExctnVn", skip_serializing_if = "Option::is_none") )]
	pub exctn_vn: Option<SecuritiesTradeVenueCriteria1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtrOfCtrPty", skip_serializing_if = "Option::is_none") )]
	pub ntr_of_ctr_pty: Option<PartyNatureType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CorpSctr", skip_serializing_if = "Option::is_none") )]
	pub corp_sctr: Option<CorporateSectorCriteria6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AsstClss", skip_serializing_if = "Option::is_none") )]
	pub asst_clss: Option<Vec<ProductType4Code>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PdctClssfctn", skip_serializing_if = "Option::is_none") )]
	pub pdct_clssfctn: Option<ProductClassificationCriteria1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Lvl", skip_serializing_if = "Option::is_none") )]
	pub lvl: Option<ModificationLevel1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EvtTp", skip_serializing_if = "Option::is_none") )]
	pub evt_tp: Option<Vec<DerivativeEventType3Code>>,
}

impl TradeAdditionalQueryCriteria9 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.actn_tp { for item in vec { item.validate()? } }
		if let Some(ref val) = self.exctn_vn { val.validate()? }
		if let Some(ref val) = self.ntr_of_ctr_pty { val.validate()? }
		if let Some(ref val) = self.corp_sctr { val.validate()? }
		if let Some(ref vec) = self.asst_clss { for item in vec { item.validate()? } }
		if let Some(ref val) = self.pdct_clssfctn { val.validate()? }
		if let Some(ref val) = self.lvl { val.validate()? }
		if let Some(ref vec) = self.evt_tp { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TradeClearing11 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeClearing11 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrOblgtn", skip_serializing_if = "Option::is_none") )]
	pub clr_oblgtn: Option<ClearingObligationType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrSts", skip_serializing_if = "Option::is_none") )]
	pub clr_sts: Option<Cleared23Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntraGrp", skip_serializing_if = "Option::is_none") )]
	pub intra_grp: Option<bool>,
}

impl TradeClearing11 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.clr_oblgtn { val.validate()? }
		if let Some(ref val) = self.clr_sts { val.validate()? }
		Ok(())
	}
}


// TradeConfirmation3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeConfirmation3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Confd", skip_serializing_if = "Option::is_none") )]
	pub confd: Option<TradeConfirmation4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NonConfd", skip_serializing_if = "Option::is_none") )]
	pub non_confd: Option<TradeNonConfirmation1>,
}

impl TradeConfirmation3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.confd { val.validate()? }
		if let Some(ref val) = self.non_confd { val.validate()? }
		Ok(())
	}
}


// TradeConfirmation4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeConfirmation4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<TradeConfirmationType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TmStmp", skip_serializing_if = "Option::is_none") )]
	pub tm_stmp: Option<String>,
}

impl TradeConfirmation4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tp { val.validate()? }
		Ok(())
	}
}


// TradeConfirmation4Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeConfirmation4Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Confd", skip_serializing_if = "Option::is_none") )]
	pub confd: Option<TradeConfirmation5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NonConfd", skip_serializing_if = "Option::is_none") )]
	pub non_confd: Option<TradeNonConfirmation1>,
}

impl TradeConfirmation4Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.confd { val.validate()? }
		if let Some(ref val) = self.non_confd { val.validate()? }
		Ok(())
	}
}


// TradeConfirmation5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeConfirmation5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: TradeConfirmationType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TmStmp", skip_serializing_if = "Option::is_none") )]
	pub tm_stmp: Option<String>,
}

impl TradeConfirmation5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.tp.validate()?;
		Ok(())
	}
}


// TradeConfirmationType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum TradeConfirmationType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ECNF") )]
	CodeECNF,
	#[cfg_attr( feature = "derive_serde", serde(rename = "YCNF") )]
	CodeYCNF,
}

impl TradeConfirmationType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// TradeConfirmationType2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum TradeConfirmationType2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "NCNF") )]
	CodeNCNF,
}

impl TradeConfirmationType2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// TradeContract4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeContract4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrctDocId", skip_serializing_if = "Option::is_none") )]
	pub ctrct_doc_id: Option<DocumentIdentification22>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradTpId", skip_serializing_if = "Option::is_none") )]
	pub trad_tp_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt", skip_serializing_if = "Option::is_none") )]
	pub amt: Option<ActiveCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Buyr") )]
	pub buyr: Vec<TradeParty6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sellr") )]
	pub sellr: Vec<TradeParty6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MtrtyDt", skip_serializing_if = "Option::is_none") )]
	pub mtrty_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrlngtnFlg", skip_serializing_if = "Option::is_none") )]
	pub prlngtn_flg: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StartDt", skip_serializing_if = "Option::is_none") )]
	pub start_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttlmCcy", skip_serializing_if = "Option::is_none") )]
	pub sttlm_ccy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XchgRateInf", skip_serializing_if = "Option::is_none") )]
	pub xchg_rate_inf: Option<ExchangeRate1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtSchdl", skip_serializing_if = "Option::is_none") )]
	pub pmt_schdl: Option<InterestPaymentDateRange1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ShipmntSchdl", skip_serializing_if = "Option::is_none") )]
	pub shipmnt_schdl: Option<ShipmentSchedule2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Attchmnt", skip_serializing_if = "Option::is_none") )]
	pub attchmnt: Option<Vec<DocumentGeneralInformation5>>,
}

impl TradeContract4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ctrct_doc_id { val.validate()? }
		if let Some(ref val) = self.trad_tp_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "trad_tp_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "trad_tp_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.amt { val.validate()? }
		for item in &self.buyr { item.validate()? }
		for item in &self.sellr { item.validate()? }
		if let Some(ref val) = self.sttlm_ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "sttlm_ccy does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.xchg_rate_inf { val.validate()? }
		if let Some(ref val) = self.pmt_schdl { val.validate()? }
		if let Some(ref val) = self.shipmnt_schdl { val.validate()? }
		if let Some(ref vec) = self.attchmnt { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TradeCounterpartyRelationship1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeCounterpartyRelationship1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl TradeCounterpartyRelationship1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 100 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 100".to_string()));
			}
		}
		Ok(())
	}
}


// TradeCounterpartyRelationshipRecord1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeCounterpartyRelationshipRecord1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "StartRltshPty") )]
	pub start_rltsh_pty: TradeCounterpartyType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EndRltshPty") )]
	pub end_rltsh_pty: TradeCounterpartyType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RltshTp") )]
	pub rltsh_tp: TradeCounterpartyRelationship1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Desc", skip_serializing_if = "Option::is_none") )]
	pub desc: Option<String>,
}

impl TradeCounterpartyRelationshipRecord1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.start_rltsh_pty.validate()?;
		self.end_rltsh_pty.validate()?;
		self.rltsh_tp.validate()?;
		if let Some(ref val) = self.desc {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "desc is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 1000 {
				return Err(ValidationError::new(1002, "desc exceeds the maximum length of 1000".to_string()));
			}
		}
		Ok(())
	}
}


// TradeCounterpartyReport20 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeCounterpartyReport20 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgCtrPty") )]
	pub rptg_ctr_pty: Counterparty45,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrCtrPty") )]
	pub othr_ctr_pty: Counterparty46,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Brkr", skip_serializing_if = "Option::is_none") )]
	pub brkr: Option<OrganisationIdentification15Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubmitgAgt", skip_serializing_if = "Option::is_none") )]
	pub submitg_agt: Option<OrganisationIdentification15Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrMmb", skip_serializing_if = "Option::is_none") )]
	pub clr_mmb: Option<PartyIdentification248Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Bnfcry", skip_serializing_if = "Option::is_none") )]
	pub bnfcry: Option<Vec<PartyIdentification248Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NttyRspnsblForRpt", skip_serializing_if = "Option::is_none") )]
	pub ntty_rspnsbl_for_rpt: Option<OrganisationIdentification15Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ExctnAgt", skip_serializing_if = "Option::is_none") )]
	pub exctn_agt: Option<Vec<OrganisationIdentification15Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RltshRcrd", skip_serializing_if = "Option::is_none") )]
	pub rltsh_rcrd: Option<Vec<TradeCounterpartyRelationshipRecord1>>,
}

impl TradeCounterpartyReport20 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.rptg_ctr_pty.validate()?;
		self.othr_ctr_pty.validate()?;
		if let Some(ref val) = self.brkr { val.validate()? }
		if let Some(ref val) = self.submitg_agt { val.validate()? }
		if let Some(ref val) = self.clr_mmb { val.validate()? }
		if let Some(ref vec) = self.bnfcry { for item in vec { item.validate()? } }
		if let Some(ref val) = self.ntty_rspnsbl_for_rpt { val.validate()? }
		if let Some(ref vec) = self.exctn_agt { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.rltsh_rcrd { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TradeCounterpartyType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum TradeCounterpartyType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "BENE") )]
	CodeBENE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BROK") )]
	CodeBROK,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CLEM") )]
	CodeCLEM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EXEA") )]
	CodeEXEA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHC") )]
	CodeOTHC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "REPC") )]
	CodeREPC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SBMA") )]
	CodeSBMA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ERFR") )]
	CodeERFR,
}

impl TradeCounterpartyType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// TradeData28 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeData28 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PairgRcncltnSts", skip_serializing_if = "Option::is_none") )]
	pub pairg_rcncltn_sts: Option<Vec<NumberOfReportsPerStatus4>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RcncltnRpt") )]
	pub rcncltn_rpt: Vec<ReconciliationReport8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl TradeData28 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.pairg_rcncltn_sts { for item in vec { item.validate()? } }
		for item in &self.rcncltn_rpt { item.validate()? }
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TradeData29 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeData29 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptSttstcs") )]
	pub rpt_sttstcs: Vec<DetailedReportStatistics5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxSttstcs") )]
	pub tx_sttstcs: Vec<DetailedTransactionStatistics2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl TradeData29 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		for item in &self.rpt_sttstcs { item.validate()? }
		for item in &self.tx_sttstcs { item.validate()? }
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TradeData34Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeData34Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DataSetActn", skip_serializing_if = "Option::is_none") )]
	pub data_set_actn: Option<ReportPeriodActivity1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rpt", skip_serializing_if = "Option::is_none") )]
	pub rpt: Option<Vec<TradeData28>>,
}

impl TradeData34Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.data_set_actn { val.validate()? }
		if let Some(ref vec) = self.rpt { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TradeData35Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeData35Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DataSetActn", skip_serializing_if = "Option::is_none") )]
	pub data_set_actn: Option<ReportPeriodActivity1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rpt", skip_serializing_if = "Option::is_none") )]
	pub rpt: Option<Vec<TradeData29>>,
}

impl TradeData35Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.data_set_actn { val.validate()? }
		if let Some(ref vec) = self.rpt { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TradeData36Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeData36Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DataSetActn", skip_serializing_if = "Option::is_none") )]
	pub data_set_actn: Option<ReportPeriodActivity1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rpt", skip_serializing_if = "Option::is_none") )]
	pub rpt: Option<Vec<ReuseDataReport6Choice>>,
}

impl TradeData36Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.data_set_actn { val.validate()? }
		if let Some(ref vec) = self.rpt { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TradeData37Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeData37Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DataSetActn", skip_serializing_if = "Option::is_none") )]
	pub data_set_actn: Option<ReportPeriodActivity1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Stat", skip_serializing_if = "Option::is_none") )]
	pub stat: Option<Vec<ReuseDataReportCorrection15>>,
}

impl TradeData37Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.data_set_actn { val.validate()? }
		if let Some(ref vec) = self.stat { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TradeData38Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeData38Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DataSetActn", skip_serializing_if = "Option::is_none") )]
	pub data_set_actn: Option<ReportPeriodActivity1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Stat", skip_serializing_if = "Option::is_none") )]
	pub stat: Option<Vec<CollateralMarginNew10>>,
}

impl TradeData38Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.data_set_actn { val.validate()? }
		if let Some(ref vec) = self.stat { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TradeData39Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeData39Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DataSetActn", skip_serializing_if = "Option::is_none") )]
	pub data_set_actn: Option<ReportPeriodActivity1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rpt", skip_serializing_if = "Option::is_none") )]
	pub rpt: Option<Vec<TradeReport21Choice>>,
}

impl TradeData39Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.data_set_actn { val.validate()? }
		if let Some(ref vec) = self.rpt { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TradeData40Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeData40Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DataSetActn", skip_serializing_if = "Option::is_none") )]
	pub data_set_actn: Option<ReportPeriodActivity1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rpt", skip_serializing_if = "Option::is_none") )]
	pub rpt: Option<Vec<TradeReport22Choice>>,
}

impl TradeData40Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.data_set_actn { val.validate()? }
		if let Some(ref vec) = self.rpt { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TradeData43 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeData43 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPtySpcfcData") )]
	pub ctr_pty_spcfc_data: Vec<CounterpartySpecificData36>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CmonTradData") )]
	pub cmon_trad_data: CommonTradeDataReport71,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Lvl", skip_serializing_if = "Option::is_none") )]
	pub lvl: Option<ModificationLevel1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechAttrbts", skip_serializing_if = "Option::is_none") )]
	pub tech_attrbts: Option<TechnicalAttributes5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PblcDssmntnData", skip_serializing_if = "Option::is_none") )]
	pub pblc_dssmntn_data: Option<DisseminationData1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl TradeData43 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		for item in &self.ctr_pty_spcfc_data { item.validate()? }
		self.cmon_trad_data.validate()?;
		if let Some(ref val) = self.lvl { val.validate()? }
		if let Some(ref val) = self.tech_attrbts { val.validate()? }
		if let Some(ref val) = self.pblc_dssmntn_data { val.validate()? }
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TradeData59Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeData59Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DataSetActn", skip_serializing_if = "Option::is_none") )]
	pub data_set_actn: Option<ReportPeriodActivity1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rpt", skip_serializing_if = "Option::is_none") )]
	pub rpt: Option<Vec<TradeReport33Choice>>,
}

impl TradeData59Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.data_set_actn { val.validate()? }
		if let Some(ref vec) = self.rpt { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TradeData60Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeData60Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DataSetActn", skip_serializing_if = "Option::is_none") )]
	pub data_set_actn: Option<ReportPeriodActivity1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Stat", skip_serializing_if = "Option::is_none") )]
	pub stat: Option<Vec<TradeStateReport23>>,
}

impl TradeData60Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.data_set_actn { val.validate()? }
		if let Some(ref vec) = self.stat { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TradeData61Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeData61Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DataSetActn", skip_serializing_if = "Option::is_none") )]
	pub data_set_actn: Option<ReportPeriodActivity1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rpt", skip_serializing_if = "Option::is_none") )]
	pub rpt: Option<Vec<TradeReport34Choice>>,
}

impl TradeData61Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.data_set_actn { val.validate()? }
		if let Some(ref vec) = self.rpt { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TradeData62Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeData62Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DataSetActn", skip_serializing_if = "Option::is_none") )]
	pub data_set_actn: Option<ReportPeriodActivity1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Stat", skip_serializing_if = "Option::is_none") )]
	pub stat: Option<Vec<MarginReportData10>>,
}

impl TradeData62Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.data_set_actn { val.validate()? }
		if let Some(ref vec) = self.stat { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TradeDateTimeQueryCriteria2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeDateTimeQueryCriteria2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgDtTm", skip_serializing_if = "Option::is_none") )]
	pub rptg_dt_tm: Option<DateTimePeriod1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ExctnDtTm", skip_serializing_if = "Option::is_none") )]
	pub exctn_dt_tm: Option<DateTimePeriod1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MtrtyDt", skip_serializing_if = "Option::is_none") )]
	pub mtrty_dt: Option<DateOrBlankQuery2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TermntnDt", skip_serializing_if = "Option::is_none") )]
	pub termntn_dt: Option<DateOrBlankQuery2Choice>,
}

impl TradeDateTimeQueryCriteria2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.rptg_dt_tm { val.validate()? }
		if let Some(ref val) = self.exctn_dt_tm { val.validate()? }
		if let Some(ref val) = self.mtrty_dt { val.validate()? }
		if let Some(ref val) = self.termntn_dt { val.validate()? }
		Ok(())
	}
}


// TradeDateTimeQueryCriteria6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeDateTimeQueryCriteria6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgDtTm", skip_serializing_if = "Option::is_none") )]
	pub rptg_dt_tm: Option<DateTimePeriod1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ExctnDtTm", skip_serializing_if = "Option::is_none") )]
	pub exctn_dt_tm: Option<DateTimePeriod1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MtrtyDt", skip_serializing_if = "Option::is_none") )]
	pub mtrty_dt: Option<DateOrBlankQuery2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FctvDt", skip_serializing_if = "Option::is_none") )]
	pub fctv_dt: Option<DatePeriod1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ValtnDtTm", skip_serializing_if = "Option::is_none") )]
	pub valtn_dt_tm: Option<DateTimePeriod1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XprtnDt", skip_serializing_if = "Option::is_none") )]
	pub xprtn_dt: Option<DateOrBlankQuery2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EarlyTermntnDt", skip_serializing_if = "Option::is_none") )]
	pub early_termntn_dt: Option<DatePeriod1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollTmStmp", skip_serializing_if = "Option::is_none") )]
	pub coll_tm_stmp: Option<DateTimeOrBlankQuery1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "HstrclAsOfDt", skip_serializing_if = "Option::is_none") )]
	pub hstrcl_as_of_dt: Option<String>,
}

impl TradeDateTimeQueryCriteria6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.rptg_dt_tm { val.validate()? }
		if let Some(ref val) = self.exctn_dt_tm { val.validate()? }
		if let Some(ref val) = self.mtrty_dt { val.validate()? }
		if let Some(ref val) = self.fctv_dt { val.validate()? }
		if let Some(ref val) = self.valtn_dt_tm { val.validate()? }
		if let Some(ref val) = self.xprtn_dt { val.validate()? }
		if let Some(ref val) = self.early_termntn_dt { val.validate()? }
		if let Some(ref val) = self.coll_tm_stmp { val.validate()? }
		Ok(())
	}
}


// TradeError9 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeError9 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechRcrdId", skip_serializing_if = "Option::is_none") )]
	pub tech_rcrd_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPtySpcfcData") )]
	pub ctr_pty_spcfc_data: CounterpartyData88,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LnData") )]
	pub ln_data: LoanData86,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl TradeError9 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tech_rcrd_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tech_rcrd_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "tech_rcrd_id exceeds the maximum length of 140".to_string()));
			}
		}
		self.ctr_pty_spcfc_data.validate()?;
		self.ln_data.validate()?;
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TradeMarket2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum TradeMarket2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "DMST") )]
	CodeDMST,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FRGN") )]
	CodeFRGN,
}

impl TradeMarket2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// TradeNewTransaction13 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeNewTransaction13 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechRcrdId", skip_serializing_if = "Option::is_none") )]
	pub tech_rcrd_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPtySpcfcData") )]
	pub ctr_pty_spcfc_data: CounterpartyData88,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LnData") )]
	pub ln_data: TransactionLoanData30Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollData", skip_serializing_if = "Option::is_none") )]
	pub coll_data: Option<TransactionCollateralData18Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LvlTp") )]
	pub lvl_tp: ModificationLevel1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl TradeNewTransaction13 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tech_rcrd_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tech_rcrd_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "tech_rcrd_id exceeds the maximum length of 140".to_string()));
			}
		}
		self.ctr_pty_spcfc_data.validate()?;
		self.ln_data.validate()?;
		if let Some(ref val) = self.coll_data { val.validate()? }
		self.lvl_tp.validate()?;
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TradeNonConfirmation1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeNonConfirmation1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: TradeConfirmationType2Code,
}

impl TradeNonConfirmation1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.tp.validate()?;
		Ok(())
	}
}


// TradeParty6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeParty6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PtyId") )]
	pub pty_id: PartyIdentification272,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LglOrg", skip_serializing_if = "Option::is_none") )]
	pub lgl_org: Option<LegalOrganisation2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TaxPty", skip_serializing_if = "Option::is_none") )]
	pub tax_pty: Option<Vec<TaxParty4>>,
}

impl TradeParty6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.pty_id.validate()?;
		if let Some(ref val) = self.lgl_org { val.validate()? }
		if let Some(ref vec) = self.tax_pty { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TradePartyIdentificationQuery10Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradePartyIdentificationQuery10Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<Vec<PartyIdentification248Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NotRptd", skip_serializing_if = "Option::is_none") )]
	pub not_rptd: Option<NotReported1Code>,
}

impl TradePartyIdentificationQuery10Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.id { for item in vec { item.validate()? } }
		if let Some(ref val) = self.not_rptd { val.validate()? }
		Ok(())
	}
}


// TradePartyIdentificationQuery11Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradePartyIdentificationQuery11Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<Vec<OrganisationIdentification15Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NotRptd", skip_serializing_if = "Option::is_none") )]
	pub not_rptd: Option<NotReported1Code>,
}

impl TradePartyIdentificationQuery11Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.id { for item in vec { item.validate()? } }
		if let Some(ref val) = self.not_rptd { val.validate()? }
		Ok(())
	}
}


// TradePartyIdentificationQuery8 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradePartyIdentificationQuery8 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "LEI", skip_serializing_if = "Option::is_none") )]
	pub lei: Option<Vec<String>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AnyBIC", skip_serializing_if = "Option::is_none") )]
	pub any_bic: Option<Vec<String>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClntId", skip_serializing_if = "Option::is_none") )]
	pub clnt_id: Option<Vec<String>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NotRptd", skip_serializing_if = "Option::is_none") )]
	pub not_rptd: Option<NotReported1Code>,
}

impl TradePartyIdentificationQuery8 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.lei {
			for item in vec {
				let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
				if !pattern.is_match(&item) {
					return Err(ValidationError::new(1005, "lei does not match the required pattern".to_string()));
				}
			}
		}
		if let Some(ref vec) = self.any_bic {
			for item in vec {
				let pattern = Regex::new("[A-Z0-9]{4,4}[A-Z]{2,2}[A-Z0-9]{2,2}([A-Z0-9]{3,3}){0,1}").unwrap();
				if !pattern.is_match(&item) {
					return Err(ValidationError::new(1005, "any_bic does not match the required pattern".to_string()));
				}
			}
		}
		if let Some(ref vec) = self.clnt_id {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "clnt_id is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 50 {
					return Err(ValidationError::new(1002, "clnt_id exceeds the maximum length of 50".to_string()));
				}
			}
		}
		if let Some(ref val) = self.not_rptd { val.validate()? }
		Ok(())
	}
}


// TradePartyIdentificationQuery9 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradePartyIdentificationQuery9 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "LEI", skip_serializing_if = "Option::is_none") )]
	pub lei: Option<Vec<String>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtryCd", skip_serializing_if = "Option::is_none") )]
	pub ctry_cd: Option<Vec<String>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AnyBIC", skip_serializing_if = "Option::is_none") )]
	pub any_bic: Option<Vec<String>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClntId", skip_serializing_if = "Option::is_none") )]
	pub clnt_id: Option<Vec<String>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NotRptd", skip_serializing_if = "Option::is_none") )]
	pub not_rptd: Option<NotReported1Code>,
}

impl TradePartyIdentificationQuery9 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.lei {
			for item in vec {
				let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
				if !pattern.is_match(&item) {
					return Err(ValidationError::new(1005, "lei does not match the required pattern".to_string()));
				}
			}
		}
		if let Some(ref vec) = self.ctry_cd {
			for item in vec {
				let pattern = Regex::new("[A-Z]{2,2}").unwrap();
				if !pattern.is_match(&item) {
					return Err(ValidationError::new(1005, "ctry_cd does not match the required pattern".to_string()));
				}
			}
		}
		if let Some(ref vec) = self.any_bic {
			for item in vec {
				let pattern = Regex::new("[A-Z0-9]{4,4}[A-Z]{2,2}[A-Z0-9]{2,2}([A-Z0-9]{3,3}){0,1}").unwrap();
				if !pattern.is_match(&item) {
					return Err(ValidationError::new(1005, "any_bic does not match the required pattern".to_string()));
				}
			}
		}
		if let Some(ref vec) = self.clnt_id {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "clnt_id is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 50 {
					return Err(ValidationError::new(1002, "clnt_id exceeds the maximum length of 50".to_string()));
				}
			}
		}
		if let Some(ref val) = self.not_rptd { val.validate()? }
		Ok(())
	}
}


// TradePartyQueryCriteria5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradePartyQueryCriteria5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Oprtr") )]
	pub oprtr: Operation3Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgCtrPty", skip_serializing_if = "Option::is_none") )]
	pub rptg_ctr_pty: Option<TradePartyIdentificationQuery8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgCtrPtyBrnch", skip_serializing_if = "Option::is_none") )]
	pub rptg_ctr_pty_brnch: Option<TradePartyIdentificationQuery9>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrCtrPty", skip_serializing_if = "Option::is_none") )]
	pub othr_ctr_pty: Option<TradePartyIdentificationQuery8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrCtrPtyBrnch", skip_serializing_if = "Option::is_none") )]
	pub othr_ctr_pty_brnch: Option<TradePartyIdentificationQuery9>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Bnfcry", skip_serializing_if = "Option::is_none") )]
	pub bnfcry: Option<TradePartyIdentificationQuery8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubmitgAgt", skip_serializing_if = "Option::is_none") )]
	pub submitg_agt: Option<TradePartyIdentificationQuery8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Brkr", skip_serializing_if = "Option::is_none") )]
	pub brkr: Option<TradePartyIdentificationQuery8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CCP", skip_serializing_if = "Option::is_none") )]
	pub ccp: Option<TradePartyIdentificationQuery8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AgtLndr", skip_serializing_if = "Option::is_none") )]
	pub agt_lndr: Option<TradePartyIdentificationQuery8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TrptyAgt", skip_serializing_if = "Option::is_none") )]
	pub trpty_agt: Option<TradePartyIdentificationQuery8>,
}

impl TradePartyQueryCriteria5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.oprtr.validate()?;
		if let Some(ref val) = self.rptg_ctr_pty { val.validate()? }
		if let Some(ref val) = self.rptg_ctr_pty_brnch { val.validate()? }
		if let Some(ref val) = self.othr_ctr_pty { val.validate()? }
		if let Some(ref val) = self.othr_ctr_pty_brnch { val.validate()? }
		if let Some(ref val) = self.bnfcry { val.validate()? }
		if let Some(ref val) = self.submitg_agt { val.validate()? }
		if let Some(ref val) = self.brkr { val.validate()? }
		if let Some(ref val) = self.ccp { val.validate()? }
		if let Some(ref val) = self.agt_lndr { val.validate()? }
		if let Some(ref val) = self.trpty_agt { val.validate()? }
		Ok(())
	}
}


// TradePartyQueryCriteria7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradePartyQueryCriteria7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Oprtr") )]
	pub oprtr: Operation3Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgCtrPty", skip_serializing_if = "Option::is_none") )]
	pub rptg_ctr_pty: Option<TradePartyIdentificationQuery10Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrCtrPty", skip_serializing_if = "Option::is_none") )]
	pub othr_ctr_pty: Option<TradePartyIdentificationQuery10Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Bnfcry", skip_serializing_if = "Option::is_none") )]
	pub bnfcry: Option<TradePartyIdentificationQuery10Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NttyRspnsblForRpt", skip_serializing_if = "Option::is_none") )]
	pub ntty_rspnsbl_for_rpt: Option<TradePartyIdentificationQuery11Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubmitgAgt", skip_serializing_if = "Option::is_none") )]
	pub submitg_agt: Option<TradePartyIdentificationQuery11Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Brkr", skip_serializing_if = "Option::is_none") )]
	pub brkr: Option<TradePartyIdentificationQuery11Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CCP", skip_serializing_if = "Option::is_none") )]
	pub ccp: Option<TradePartyIdentificationQuery11Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrMmb", skip_serializing_if = "Option::is_none") )]
	pub clr_mmb: Option<TradePartyIdentificationQuery10Choice>,
}

impl TradePartyQueryCriteria7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.oprtr.validate()?;
		if let Some(ref val) = self.rptg_ctr_pty { val.validate()? }
		if let Some(ref val) = self.othr_ctr_pty { val.validate()? }
		if let Some(ref val) = self.bnfcry { val.validate()? }
		if let Some(ref val) = self.ntty_rspnsbl_for_rpt { val.validate()? }
		if let Some(ref val) = self.submitg_agt { val.validate()? }
		if let Some(ref val) = self.brkr { val.validate()? }
		if let Some(ref val) = self.ccp { val.validate()? }
		if let Some(ref val) = self.clr_mmb { val.validate()? }
		Ok(())
	}
}


// TradeQueryCriteria10 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeQueryCriteria10 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradLifeCyclHstry") )]
	pub trad_life_cycl_hstry: bool,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OutsdngTradInd") )]
	pub outsdng_trad_ind: bool,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradPtyCrit", skip_serializing_if = "Option::is_none") )]
	pub trad_pty_crit: Option<TradePartyQueryCriteria5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradTpCrit", skip_serializing_if = "Option::is_none") )]
	pub trad_tp_crit: Option<TradeTypeQueryCriteria2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TmCrit", skip_serializing_if = "Option::is_none") )]
	pub tm_crit: Option<TradeDateTimeQueryCriteria2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrCrit", skip_serializing_if = "Option::is_none") )]
	pub othr_crit: Option<TradeAdditionalQueryCriteria7>,
}

impl TradeQueryCriteria10 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.trad_pty_crit { val.validate()? }
		if let Some(ref val) = self.trad_tp_crit { val.validate()? }
		if let Some(ref val) = self.tm_crit { val.validate()? }
		if let Some(ref val) = self.othr_crit { val.validate()? }
		Ok(())
	}
}


// TradeQueryCriteria14 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeQueryCriteria14 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradLifeCyclHstry", skip_serializing_if = "Option::is_none") )]
	pub trad_life_cycl_hstry: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MrgnLifeCyclHstry", skip_serializing_if = "Option::is_none") )]
	pub mrgn_life_cycl_hstry: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OutsdngTradInd") )]
	pub outsdng_trad_ind: bool,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradPtyCrit", skip_serializing_if = "Option::is_none") )]
	pub trad_pty_crit: Option<TradePartyQueryCriteria7>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FinInstrmCrit", skip_serializing_if = "Option::is_none") )]
	pub fin_instrm_crit: Option<TradeSecurityIdentificationQueryCriteria3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TmCrit", skip_serializing_if = "Option::is_none") )]
	pub tm_crit: Option<TradeDateTimeQueryCriteria6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrCrit", skip_serializing_if = "Option::is_none") )]
	pub othr_crit: Option<TradeAdditionalQueryCriteria9>,
}

impl TradeQueryCriteria14 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.trad_pty_crit { val.validate()? }
		if let Some(ref val) = self.fin_instrm_crit { val.validate()? }
		if let Some(ref val) = self.tm_crit { val.validate()? }
		if let Some(ref val) = self.othr_crit { val.validate()? }
		Ok(())
	}
}


// TradeQueryExecutionFrequency3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeQueryExecutionFrequency3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrqcyTp") )]
	pub frqcy_tp: Frequency14Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DlvryDay", skip_serializing_if = "Option::is_none") )]
	pub dlvry_day: Option<Vec<WeekDay3Code>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DayOfMnth", skip_serializing_if = "Option::is_none") )]
	pub day_of_mnth: Option<Vec<f64>>,
}

impl TradeQueryExecutionFrequency3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.frqcy_tp.validate()?;
		if let Some(ref vec) = self.dlvry_day { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TradeRecurrentQuery5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeRecurrentQuery5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "QryTp") )]
	pub qry_tp: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Frqcy") )]
	pub frqcy: TradeQueryExecutionFrequency3,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VldUntil") )]
	pub vld_until: String,
}

impl TradeRecurrentQuery5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.qry_tp.chars().count() < 1 {
			return Err(ValidationError::new(1001, "qry_tp is shorter than the minimum length of 1".to_string()));
		}
		if self.qry_tp.chars().count() > 1000 {
			return Err(ValidationError::new(1002, "qry_tp exceeds the maximum length of 1000".to_string()));
		}
		self.frqcy.validate()?;
		Ok(())
	}
}


// TradeRecurrentQuery7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeRecurrentQuery7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "QryTp") )]
	pub qry_tp: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Frqcy") )]
	pub frqcy: Vec<TradeQueryExecutionFrequency3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VldUntil") )]
	pub vld_until: String,
}

impl TradeRecurrentQuery7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.qry_tp.chars().count() < 1 {
			return Err(ValidationError::new(1001, "qry_tp is shorter than the minimum length of 1".to_string()));
		}
		if self.qry_tp.chars().count() > 1000 {
			return Err(ValidationError::new(1002, "qry_tp exceeds the maximum length of 1000".to_string()));
		}
		for item in &self.frqcy { item.validate()? }
		Ok(())
	}
}


// TradeReport21Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeReport21Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "New", skip_serializing_if = "Option::is_none") )]
	pub new: Option<CollateralMarginCorrection6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Err", skip_serializing_if = "Option::is_none") )]
	pub err: Option<CollateralMarginError4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Crrctn", skip_serializing_if = "Option::is_none") )]
	pub crrctn: Option<CollateralMarginCorrection6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradUpd", skip_serializing_if = "Option::is_none") )]
	pub trad_upd: Option<CollateralMarginMarginUpdate5>,
}

impl TradeReport21Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.new { val.validate()? }
		if let Some(ref val) = self.err { val.validate()? }
		if let Some(ref val) = self.crrctn { val.validate()? }
		if let Some(ref val) = self.trad_upd { val.validate()? }
		Ok(())
	}
}


// TradeReport22Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeReport22Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "New", skip_serializing_if = "Option::is_none") )]
	pub new: Option<TradeNewTransaction13>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Mod", skip_serializing_if = "Option::is_none") )]
	pub mod_attr: Option<TradeTransactionCorrection13>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Err", skip_serializing_if = "Option::is_none") )]
	pub err: Option<TradeError9>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EarlyTermntn", skip_serializing_if = "Option::is_none") )]
	pub early_termntn: Option<TradeError9>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PosCmpnt", skip_serializing_if = "Option::is_none") )]
	pub pos_cmpnt: Option<TradeTransactionPositionComponent8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollUpd", skip_serializing_if = "Option::is_none") )]
	pub coll_upd: Option<TradeTransactionCollateralUpdate8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Crrctn", skip_serializing_if = "Option::is_none") )]
	pub crrctn: Option<TradeTransactionCorrection13>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ValtnUpd", skip_serializing_if = "Option::is_none") )]
	pub valtn_upd: Option<TradeValuationUpdate9>,
}

impl TradeReport22Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.new { val.validate()? }
		if let Some(ref val) = self.mod_attr { val.validate()? }
		if let Some(ref val) = self.err { val.validate()? }
		if let Some(ref val) = self.early_termntn { val.validate()? }
		if let Some(ref val) = self.pos_cmpnt { val.validate()? }
		if let Some(ref val) = self.coll_upd { val.validate()? }
		if let Some(ref val) = self.crrctn { val.validate()? }
		if let Some(ref val) = self.valtn_upd { val.validate()? }
		Ok(())
	}
}


// TradeReport33Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeReport33Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "New", skip_serializing_if = "Option::is_none") )]
	pub new: Option<TradeData43>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Mod", skip_serializing_if = "Option::is_none") )]
	pub mod_attr: Option<TradeData43>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Crrctn", skip_serializing_if = "Option::is_none") )]
	pub crrctn: Option<TradeData43>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Termntn", skip_serializing_if = "Option::is_none") )]
	pub termntn: Option<TradeData43>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PosCmpnt", skip_serializing_if = "Option::is_none") )]
	pub pos_cmpnt: Option<TradeData43>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ValtnUpd", skip_serializing_if = "Option::is_none") )]
	pub valtn_upd: Option<TradeData43>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cmprssn", skip_serializing_if = "Option::is_none") )]
	pub cmprssn: Option<TradeData43>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Err", skip_serializing_if = "Option::is_none") )]
	pub err: Option<TradeData43>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PortOut", skip_serializing_if = "Option::is_none") )]
	pub port_out: Option<TradeData43>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rvv", skip_serializing_if = "Option::is_none") )]
	pub rvv: Option<TradeData43>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<TradeData43>,
}

impl TradeReport33Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.new { val.validate()? }
		if let Some(ref val) = self.mod_attr { val.validate()? }
		if let Some(ref val) = self.crrctn { val.validate()? }
		if let Some(ref val) = self.termntn { val.validate()? }
		if let Some(ref val) = self.pos_cmpnt { val.validate()? }
		if let Some(ref val) = self.valtn_upd { val.validate()? }
		if let Some(ref val) = self.cmprssn { val.validate()? }
		if let Some(ref val) = self.err { val.validate()? }
		if let Some(ref val) = self.port_out { val.validate()? }
		if let Some(ref val) = self.rvv { val.validate()? }
		if let Some(ref val) = self.othr { val.validate()? }
		Ok(())
	}
}


// TradeReport34Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeReport34Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "New", skip_serializing_if = "Option::is_none") )]
	pub new: Option<MarginReportData9>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MrgnUpd", skip_serializing_if = "Option::is_none") )]
	pub mrgn_upd: Option<MarginReportData9>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Err", skip_serializing_if = "Option::is_none") )]
	pub err: Option<MarginReportData9>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Crrctn", skip_serializing_if = "Option::is_none") )]
	pub crrctn: Option<MarginReportData9>,
}

impl TradeReport34Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.new { val.validate()? }
		if let Some(ref val) = self.mrgn_upd { val.validate()? }
		if let Some(ref val) = self.err { val.validate()? }
		if let Some(ref val) = self.crrctn { val.validate()? }
		Ok(())
	}
}


// TradeReportHeader4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeReportHeader4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptExctnDt", skip_serializing_if = "Option::is_none") )]
	pub rpt_exctn_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgPgntn", skip_serializing_if = "Option::is_none") )]
	pub msg_pgntn: Option<Pagination1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbRcrds") )]
	pub nb_rcrds: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CmptntAuthrty", skip_serializing_if = "Option::is_none") )]
	pub cmptnt_authrty: Option<Vec<String>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NewTradRpstryIdr", skip_serializing_if = "Option::is_none") )]
	pub new_trad_rpstry_idr: Option<OrganisationIdentification15Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgPurp", skip_serializing_if = "Option::is_none") )]
	pub rptg_purp: Option<Vec<String>>,
}

impl TradeReportHeader4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.msg_pgntn { val.validate()? }
		if let Some(ref vec) = self.cmptnt_authrty {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "cmptnt_authrty is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 100 {
					return Err(ValidationError::new(1002, "cmptnt_authrty exceeds the maximum length of 100".to_string()));
				}
			}
		}
		if let Some(ref val) = self.new_trad_rpstry_idr { val.validate()? }
		if let Some(ref vec) = self.rptg_purp {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "rptg_purp is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 100 {
					return Err(ValidationError::new(1002, "rptg_purp exceeds the maximum length of 100".to_string()));
				}
			}
		}
		Ok(())
	}
}


// TradeReportQuery13Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeReportQuery13Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AdHocQry", skip_serializing_if = "Option::is_none") )]
	pub ad_hoc_qry: Option<TradeQueryCriteria10>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RcrntQry", skip_serializing_if = "Option::is_none") )]
	pub rcrnt_qry: Option<TradeRecurrentQuery5>,
}

impl TradeReportQuery13Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ad_hoc_qry { val.validate()? }
		if let Some(ref val) = self.rcrnt_qry { val.validate()? }
		Ok(())
	}
}


// TradeReportQuery18Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeReportQuery18Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AdHocQry", skip_serializing_if = "Option::is_none") )]
	pub ad_hoc_qry: Option<TradeQueryCriteria14>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RcrntQry", skip_serializing_if = "Option::is_none") )]
	pub rcrnt_qry: Option<TradeRecurrentQuery7>,
}

impl TradeReportQuery18Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ad_hoc_qry { val.validate()? }
		if let Some(ref val) = self.rcrnt_qry { val.validate()? }
		Ok(())
	}
}


// TradeRepositoryReportingType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum TradeRepositoryReportingType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "SWOS") )]
	CodeSWOS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TWOS") )]
	CodeTWOS,
}

impl TradeRepositoryReportingType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// TradeSecurityIdentificationQueryCriteria3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeSecurityIdentificationQueryCriteria3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Oprtr") )]
	pub oprtr: Operation3Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<Vec<SecurityIdentificationQueryCriteria1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrctTp", skip_serializing_if = "Option::is_none") )]
	pub ctrct_tp: Option<Vec<FinancialInstrumentContractType2Code>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ISIN", skip_serializing_if = "Option::is_none") )]
	pub isin: Option<Vec<ISINQueryCriteria1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnqPdctIdr", skip_serializing_if = "Option::is_none") )]
	pub unq_pdct_idr: Option<Vec<UPIQueryCriteria1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UndrlygInstrmId", skip_serializing_if = "Option::is_none") )]
	pub undrlyg_instrm_id: Option<Vec<SecurityIdentificationQuery4Choice>>,
}

impl TradeSecurityIdentificationQueryCriteria3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.oprtr.validate()?;
		if let Some(ref vec) = self.id { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.ctrct_tp { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.isin { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.unq_pdct_idr { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.undrlyg_instrm_id { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TradeSettlement2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeSettlement2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtRef", skip_serializing_if = "Option::is_none") )]
	pub pmt_ref: Option<CreditorReferenceInformation2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DueDt", skip_serializing_if = "Option::is_none") )]
	pub due_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DuePyblAmt") )]
	pub due_pybl_amt: CurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InvcCcyXchg", skip_serializing_if = "Option::is_none") )]
	pub invc_ccy_xchg: Option<CurrencyReference3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DlvryDt", skip_serializing_if = "Option::is_none") )]
	pub dlvry_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BllgPrd", skip_serializing_if = "Option::is_none") )]
	pub bllg_prd: Option<Period2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TaxTtlAmt") )]
	pub tax_ttl_amt: CurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XmptnRsnCd", skip_serializing_if = "Option::is_none") )]
	pub xmptn_rsn_cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XmptnRsn", skip_serializing_if = "Option::is_none") )]
	pub xmptn_rsn: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubTtlClctdTax", skip_serializing_if = "Option::is_none") )]
	pub sub_ttl_clctd_tax: Option<Vec<SettlementSubTotalCalculatedTax2>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EarlyPmts", skip_serializing_if = "Option::is_none") )]
	pub early_pmts: Option<Vec<EarlyPayment1>>,
}

impl TradeSettlement2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.pmt_ref { val.validate()? }
		self.due_pybl_amt.validate()?;
		if let Some(ref val) = self.invc_ccy_xchg { val.validate()? }
		if let Some(ref val) = self.bllg_prd { val.validate()? }
		self.tax_ttl_amt.validate()?;
		if let Some(ref val) = self.xmptn_rsn_cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "xmptn_rsn_cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "xmptn_rsn_cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.xmptn_rsn {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "xmptn_rsn is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 500 {
				return Err(ValidationError::new(1002, "xmptn_rsn exceeds the maximum length of 500".to_string()));
			}
		}
		if let Some(ref vec) = self.sub_ttl_clctd_tax { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.early_pmts { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TradeStateReport16 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeStateReport16 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechRcrdId", skip_serializing_if = "Option::is_none") )]
	pub tech_rcrd_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPtySpcfcData") )]
	pub ctr_pty_spcfc_data: CounterpartyData88,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LnData", skip_serializing_if = "Option::is_none") )]
	pub ln_data: Option<TransactionLoanData31Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollData", skip_serializing_if = "Option::is_none") )]
	pub coll_data: Option<TransactionCollateralData18Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RcncltnFlg", skip_serializing_if = "Option::is_none") )]
	pub rcncltn_flg: Option<ReconciliationFlag2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrctMod") )]
	pub ctrct_mod: ContractModification3,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl TradeStateReport16 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tech_rcrd_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tech_rcrd_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "tech_rcrd_id exceeds the maximum length of 140".to_string()));
			}
		}
		self.ctr_pty_spcfc_data.validate()?;
		if let Some(ref val) = self.ln_data { val.validate()? }
		if let Some(ref val) = self.coll_data { val.validate()? }
		if let Some(ref val) = self.rcncltn_flg { val.validate()? }
		self.ctrct_mod.validate()?;
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TradeStateReport23 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeStateReport23 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPtySpcfcData") )]
	pub ctr_pty_spcfc_data: Vec<CounterpartySpecificData36>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CmonTradData") )]
	pub cmon_trad_data: CommonTradeDataReport72,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechAttrbts", skip_serializing_if = "Option::is_none") )]
	pub tech_attrbts: Option<TechnicalAttributes5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PblcDssmntnData", skip_serializing_if = "Option::is_none") )]
	pub pblc_dssmntn_data: Option<DisseminationData1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl TradeStateReport23 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		for item in &self.ctr_pty_spcfc_data { item.validate()? }
		self.cmon_trad_data.validate()?;
		if let Some(ref val) = self.tech_attrbts { val.validate()? }
		if let Some(ref val) = self.pblc_dssmntn_data { val.validate()? }
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TradeStateReport5Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeStateReport5Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DataSetActn", skip_serializing_if = "Option::is_none") )]
	pub data_set_actn: Option<ReportPeriodActivity1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Stat", skip_serializing_if = "Option::is_none") )]
	pub stat: Option<Vec<TradeStateReport16>>,
}

impl TradeStateReport5Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.data_set_actn { val.validate()? }
		if let Some(ref vec) = self.stat { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TradeTransaction50 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeTransaction50 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxId", skip_serializing_if = "Option::is_none") )]
	pub tx_id: Option<UniqueTransactionIdentifier2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ScndryTxId", skip_serializing_if = "Option::is_none") )]
	pub scndry_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrrTxId", skip_serializing_if = "Option::is_none") )]
	pub prr_tx_id: Option<UniqueTransactionIdentifier3Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SbsqntTxId", skip_serializing_if = "Option::is_none") )]
	pub sbsqnt_tx_id: Option<UniqueTransactionIdentifier3Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollPrtflCd", skip_serializing_if = "Option::is_none") )]
	pub coll_prtfl_cd: Option<CollateralPortfolioCode6Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptTrckgNb", skip_serializing_if = "Option::is_none") )]
	pub rpt_trckg_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PltfmIdr", skip_serializing_if = "Option::is_none") )]
	pub pltfm_idr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MrrrOrTrggrTx", skip_serializing_if = "Option::is_none") )]
	pub mrrr_or_trggr_tx: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxPric", skip_serializing_if = "Option::is_none") )]
	pub tx_pric: Option<PriceData2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtnlAmt", skip_serializing_if = "Option::is_none") )]
	pub ntnl_amt: Option<NotionalAmountLegs5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtnlQty", skip_serializing_if = "Option::is_none") )]
	pub ntnl_qty: Option<NotionalQuantityLegs5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Qty", skip_serializing_if = "Option::is_none") )]
	pub qty: Option<FinancialInstrumentQuantity32Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DlvryTp", skip_serializing_if = "Option::is_none") )]
	pub dlvry_tp: Option<PhysicalTransferType4Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ExctnTmStmp", skip_serializing_if = "Option::is_none") )]
	pub exctn_tm_stmp: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FctvDt", skip_serializing_if = "Option::is_none") )]
	pub fctv_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XprtnDt", skip_serializing_if = "Option::is_none") )]
	pub xprtn_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EarlyTermntnDt", skip_serializing_if = "Option::is_none") )]
	pub early_termntn_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttlmDt", skip_serializing_if = "Option::is_none") )]
	pub sttlm_dt: Option<Vec<String>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MstrAgrmt", skip_serializing_if = "Option::is_none") )]
	pub mstr_agrmt: Option<MasterAgreement8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cmprssn", skip_serializing_if = "Option::is_none") )]
	pub cmprssn: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstTradRskRdctnFlg", skip_serializing_if = "Option::is_none") )]
	pub pst_trad_rsk_rdctn_flg: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstTradRskRdctnEvt", skip_serializing_if = "Option::is_none") )]
	pub pst_trad_rsk_rdctn_evt: Option<PTRREvent2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DerivEvt", skip_serializing_if = "Option::is_none") )]
	pub deriv_evt: Option<DerivativeEvent6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradConf", skip_serializing_if = "Option::is_none") )]
	pub trad_conf: Option<TradeConfirmation4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NonStdsdTerm", skip_serializing_if = "Option::is_none") )]
	pub non_stdsd_term: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradClr", skip_serializing_if = "Option::is_none") )]
	pub trad_clr: Option<TradeClearing11>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BlckTradElctn", skip_serializing_if = "Option::is_none") )]
	pub blck_trad_elctn: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LrgNtnlOffFcltyElctn", skip_serializing_if = "Option::is_none") )]
	pub lrg_ntnl_off_fclty_elctn: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstRate", skip_serializing_if = "Option::is_none") )]
	pub intrst_rate: Option<InterestRateLegs14>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ccy", skip_serializing_if = "Option::is_none") )]
	pub ccy: Option<CurrencyExchange22>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cmmdty", skip_serializing_if = "Option::is_none") )]
	pub cmmdty: Option<AssetClassCommodity7Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Optn", skip_serializing_if = "Option::is_none") )]
	pub optn: Option<OptionOrSwaption11>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NrgySpcfcAttrbts", skip_serializing_if = "Option::is_none") )]
	pub nrgy_spcfc_attrbts: Option<EnergySpecificAttribute9>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cdt", skip_serializing_if = "Option::is_none") )]
	pub cdt: Option<CreditDerivative4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrPmt", skip_serializing_if = "Option::is_none") )]
	pub othr_pmt: Option<Vec<OtherPayment5>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Packg", skip_serializing_if = "Option::is_none") )]
	pub packg: Option<Package4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradAllcnSts", skip_serializing_if = "Option::is_none") )]
	pub trad_allcn_sts: Option<AllocationIndicator1Code>,
}

impl TradeTransaction50 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tx_id { val.validate()? }
		if let Some(ref val) = self.scndry_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "scndry_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 72 {
				return Err(ValidationError::new(1002, "scndry_tx_id exceeds the maximum length of 72".to_string()));
			}
		}
		if let Some(ref val) = self.prr_tx_id { val.validate()? }
		if let Some(ref val) = self.sbsqnt_tx_id { val.validate()? }
		if let Some(ref val) = self.coll_prtfl_cd { val.validate()? }
		if let Some(ref val) = self.rpt_trckg_nb {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "rpt_trckg_nb is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 52 {
				return Err(ValidationError::new(1002, "rpt_trckg_nb exceeds the maximum length of 52".to_string()));
			}
		}
		if let Some(ref val) = self.pltfm_idr {
			let pattern = Regex::new("[A-Z0-9]{4,4}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "pltfm_idr does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.tx_pric { val.validate()? }
		if let Some(ref val) = self.ntnl_amt { val.validate()? }
		if let Some(ref val) = self.ntnl_qty { val.validate()? }
		if let Some(ref val) = self.qty { val.validate()? }
		if let Some(ref val) = self.dlvry_tp { val.validate()? }
		if let Some(ref val) = self.mstr_agrmt { val.validate()? }
		if let Some(ref val) = self.pst_trad_rsk_rdctn_evt { val.validate()? }
		if let Some(ref val) = self.deriv_evt { val.validate()? }
		if let Some(ref val) = self.trad_conf { val.validate()? }
		if let Some(ref val) = self.trad_clr { val.validate()? }
		if let Some(ref val) = self.intrst_rate { val.validate()? }
		if let Some(ref val) = self.ccy { val.validate()? }
		if let Some(ref val) = self.cmmdty { val.validate()? }
		if let Some(ref val) = self.optn { val.validate()? }
		if let Some(ref val) = self.nrgy_spcfc_attrbts { val.validate()? }
		if let Some(ref val) = self.cdt { val.validate()? }
		if let Some(ref vec) = self.othr_pmt { for item in vec { item.validate()? } }
		if let Some(ref val) = self.packg { val.validate()? }
		if let Some(ref val) = self.trad_allcn_sts { val.validate()? }
		Ok(())
	}
}


// TradeTransactionCollateralUpdate8 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeTransactionCollateralUpdate8 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechRcrdId", skip_serializing_if = "Option::is_none") )]
	pub tech_rcrd_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPtySpcfcData") )]
	pub ctr_pty_spcfc_data: CounterpartyData88,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LnData", skip_serializing_if = "Option::is_none") )]
	pub ln_data: Option<TransactionLoanData26Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollData") )]
	pub coll_data: TransactionCollateralData18Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl TradeTransactionCollateralUpdate8 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tech_rcrd_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tech_rcrd_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "tech_rcrd_id exceeds the maximum length of 140".to_string()));
			}
		}
		self.ctr_pty_spcfc_data.validate()?;
		if let Some(ref val) = self.ln_data { val.validate()? }
		self.coll_data.validate()?;
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TradeTransactionCorrection13 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeTransactionCorrection13 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechRcrdId", skip_serializing_if = "Option::is_none") )]
	pub tech_rcrd_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPtySpcfcData") )]
	pub ctr_pty_spcfc_data: CounterpartyData88,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LnData", skip_serializing_if = "Option::is_none") )]
	pub ln_data: Option<TransactionLoanData31Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollData", skip_serializing_if = "Option::is_none") )]
	pub coll_data: Option<TransactionCollateralData18Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LvlTp") )]
	pub lvl_tp: ModificationLevel1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl TradeTransactionCorrection13 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tech_rcrd_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tech_rcrd_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "tech_rcrd_id exceeds the maximum length of 140".to_string()));
			}
		}
		self.ctr_pty_spcfc_data.validate()?;
		if let Some(ref val) = self.ln_data { val.validate()? }
		if let Some(ref val) = self.coll_data { val.validate()? }
		self.lvl_tp.validate()?;
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TradeTransactionIdentification15 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeTransactionIdentification15 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgCtrPty") )]
	pub rptg_ctr_pty: OrganisationIdentification15Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrCtrPty") )]
	pub othr_ctr_pty: PartyIdentification236Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnqTradIdr", skip_serializing_if = "Option::is_none") )]
	pub unq_trad_idr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MstrAgrmt", skip_serializing_if = "Option::is_none") )]
	pub mstr_agrmt: Option<MasterAgreement7>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AgtLndr", skip_serializing_if = "Option::is_none") )]
	pub agt_lndr: Option<OrganisationIdentification15Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TrptyAgt", skip_serializing_if = "Option::is_none") )]
	pub trpty_agt: Option<OrganisationIdentification15Choice>,
}

impl TradeTransactionIdentification15 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.rptg_ctr_pty.validate()?;
		self.othr_ctr_pty.validate()?;
		if let Some(ref val) = self.unq_trad_idr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "unq_trad_idr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 52 {
				return Err(ValidationError::new(1002, "unq_trad_idr exceeds the maximum length of 52".to_string()));
			}
		}
		if let Some(ref val) = self.mstr_agrmt { val.validate()? }
		if let Some(ref val) = self.agt_lndr { val.validate()? }
		if let Some(ref val) = self.trpty_agt { val.validate()? }
		Ok(())
	}
}


// TradeTransactionIdentification16 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeTransactionIdentification16 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechRcrdId", skip_serializing_if = "Option::is_none") )]
	pub tech_rcrd_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgCtrPty") )]
	pub rptg_ctr_pty: OrganisationIdentification15Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrCtrPty") )]
	pub othr_ctr_pty: PartyIdentification236Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NttyRspnsblForRpt", skip_serializing_if = "Option::is_none") )]
	pub ntty_rspnsbl_for_rpt: Option<OrganisationIdentification15Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollPrtflId", skip_serializing_if = "Option::is_none") )]
	pub coll_prtfl_id: Option<String>,
}

impl TradeTransactionIdentification16 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tech_rcrd_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tech_rcrd_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "tech_rcrd_id exceeds the maximum length of 140".to_string()));
			}
		}
		self.rptg_ctr_pty.validate()?;
		self.othr_ctr_pty.validate()?;
		if let Some(ref val) = self.ntty_rspnsbl_for_rpt { val.validate()? }
		if let Some(ref val) = self.coll_prtfl_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "coll_prtfl_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 52 {
				return Err(ValidationError::new(1002, "coll_prtfl_id exceeds the maximum length of 52".to_string()));
			}
		}
		Ok(())
	}
}


// TradeTransactionIdentification17 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeTransactionIdentification17 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechRcrdId", skip_serializing_if = "Option::is_none") )]
	pub tech_rcrd_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgCtrPty") )]
	pub rptg_ctr_pty: OrganisationIdentification15Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptSubmitgNtty") )]
	pub rpt_submitg_ntty: OrganisationIdentification15Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NttyRspnsblForRpt", skip_serializing_if = "Option::is_none") )]
	pub ntty_rspnsbl_for_rpt: Option<OrganisationIdentification15Choice>,
}

impl TradeTransactionIdentification17 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tech_rcrd_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tech_rcrd_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "tech_rcrd_id exceeds the maximum length of 140".to_string()));
			}
		}
		self.rptg_ctr_pty.validate()?;
		self.rpt_submitg_ntty.validate()?;
		if let Some(ref val) = self.ntty_rspnsbl_for_rpt { val.validate()? }
		Ok(())
	}
}


// TradeTransactionIdentification18 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeTransactionIdentification18 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgCtrPty") )]
	pub rptg_ctr_pty: OrganisationIdentification15Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrCtrPty") )]
	pub othr_ctr_pty: PartyIdentification236Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnqTradIdr", skip_serializing_if = "Option::is_none") )]
	pub unq_trad_idr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MstrAgrmt", skip_serializing_if = "Option::is_none") )]
	pub mstr_agrmt: Option<MasterAgreement7>,
}

impl TradeTransactionIdentification18 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.rptg_ctr_pty.validate()?;
		self.othr_ctr_pty.validate()?;
		if let Some(ref val) = self.unq_trad_idr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "unq_trad_idr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 52 {
				return Err(ValidationError::new(1002, "unq_trad_idr exceeds the maximum length of 52".to_string()));
			}
		}
		if let Some(ref val) = self.mstr_agrmt { val.validate()? }
		Ok(())
	}
}


// TradeTransactionIdentification19 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeTransactionIdentification19 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgCtrPty") )]
	pub rptg_ctr_pty: OrganisationIdentification15Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrCtrPty") )]
	pub othr_ctr_pty: PartyIdentification236Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NttyRspnsblForRpt", skip_serializing_if = "Option::is_none") )]
	pub ntty_rspnsbl_for_rpt: Option<OrganisationIdentification15Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnqTradIdr", skip_serializing_if = "Option::is_none") )]
	pub unq_trad_idr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MstrAgrmt", skip_serializing_if = "Option::is_none") )]
	pub mstr_agrmt: Option<MasterAgreement7>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AgtLndr", skip_serializing_if = "Option::is_none") )]
	pub agt_lndr: Option<OrganisationIdentification15Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TrptyAgt", skip_serializing_if = "Option::is_none") )]
	pub trpty_agt: Option<OrganisationIdentification15Choice>,
}

impl TradeTransactionIdentification19 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.rptg_ctr_pty.validate()?;
		self.othr_ctr_pty.validate()?;
		if let Some(ref val) = self.ntty_rspnsbl_for_rpt { val.validate()? }
		if let Some(ref val) = self.unq_trad_idr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "unq_trad_idr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 52 {
				return Err(ValidationError::new(1002, "unq_trad_idr exceeds the maximum length of 52".to_string()));
			}
		}
		if let Some(ref val) = self.mstr_agrmt { val.validate()? }
		if let Some(ref val) = self.agt_lndr { val.validate()? }
		if let Some(ref val) = self.trpty_agt { val.validate()? }
		Ok(())
	}
}


// TradeTransactionIdentification20 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeTransactionIdentification20 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechRcrdId", skip_serializing_if = "Option::is_none") )]
	pub tech_rcrd_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgCtrPty") )]
	pub rptg_ctr_pty: OrganisationIdentification15Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrCtrPty") )]
	pub othr_ctr_pty: PartyIdentification236Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NttyRspnsblForRpt", skip_serializing_if = "Option::is_none") )]
	pub ntty_rspnsbl_for_rpt: Option<OrganisationIdentification15Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnqTradIdr", skip_serializing_if = "Option::is_none") )]
	pub unq_trad_idr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MstrAgrmt", skip_serializing_if = "Option::is_none") )]
	pub mstr_agrmt: Option<MasterAgreement7>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AgtLndr", skip_serializing_if = "Option::is_none") )]
	pub agt_lndr: Option<OrganisationIdentification15Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TrptyAgt", skip_serializing_if = "Option::is_none") )]
	pub trpty_agt: Option<OrganisationIdentification15Choice>,
}

impl TradeTransactionIdentification20 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tech_rcrd_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tech_rcrd_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "tech_rcrd_id exceeds the maximum length of 140".to_string()));
			}
		}
		self.rptg_ctr_pty.validate()?;
		self.othr_ctr_pty.validate()?;
		if let Some(ref val) = self.ntty_rspnsbl_for_rpt { val.validate()? }
		if let Some(ref val) = self.unq_trad_idr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "unq_trad_idr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 52 {
				return Err(ValidationError::new(1002, "unq_trad_idr exceeds the maximum length of 52".to_string()));
			}
		}
		if let Some(ref val) = self.mstr_agrmt { val.validate()? }
		if let Some(ref val) = self.agt_lndr { val.validate()? }
		if let Some(ref val) = self.trpty_agt { val.validate()? }
		Ok(())
	}
}


// TradeTransactionIdentification24 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeTransactionIdentification24 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechRcrdId", skip_serializing_if = "Option::is_none") )]
	pub tech_rcrd_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ActnTp", skip_serializing_if = "Option::is_none") )]
	pub actn_tp: Option<TransactionOperationType10Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgTmStmp", skip_serializing_if = "Option::is_none") )]
	pub rptg_tm_stmp: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DerivEvtTp", skip_serializing_if = "Option::is_none") )]
	pub deriv_evt_tp: Option<DerivativeEventType3Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DerivEvtTmStmp", skip_serializing_if = "Option::is_none") )]
	pub deriv_evt_tm_stmp: Option<DateAndDateTime2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrCtrPty", skip_serializing_if = "Option::is_none") )]
	pub othr_ctr_pty: Option<PartyIdentification248Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnqIdr", skip_serializing_if = "Option::is_none") )]
	pub unq_idr: Option<UniqueTransactionIdentifier2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MstrAgrmt", skip_serializing_if = "Option::is_none") )]
	pub mstr_agrmt: Option<MasterAgreement8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollPrtflCd", skip_serializing_if = "Option::is_none") )]
	pub coll_prtfl_cd: Option<CollateralPortfolioCode5Choice>,
}

impl TradeTransactionIdentification24 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tech_rcrd_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tech_rcrd_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "tech_rcrd_id exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.actn_tp { val.validate()? }
		if let Some(ref val) = self.deriv_evt_tp { val.validate()? }
		if let Some(ref val) = self.deriv_evt_tm_stmp { val.validate()? }
		if let Some(ref val) = self.othr_ctr_pty { val.validate()? }
		if let Some(ref val) = self.unq_idr { val.validate()? }
		if let Some(ref val) = self.mstr_agrmt { val.validate()? }
		if let Some(ref val) = self.coll_prtfl_cd { val.validate()? }
		Ok(())
	}
}


// TradeTransactionPositionComponent8 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeTransactionPositionComponent8 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechRcrdId", skip_serializing_if = "Option::is_none") )]
	pub tech_rcrd_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPtySpcfcData") )]
	pub ctr_pty_spcfc_data: CounterpartyData88,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LnData", skip_serializing_if = "Option::is_none") )]
	pub ln_data: Option<TransactionLoanData32Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollData", skip_serializing_if = "Option::is_none") )]
	pub coll_data: Option<CollateralData35>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LvlTp") )]
	pub lvl_tp: ModificationLevel1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl TradeTransactionPositionComponent8 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tech_rcrd_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tech_rcrd_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "tech_rcrd_id exceeds the maximum length of 140".to_string()));
			}
		}
		self.ctr_pty_spcfc_data.validate()?;
		if let Some(ref val) = self.ln_data { val.validate()? }
		if let Some(ref val) = self.coll_data { val.validate()? }
		self.lvl_tp.validate()?;
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TradeTypeQueryCriteria2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeTypeQueryCriteria2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Oprtr") )]
	pub oprtr: Operation3Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SctiesFincgTxTp", skip_serializing_if = "Option::is_none") )]
	pub scties_fincg_tx_tp: Option<Vec<ExposureType10Code>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollCmpntTp", skip_serializing_if = "Option::is_none") )]
	pub coll_cmpnt_tp: Option<Vec<CollateralType6Code>>,
}

impl TradeTypeQueryCriteria2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.oprtr.validate()?;
		if let Some(ref vec) = self.scties_fincg_tx_tp { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.coll_cmpnt_tp { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TradeValuationUpdate9 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradeValuationUpdate9 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechRcrdId", skip_serializing_if = "Option::is_none") )]
	pub tech_rcrd_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPtySpcfcData") )]
	pub ctr_pty_spcfc_data: CounterpartyData88,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LnData") )]
	pub ln_data: LoanData113,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl TradeValuationUpdate9 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tech_rcrd_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tech_rcrd_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "tech_rcrd_id exceeds the maximum length of 140".to_string()));
			}
		}
		self.ctr_pty_spcfc_data.validate()?;
		self.ln_data.validate()?;
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TradingCapacity7Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum TradingCapacity7Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "AGEN") )]
	CodeAGEN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PRIN") )]
	CodePRIN,
}

impl TradingCapacity7Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// TradingUnderWaiversPercentage1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradingUnderWaiversPercentage1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradgUdrWvrPctg") )]
	pub tradg_udr_wvr_pctg: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradgVn") )]
	pub tradg_vn: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dsclmr", skip_serializing_if = "Option::is_none") )]
	pub dsclmr: Option<String>,
}

impl TradingUnderWaiversPercentage1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z0-9]{4,4}").unwrap();
		if !pattern.is_match(&self.tradg_vn) {
			return Err(ValidationError::new(1005, "tradg_vn does not match the required pattern".to_string()));
		}
		if let Some(ref val) = self.dsclmr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "dsclmr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 350 {
				return Err(ValidationError::new(1002, "dsclmr exceeds the maximum length of 350".to_string()));
			}
		}
		Ok(())
	}
}


// TradingVenue2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum TradingVenue2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "APPA") )]
	CodeAPPA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CTPS") )]
	CodeCTPS,
}

impl TradingVenue2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// TradingVenueAttributes1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradingVenueAttributes1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IssrReq") )]
	pub issr_req: bool,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AdmssnApprvlDtByIssr", skip_serializing_if = "Option::is_none") )]
	pub admssn_apprvl_dt_by_issr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReqForAdmssnDt", skip_serializing_if = "Option::is_none") )]
	pub req_for_admssn_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrstTradDt", skip_serializing_if = "Option::is_none") )]
	pub frst_trad_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TermntnDt", skip_serializing_if = "Option::is_none") )]
	pub termntn_dt: Option<String>,
}

impl TradingVenueAttributes1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z0-9]{4,4}").unwrap();
		if !pattern.is_match(&self.id) {
			return Err(ValidationError::new(1005, "id does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// TradingVenueAttributes2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradingVenueAttributes2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IssrReq", skip_serializing_if = "Option::is_none") )]
	pub issr_req: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AdmssnApprvlDtByIssr", skip_serializing_if = "Option::is_none") )]
	pub admssn_apprvl_dt_by_issr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReqForAdmssnDt", skip_serializing_if = "Option::is_none") )]
	pub req_for_admssn_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrstTradDt", skip_serializing_if = "Option::is_none") )]
	pub frst_trad_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TermntnDt", skip_serializing_if = "Option::is_none") )]
	pub termntn_dt: Option<String>,
}

impl TradingVenueAttributes2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z0-9]{4,4}").unwrap();
		if !pattern.is_match(&self.id) {
			return Err(ValidationError::new(1005, "id does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// TradingVenueIdentification1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradingVenueIdentification1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MktIdCd", skip_serializing_if = "Option::is_none") )]
	pub mkt_id_cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtlCmptntAuthrty", skip_serializing_if = "Option::is_none") )]
	pub ntl_cmptnt_authrty: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<TradingVenueIdentification2>,
}

impl TradingVenueIdentification1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.mkt_id_cd {
			let pattern = Regex::new("[A-Z0-9]{4,4}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "mkt_id_cd does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.ntl_cmptnt_authrty {
			let pattern = Regex::new("[A-Z]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ntl_cmptnt_authrty does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.othr { val.validate()? }
		Ok(())
	}
}


// TradingVenueIdentification2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradingVenueIdentification2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: TradingVenue2Code,
}

impl TradingVenueIdentification2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 50 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 50".to_string()));
		}
		self.tp.validate()?;
		Ok(())
	}
}


// TradingVenueType1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TradingVenueType1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OnVn", skip_serializing_if = "Option::is_none") )]
	pub on_vn: Option<TradeMarket2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OffVn", skip_serializing_if = "Option::is_none") )]
	pub off_vn: Option<NoReasonCode>,
}

impl TradingVenueType1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.on_vn { val.validate()? }
		if let Some(ref val) = self.off_vn { val.validate()? }
		Ok(())
	}
}


// Tranche3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct Tranche3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AttchmntPt", skip_serializing_if = "Option::is_none") )]
	pub attchmnt_pt: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtchmntPt", skip_serializing_if = "Option::is_none") )]
	pub dtchmnt_pt: Option<f64>,
}

impl Tranche3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// TrancheIndicator3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TrancheIndicator3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Trnchd", skip_serializing_if = "Option::is_none") )]
	pub trnchd: Option<Tranche3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Utrnchd", skip_serializing_if = "Option::is_none") )]
	pub utrnchd: Option<NoReasonCode>,
}

impl TrancheIndicator3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.trnchd { val.validate()? }
		if let Some(ref val) = self.utrnchd { val.validate()? }
		Ok(())
	}
}


// TransactionCertificate4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TransactionCertificate4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxId") )]
	pub tx_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cert") )]
	pub cert: DocumentIdentification28,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Acct", skip_serializing_if = "Option::is_none") )]
	pub acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BkAcctDmcltnCtry", skip_serializing_if = "Option::is_none") )]
	pub bk_acct_dmcltn_ctry: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amdmnt", skip_serializing_if = "Option::is_none") )]
	pub amdmnt: Option<DocumentAmendment1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CertRcrd") )]
	pub cert_rcrd: Vec<TransactionCertificateRecord2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl TransactionCertificate4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.tx_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "tx_id is shorter than the minimum length of 1".to_string()));
		}
		if self.tx_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "tx_id exceeds the maximum length of 35".to_string()));
		}
		self.cert.validate()?;
		if let Some(ref val) = self.acct { val.validate()? }
		if let Some(ref val) = self.bk_acct_dmcltn_ctry {
			let pattern = Regex::new("[A-Z]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "bk_acct_dmcltn_ctry does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.amdmnt { val.validate()? }
		for item in &self.cert_rcrd { item.validate()? }
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TransactionCertificate5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TransactionCertificate5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RfrdDoc") )]
	pub rfrd_doc: CertificateReference2,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxDt") )]
	pub tx_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxTp", skip_serializing_if = "Option::is_none") )]
	pub tx_tp: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LclInstrm") )]
	pub lcl_instrm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveCurrencyAndAmount,
}

impl TransactionCertificate5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.rfrd_doc.validate()?;
		if let Some(ref val) = self.tx_tp {
			let pattern = Regex::new("[0-9]").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "tx_tp does not match the required pattern".to_string()));
			}
		}
		let pattern = Regex::new("[0-9]{5}").unwrap();
		if !pattern.is_match(&self.lcl_instrm) {
			return Err(ValidationError::new(1005, "lcl_instrm does not match the required pattern".to_string()));
		}
		self.amt.validate()?;
		Ok(())
	}
}


// TransactionCertificateContract2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TransactionCertificateContract2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrctRef", skip_serializing_if = "Option::is_none") )]
	pub ctrct_ref: Option<ContractRegistrationReference2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxAmtInCtrctCcy", skip_serializing_if = "Option::is_none") )]
	pub tx_amt_in_ctrct_ccy: Option<ActiveCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XpctdShipmntDt", skip_serializing_if = "Option::is_none") )]
	pub xpctd_shipmnt_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XpctdAdvncPmtRtrDt", skip_serializing_if = "Option::is_none") )]
	pub xpctd_advnc_pmt_rtr_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_inf: Option<String>,
}

impl TransactionCertificateContract2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ctrct_ref { val.validate()? }
		if let Some(ref val) = self.tx_amt_in_ctrct_ccy { val.validate()? }
		if let Some(ref val) = self.addtl_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 1025 {
				return Err(ValidationError::new(1002, "addtl_inf exceeds the maximum length of 1025".to_string()));
			}
		}
		Ok(())
	}
}


// TransactionCertificateRecord2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TransactionCertificateRecord2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CertRcrdId") )]
	pub cert_rcrd_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DocSubmitgPrcdr", skip_serializing_if = "Option::is_none") )]
	pub doc_submitg_prcdr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tx") )]
	pub tx: TransactionCertificate5,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ctrct", skip_serializing_if = "Option::is_none") )]
	pub ctrct: Option<TransactionCertificateContract2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Attchmnt", skip_serializing_if = "Option::is_none") )]
	pub attchmnt: Option<Vec<DocumentGeneralInformation5>>,
}

impl TransactionCertificateRecord2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.cert_rcrd_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "cert_rcrd_id is shorter than the minimum length of 1".to_string()));
		}
		if self.cert_rcrd_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "cert_rcrd_id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.doc_submitg_prcdr {
			let pattern = Regex::new("[0-9]").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "doc_submitg_prcdr does not match the required pattern".to_string()));
			}
		}
		self.tx.validate()?;
		if let Some(ref val) = self.ctrct { val.validate()? }
		if let Some(ref vec) = self.attchmnt { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TransactionCollateralData18Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TransactionCollateralData18Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RpTrad", skip_serializing_if = "Option::is_none") )]
	pub rp_trad: Option<Collateral52>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BuySellBck", skip_serializing_if = "Option::is_none") )]
	pub buy_sell_bck: Option<Collateral52>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SctiesLndg", skip_serializing_if = "Option::is_none") )]
	pub scties_lndg: Option<CollateralFlag13Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MrgnLndg", skip_serializing_if = "Option::is_none") )]
	pub mrgn_lndg: Option<Vec<Security55>>,
}

impl TransactionCollateralData18Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.rp_trad { val.validate()? }
		if let Some(ref val) = self.buy_sell_bck { val.validate()? }
		if let Some(ref val) = self.scties_lndg { val.validate()? }
		if let Some(ref vec) = self.mrgn_lndg { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TransactionCounterpartyData11 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TransactionCounterpartyData11 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Bnfcry", skip_serializing_if = "Option::is_none") )]
	pub bnfcry: Option<PartyIdentification236Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TrptyAgt", skip_serializing_if = "Option::is_none") )]
	pub trpty_agt: Option<OrganisationIdentification15Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Brkr", skip_serializing_if = "Option::is_none") )]
	pub brkr: Option<OrganisationIdentification15Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrMmb", skip_serializing_if = "Option::is_none") )]
	pub clr_mmb: Option<OrganisationIdentification15Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttlmPties", skip_serializing_if = "Option::is_none") )]
	pub sttlm_pties: Option<SettlementParties34Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AgtLndr", skip_serializing_if = "Option::is_none") )]
	pub agt_lndr: Option<OrganisationIdentification15Choice>,
}

impl TransactionCounterpartyData11 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.bnfcry { val.validate()? }
		if let Some(ref val) = self.trpty_agt { val.validate()? }
		if let Some(ref val) = self.brkr { val.validate()? }
		if let Some(ref val) = self.clr_mmb { val.validate()? }
		if let Some(ref val) = self.sttlm_pties { val.validate()? }
		if let Some(ref val) = self.agt_lndr { val.validate()? }
		Ok(())
	}
}


// TransactionData3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TransactionData3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxPric", skip_serializing_if = "Option::is_none") )]
	pub tx_pric: Option<SecuritiesTransactionPrice4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TraddQty", skip_serializing_if = "Option::is_none") )]
	pub tradd_qty: Option<FinancialInstrumentQuantity25Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PssvOrAggrssvInd", skip_serializing_if = "Option::is_none") )]
	pub pssv_or_aggrssv_ind: Option<PassiveOrAgressiveType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StrtgyLkdOrdrId", skip_serializing_if = "Option::is_none") )]
	pub strtgy_lkd_ordr_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxId", skip_serializing_if = "Option::is_none") )]
	pub tx_id: Option<String>,
}

impl TransactionData3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tx_pric { val.validate()? }
		if let Some(ref val) = self.tradd_qty { val.validate()? }
		if let Some(ref val) = self.pssv_or_aggrssv_ind { val.validate()? }
		if let Some(ref val) = self.strtgy_lkd_ordr_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "strtgy_lkd_ordr_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 50 {
				return Err(ValidationError::new(1002, "strtgy_lkd_ordr_id exceeds the maximum length of 50".to_string()));
			}
		}
		if let Some(ref val) = self.tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 52 {
				return Err(ValidationError::new(1002, "tx_id exceeds the maximum length of 52".to_string()));
			}
		}
		Ok(())
	}
}


// TransactionIdentification3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TransactionIdentification3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tx", skip_serializing_if = "Option::is_none") )]
	pub tx: Option<TradeTransactionIdentification20>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MrgnRptg", skip_serializing_if = "Option::is_none") )]
	pub mrgn_rptg: Option<TradeTransactionIdentification16>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollReuse", skip_serializing_if = "Option::is_none") )]
	pub coll_reuse: Option<TradeTransactionIdentification17>,
}

impl TransactionIdentification3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tx { val.validate()? }
		if let Some(ref val) = self.mrgn_rptg { val.validate()? }
		if let Some(ref val) = self.coll_reuse { val.validate()? }
		Ok(())
	}
}


// TransactionLoanData26Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TransactionLoanData26Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RpTrad", skip_serializing_if = "Option::is_none") )]
	pub rp_trad: Option<LoanData120>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BuySellBck", skip_serializing_if = "Option::is_none") )]
	pub buy_sell_bck: Option<LoanData120>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SctiesLndg", skip_serializing_if = "Option::is_none") )]
	pub scties_lndg: Option<LoanData120>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MrgnLndg", skip_serializing_if = "Option::is_none") )]
	pub mrgn_lndg: Option<LoanData120>,
}

impl TransactionLoanData26Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.rp_trad { val.validate()? }
		if let Some(ref val) = self.buy_sell_bck { val.validate()? }
		if let Some(ref val) = self.scties_lndg { val.validate()? }
		if let Some(ref val) = self.mrgn_lndg { val.validate()? }
		Ok(())
	}
}


// TransactionLoanData30Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TransactionLoanData30Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RpTrad", skip_serializing_if = "Option::is_none") )]
	pub rp_trad: Option<LoanData135>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BuySellBck", skip_serializing_if = "Option::is_none") )]
	pub buy_sell_bck: Option<LoanData136>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SctiesLndg", skip_serializing_if = "Option::is_none") )]
	pub scties_lndg: Option<LoanData137>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MrgnLndg", skip_serializing_if = "Option::is_none") )]
	pub mrgn_lndg: Option<LoanData138>,
}

impl TransactionLoanData30Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.rp_trad { val.validate()? }
		if let Some(ref val) = self.buy_sell_bck { val.validate()? }
		if let Some(ref val) = self.scties_lndg { val.validate()? }
		if let Some(ref val) = self.mrgn_lndg { val.validate()? }
		Ok(())
	}
}


// TransactionLoanData31Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TransactionLoanData31Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RpTrad", skip_serializing_if = "Option::is_none") )]
	pub rp_trad: Option<LoanData139>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BuySellBck", skip_serializing_if = "Option::is_none") )]
	pub buy_sell_bck: Option<LoanData140>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SctiesLndg", skip_serializing_if = "Option::is_none") )]
	pub scties_lndg: Option<LoanData141>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MrgnLndg", skip_serializing_if = "Option::is_none") )]
	pub mrgn_lndg: Option<LoanData142>,
}

impl TransactionLoanData31Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.rp_trad { val.validate()? }
		if let Some(ref val) = self.buy_sell_bck { val.validate()? }
		if let Some(ref val) = self.scties_lndg { val.validate()? }
		if let Some(ref val) = self.mrgn_lndg { val.validate()? }
		Ok(())
	}
}


// TransactionLoanData32Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TransactionLoanData32Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RpTrad", skip_serializing_if = "Option::is_none") )]
	pub rp_trad: Option<LoanData143>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BuySellBck", skip_serializing_if = "Option::is_none") )]
	pub buy_sell_bck: Option<LoanData144>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SctiesLndg", skip_serializing_if = "Option::is_none") )]
	pub scties_lndg: Option<LoanData145>,
}

impl TransactionLoanData32Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.rp_trad { val.validate()? }
		if let Some(ref val) = self.buy_sell_bck { val.validate()? }
		if let Some(ref val) = self.scties_lndg { val.validate()? }
		Ok(())
	}
}


// TransactionMatchingCriteria7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TransactionMatchingCriteria7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptTrckgNb", skip_serializing_if = "Option::is_none") )]
	pub rpt_trckg_nb: Option<CompareText2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnqTxIdr", skip_serializing_if = "Option::is_none") )]
	pub unq_tx_idr: Option<CompareUniqueTransactionIdentifier2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrrUnqTxIdr", skip_serializing_if = "Option::is_none") )]
	pub prr_unq_tx_idr: Option<CompareUniqueTransactionIdentifier2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SbsqntPosUnqTxIdr", skip_serializing_if = "Option::is_none") )]
	pub sbsqnt_pos_unq_tx_idr: Option<CompareUniqueTransactionIdentifier2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dlta", skip_serializing_if = "Option::is_none") )]
	pub dlta: Option<CompareLongFraction19DecimalNumber1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradConf", skip_serializing_if = "Option::is_none") )]
	pub trad_conf: Option<CompareTradeConfirmation2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradClrOblgtn", skip_serializing_if = "Option::is_none") )]
	pub trad_clr_oblgtn: Option<CompareTradeClearingObligation1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradClrSts", skip_serializing_if = "Option::is_none") )]
	pub trad_clr_sts: Option<CompareTradeClearingStatus3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MstrAgrmtTp", skip_serializing_if = "Option::is_none") )]
	pub mstr_agrmt_tp: Option<CompareMasterAgreementType1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MstrAgrmtVrsn", skip_serializing_if = "Option::is_none") )]
	pub mstr_agrmt_vrsn: Option<CompareMax50Text1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntraGrp", skip_serializing_if = "Option::is_none") )]
	pub intra_grp: Option<CompareTrueFalseIndicator3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstTradRskRdctn", skip_serializing_if = "Option::is_none") )]
	pub pst_trad_rsk_rdctn: Option<ComparePostTradeRiskReduction2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DerivEvt", skip_serializing_if = "Option::is_none") )]
	pub deriv_evt: Option<CompareDerivativeEvent1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PltfmIdr", skip_serializing_if = "Option::is_none") )]
	pub pltfm_idr: Option<CompareMICIdentifier3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ExctnTmStmp", skip_serializing_if = "Option::is_none") )]
	pub exctn_tm_stmp: Option<CompareDateTime3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FctvDt", skip_serializing_if = "Option::is_none") )]
	pub fctv_dt: Option<CompareDate3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XprtnDt", skip_serializing_if = "Option::is_none") )]
	pub xprtn_dt: Option<CompareDate3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EarlyTermntnDt", skip_serializing_if = "Option::is_none") )]
	pub early_termntn_dt: Option<CompareDate3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttlmDt", skip_serializing_if = "Option::is_none") )]
	pub sttlm_dt: Option<Vec<CompareDate3>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DlvryTp", skip_serializing_if = "Option::is_none") )]
	pub dlvry_tp: Option<CompareDeliveryType1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxPric", skip_serializing_if = "Option::is_none") )]
	pub tx_pric: Option<CompareUnitPrice5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PricSchdlUadjstdFctvDt", skip_serializing_if = "Option::is_none") )]
	pub pric_schdl_uadjstd_fctv_dt: Option<Vec<CompareDate3>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PricSchdlUadjstdEndDt", skip_serializing_if = "Option::is_none") )]
	pub pric_schdl_uadjstd_end_dt: Option<Vec<CompareDate3>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxSchdlPric", skip_serializing_if = "Option::is_none") )]
	pub tx_schdl_pric: Option<Vec<CompareUnitPrice5>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PackgPric", skip_serializing_if = "Option::is_none") )]
	pub packg_pric: Option<CompareUnitPrice5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtnlAmtFrstLeg", skip_serializing_if = "Option::is_none") )]
	pub ntnl_amt_frst_leg: Option<CompareAmountAndDirection3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtnlAmtFrstLegUadjstdFctvDt", skip_serializing_if = "Option::is_none") )]
	pub ntnl_amt_frst_leg_uadjstd_fctv_dt: Option<Vec<CompareDate3>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtnlAmtFrstLegUadjstdEndDt", skip_serializing_if = "Option::is_none") )]
	pub ntnl_amt_frst_leg_uadjstd_end_dt: Option<Vec<CompareDate3>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtnlAmtFrstLegSchdlAmt", skip_serializing_if = "Option::is_none") )]
	pub ntnl_amt_frst_leg_schdl_amt: Option<Vec<CompareAmountAndDirection3>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtnlQtyFrstLeg", skip_serializing_if = "Option::is_none") )]
	pub ntnl_qty_frst_leg: Option<CompareLongFraction19DecimalNumber1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtnlQtyFrstLegUadjstdFctvDt", skip_serializing_if = "Option::is_none") )]
	pub ntnl_qty_frst_leg_uadjstd_fctv_dt: Option<Vec<CompareDate3>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtnlQtyFrstLegUadjstdEndDt", skip_serializing_if = "Option::is_none") )]
	pub ntnl_qty_frst_leg_uadjstd_end_dt: Option<Vec<CompareDate3>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtnlQtyFrstLegSchdlQty", skip_serializing_if = "Option::is_none") )]
	pub ntnl_qty_frst_leg_schdl_qty: Option<Vec<CompareLongFraction19DecimalNumber1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtnlAmtScndLeg", skip_serializing_if = "Option::is_none") )]
	pub ntnl_amt_scnd_leg: Option<CompareAmountAndDirection3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtnlAmtScndLegUadjstdFctvDt", skip_serializing_if = "Option::is_none") )]
	pub ntnl_amt_scnd_leg_uadjstd_fctv_dt: Option<Vec<CompareDate3>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtnlAmtScndLegUadjstdEndDt", skip_serializing_if = "Option::is_none") )]
	pub ntnl_amt_scnd_leg_uadjstd_end_dt: Option<Vec<CompareDate3>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtnlAmtScndLegSchdlAmt", skip_serializing_if = "Option::is_none") )]
	pub ntnl_amt_scnd_leg_schdl_amt: Option<Vec<CompareAmountAndDirection3>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtnlQtyScndLeg", skip_serializing_if = "Option::is_none") )]
	pub ntnl_qty_scnd_leg: Option<CompareLongFraction19DecimalNumber1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtnlQtyScndLegUadjstdFctvDt", skip_serializing_if = "Option::is_none") )]
	pub ntnl_qty_scnd_leg_uadjstd_fctv_dt: Option<Vec<CompareDate3>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtnlQtyScndLegUadjstdEndDt", skip_serializing_if = "Option::is_none") )]
	pub ntnl_qty_scnd_leg_uadjstd_end_dt: Option<Vec<CompareDate3>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtnlQtyScndLegSchdlQty", skip_serializing_if = "Option::is_none") )]
	pub ntnl_qty_scnd_leg_schdl_qty: Option<Vec<CompareLongFraction19DecimalNumber1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrPmt", skip_serializing_if = "Option::is_none") )]
	pub othr_pmt: Option<Vec<CompareOtherPayment1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstFxdRateFrstLeg", skip_serializing_if = "Option::is_none") )]
	pub intrst_fxd_rate_frst_leg: Option<CompareUnitPrice7>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstFxdRateFrstLegDayCnt", skip_serializing_if = "Option::is_none") )]
	pub intrst_fxd_rate_frst_leg_day_cnt: Option<CompareDayCount1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstFxdRateFrstLegPmtFrqcyUnit", skip_serializing_if = "Option::is_none") )]
	pub intrst_fxd_rate_frst_leg_pmt_frqcy_unit: Option<CompareFrequencyUnit1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstFxdRateFrstLegPmtFrqcyVal", skip_serializing_if = "Option::is_none") )]
	pub intrst_fxd_rate_frst_leg_pmt_frqcy_val: Option<CompareNumber5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstFltgRateFrstLegId", skip_serializing_if = "Option::is_none") )]
	pub intrst_fltg_rate_frst_leg_id: Option<CompareISINIdentifier4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstFltgRateFrstLegCd", skip_serializing_if = "Option::is_none") )]
	pub intrst_fltg_rate_frst_leg_cd: Option<CompareBenchmarkCode1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstFltgRateFrstLegNm", skip_serializing_if = "Option::is_none") )]
	pub intrst_fltg_rate_frst_leg_nm: Option<CompareMax350Text1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstFltgRateFrstLegDayCnt", skip_serializing_if = "Option::is_none") )]
	pub intrst_fltg_rate_frst_leg_day_cnt: Option<CompareDayCount1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstFltgRateFrstLegPmtFrqcyUnit", skip_serializing_if = "Option::is_none") )]
	pub intrst_fltg_rate_frst_leg_pmt_frqcy_unit: Option<CompareFrequencyUnit1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstFltgRateFrstLegPmtFrqcyVal", skip_serializing_if = "Option::is_none") )]
	pub intrst_fltg_rate_frst_leg_pmt_frqcy_val: Option<CompareNumber5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstFltgRateFrstLegRefPrdUnit", skip_serializing_if = "Option::is_none") )]
	pub intrst_fltg_rate_frst_leg_ref_prd_unit: Option<CompareFrequencyUnit1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstFltgRateFrstLegRefPrdVal", skip_serializing_if = "Option::is_none") )]
	pub intrst_fltg_rate_frst_leg_ref_prd_val: Option<CompareNumber5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstFltgRateFrstLegRstFrqcyUnit", skip_serializing_if = "Option::is_none") )]
	pub intrst_fltg_rate_frst_leg_rst_frqcy_unit: Option<CompareFrequencyUnit1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstFltgRateFrstLegRstFrqcyVal", skip_serializing_if = "Option::is_none") )]
	pub intrst_fltg_rate_frst_leg_rst_frqcy_val: Option<CompareNumber5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstFltgRateFrstLegSprd", skip_serializing_if = "Option::is_none") )]
	pub intrst_fltg_rate_frst_leg_sprd: Option<CompareUnitPrice8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstRateFxdScndLeg", skip_serializing_if = "Option::is_none") )]
	pub intrst_rate_fxd_scnd_leg: Option<CompareUnitPrice7>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstFxdRateScndLegDayCnt", skip_serializing_if = "Option::is_none") )]
	pub intrst_fxd_rate_scnd_leg_day_cnt: Option<CompareDayCount1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstFxdRateScndLegPmtFrqcyUnit", skip_serializing_if = "Option::is_none") )]
	pub intrst_fxd_rate_scnd_leg_pmt_frqcy_unit: Option<CompareFrequencyUnit1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstFxdRateScndLegPmtFrqcyVal", skip_serializing_if = "Option::is_none") )]
	pub intrst_fxd_rate_scnd_leg_pmt_frqcy_val: Option<CompareNumber5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstFltgRateScndLegId", skip_serializing_if = "Option::is_none") )]
	pub intrst_fltg_rate_scnd_leg_id: Option<CompareISINIdentifier4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstFltgRateScndLegCd", skip_serializing_if = "Option::is_none") )]
	pub intrst_fltg_rate_scnd_leg_cd: Option<CompareBenchmarkCode1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstFltgRateScndLegNm", skip_serializing_if = "Option::is_none") )]
	pub intrst_fltg_rate_scnd_leg_nm: Option<CompareMax350Text1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstFltgRateScndLegDayCnt", skip_serializing_if = "Option::is_none") )]
	pub intrst_fltg_rate_scnd_leg_day_cnt: Option<CompareDayCount1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstFltgRateScndLegPmtFrqcyUnit", skip_serializing_if = "Option::is_none") )]
	pub intrst_fltg_rate_scnd_leg_pmt_frqcy_unit: Option<CompareFrequencyUnit1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstFltgRateScndLegPmtFrqcyVal", skip_serializing_if = "Option::is_none") )]
	pub intrst_fltg_rate_scnd_leg_pmt_frqcy_val: Option<CompareNumber5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstFltgRateScndLegRefPrdUnit", skip_serializing_if = "Option::is_none") )]
	pub intrst_fltg_rate_scnd_leg_ref_prd_unit: Option<CompareFrequencyUnit1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstFltgRateScndLegRefPrdVal", skip_serializing_if = "Option::is_none") )]
	pub intrst_fltg_rate_scnd_leg_ref_prd_val: Option<CompareNumber5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstFltgRateScndLegRstFrqcyUnit", skip_serializing_if = "Option::is_none") )]
	pub intrst_fltg_rate_scnd_leg_rst_frqcy_unit: Option<CompareFrequencyUnit1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstFltgRateScndLegRstFrqcyVal", skip_serializing_if = "Option::is_none") )]
	pub intrst_fltg_rate_scnd_leg_rst_frqcy_val: Option<CompareNumber5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstFltgRateScndLegSprd", skip_serializing_if = "Option::is_none") )]
	pub intrst_fltg_rate_scnd_leg_sprd: Option<CompareUnitPrice8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PackgSprd", skip_serializing_if = "Option::is_none") )]
	pub packg_sprd: Option<CompareUnitPrice8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CcyXchgRate", skip_serializing_if = "Option::is_none") )]
	pub ccy_xchg_rate: Option<CompareExchangeRate1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CcyFwdXchgRate", skip_serializing_if = "Option::is_none") )]
	pub ccy_fwd_xchg_rate: Option<CompareExchangeRate1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CcyXchgRateBsis", skip_serializing_if = "Option::is_none") )]
	pub ccy_xchg_rate_bsis: Option<CompareExchangeRateBasis1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cmmdty", skip_serializing_if = "Option::is_none") )]
	pub cmmdty: Option<CompareCommodityAssetClass4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NrgyDlvryPtOrZone", skip_serializing_if = "Option::is_none") )]
	pub nrgy_dlvry_pt_or_zone: Option<Vec<CompareDeliveryInterconnectionPoint1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NrgyIntrCnnctnPt", skip_serializing_if = "Option::is_none") )]
	pub nrgy_intr_cnnctn_pt: Option<CompareDeliveryInterconnectionPoint1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NrgyLdTp", skip_serializing_if = "Option::is_none") )]
	pub nrgy_ld_tp: Option<CompareEnergyLoadType1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DlvryAttr", skip_serializing_if = "Option::is_none") )]
	pub dlvry_attr: Option<Vec<CompareEnergyDeliveryAttribute1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OptnTp", skip_serializing_if = "Option::is_none") )]
	pub optn_tp: Option<CompareOptionType1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OptnExrcStyle", skip_serializing_if = "Option::is_none") )]
	pub optn_exrc_style: Option<Vec<CompareOptionStyle1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OptnStrkPric", skip_serializing_if = "Option::is_none") )]
	pub optn_strk_pric: Option<CompareUnitPrice4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OptnStrkPricSchdlUadjstdFctvDt", skip_serializing_if = "Option::is_none") )]
	pub optn_strk_pric_schdl_uadjstd_fctv_dt: Option<Vec<CompareDate3>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OptnStrkPricSchdlUadjstdEndDt", skip_serializing_if = "Option::is_none") )]
	pub optn_strk_pric_schdl_uadjstd_end_dt: Option<Vec<CompareDate3>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OptnStrkPricSchdlAmt", skip_serializing_if = "Option::is_none") )]
	pub optn_strk_pric_schdl_amt: Option<Vec<CompareUnitPrice4>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OptnPrmAmt", skip_serializing_if = "Option::is_none") )]
	pub optn_prm_amt: Option<CompareActiveOrHistoricCurrencyAndAmount4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OptnPrmPmtDt", skip_serializing_if = "Option::is_none") )]
	pub optn_prm_pmt_dt: Option<CompareDate3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OptnMtrtyDtOfUndrlyg", skip_serializing_if = "Option::is_none") )]
	pub optn_mtrty_dt_of_undrlyg: Option<CompareDate3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtSnrty", skip_serializing_if = "Option::is_none") )]
	pub cdt_snrty: Option<CompareSeniorityType1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtRefPty", skip_serializing_if = "Option::is_none") )]
	pub cdt_ref_pty: Option<CompareReferenceParty1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtSrs", skip_serializing_if = "Option::is_none") )]
	pub cdt_srs: Option<CompareNumber7>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtVrsn", skip_serializing_if = "Option::is_none") )]
	pub cdt_vrsn: Option<CompareNumber7>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtIndxFctr", skip_serializing_if = "Option::is_none") )]
	pub cdt_indx_fctr: Option<ComparePercentageRate3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtTrch", skip_serializing_if = "Option::is_none") )]
	pub cdt_trch: Option<CompareTrancheIndicator1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Lvl", skip_serializing_if = "Option::is_none") )]
	pub lvl: Option<CompareReportingLevelType2>,
}

impl TransactionMatchingCriteria7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.rpt_trckg_nb { val.validate()? }
		if let Some(ref val) = self.unq_tx_idr { val.validate()? }
		if let Some(ref val) = self.prr_unq_tx_idr { val.validate()? }
		if let Some(ref val) = self.sbsqnt_pos_unq_tx_idr { val.validate()? }
		if let Some(ref val) = self.dlta { val.validate()? }
		if let Some(ref val) = self.trad_conf { val.validate()? }
		if let Some(ref val) = self.trad_clr_oblgtn { val.validate()? }
		if let Some(ref val) = self.trad_clr_sts { val.validate()? }
		if let Some(ref val) = self.mstr_agrmt_tp { val.validate()? }
		if let Some(ref val) = self.mstr_agrmt_vrsn { val.validate()? }
		if let Some(ref val) = self.intra_grp { val.validate()? }
		if let Some(ref val) = self.pst_trad_rsk_rdctn { val.validate()? }
		if let Some(ref val) = self.deriv_evt { val.validate()? }
		if let Some(ref val) = self.pltfm_idr { val.validate()? }
		if let Some(ref val) = self.exctn_tm_stmp { val.validate()? }
		if let Some(ref val) = self.fctv_dt { val.validate()? }
		if let Some(ref val) = self.xprtn_dt { val.validate()? }
		if let Some(ref val) = self.early_termntn_dt { val.validate()? }
		if let Some(ref vec) = self.sttlm_dt { for item in vec { item.validate()? } }
		if let Some(ref val) = self.dlvry_tp { val.validate()? }
		if let Some(ref val) = self.tx_pric { val.validate()? }
		if let Some(ref vec) = self.pric_schdl_uadjstd_fctv_dt { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.pric_schdl_uadjstd_end_dt { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.tx_schdl_pric { for item in vec { item.validate()? } }
		if let Some(ref val) = self.packg_pric { val.validate()? }
		if let Some(ref val) = self.ntnl_amt_frst_leg { val.validate()? }
		if let Some(ref vec) = self.ntnl_amt_frst_leg_uadjstd_fctv_dt { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.ntnl_amt_frst_leg_uadjstd_end_dt { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.ntnl_amt_frst_leg_schdl_amt { for item in vec { item.validate()? } }
		if let Some(ref val) = self.ntnl_qty_frst_leg { val.validate()? }
		if let Some(ref vec) = self.ntnl_qty_frst_leg_uadjstd_fctv_dt { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.ntnl_qty_frst_leg_uadjstd_end_dt { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.ntnl_qty_frst_leg_schdl_qty { for item in vec { item.validate()? } }
		if let Some(ref val) = self.ntnl_amt_scnd_leg { val.validate()? }
		if let Some(ref vec) = self.ntnl_amt_scnd_leg_uadjstd_fctv_dt { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.ntnl_amt_scnd_leg_uadjstd_end_dt { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.ntnl_amt_scnd_leg_schdl_amt { for item in vec { item.validate()? } }
		if let Some(ref val) = self.ntnl_qty_scnd_leg { val.validate()? }
		if let Some(ref vec) = self.ntnl_qty_scnd_leg_uadjstd_fctv_dt { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.ntnl_qty_scnd_leg_uadjstd_end_dt { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.ntnl_qty_scnd_leg_schdl_qty { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.othr_pmt { for item in vec { item.validate()? } }
		if let Some(ref val) = self.intrst_fxd_rate_frst_leg { val.validate()? }
		if let Some(ref val) = self.intrst_fxd_rate_frst_leg_day_cnt { val.validate()? }
		if let Some(ref val) = self.intrst_fxd_rate_frst_leg_pmt_frqcy_unit { val.validate()? }
		if let Some(ref val) = self.intrst_fxd_rate_frst_leg_pmt_frqcy_val { val.validate()? }
		if let Some(ref val) = self.intrst_fltg_rate_frst_leg_id { val.validate()? }
		if let Some(ref val) = self.intrst_fltg_rate_frst_leg_cd { val.validate()? }
		if let Some(ref val) = self.intrst_fltg_rate_frst_leg_nm { val.validate()? }
		if let Some(ref val) = self.intrst_fltg_rate_frst_leg_day_cnt { val.validate()? }
		if let Some(ref val) = self.intrst_fltg_rate_frst_leg_pmt_frqcy_unit { val.validate()? }
		if let Some(ref val) = self.intrst_fltg_rate_frst_leg_pmt_frqcy_val { val.validate()? }
		if let Some(ref val) = self.intrst_fltg_rate_frst_leg_ref_prd_unit { val.validate()? }
		if let Some(ref val) = self.intrst_fltg_rate_frst_leg_ref_prd_val { val.validate()? }
		if let Some(ref val) = self.intrst_fltg_rate_frst_leg_rst_frqcy_unit { val.validate()? }
		if let Some(ref val) = self.intrst_fltg_rate_frst_leg_rst_frqcy_val { val.validate()? }
		if let Some(ref val) = self.intrst_fltg_rate_frst_leg_sprd { val.validate()? }
		if let Some(ref val) = self.intrst_rate_fxd_scnd_leg { val.validate()? }
		if let Some(ref val) = self.intrst_fxd_rate_scnd_leg_day_cnt { val.validate()? }
		if let Some(ref val) = self.intrst_fxd_rate_scnd_leg_pmt_frqcy_unit { val.validate()? }
		if let Some(ref val) = self.intrst_fxd_rate_scnd_leg_pmt_frqcy_val { val.validate()? }
		if let Some(ref val) = self.intrst_fltg_rate_scnd_leg_id { val.validate()? }
		if let Some(ref val) = self.intrst_fltg_rate_scnd_leg_cd { val.validate()? }
		if let Some(ref val) = self.intrst_fltg_rate_scnd_leg_nm { val.validate()? }
		if let Some(ref val) = self.intrst_fltg_rate_scnd_leg_day_cnt { val.validate()? }
		if let Some(ref val) = self.intrst_fltg_rate_scnd_leg_pmt_frqcy_unit { val.validate()? }
		if let Some(ref val) = self.intrst_fltg_rate_scnd_leg_pmt_frqcy_val { val.validate()? }
		if let Some(ref val) = self.intrst_fltg_rate_scnd_leg_ref_prd_unit { val.validate()? }
		if let Some(ref val) = self.intrst_fltg_rate_scnd_leg_ref_prd_val { val.validate()? }
		if let Some(ref val) = self.intrst_fltg_rate_scnd_leg_rst_frqcy_unit { val.validate()? }
		if let Some(ref val) = self.intrst_fltg_rate_scnd_leg_rst_frqcy_val { val.validate()? }
		if let Some(ref val) = self.intrst_fltg_rate_scnd_leg_sprd { val.validate()? }
		if let Some(ref val) = self.packg_sprd { val.validate()? }
		if let Some(ref val) = self.ccy_xchg_rate { val.validate()? }
		if let Some(ref val) = self.ccy_fwd_xchg_rate { val.validate()? }
		if let Some(ref val) = self.ccy_xchg_rate_bsis { val.validate()? }
		if let Some(ref val) = self.cmmdty { val.validate()? }
		if let Some(ref vec) = self.nrgy_dlvry_pt_or_zone { for item in vec { item.validate()? } }
		if let Some(ref val) = self.nrgy_intr_cnnctn_pt { val.validate()? }
		if let Some(ref val) = self.nrgy_ld_tp { val.validate()? }
		if let Some(ref vec) = self.dlvry_attr { for item in vec { item.validate()? } }
		if let Some(ref val) = self.optn_tp { val.validate()? }
		if let Some(ref vec) = self.optn_exrc_style { for item in vec { item.validate()? } }
		if let Some(ref val) = self.optn_strk_pric { val.validate()? }
		if let Some(ref vec) = self.optn_strk_pric_schdl_uadjstd_fctv_dt { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.optn_strk_pric_schdl_uadjstd_end_dt { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.optn_strk_pric_schdl_amt { for item in vec { item.validate()? } }
		if let Some(ref val) = self.optn_prm_amt { val.validate()? }
		if let Some(ref val) = self.optn_prm_pmt_dt { val.validate()? }
		if let Some(ref val) = self.optn_mtrty_dt_of_undrlyg { val.validate()? }
		if let Some(ref val) = self.cdt_snrty { val.validate()? }
		if let Some(ref val) = self.cdt_ref_pty { val.validate()? }
		if let Some(ref val) = self.cdt_srs { val.validate()? }
		if let Some(ref val) = self.cdt_vrsn { val.validate()? }
		if let Some(ref val) = self.cdt_indx_fctr { val.validate()? }
		if let Some(ref val) = self.cdt_trch { val.validate()? }
		if let Some(ref val) = self.lvl { val.validate()? }
		Ok(())
	}
}


// TransactionOperationType10Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum TransactionOperationType10Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "COMP") )]
	CodeCOMP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CORR") )]
	CodeCORR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EROR") )]
	CodeEROR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MODI") )]
	CodeMODI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NEWT") )]
	CodeNEWT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "POSC") )]
	CodePOSC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "REVI") )]
	CodeREVI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TERM") )]
	CodeTERM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VALU") )]
	CodeVALU,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MARU") )]
	CodeMARU,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PRTO") )]
	CodePRTO,
}

impl TransactionOperationType10Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// TransactionOperationType11Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum TransactionOperationType11Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "CORR") )]
	CodeCORR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MARU") )]
	CodeMARU,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NEWT") )]
	CodeNEWT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EROR") )]
	CodeEROR,
}

impl TransactionOperationType11Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// TransactionOperationType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum TransactionOperationType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "AMND") )]
	CodeAMND,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CANC") )]
	CodeCANC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CORR") )]
	CodeCORR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NEWT") )]
	CodeNEWT,
}

impl TransactionOperationType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// TransactionOperationType4Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum TransactionOperationType4Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "NEWT") )]
	CodeNEWT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AMND") )]
	CodeAMND,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CANC") )]
	CodeCANC,
}

impl TransactionOperationType4Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// TransactionOperationType6Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum TransactionOperationType6Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "REUU") )]
	CodeREUU,
	#[cfg_attr( feature = "derive_serde", serde(rename = "COLU") )]
	CodeCOLU,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CORR") )]
	CodeCORR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ETRM") )]
	CodeETRM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VALU") )]
	CodeVALU,
	#[cfg_attr( feature = "derive_serde", serde(rename = "POSC") )]
	CodePOSC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NEWT") )]
	CodeNEWT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MODI") )]
	CodeMODI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MARU") )]
	CodeMARU,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EROR") )]
	CodeEROR,
}

impl TransactionOperationType6Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// TransactionOperationType8Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum TransactionOperationType8Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "COMP") )]
	CodeCOMP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CORR") )]
	CodeCORR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EROR") )]
	CodeEROR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MODI") )]
	CodeMODI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NEWT") )]
	CodeNEWT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "POSC") )]
	CodePOSC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "REVI") )]
	CodeREVI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TERM") )]
	CodeTERM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VALU") )]
	CodeVALU,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MARU") )]
	CodeMARU,
}

impl TransactionOperationType8Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// TransactionRequestType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum TransactionRequestType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "DTTX") )]
	CodeDTTX,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OREC") )]
	CodeOREC,
}

impl TransactionRequestType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// TransactionsBin2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TransactionsBin2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfTxs") )]
	pub nb_of_txs: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlNtnlAmt") )]
	pub ttl_ntnl_amt: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rg") )]
	pub rg: FromToQuantityRange2,
}

impl TransactionsBin2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.rg.validate()?;
		Ok(())
	}
}


// TransparencyDataReport11 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TransparencyDataReport11 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechRcrdId", skip_serializing_if = "Option::is_none") )]
	pub tech_rcrd_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FullNm", skip_serializing_if = "Option::is_none") )]
	pub full_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradgVn", skip_serializing_if = "Option::is_none") )]
	pub tradg_vn: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgDt", skip_serializing_if = "Option::is_none") )]
	pub rptg_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FinInstrmClssfctn") )]
	pub fin_instrm_clssfctn: EquityInstrumentReportingClassification1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOutsdngInstrms", skip_serializing_if = "Option::is_none") )]
	pub nb_outsdng_instrms: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "HldgsExcdgTtlVtngRghtThrshld", skip_serializing_if = "Option::is_none") )]
	pub hldgs_excdg_ttl_vtng_rght_thrshld: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IssncSz", skip_serializing_if = "Option::is_none") )]
	pub issnc_sz: Option<ActiveCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstrmPric", skip_serializing_if = "Option::is_none") )]
	pub instrm_pric: Option<ActiveCurrencyAnd13DecimalAmount>,
}

impl TransparencyDataReport11 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tech_rcrd_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tech_rcrd_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "tech_rcrd_id exceeds the maximum length of 35".to_string()));
			}
		}
		let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
		if !pattern.is_match(&self.id) {
			return Err(ValidationError::new(1005, "id does not match the required pattern".to_string()));
		}
		if let Some(ref val) = self.full_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "full_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 350 {
				return Err(ValidationError::new(1002, "full_nm exceeds the maximum length of 350".to_string()));
			}
		}
		if let Some(ref val) = self.tradg_vn {
			let pattern = Regex::new("[A-Z0-9]{4,4}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "tradg_vn does not match the required pattern".to_string()));
			}
		}
		self.fin_instrm_clssfctn.validate()?;
		if let Some(ref val) = self.issnc_sz { val.validate()? }
		if let Some(ref val) = self.instrm_pric { val.validate()? }
		Ok(())
	}
}


// TransparencyDataReport13 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TransparencyDataReport13 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechRcrdId", skip_serializing_if = "Option::is_none") )]
	pub tech_rcrd_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgDt", skip_serializing_if = "Option::is_none") )]
	pub rptg_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradgVn", skip_serializing_if = "Option::is_none") )]
	pub tradg_vn: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sspnsn") )]
	pub sspnsn: bool,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxsExctd") )]
	pub txs_exctd: NumberAndVolume2,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxsExctdExclgPreTradWvr") )]
	pub txs_exctd_exclg_pre_trad_wvr: NumberAndVolume2,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxsExctdExclgPstTradLrgInScaleWvr") )]
	pub txs_exctd_exclg_pst_trad_lrg_in_scale_wvr: NumberAndVolume2,
}

impl TransparencyDataReport13 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tech_rcrd_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tech_rcrd_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "tech_rcrd_id exceeds the maximum length of 35".to_string()));
			}
		}
		let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
		if !pattern.is_match(&self.id) {
			return Err(ValidationError::new(1005, "id does not match the required pattern".to_string()));
		}
		if let Some(ref val) = self.tradg_vn {
			let pattern = Regex::new("[A-Z0-9]{4,4}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "tradg_vn does not match the required pattern".to_string()));
			}
		}
		self.txs_exctd.validate()?;
		self.txs_exctd_exclg_pre_trad_wvr.validate()?;
		self.txs_exctd_exclg_pst_trad_lrg_in_scale_wvr.validate()?;
		Ok(())
	}
}


// TransparencyDataReport15 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TransparencyDataReport15 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechRcrdId", skip_serializing_if = "Option::is_none") )]
	pub tech_rcrd_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgDt", skip_serializing_if = "Option::is_none") )]
	pub rptg_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradgVn", skip_serializing_if = "Option::is_none") )]
	pub tradg_vn: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sspnsn") )]
	pub sspnsn: bool,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbTxs", skip_serializing_if = "Option::is_none") )]
	pub nb_txs: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AggtdQttvData", skip_serializing_if = "Option::is_none") )]
	pub aggtd_qttv_data: Option<Vec<TransactionsBin2>>,
}

impl TransparencyDataReport15 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tech_rcrd_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tech_rcrd_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "tech_rcrd_id exceeds the maximum length of 35".to_string()));
			}
		}
		let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
		if !pattern.is_match(&self.id) {
			return Err(ValidationError::new(1005, "id does not match the required pattern".to_string()));
		}
		if let Some(ref val) = self.tradg_vn {
			let pattern = Regex::new("[A-Z0-9]{4,4}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "tradg_vn does not match the required pattern".to_string()));
			}
		}
		if let Some(ref vec) = self.aggtd_qttv_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TransparencyDataReport17 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TransparencyDataReport17 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechRcrdId", skip_serializing_if = "Option::is_none") )]
	pub tech_rcrd_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FinInstrmClssfctn", skip_serializing_if = "Option::is_none") )]
	pub fin_instrm_clssfctn: Option<EquityInstrumentReportingClassification1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FullNm", skip_serializing_if = "Option::is_none") )]
	pub full_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradgVn", skip_serializing_if = "Option::is_none") )]
	pub tradg_vn: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgPrd", skip_serializing_if = "Option::is_none") )]
	pub rptg_prd: Option<Period4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Lqdty", skip_serializing_if = "Option::is_none") )]
	pub lqdty: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Mthdlgy", skip_serializing_if = "Option::is_none") )]
	pub mthdlgy: Option<TransparencyMethodology2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sttstcs", skip_serializing_if = "Option::is_none") )]
	pub sttstcs: Option<StatisticsTransparency3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RlvntMkt", skip_serializing_if = "Option::is_none") )]
	pub rlvnt_mkt: Option<MarketDetail2>,
}

impl TransparencyDataReport17 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tech_rcrd_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tech_rcrd_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "tech_rcrd_id exceeds the maximum length of 35".to_string()));
			}
		}
		let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
		if !pattern.is_match(&self.id) {
			return Err(ValidationError::new(1005, "id does not match the required pattern".to_string()));
		}
		if let Some(ref val) = self.fin_instrm_clssfctn { val.validate()? }
		if let Some(ref val) = self.full_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "full_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 350 {
				return Err(ValidationError::new(1002, "full_nm exceeds the maximum length of 350".to_string()));
			}
		}
		if let Some(ref val) = self.tradg_vn {
			let pattern = Regex::new("[A-Z0-9]{4,4}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "tradg_vn does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.rptg_prd { val.validate()? }
		if let Some(ref val) = self.mthdlgy { val.validate()? }
		if let Some(ref val) = self.sttstcs { val.validate()? }
		if let Some(ref val) = self.rlvnt_mkt { val.validate()? }
		Ok(())
	}
}


// TransparencyDataReport20 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TransparencyDataReport20 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechRcrdId", skip_serializing_if = "Option::is_none") )]
	pub tech_rcrd_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: InstrumentOrSubClassIdentification2Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FullNm", skip_serializing_if = "Option::is_none") )]
	pub full_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradgVn", skip_serializing_if = "Option::is_none") )]
	pub tradg_vn: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgPrd", skip_serializing_if = "Option::is_none") )]
	pub rptg_prd: Option<Period4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Lqdty", skip_serializing_if = "Option::is_none") )]
	pub lqdty: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PreTradLrgInScaleThrshld", skip_serializing_if = "Option::is_none") )]
	pub pre_trad_lrg_in_scale_thrshld: Option<TonsOrCurrency2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstTradLrgInScaleThrshld", skip_serializing_if = "Option::is_none") )]
	pub pst_trad_lrg_in_scale_thrshld: Option<TonsOrCurrency2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PreTradInstrmSzSpcfcThrshld", skip_serializing_if = "Option::is_none") )]
	pub pre_trad_instrm_sz_spcfc_thrshld: Option<TonsOrCurrency2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstTradInstrmSzSpcfcThrshld", skip_serializing_if = "Option::is_none") )]
	pub pst_trad_instrm_sz_spcfc_thrshld: Option<TonsOrCurrency2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sttstcs", skip_serializing_if = "Option::is_none") )]
	pub sttstcs: Option<StatisticsTransparency2>,
}

impl TransparencyDataReport20 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tech_rcrd_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tech_rcrd_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "tech_rcrd_id exceeds the maximum length of 35".to_string()));
			}
		}
		self.id.validate()?;
		if let Some(ref val) = self.full_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "full_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 350 {
				return Err(ValidationError::new(1002, "full_nm exceeds the maximum length of 350".to_string()));
			}
		}
		if let Some(ref val) = self.tradg_vn {
			let pattern = Regex::new("[A-Z0-9]{4,4}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "tradg_vn does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.rptg_prd { val.validate()? }
		if let Some(ref val) = self.pre_trad_lrg_in_scale_thrshld { val.validate()? }
		if let Some(ref val) = self.pst_trad_lrg_in_scale_thrshld { val.validate()? }
		if let Some(ref val) = self.pre_trad_instrm_sz_spcfc_thrshld { val.validate()? }
		if let Some(ref val) = self.pst_trad_instrm_sz_spcfc_thrshld { val.validate()? }
		if let Some(ref val) = self.sttstcs { val.validate()? }
		Ok(())
	}
}


// TransparencyDataReport21 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TransparencyDataReport21 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechRcrdId", skip_serializing_if = "Option::is_none") )]
	pub tech_rcrd_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FullNm", skip_serializing_if = "Option::is_none") )]
	pub full_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradgVn", skip_serializing_if = "Option::is_none") )]
	pub tradg_vn: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgDt", skip_serializing_if = "Option::is_none") )]
	pub rptg_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MtrtyDt", skip_serializing_if = "Option::is_none") )]
	pub mtrty_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FinInstrmClssfctn") )]
	pub fin_instrm_clssfctn: NonEquityInstrumentReportingClassification1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UndrlygInstrmAsstClss", skip_serializing_if = "Option::is_none") )]
	pub undrlyg_instrm_asst_clss: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DerivCtrctTp", skip_serializing_if = "Option::is_none") )]
	pub deriv_ctrct_tp: Option<FinancialInstrumentContractType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Bd", skip_serializing_if = "Option::is_none") )]
	pub bd: Option<DebtInstrument5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EmssnAllwncTp", skip_serializing_if = "Option::is_none") )]
	pub emssn_allwnc_tp: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Deriv", skip_serializing_if = "Option::is_none") )]
	pub deriv: Option<Derivative3Choice>,
}

impl TransparencyDataReport21 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tech_rcrd_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tech_rcrd_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "tech_rcrd_id exceeds the maximum length of 35".to_string()));
			}
		}
		let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
		if !pattern.is_match(&self.id) {
			return Err(ValidationError::new(1005, "id does not match the required pattern".to_string()));
		}
		if let Some(ref val) = self.full_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "full_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 350 {
				return Err(ValidationError::new(1002, "full_nm exceeds the maximum length of 350".to_string()));
			}
		}
		if let Some(ref val) = self.tradg_vn {
			let pattern = Regex::new("[A-Z0-9]{4,4}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "tradg_vn does not match the required pattern".to_string()));
			}
		}
		self.fin_instrm_clssfctn.validate()?;
		if let Some(ref val) = self.undrlyg_instrm_asst_clss {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "undrlyg_instrm_asst_clss is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "undrlyg_instrm_asst_clss exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.deriv_ctrct_tp { val.validate()? }
		if let Some(ref val) = self.bd { val.validate()? }
		if let Some(ref val) = self.emssn_allwnc_tp {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "emssn_allwnc_tp is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "emssn_allwnc_tp exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.deriv { val.validate()? }
		Ok(())
	}
}


// TransparencyMethodology2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum TransparencyMethodology2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "YEAR") )]
	CodeYEAR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SINT") )]
	CodeSINT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FFWK") )]
	CodeFFWK,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ESTM") )]
	CodeESTM,
}

impl TransparencyMethodology2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// TripartyCollateralAndAmount1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct TripartyCollateralAndAmount1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Trpty") )]
	pub trpty: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CollTp") )]
	pub coll_tp: CollateralType22Choice,
}

impl TripartyCollateralAndAmount1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.trpty.validate()?;
		self.coll_tp.validate()?;
		Ok(())
	}
}


// UPIQueryCriteria1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct UPIQueryCriteria1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Idr", skip_serializing_if = "Option::is_none") )]
	pub idr: Option<Vec<String>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NotRptd", skip_serializing_if = "Option::is_none") )]
	pub not_rptd: Option<NotReported1Code>,
}

impl UPIQueryCriteria1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.idr {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "idr is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 52 {
					return Err(ValidationError::new(1002, "idr exceeds the maximum length of 52".to_string()));
				}
			}
		}
		if let Some(ref val) = self.not_rptd { val.validate()? }
		Ok(())
	}
}


// UnderlyingContract4Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct UnderlyingContract4Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ln", skip_serializing_if = "Option::is_none") )]
	pub ln: Option<LoanContract4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Trad", skip_serializing_if = "Option::is_none") )]
	pub trad: Option<TradeContract4>,
}

impl UnderlyingContract4Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ln { val.validate()? }
		if let Some(ref val) = self.trad { val.validate()? }
		Ok(())
	}
}


// UnderlyingContractForDifferenceType3Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum UnderlyingContractForDifferenceType3Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "BOND") )]
	CodeBOND,
	#[cfg_attr( feature = "derive_serde", serde(rename = "COMM") )]
	CodeCOMM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CURR") )]
	CodeCURR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EMAL") )]
	CodeEMAL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EQUI") )]
	CodeEQUI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FTEQ") )]
	CodeFTEQ,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OPEQ") )]
	CodeOPEQ,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
}

impl UnderlyingContractForDifferenceType3Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// UnderlyingEquityType3Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum UnderlyingEquityType3Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "BSKT") )]
	CodeBSKT,
}

impl UnderlyingEquityType3Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// UnderlyingEquityType4Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum UnderlyingEquityType4Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "STIX") )]
	CodeSTIX,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DIVI") )]
	CodeDIVI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VOLI") )]
	CodeVOLI,
}

impl UnderlyingEquityType4Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// UnderlyingEquityType5Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum UnderlyingEquityType5Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ETFS") )]
	CodeETFS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SHRS") )]
	CodeSHRS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DVSE") )]
	CodeDVSE,
}

impl UnderlyingEquityType5Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// UnderlyingEquityType6Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum UnderlyingEquityType6Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "BSKT") )]
	CodeBSKT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DIVI") )]
	CodeDIVI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ETFS") )]
	CodeETFS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SHRS") )]
	CodeSHRS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DVSE") )]
	CodeDVSE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "STIX") )]
	CodeSTIX,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VOLI") )]
	CodeVOLI,
}

impl UnderlyingEquityType6Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// UnderlyingIdentification1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum UnderlyingIdentification1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "UKWN") )]
	CodeUKWN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BSKT") )]
	CodeBSKT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INDX") )]
	CodeINDX,
}

impl UnderlyingIdentification1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// UnderlyingIdentification2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct UnderlyingIdentification2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Swp", skip_serializing_if = "Option::is_none") )]
	pub swp: Option<SwapLegIdentification2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<FinancialInstrumentIdentification7Choice>,
}

impl UnderlyingIdentification2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.swp { val.validate()? }
		if let Some(ref val) = self.othr { val.validate()? }
		Ok(())
	}
}


// UnderlyingInterestRateType3Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum UnderlyingInterestRateType3Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "BOND") )]
	CodeBOND,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BNDF") )]
	CodeBNDF,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INTR") )]
	CodeINTR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IFUT") )]
	CodeIFUT,
}

impl UnderlyingInterestRateType3Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// UniqueProductIdentifier1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct UniqueProductIdentifier1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification175>,
}

impl UniqueProductIdentifier1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 52 {
				return Err(ValidationError::new(1002, "id exceeds the maximum length of 52".to_string()));
			}
		}
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// UniqueProductIdentifier2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct UniqueProductIdentifier2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification185>,
}

impl UniqueProductIdentifier2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 52 {
				return Err(ValidationError::new(1002, "id exceeds the maximum length of 52".to_string()));
			}
		}
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// UniqueTransactionIdentifier1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct UniqueTransactionIdentifier1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnqTxIdr", skip_serializing_if = "Option::is_none") )]
	pub unq_tx_idr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification179>,
}

impl UniqueTransactionIdentifier1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.unq_tx_idr {
			let pattern = Regex::new("[A-Z0-9]{18}[0-9]{2}[A-Z0-9]{0,32}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "unq_tx_idr does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// UniqueTransactionIdentifier2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct UniqueTransactionIdentifier2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnqTxIdr", skip_serializing_if = "Option::is_none") )]
	pub unq_tx_idr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification175>,
}

impl UniqueTransactionIdentifier2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.unq_tx_idr {
			let pattern = Regex::new("[A-Z0-9]{18}[0-9]{2}[A-Z0-9]{0,32}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "unq_tx_idr does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// UniqueTransactionIdentifier3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct UniqueTransactionIdentifier3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnqTxIdr", skip_serializing_if = "Option::is_none") )]
	pub unq_tx_idr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification175>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NotAvlbl", skip_serializing_if = "Option::is_none") )]
	pub not_avlbl: Option<NoReasonCode>,
}

impl UniqueTransactionIdentifier3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.unq_tx_idr {
			let pattern = Regex::new("[A-Z0-9]{18}[0-9]{2}[A-Z0-9]{0,32}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "unq_tx_idr does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.prtry { val.validate()? }
		if let Some(ref val) = self.not_avlbl { val.validate()? }
		Ok(())
	}
}


// UnitOfMeasure11Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum UnitOfMeasure11Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ALOW") )]
	CodeALOW,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ACCY") )]
	CodeACCY,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BARL") )]
	CodeBARL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BCUF") )]
	CodeBCUF,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BDFT") )]
	CodeBDFT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BUSL") )]
	CodeBUSL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CEER") )]
	CodeCEER,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CLRT") )]
	CodeCLRT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "KILO") )]
	CodeKILO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PIEC") )]
	CodePIEC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TONS") )]
	CodeTONS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "METR") )]
	CodeMETR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INCH") )]
	CodeINCH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "YARD") )]
	CodeYARD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GBGA") )]
	CodeGBGA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GRAM") )]
	CodeGRAM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CMET") )]
	CodeCMET,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SMET") )]
	CodeSMET,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FOOT") )]
	CodeFOOT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MILE") )]
	CodeMILE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SQIN") )]
	CodeSQIN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SQFO") )]
	CodeSQFO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SQMI") )]
	CodeSQMI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GBOU") )]
	CodeGBOU,
	#[cfg_attr( feature = "derive_serde", serde(rename = "USOU") )]
	CodeUSOU,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GBPI") )]
	CodeGBPI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "USPI") )]
	CodeUSPI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GBQA") )]
	CodeGBQA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "USGA") )]
	CodeUSGA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MMET") )]
	CodeMMET,
	#[cfg_attr( feature = "derive_serde", serde(rename = "KMET") )]
	CodeKMET,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SQYA") )]
	CodeSQYA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ACRE") )]
	CodeACRE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ARES") )]
	CodeARES,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SMIL") )]
	CodeSMIL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SCMT") )]
	CodeSCMT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "HECT") )]
	CodeHECT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SQKI") )]
	CodeSQKI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MILI") )]
	CodeMILI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CELI") )]
	CodeCELI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LITR") )]
	CodeLITR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PUND") )]
	CodePUND,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CBME") )]
	CodeCBME,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DAYS") )]
	CodeDAYS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DMET") )]
	CodeDMET,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ENVC") )]
	CodeENVC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ENVO") )]
	CodeENVO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "HUWG") )]
	CodeHUWG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "KWDC") )]
	CodeKWDC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "KWHO") )]
	CodeKWHO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "KWHC") )]
	CodeKWHC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "KMOC") )]
	CodeKMOC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "KWMC") )]
	CodeKWMC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "KWYC") )]
	CodeKWYC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MWDC") )]
	CodeMWDC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MWHO") )]
	CodeMWHO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MWHC") )]
	CodeMWHC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MWMC") )]
	CodeMWMC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MMOC") )]
	CodeMMOC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MWYC") )]
	CodeMWYC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TONE") )]
	CodeTONE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MIBA") )]
	CodeMIBA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MBTU") )]
	CodeMBTU,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OZTR") )]
	CodeOZTR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UCWT") )]
	CodeUCWT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IPNT") )]
	CodeIPNT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PWRD") )]
	CodePWRD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DGEU") )]
	CodeDGEU,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TOCD") )]
	CodeTOCD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GGEU") )]
	CodeGGEU,
	#[cfg_attr( feature = "derive_serde", serde(rename = "USQA") )]
	CodeUSQA,
}

impl UnitOfMeasure11Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// UnitOfMeasure5Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct UnitOfMeasure5Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<UnitOfMeasure8Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification36>,
}

impl UnitOfMeasure5Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// UnitOfMeasure8Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct UnitOfMeasure8Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification175>,
}

impl UnitOfMeasure8Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// UnitOfMeasure8Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum UnitOfMeasure8Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "KILO") )]
	CodeKILO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "KMET") )]
	CodeKMET,
	#[cfg_attr( feature = "derive_serde", serde(rename = "KWDC") )]
	CodeKWDC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "KWHO") )]
	CodeKWHO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "KWHC") )]
	CodeKWHC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "KMOC") )]
	CodeKMOC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "KWMC") )]
	CodeKWMC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "KWYC") )]
	CodeKWYC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LITR") )]
	CodeLITR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MWDC") )]
	CodeMWDC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MWHO") )]
	CodeMWHO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MWHC") )]
	CodeMWHC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MWMC") )]
	CodeMWMC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MMOC") )]
	CodeMMOC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MWYC") )]
	CodeMWYC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "METR") )]
	CodeMETR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TONE") )]
	CodeTONE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MILE") )]
	CodeMILE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MILI") )]
	CodeMILI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MMET") )]
	CodeMMET,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MIBA") )]
	CodeMIBA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MBTU") )]
	CodeMBTU,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PIEC") )]
	CodePIEC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PUND") )]
	CodePUND,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PWRD") )]
	CodePWRD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SHAS") )]
	CodeSHAS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SCMT") )]
	CodeSCMT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SQFO") )]
	CodeSQFO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SQIN") )]
	CodeSQIN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SQKI") )]
	CodeSQKI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SMET") )]
	CodeSMET,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SQMI") )]
	CodeSQMI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SMIL") )]
	CodeSMIL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SQYA") )]
	CodeSQYA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "THMS") )]
	CodeTHMS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TONS") )]
	CodeTONS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TOCD") )]
	CodeTOCD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OZTR") )]
	CodeOZTR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "USGA") )]
	CodeUSGA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UCWT") )]
	CodeUCWT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "USOU") )]
	CodeUSOU,
	#[cfg_attr( feature = "derive_serde", serde(rename = "USPI") )]
	CodeUSPI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "USQA") )]
	CodeUSQA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "YARD") )]
	CodeYARD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ACRE") )]
	CodeACRE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ALOW") )]
	CodeALOW,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ACCY") )]
	CodeACCY,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ARES") )]
	CodeARES,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BARL") )]
	CodeBARL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BCUF") )]
	CodeBCUF,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BDFT") )]
	CodeBDFT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BUSL") )]
	CodeBUSL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CELI") )]
	CodeCELI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CMET") )]
	CodeCMET,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CEER") )]
	CodeCEER,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CLRT") )]
	CodeCLRT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CBME") )]
	CodeCBME,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DAYS") )]
	CodeDAYS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DGEU") )]
	CodeDGEU,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DMET") )]
	CodeDMET,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ENVC") )]
	CodeENVC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ENVO") )]
	CodeENVO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FOOT") )]
	CodeFOOT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GGEU") )]
	CodeGGEU,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GBGA") )]
	CodeGBGA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GBOU") )]
	CodeGBOU,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GBPI") )]
	CodeGBPI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GBQA") )]
	CodeGBQA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GRAM") )]
	CodeGRAM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "HECT") )]
	CodeHECT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "HUWG") )]
	CodeHUWG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INCH") )]
	CodeINCH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IPNT") )]
	CodeIPNT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FUTU") )]
	CodeFUTU,
	#[cfg_attr( feature = "derive_serde", serde(rename = "USTN") )]
	CodeUSTN,
}

impl UnitOfMeasure8Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// UnsecuredMarketReport4Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct UnsecuredMarketReport4Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DataSetActn", skip_serializing_if = "Option::is_none") )]
	pub data_set_actn: Option<ReportPeriodActivity3Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tx", skip_serializing_if = "Option::is_none") )]
	pub tx: Option<Vec<UnsecuredMarketTransaction4>>,
}

impl UnsecuredMarketReport4Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.data_set_actn { val.validate()? }
		if let Some(ref vec) = self.tx { for item in vec { item.validate()? } }
		Ok(())
	}
}


// UnsecuredMarketTransaction4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct UnsecuredMarketTransaction4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptdTxSts") )]
	pub rptd_tx_sts: TransactionOperationType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NvtnSts", skip_serializing_if = "Option::is_none") )]
	pub nvtn_sts: Option<NovationStatus1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BrnchId", skip_serializing_if = "Option::is_none") )]
	pub brnch_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnqTxIdr", skip_serializing_if = "Option::is_none") )]
	pub unq_tx_idr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrtryTxId") )]
	pub prtry_tx_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RltdPrtryTxId", skip_serializing_if = "Option::is_none") )]
	pub rltd_prtry_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPtyPrtryTxId", skip_serializing_if = "Option::is_none") )]
	pub ctr_pty_prtry_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPtyId") )]
	pub ctr_pty_id: CounterpartyIdentification3Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradDt") )]
	pub trad_dt: DateAndDateTimeChoice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttlmDt") )]
	pub sttlm_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MtrtyDt") )]
	pub mtrty_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxTp") )]
	pub tx_tp: MoneyMarketTransactionType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstrmTp") )]
	pub instrm_tp: FinancialInstrumentProductType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxNmnlAmt") )]
	pub tx_nmnl_amt: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DealPric") )]
	pub deal_pric: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RateTp") )]
	pub rate_tp: InterestRateType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DealRate", skip_serializing_if = "Option::is_none") )]
	pub deal_rate: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FltgRateNote", skip_serializing_if = "Option::is_none") )]
	pub fltg_rate_note: Option<FloatingRateNote2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BrkrdDeal", skip_serializing_if = "Option::is_none") )]
	pub brkrd_deal: Option<BrokeredDeal1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CallPutOptn", skip_serializing_if = "Option::is_none") )]
	pub call_put_optn: Option<Vec<Option12>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl UnsecuredMarketTransaction4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.rptd_tx_sts.validate()?;
		if let Some(ref val) = self.nvtn_sts { val.validate()? }
		if let Some(ref val) = self.brnch_id {
			let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "brnch_id does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.unq_tx_idr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "unq_tx_idr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 105 {
				return Err(ValidationError::new(1002, "unq_tx_idr exceeds the maximum length of 105".to_string()));
			}
		}
		if self.prtry_tx_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "prtry_tx_id is shorter than the minimum length of 1".to_string()));
		}
		if self.prtry_tx_id.chars().count() > 105 {
			return Err(ValidationError::new(1002, "prtry_tx_id exceeds the maximum length of 105".to_string()));
		}
		if let Some(ref val) = self.rltd_prtry_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "rltd_prtry_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 105 {
				return Err(ValidationError::new(1002, "rltd_prtry_tx_id exceeds the maximum length of 105".to_string()));
			}
		}
		if let Some(ref val) = self.ctr_pty_prtry_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "ctr_pty_prtry_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 105 {
				return Err(ValidationError::new(1002, "ctr_pty_prtry_tx_id exceeds the maximum length of 105".to_string()));
			}
		}
		self.ctr_pty_id.validate()?;
		self.trad_dt.validate()?;
		self.tx_tp.validate()?;
		self.instrm_tp.validate()?;
		self.tx_nmnl_amt.validate()?;
		self.rate_tp.validate()?;
		if let Some(ref val) = self.fltg_rate_note { val.validate()? }
		if let Some(ref val) = self.brkrd_deal { val.validate()? }
		if let Some(ref vec) = self.call_put_optn { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// ValidationRuleSchemeName1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ValidationRuleSchemeName1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl ValidationRuleSchemeName1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// ValidationStatusReason3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ValidationStatusReason3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Orgtr", skip_serializing_if = "Option::is_none") )]
	pub orgtr: Option<PartyIdentification272>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn", skip_serializing_if = "Option::is_none") )]
	pub rsn: Option<StatusReason6Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VldtnRule", skip_serializing_if = "Option::is_none") )]
	pub vldtn_rule: Option<Vec<GenericValidationRuleIdentification1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_inf: Option<Vec<String>>,
}

impl ValidationStatusReason3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.orgtr { val.validate()? }
		if let Some(ref val) = self.rsn { val.validate()? }
		if let Some(ref vec) = self.vldtn_rule { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.addtl_inf {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "addtl_inf is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 105 {
					return Err(ValidationError::new(1002, "addtl_inf exceeds the maximum length of 105".to_string()));
				}
			}
		}
		Ok(())
	}
}


// ValidityPeriod1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ValidityPeriod1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "VldtyPrdCd", skip_serializing_if = "Option::is_none") )]
	pub vldty_prd_cd: Option<ValidityPeriodType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification30>,
}

impl ValidityPeriod1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.vldty_prd_cd { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// ValidityPeriodType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum ValidityPeriodType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "FOKV") )]
	CodeFOKV,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GADV") )]
	CodeGADV,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GASV") )]
	CodeGASV,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GATV") )]
	CodeGATV,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DAVY") )]
	CodeDAVY,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GTCV") )]
	CodeGTCV,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GTDV") )]
	CodeGTDV,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GTSV") )]
	CodeGTSV,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GTTV") )]
	CodeGTTV,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IOCV") )]
	CodeIOCV,
}

impl ValidityPeriodType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ValuationMatchingCriteria1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct ValuationMatchingCriteria1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrctVal", skip_serializing_if = "Option::is_none") )]
	pub ctrct_val: Option<CompareAmountAndDirection3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<CompareValuationType1>,
}

impl ValuationMatchingCriteria1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ctrct_val { val.validate()? }
		if let Some(ref val) = self.tp { val.validate()? }
		Ok(())
	}
}


// ValuationType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum ValuationType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "CCPV") )]
	CodeCCPV,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MTMA") )]
	CodeMTMA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MTMO") )]
	CodeMTMO,
}

impl ValuationType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// VariationType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum VariationType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "DECR") )]
	CodeDECR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INCR") )]
	CodeINCR,
}

impl VariationType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// VolumeCapReport1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct VolumeCapReport1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgPrd", skip_serializing_if = "Option::is_none") )]
	pub rptg_prd: Option<Period4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradgVn", skip_serializing_if = "Option::is_none") )]
	pub tradg_vn: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstrmRpt") )]
	pub instrm_rpt: Vec<VolumeCapReport2>,
}

impl VolumeCapReport1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.rptg_prd { val.validate()? }
		if let Some(ref val) = self.tradg_vn {
			let pattern = Regex::new("[A-Z0-9]{4,4}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "tradg_vn does not match the required pattern".to_string()));
			}
		}
		for item in &self.instrm_rpt { item.validate()? }
		Ok(())
	}
}


// VolumeCapReport2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct VolumeCapReport2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechRcrdId", skip_serializing_if = "Option::is_none") )]
	pub tech_rcrd_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ccy") )]
	pub ccy: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlTradgVol") )]
	pub ttl_tradg_vol: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlRefPricTradgVol") )]
	pub ttl_ref_pric_tradg_vol: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlNgtdTxsTradgVol") )]
	pub ttl_ngtd_txs_tradg_vol: f64,
}

impl VolumeCapReport2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tech_rcrd_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tech_rcrd_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "tech_rcrd_id exceeds the maximum length of 35".to_string()));
			}
		}
		let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
		if !pattern.is_match(&self.id) {
			return Err(ValidationError::new(1005, "id does not match the required pattern".to_string()));
		}
		let pattern = Regex::new("[A-Z]{3,3}").unwrap();
		if !pattern.is_match(&self.ccy) {
			return Err(ValidationError::new(1005, "ccy does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// VolumeCapResult1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct VolumeCapResult1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgPrd") )]
	pub rptg_prd: Period4Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LastUpdDt", skip_serializing_if = "Option::is_none") )]
	pub last_upd_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlTradgVol") )]
	pub ttl_tradg_vol: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradgUdrWvrPctg") )]
	pub tradg_udr_wvr_pctg: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradgUdrWvrBrkdwn", skip_serializing_if = "Option::is_none") )]
	pub tradg_udr_wvr_brkdwn: Option<Vec<TradingUnderWaiversPercentage1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dsclmr", skip_serializing_if = "Option::is_none") )]
	pub dsclmr: Option<String>,
}

impl VolumeCapResult1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
		if !pattern.is_match(&self.id) {
			return Err(ValidationError::new(1005, "id does not match the required pattern".to_string()));
		}
		self.rptg_prd.validate()?;
		self.ttl_tradg_vol.validate()?;
		if let Some(ref vec) = self.tradg_udr_wvr_brkdwn { for item in vec { item.validate()? } }
		if let Some(ref val) = self.dsclmr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "dsclmr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 350 {
				return Err(ValidationError::new(1002, "dsclmr exceeds the maximum length of 350".to_string()));
			}
		}
		Ok(())
	}
}


// VolumeMetrics4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct VolumeMetrics4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReuseVal", skip_serializing_if = "Option::is_none") )]
	pub reuse_val: Option<ReuseValue1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RinvstdCshAmt", skip_serializing_if = "Option::is_none") )]
	pub rinvstd_csh_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
}

impl VolumeMetrics4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.reuse_val { val.validate()? }
		if let Some(ref val) = self.rinvstd_csh_amt { val.validate()? }
		Ok(())
	}
}


// VolumeMetrics5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct VolumeMetrics5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfTxs", skip_serializing_if = "Option::is_none") )]
	pub nb_of_txs: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Xpsr", skip_serializing_if = "Option::is_none") )]
	pub xpsr: Option<ExposureMetrics4>,
}

impl VolumeMetrics5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.nb_of_txs {
			let pattern = Regex::new("[0-9]{1,15}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "nb_of_txs does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.xpsr { val.validate()? }
		Ok(())
	}
}


// VolumeMetrics6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub struct VolumeMetrics6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Postv", skip_serializing_if = "Option::is_none") )]
	pub postv: Option<ExposureMetrics5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Neg", skip_serializing_if = "Option::is_none") )]
	pub neg: Option<ExposureMetrics5>,
}

impl VolumeMetrics6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.postv { val.validate()? }
		if let Some(ref val) = self.neg { val.validate()? }
		Ok(())
	}
}


// WeekDay3Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
#[cfg_attr(feature = "derive_samplify", derive(Sampleable))]
pub enum WeekDay3Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ALLD") )]
	CodeALLD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XBHL") )]
	CodeXBHL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IBHL") )]
	CodeIBHL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FRID") )]
	CodeFRID,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MOND") )]
	CodeMOND,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SATD") )]
	CodeSATD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SUND") )]
	CodeSUND,
	#[cfg_attr( feature = "derive_serde", serde(rename = "THUD") )]
	CodeTHUD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TUED") )]
	CodeTUED,
	#[cfg_attr( feature = "derive_serde", serde(rename = "WEDD") )]
	CodeWEDD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "WDAY") )]
	CodeWDAY,
	#[cfg_attr( feature = "derive_serde", serde(rename = "WEND") )]
	CodeWEND,
}

impl WeekDay3Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}