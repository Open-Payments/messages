// Suppress warnings about unused imports when features are not enabled
#![allow(unused_imports)]
use regex::Regex;

// Conditionally import necessary traits and modules
#[cfg(feature = "derive_serde")]
use serde::{Deserialize, Serialize};


#[derive(Debug)]
pub struct ValidationError {
    pub code: u32,
    pub message: String,
}

impl ValidationError {
    pub fn new(code: u32, message: String) -> Self {
        ValidationError { code, message }
    }
}


// AccountCashEntryReturnCriteria3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct AccountCashEntryReturnCriteria3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtryRefInd", skip_serializing_if = "Option::is_none") )]
	pub ntry_ref_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctTpInd", skip_serializing_if = "Option::is_none") )]
	pub acct_tp_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtryAmtInd", skip_serializing_if = "Option::is_none") )]
	pub ntry_amt_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctCcyInd", skip_serializing_if = "Option::is_none") )]
	pub acct_ccy_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtryStsInd", skip_serializing_if = "Option::is_none") )]
	pub ntry_sts_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtryDtInd", skip_serializing_if = "Option::is_none") )]
	pub ntry_dt_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctSvcrInd", skip_serializing_if = "Option::is_none") )]
	pub acct_svcr_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctOwnrInd", skip_serializing_if = "Option::is_none") )]
	pub acct_ownr_ind: Option<bool>,
}

impl AccountCashEntryReturnCriteria3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AccountCriteria4Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct AccountCriteria4Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "QryNm", skip_serializing_if = "Option::is_none") )]
	pub qry_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NewCrit", skip_serializing_if = "Option::is_none") )]
	pub new_crit: Option<AccountCriteria8>,
}

impl AccountCriteria4Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.qry_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "qry_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "qry_nm exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.new_crit { val.validate()? }
		Ok(())
	}
}


// AccountCriteria8 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct AccountCriteria8 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NewQryNm", skip_serializing_if = "Option::is_none") )]
	pub new_qry_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SchCrit", skip_serializing_if = "Option::is_none") )]
	pub sch_crit: Option<Vec<CashAccountSearchCriteria8>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RtrCrit", skip_serializing_if = "Option::is_none") )]
	pub rtr_crit: Option<CashAccountReturnCriteria5>,
}

impl AccountCriteria8 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.new_qry_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "new_qry_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "new_qry_nm exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref vec) = self.sch_crit { for item in vec { item.validate()? } }
		if let Some(ref val) = self.rtr_crit { val.validate()? }
		Ok(())
	}
}


// AccountIdentification1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct AccountIdentification1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry") )]
	pub prtry: SimpleIdentificationInformation,
}

impl AccountIdentification1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.prtry.validate()?;
		Ok(())
	}
}


// AccountIdentification4Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct AccountIdentification4Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "IBAN", skip_serializing_if = "Option::is_none") )]
	pub iban: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<GenericAccountIdentification1>,
}

impl AccountIdentification4Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.iban {
			let pattern = Regex::new("[A-Z]{2,2}[0-9]{2,2}[a-zA-Z0-9]{1,30}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "iban does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.othr { val.validate()? }
		Ok(())
	}
}


// AccountIdentificationSearchCriteria2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct AccountIdentificationSearchCriteria2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "EQ", skip_serializing_if = "Option::is_none") )]
	pub eq: Option<AccountIdentification4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CTTxt", skip_serializing_if = "Option::is_none") )]
	pub ct_txt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NCTTxt", skip_serializing_if = "Option::is_none") )]
	pub nct_txt: Option<String>,
}

impl AccountIdentificationSearchCriteria2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.eq { val.validate()? }
		if let Some(ref val) = self.ct_txt {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "ct_txt is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "ct_txt exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.nct_txt {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nct_txt is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "nct_txt exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// AccountInterest4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct AccountInterest4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<InterestType1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rate", skip_serializing_if = "Option::is_none") )]
	pub rate: Option<Vec<Rate4>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrToDt", skip_serializing_if = "Option::is_none") )]
	pub fr_to_dt: Option<DateTimePeriod1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn", skip_serializing_if = "Option::is_none") )]
	pub rsn: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tax", skip_serializing_if = "Option::is_none") )]
	pub tax: Option<TaxCharges2>,
}

impl AccountInterest4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tp { val.validate()? }
		if let Some(ref vec) = self.rate { for item in vec { item.validate()? } }
		if let Some(ref val) = self.fr_to_dt { val.validate()? }
		if let Some(ref val) = self.rsn {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "rsn is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "rsn exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.tax { val.validate()? }
		Ok(())
	}
}


// AccountLevel1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum AccountLevel1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "INTM") )]
	CodeINTM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SMRY") )]
	CodeSMRY,
}

impl AccountLevel1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AccountLevel2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum AccountLevel2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "INTM") )]
	CodeINTM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SMRY") )]
	CodeSMRY,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DETL") )]
	CodeDETL,
}

impl AccountLevel2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AccountNotification22 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct AccountNotification22 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtfctnPgntn", skip_serializing_if = "Option::is_none") )]
	pub ntfctn_pgntn: Option<Pagination1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ElctrncSeqNb", skip_serializing_if = "Option::is_none") )]
	pub elctrnc_seq_nb: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgSeq", skip_serializing_if = "Option::is_none") )]
	pub rptg_seq: Option<SequenceRange1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LglSeqNb", skip_serializing_if = "Option::is_none") )]
	pub lgl_seq_nb: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CreDtTm", skip_serializing_if = "Option::is_none") )]
	pub cre_dt_tm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrToDt", skip_serializing_if = "Option::is_none") )]
	pub fr_to_dt: Option<DateTimePeriod1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CpyDplctInd", skip_serializing_if = "Option::is_none") )]
	pub cpy_dplct_ind: Option<CopyDuplicate1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgSrc", skip_serializing_if = "Option::is_none") )]
	pub rptg_src: Option<ReportingSource1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Acct") )]
	pub acct: CashAccount43,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RltdAcct", skip_serializing_if = "Option::is_none") )]
	pub rltd_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Intrst", skip_serializing_if = "Option::is_none") )]
	pub intrst: Option<Vec<AccountInterest4>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxsSummry", skip_serializing_if = "Option::is_none") )]
	pub txs_summry: Option<TotalTransactions6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ntry", skip_serializing_if = "Option::is_none") )]
	pub ntry: Option<Vec<ReportEntry14>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlNtfctnInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_ntfctn_inf: Option<String>,
}

impl AccountNotification22 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.ntfctn_pgntn { val.validate()? }
		if let Some(ref val) = self.rptg_seq { val.validate()? }
		if let Some(ref val) = self.fr_to_dt { val.validate()? }
		if let Some(ref val) = self.cpy_dplct_ind { val.validate()? }
		if let Some(ref val) = self.rptg_src { val.validate()? }
		self.acct.validate()?;
		if let Some(ref val) = self.rltd_acct { val.validate()? }
		if let Some(ref vec) = self.intrst { for item in vec { item.validate()? } }
		if let Some(ref val) = self.txs_summry { val.validate()? }
		if let Some(ref vec) = self.ntry { for item in vec { item.validate()? } }
		if let Some(ref val) = self.addtl_ntfctn_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_ntfctn_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 500 {
				return Err(ValidationError::new(1002, "addtl_ntfctn_inf exceeds the maximum length of 500".to_string()));
			}
		}
		Ok(())
	}
}


// AccountNotification23 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct AccountNotification23 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Acct", skip_serializing_if = "Option::is_none") )]
	pub acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctOwnr", skip_serializing_if = "Option::is_none") )]
	pub acct_ownr: Option<Party50Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctSvcr", skip_serializing_if = "Option::is_none") )]
	pub acct_svcr: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RltdAcct", skip_serializing_if = "Option::is_none") )]
	pub rltd_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlAmt", skip_serializing_if = "Option::is_none") )]
	pub ttl_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XpctdValDt", skip_serializing_if = "Option::is_none") )]
	pub xpctd_val_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dbtr", skip_serializing_if = "Option::is_none") )]
	pub dbtr: Option<Party50Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtrAgt", skip_serializing_if = "Option::is_none") )]
	pub dbtr_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrmyAgt", skip_serializing_if = "Option::is_none") )]
	pub intrmy_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Itm") )]
	pub itm: Vec<NotificationItem9>,
}

impl AccountNotification23 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.acct { val.validate()? }
		if let Some(ref val) = self.acct_ownr { val.validate()? }
		if let Some(ref val) = self.acct_svcr { val.validate()? }
		if let Some(ref val) = self.rltd_acct { val.validate()? }
		if let Some(ref val) = self.ttl_amt { val.validate()? }
		if let Some(ref val) = self.dbtr { val.validate()? }
		if let Some(ref val) = self.dbtr_agt { val.validate()? }
		if let Some(ref val) = self.intrmy_agt { val.validate()? }
		for item in &self.itm { item.validate()? }
		Ok(())
	}
}


// AccountOrBusinessError6Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct AccountOrBusinessError6Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Acct", skip_serializing_if = "Option::is_none") )]
	pub acct: Option<CashAccountData1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BizErr", skip_serializing_if = "Option::is_none") )]
	pub biz_err: Option<Vec<ErrorHandling5>>,
}

impl AccountOrBusinessError6Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.acct { val.validate()? }
		if let Some(ref vec) = self.biz_err { for item in vec { item.validate()? } }
		Ok(())
	}
}


// AccountOrOperationalError6Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct AccountOrOperationalError6Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctRpt", skip_serializing_if = "Option::is_none") )]
	pub acct_rpt: Option<Vec<AccountReport35>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OprlErr", skip_serializing_if = "Option::is_none") )]
	pub oprl_err: Option<Vec<ErrorHandling5>>,
}

impl AccountOrOperationalError6Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.acct_rpt { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.oprl_err { for item in vec { item.validate()? } }
		Ok(())
	}
}


// AccountQuery4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct AccountQuery4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "QryTp", skip_serializing_if = "Option::is_none") )]
	pub qry_tp: Option<QueryType2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctCrit", skip_serializing_if = "Option::is_none") )]
	pub acct_crit: Option<AccountCriteria4Choice>,
}

impl AccountQuery4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.qry_tp { val.validate()? }
		if let Some(ref val) = self.acct_crit { val.validate()? }
		Ok(())
	}
}


// AccountReport33 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct AccountReport33 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptPgntn", skip_serializing_if = "Option::is_none") )]
	pub rpt_pgntn: Option<Pagination1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ElctrncSeqNb", skip_serializing_if = "Option::is_none") )]
	pub elctrnc_seq_nb: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgSeq", skip_serializing_if = "Option::is_none") )]
	pub rptg_seq: Option<SequenceRange1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LglSeqNb", skip_serializing_if = "Option::is_none") )]
	pub lgl_seq_nb: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CreDtTm", skip_serializing_if = "Option::is_none") )]
	pub cre_dt_tm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrToDt", skip_serializing_if = "Option::is_none") )]
	pub fr_to_dt: Option<DateTimePeriod1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CpyDplctInd", skip_serializing_if = "Option::is_none") )]
	pub cpy_dplct_ind: Option<CopyDuplicate1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgSrc", skip_serializing_if = "Option::is_none") )]
	pub rptg_src: Option<ReportingSource1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Acct") )]
	pub acct: CashAccount43,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RltdAcct", skip_serializing_if = "Option::is_none") )]
	pub rltd_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Intrst", skip_serializing_if = "Option::is_none") )]
	pub intrst: Option<Vec<AccountInterest4>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Bal", skip_serializing_if = "Option::is_none") )]
	pub bal: Option<Vec<CashBalance8>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxsSummry", skip_serializing_if = "Option::is_none") )]
	pub txs_summry: Option<TotalTransactions6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ntry", skip_serializing_if = "Option::is_none") )]
	pub ntry: Option<Vec<ReportEntry14>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlRptInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_rpt_inf: Option<String>,
}

impl AccountReport33 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.rpt_pgntn { val.validate()? }
		if let Some(ref val) = self.rptg_seq { val.validate()? }
		if let Some(ref val) = self.fr_to_dt { val.validate()? }
		if let Some(ref val) = self.cpy_dplct_ind { val.validate()? }
		if let Some(ref val) = self.rptg_src { val.validate()? }
		self.acct.validate()?;
		if let Some(ref val) = self.rltd_acct { val.validate()? }
		if let Some(ref vec) = self.intrst { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.bal { for item in vec { item.validate()? } }
		if let Some(ref val) = self.txs_summry { val.validate()? }
		if let Some(ref vec) = self.ntry { for item in vec { item.validate()? } }
		if let Some(ref val) = self.addtl_rpt_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_rpt_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 500 {
				return Err(ValidationError::new(1002, "addtl_rpt_inf exceeds the maximum length of 500".to_string()));
			}
		}
		Ok(())
	}
}


// AccountReport35 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct AccountReport35 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctId") )]
	pub acct_id: AccountIdentification4Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctOrErr") )]
	pub acct_or_err: AccountOrBusinessError6Choice,
}

impl AccountReport35 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.acct_id.validate()?;
		self.acct_or_err.validate()?;
		Ok(())
	}
}


// AccountSchemeName1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct AccountSchemeName1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl AccountSchemeName1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// AccountStatement13 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct AccountStatement13 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StmtPgntn", skip_serializing_if = "Option::is_none") )]
	pub stmt_pgntn: Option<Pagination1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ElctrncSeqNb", skip_serializing_if = "Option::is_none") )]
	pub elctrnc_seq_nb: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgSeq", skip_serializing_if = "Option::is_none") )]
	pub rptg_seq: Option<SequenceRange1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LglSeqNb", skip_serializing_if = "Option::is_none") )]
	pub lgl_seq_nb: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CreDtTm", skip_serializing_if = "Option::is_none") )]
	pub cre_dt_tm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrToDt", skip_serializing_if = "Option::is_none") )]
	pub fr_to_dt: Option<DateTimePeriod1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CpyDplctInd", skip_serializing_if = "Option::is_none") )]
	pub cpy_dplct_ind: Option<CopyDuplicate1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgSrc", skip_serializing_if = "Option::is_none") )]
	pub rptg_src: Option<ReportingSource1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Acct") )]
	pub acct: CashAccount43,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RltdAcct", skip_serializing_if = "Option::is_none") )]
	pub rltd_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Intrst", skip_serializing_if = "Option::is_none") )]
	pub intrst: Option<Vec<AccountInterest4>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Bal") )]
	pub bal: Vec<CashBalance8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxsSummry", skip_serializing_if = "Option::is_none") )]
	pub txs_summry: Option<TotalTransactions6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ntry", skip_serializing_if = "Option::is_none") )]
	pub ntry: Option<Vec<ReportEntry14>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlStmtInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_stmt_inf: Option<String>,
}

impl AccountStatement13 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.stmt_pgntn { val.validate()? }
		if let Some(ref val) = self.rptg_seq { val.validate()? }
		if let Some(ref val) = self.fr_to_dt { val.validate()? }
		if let Some(ref val) = self.cpy_dplct_ind { val.validate()? }
		if let Some(ref val) = self.rptg_src { val.validate()? }
		self.acct.validate()?;
		if let Some(ref val) = self.rltd_acct { val.validate()? }
		if let Some(ref vec) = self.intrst { for item in vec { item.validate()? } }
		for item in &self.bal { item.validate()? }
		if let Some(ref val) = self.txs_summry { val.validate()? }
		if let Some(ref vec) = self.ntry { for item in vec { item.validate()? } }
		if let Some(ref val) = self.addtl_stmt_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_stmt_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 500 {
				return Err(ValidationError::new(1002, "addtl_stmt_inf exceeds the maximum length of 500".to_string()));
			}
		}
		Ok(())
	}
}


// AccountTax1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct AccountTax1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClctnMtd") )]
	pub clctn_mtd: BillingTaxCalculationMethod1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rgn", skip_serializing_if = "Option::is_none") )]
	pub rgn: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NonResCtry", skip_serializing_if = "Option::is_none") )]
	pub non_res_ctry: Option<ResidenceLocation1Choice>,
}

impl AccountTax1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.clctn_mtd.validate()?;
		if let Some(ref val) = self.rgn {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "rgn is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 40 {
				return Err(ValidationError::new(1002, "rgn exceeds the maximum length of 40".to_string()));
			}
		}
		if let Some(ref val) = self.non_res_ctry { val.validate()? }
		Ok(())
	}
}


// AcknowledgedAcceptedStatus21Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct AcknowledgedAcceptedStatus21Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NoSpcfdRsn", skip_serializing_if = "Option::is_none") )]
	pub no_spcfd_rsn: Option<NoReasonCode>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn", skip_serializing_if = "Option::is_none") )]
	pub rsn: Option<Vec<AcknowledgementReason9>>,
}

impl AcknowledgedAcceptedStatus21Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.no_spcfd_rsn { val.validate()? }
		if let Some(ref vec) = self.rsn { for item in vec { item.validate()? } }
		Ok(())
	}
}


// AcknowledgedAcceptedStatus24Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct AcknowledgedAcceptedStatus24Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NoSpcfdRsn", skip_serializing_if = "Option::is_none") )]
	pub no_spcfd_rsn: Option<NoReasonCode>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn", skip_serializing_if = "Option::is_none") )]
	pub rsn: Option<Vec<AcknowledgementReason12>>,
}

impl AcknowledgedAcceptedStatus24Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.no_spcfd_rsn { val.validate()? }
		if let Some(ref vec) = self.rsn { for item in vec { item.validate()? } }
		Ok(())
	}
}


// AcknowledgementDetails1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct AcknowledgementDetails1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PayInSchdlRef", skip_serializing_if = "Option::is_none") )]
	pub pay_in_schdl_ref: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PayInCallRef", skip_serializing_if = "Option::is_none") )]
	pub pay_in_call_ref: Option<String>,
}

impl AcknowledgementDetails1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.pay_in_schdl_ref {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "pay_in_schdl_ref is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "pay_in_schdl_ref exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.pay_in_call_ref {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "pay_in_call_ref is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "pay_in_call_ref exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// AcknowledgementReason12 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct AcknowledgementReason12 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd") )]
	pub cd: AcknowledgementReason15Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlRsnInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_rsn_inf: Option<String>,
}

impl AcknowledgementReason12 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.cd.validate()?;
		if let Some(ref val) = self.addtl_rsn_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_rsn_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 210 {
				return Err(ValidationError::new(1002, "addtl_rsn_inf exceeds the maximum length of 210".to_string()));
			}
		}
		Ok(())
	}
}


// AcknowledgementReason12Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct AcknowledgementReason12Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<AcknowledgementReason5Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification30>,
}

impl AcknowledgementReason12Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// AcknowledgementReason15Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct AcknowledgementReason15Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<AcknowledgementReason3Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification30>,
}

impl AcknowledgementReason15Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// AcknowledgementReason3Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum AcknowledgementReason3Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ADEA") )]
	CodeADEA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SMPG") )]
	CodeSMPG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
}

impl AcknowledgementReason3Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AcknowledgementReason5Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum AcknowledgementReason5Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ADEA") )]
	CodeADEA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SMPG") )]
	CodeSMPG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CDCY") )]
	CodeCDCY,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CDRG") )]
	CodeCDRG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CDRE") )]
	CodeCDRE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NSTP") )]
	CodeNSTP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RQWV") )]
	CodeRQWV,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LATE") )]
	CodeLATE,
}

impl AcknowledgementReason5Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AcknowledgementReason9 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct AcknowledgementReason9 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd") )]
	pub cd: AcknowledgementReason12Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlRsnInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_rsn_inf: Option<String>,
}

impl AcknowledgementReason9 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.cd.validate()?;
		if let Some(ref val) = self.addtl_rsn_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_rsn_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 210 {
				return Err(ValidationError::new(1002, "addtl_rsn_inf exceeds the maximum length of 210".to_string()));
			}
		}
		Ok(())
	}
}


// ActiveAmountRange3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ActiveAmountRange3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ImpldCcyAndAmtRg", skip_serializing_if = "Option::is_none") )]
	pub impld_ccy_and_amt_rg: Option<ImpliedCurrencyAndAmountRange1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CcyAndAmtRg", skip_serializing_if = "Option::is_none") )]
	pub ccy_and_amt_rg: Option<ActiveCurrencyAndAmountRange3>,
}

impl ActiveAmountRange3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.impld_ccy_and_amt_rg { val.validate()? }
		if let Some(ref val) = self.ccy_and_amt_rg { val.validate()? }
		Ok(())
	}
}


// ActiveCurrencyAnd13DecimalAmount ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ActiveCurrencyAnd13DecimalAmount {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ccy") )]
	pub ccy: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "$value") )]
	pub value: f64,
}

impl ActiveCurrencyAnd13DecimalAmount {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ActiveCurrencyAndAmount ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ActiveCurrencyAndAmount {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ccy") )]
	pub ccy: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "$value") )]
	pub value: f64,
}

impl ActiveCurrencyAndAmount {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ActiveCurrencyAndAmountRange3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ActiveCurrencyAndAmountRange3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ImpliedCurrencyAmountRange1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtDbtInd", skip_serializing_if = "Option::is_none") )]
	pub cdt_dbt_ind: Option<CreditDebitCode>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ccy") )]
	pub ccy: String,
}

impl ActiveCurrencyAndAmountRange3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.amt.validate()?;
		if let Some(ref val) = self.cdt_dbt_ind { val.validate()? }
		let pattern = Regex::new("[A-Z]{3,3}").unwrap();
		if !pattern.is_match(&self.ccy) {
			return Err(ValidationError::new(1005, "ccy does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// ActiveOrHistoricAmountRange2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ActiveOrHistoricAmountRange2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ImpldCcyAndAmtRg", skip_serializing_if = "Option::is_none") )]
	pub impld_ccy_and_amt_rg: Option<ImpliedCurrencyAndAmountRange1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CcyAndAmtRg", skip_serializing_if = "Option::is_none") )]
	pub ccy_and_amt_rg: Option<ActiveOrHistoricCurrencyAndAmountRange2>,
}

impl ActiveOrHistoricAmountRange2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.impld_ccy_and_amt_rg { val.validate()? }
		if let Some(ref val) = self.ccy_and_amt_rg { val.validate()? }
		Ok(())
	}
}


// ActiveOrHistoricCurrencyAnd13DecimalAmount ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ActiveOrHistoricCurrencyAnd13DecimalAmount {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ccy") )]
	pub ccy: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "$value") )]
	pub value: f64,
}

impl ActiveOrHistoricCurrencyAnd13DecimalAmount {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ActiveOrHistoricCurrencyAndAmount ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ActiveOrHistoricCurrencyAndAmount {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ccy") )]
	pub ccy: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "$value") )]
	pub value: f64,
}

impl ActiveOrHistoricCurrencyAndAmount {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ActiveOrHistoricCurrencyAndAmountRange2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ActiveOrHistoricCurrencyAndAmountRange2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ImpliedCurrencyAmountRange1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtDbtInd", skip_serializing_if = "Option::is_none") )]
	pub cdt_dbt_ind: Option<CreditDebitCode>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ccy") )]
	pub ccy: String,
}

impl ActiveOrHistoricCurrencyAndAmountRange2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.amt.validate()?;
		if let Some(ref val) = self.cdt_dbt_ind { val.validate()? }
		let pattern = Regex::new("[A-Z]{3,3}").unwrap();
		if !pattern.is_match(&self.ccy) {
			return Err(ValidationError::new(1005, "ccy does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// AdditionalParameters1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct AdditionalParameters1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ctry", skip_serializing_if = "Option::is_none") )]
	pub ctry: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ccy", skip_serializing_if = "Option::is_none") )]
	pub ccy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GeoArea", skip_serializing_if = "Option::is_none") )]
	pub geo_area: Option<String>,
}

impl AdditionalParameters1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ctry {
			let pattern = Regex::new("[A-Z]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ctry does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ccy does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.geo_area {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "geo_area is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "geo_area exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// AdditionalParameters16 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct AdditionalParameters16 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrtlSttlm", skip_serializing_if = "Option::is_none") )]
	pub prtl_sttlm: Option<PartialSettlement2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrvsPrtlConfId", skip_serializing_if = "Option::is_none") )]
	pub prvs_prtl_conf_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctOwnrTxId", skip_serializing_if = "Option::is_none") )]
	pub acct_ownr_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctSvcrTxId", skip_serializing_if = "Option::is_none") )]
	pub acct_svcr_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PoolId", skip_serializing_if = "Option::is_none") )]
	pub pool_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CorpActnEvtId", skip_serializing_if = "Option::is_none") )]
	pub corp_actn_evt_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MktInfrstrctrTxId", skip_serializing_if = "Option::is_none") )]
	pub mkt_infrstrctr_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrcrTxId", skip_serializing_if = "Option::is_none") )]
	pub prcr_tx_id: Option<String>,
}

impl AdditionalParameters16 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.prtl_sttlm { val.validate()? }
		if let Some(ref val) = self.prvs_prtl_conf_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prvs_prtl_conf_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prvs_prtl_conf_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.acct_ownr_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "acct_ownr_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "acct_ownr_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.acct_svcr_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "acct_svcr_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "acct_svcr_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.pool_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "pool_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "pool_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.corp_actn_evt_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "corp_actn_evt_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "corp_actn_evt_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.mkt_infrstrctr_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "mkt_infrstrctr_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "mkt_infrstrctr_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.prcr_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prcr_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prcr_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// AdditionalReference3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct AdditionalReference3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ref") )]
	pub ref_attr: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RefIssr", skip_serializing_if = "Option::is_none") )]
	pub ref_issr: Option<PartyIdentification2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgNm", skip_serializing_if = "Option::is_none") )]
	pub msg_nm: Option<String>,
}

impl AdditionalReference3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.ref_attr.chars().count() < 1 {
			return Err(ValidationError::new(1001, "ref_attr is shorter than the minimum length of 1".to_string()));
		}
		if self.ref_attr.chars().count() > 35 {
			return Err(ValidationError::new(1002, "ref_attr exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.ref_issr { val.validate()? }
		if let Some(ref val) = self.msg_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "msg_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "msg_nm exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// AdditionalRequestData1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct AdditionalRequestData1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReqdDbtAuthstn", skip_serializing_if = "Option::is_none") )]
	pub reqd_dbt_authstn: Option<DebitAuthorisation3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReqdCompstn", skip_serializing_if = "Option::is_none") )]
	pub reqd_compstn: Option<CompensationRequest1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReqdValtn", skip_serializing_if = "Option::is_none") )]
	pub reqd_valtn: Option<AdjustmentRequest1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReqNrrtv", skip_serializing_if = "Option::is_none") )]
	pub req_nrrtv: Option<String>,
}

impl AdditionalRequestData1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.reqd_dbt_authstn { val.validate()? }
		if let Some(ref val) = self.reqd_compstn { val.validate()? }
		if let Some(ref val) = self.reqd_valtn { val.validate()? }
		if let Some(ref val) = self.req_nrrtv {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "req_nrrtv is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 500 {
				return Err(ValidationError::new(1002, "req_nrrtv exceeds the maximum length of 500".to_string()));
			}
		}
		Ok(())
	}
}


// AddressType2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum AddressType2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ADDR") )]
	CodeADDR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PBOX") )]
	CodePBOX,
	#[cfg_attr( feature = "derive_serde", serde(rename = "HOME") )]
	CodeHOME,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BIZZ") )]
	CodeBIZZ,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MLTO") )]
	CodeMLTO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DLVY") )]
	CodeDLVY,
}

impl AddressType2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AddressType3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct AddressType3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<AddressType2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification30>,
}

impl AddressType3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// AdjustmentCompensation1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct AdjustmentCompensation1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "InitlAmt", skip_serializing_if = "Option::is_none") )]
	pub initl_amt: Option<ActiveCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DueChrgs", skip_serializing_if = "Option::is_none") )]
	pub due_chrgs: Option<ActiveCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AmtDue") )]
	pub amt_due: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CompstnAgt", skip_serializing_if = "Option::is_none") )]
	pub compstn_agt: Option<BranchAndFinancialInstitutionIdentification6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CompstnAcct", skip_serializing_if = "Option::is_none") )]
	pub compstn_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prd", skip_serializing_if = "Option::is_none") )]
	pub prd: Option<DatePeriod5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstRate", skip_serializing_if = "Option::is_none") )]
	pub intrst_rate: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn", skip_serializing_if = "Option::is_none") )]
	pub rsn: Option<String>,
}

impl AdjustmentCompensation1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.initl_amt { val.validate()? }
		if let Some(ref val) = self.due_chrgs { val.validate()? }
		self.amt_due.validate()?;
		if let Some(ref val) = self.compstn_agt { val.validate()? }
		if let Some(ref val) = self.compstn_acct { val.validate()? }
		if let Some(ref val) = self.prd { val.validate()? }
		if let Some(ref val) = self.rsn {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "rsn is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "rsn exceeds the maximum length of 140".to_string()));
			}
		}
		Ok(())
	}
}


// AdjustmentRequest1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct AdjustmentRequest1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prd", skip_serializing_if = "Option::is_none") )]
	pub prd: Option<DatePeriod5>,
}

impl AdjustmentRequest1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.prd { val.validate()? }
		Ok(())
	}
}


// AgreedRate2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct AgreedRate2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "XchgRate") )]
	pub xchg_rate: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnitCcy") )]
	pub unit_ccy: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "QtdCcy") )]
	pub qtd_ccy: String,
}

impl AgreedRate2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z]{3,3}").unwrap();
		if !pattern.is_match(&self.unit_ccy) {
			return Err(ValidationError::new(1005, "unit_ccy does not match the required pattern".to_string()));
		}
		let pattern = Regex::new("[A-Z]{3,3}").unwrap();
		if !pattern.is_match(&self.qtd_ccy) {
			return Err(ValidationError::new(1005, "qtd_ccy does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// AlternateSecurityIdentification1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct AlternateSecurityIdentification1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DmstIdSrc", skip_serializing_if = "Option::is_none") )]
	pub dmst_id_src: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrtryIdSrc", skip_serializing_if = "Option::is_none") )]
	pub prtry_id_src: Option<String>,
}

impl AlternateSecurityIdentification1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.dmst_id_src {
			let pattern = Regex::new("[A-Z]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "dmst_id_src does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.prtry_id_src {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry_id_src is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry_id_src exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// AmendmentInformationDetails14 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct AmendmentInformationDetails14 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlMndtId", skip_serializing_if = "Option::is_none") )]
	pub orgnl_mndt_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlCdtrSchmeId", skip_serializing_if = "Option::is_none") )]
	pub orgnl_cdtr_schme_id: Option<PartyIdentification135>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlCdtrAgt", skip_serializing_if = "Option::is_none") )]
	pub orgnl_cdtr_agt: Option<BranchAndFinancialInstitutionIdentification6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlCdtrAgtAcct", skip_serializing_if = "Option::is_none") )]
	pub orgnl_cdtr_agt_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlDbtr", skip_serializing_if = "Option::is_none") )]
	pub orgnl_dbtr: Option<PartyIdentification135>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlDbtrAcct", skip_serializing_if = "Option::is_none") )]
	pub orgnl_dbtr_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlDbtrAgt", skip_serializing_if = "Option::is_none") )]
	pub orgnl_dbtr_agt: Option<BranchAndFinancialInstitutionIdentification6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlDbtrAgtAcct", skip_serializing_if = "Option::is_none") )]
	pub orgnl_dbtr_agt_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlFnlColltnDt", skip_serializing_if = "Option::is_none") )]
	pub orgnl_fnl_colltn_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlFrqcy", skip_serializing_if = "Option::is_none") )]
	pub orgnl_frqcy: Option<Frequency36Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlRsn", skip_serializing_if = "Option::is_none") )]
	pub orgnl_rsn: Option<MandateSetupReason1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlTrckgDays", skip_serializing_if = "Option::is_none") )]
	pub orgnl_trckg_days: Option<String>,
}

impl AmendmentInformationDetails14 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.orgnl_mndt_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_mndt_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_mndt_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.orgnl_cdtr_schme_id { val.validate()? }
		if let Some(ref val) = self.orgnl_cdtr_agt { val.validate()? }
		if let Some(ref val) = self.orgnl_cdtr_agt_acct { val.validate()? }
		if let Some(ref val) = self.orgnl_dbtr { val.validate()? }
		if let Some(ref val) = self.orgnl_dbtr_acct { val.validate()? }
		if let Some(ref val) = self.orgnl_dbtr_agt { val.validate()? }
		if let Some(ref val) = self.orgnl_dbtr_agt_acct { val.validate()? }
		if let Some(ref val) = self.orgnl_frqcy { val.validate()? }
		if let Some(ref val) = self.orgnl_rsn { val.validate()? }
		if let Some(ref val) = self.orgnl_trckg_days {
			let pattern = Regex::new("[0-9]{2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "orgnl_trckg_days does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// AmendmentInformationDetails15 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct AmendmentInformationDetails15 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlMndtId", skip_serializing_if = "Option::is_none") )]
	pub orgnl_mndt_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlCdtrSchmeId", skip_serializing_if = "Option::is_none") )]
	pub orgnl_cdtr_schme_id: Option<PartyIdentification272>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlCdtrAgt", skip_serializing_if = "Option::is_none") )]
	pub orgnl_cdtr_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlCdtrAgtAcct", skip_serializing_if = "Option::is_none") )]
	pub orgnl_cdtr_agt_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlDbtr", skip_serializing_if = "Option::is_none") )]
	pub orgnl_dbtr: Option<PartyIdentification272>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlDbtrAcct", skip_serializing_if = "Option::is_none") )]
	pub orgnl_dbtr_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlDbtrAgt", skip_serializing_if = "Option::is_none") )]
	pub orgnl_dbtr_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlDbtrAgtAcct", skip_serializing_if = "Option::is_none") )]
	pub orgnl_dbtr_agt_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlFnlColltnDt", skip_serializing_if = "Option::is_none") )]
	pub orgnl_fnl_colltn_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlFrqcy", skip_serializing_if = "Option::is_none") )]
	pub orgnl_frqcy: Option<Frequency36Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlRsn", skip_serializing_if = "Option::is_none") )]
	pub orgnl_rsn: Option<MandateSetupReason1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlTrckgDays", skip_serializing_if = "Option::is_none") )]
	pub orgnl_trckg_days: Option<String>,
}

impl AmendmentInformationDetails15 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.orgnl_mndt_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_mndt_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_mndt_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.orgnl_cdtr_schme_id { val.validate()? }
		if let Some(ref val) = self.orgnl_cdtr_agt { val.validate()? }
		if let Some(ref val) = self.orgnl_cdtr_agt_acct { val.validate()? }
		if let Some(ref val) = self.orgnl_dbtr { val.validate()? }
		if let Some(ref val) = self.orgnl_dbtr_acct { val.validate()? }
		if let Some(ref val) = self.orgnl_dbtr_agt { val.validate()? }
		if let Some(ref val) = self.orgnl_dbtr_agt_acct { val.validate()? }
		if let Some(ref val) = self.orgnl_frqcy { val.validate()? }
		if let Some(ref val) = self.orgnl_rsn { val.validate()? }
		if let Some(ref val) = self.orgnl_trckg_days {
			let pattern = Regex::new("[0-9]{2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "orgnl_trckg_days does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// Amount2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Amount2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AmtWthtCcy", skip_serializing_if = "Option::is_none") )]
	pub amt_wtht_ccy: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AmtWthCcy", skip_serializing_if = "Option::is_none") )]
	pub amt_wth_ccy: Option<ActiveCurrencyAndAmount>,
}

impl Amount2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.amt_wtht_ccy {
			if *val < 0.000000 {
				return Err(ValidationError::new(1003, "amt_wtht_ccy is less than the minimum value of 0.000000".to_string()));
			}
		}
		if let Some(ref val) = self.amt_wth_ccy { val.validate()? }
		Ok(())
	}
}


// Amount3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Amount3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AmtWthCcy", skip_serializing_if = "Option::is_none") )]
	pub amt_wth_ccy: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AmtWthtCcy", skip_serializing_if = "Option::is_none") )]
	pub amt_wtht_ccy: Option<f64>,
}

impl Amount3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.amt_wth_ccy { val.validate()? }
		if let Some(ref val) = self.amt_wtht_ccy {
			if *val < 0.000000 {
				return Err(ValidationError::new(1003, "amt_wtht_ccy is less than the minimum value of 0.000000".to_string()));
			}
		}
		Ok(())
	}
}


// Amount4Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Amount4Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "IncrAmt", skip_serializing_if = "Option::is_none") )]
	pub incr_amt: Option<Amount2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DcrAmt", skip_serializing_if = "Option::is_none") )]
	pub dcr_amt: Option<Amount2Choice>,
}

impl Amount4Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.incr_amt { val.validate()? }
		if let Some(ref val) = self.dcr_amt { val.validate()? }
		Ok(())
	}
}


// AmountAndCurrencyExchange4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct AmountAndCurrencyExchange4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstdAmt", skip_serializing_if = "Option::is_none") )]
	pub instd_amt: Option<AmountAndCurrencyExchangeDetails5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxAmt", skip_serializing_if = "Option::is_none") )]
	pub tx_amt: Option<AmountAndCurrencyExchangeDetails5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CntrValAmt", skip_serializing_if = "Option::is_none") )]
	pub cntr_val_amt: Option<AmountAndCurrencyExchangeDetails5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AnncdPstngAmt", skip_serializing_if = "Option::is_none") )]
	pub anncd_pstng_amt: Option<AmountAndCurrencyExchangeDetails5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrtryAmt", skip_serializing_if = "Option::is_none") )]
	pub prtry_amt: Option<Vec<AmountAndCurrencyExchangeDetails6>>,
}

impl AmountAndCurrencyExchange4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.instd_amt { val.validate()? }
		if let Some(ref val) = self.tx_amt { val.validate()? }
		if let Some(ref val) = self.cntr_val_amt { val.validate()? }
		if let Some(ref val) = self.anncd_pstng_amt { val.validate()? }
		if let Some(ref vec) = self.prtry_amt { for item in vec { item.validate()? } }
		Ok(())
	}
}


// AmountAndCurrencyExchangeDetails5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct AmountAndCurrencyExchangeDetails5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveOrHistoricCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CcyXchg", skip_serializing_if = "Option::is_none") )]
	pub ccy_xchg: Option<CurrencyExchange24>,
}

impl AmountAndCurrencyExchangeDetails5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.amt.validate()?;
		if let Some(ref val) = self.ccy_xchg { val.validate()? }
		Ok(())
	}
}


// AmountAndCurrencyExchangeDetails6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct AmountAndCurrencyExchangeDetails6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveOrHistoricCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CcyXchg", skip_serializing_if = "Option::is_none") )]
	pub ccy_xchg: Option<CurrencyExchange24>,
}

impl AmountAndCurrencyExchangeDetails6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.tp.chars().count() < 1 {
			return Err(ValidationError::new(1001, "tp is shorter than the minimum length of 1".to_string()));
		}
		if self.tp.chars().count() > 35 {
			return Err(ValidationError::new(1002, "tp exceeds the maximum length of 35".to_string()));
		}
		self.amt.validate()?;
		if let Some(ref val) = self.ccy_xchg { val.validate()? }
		Ok(())
	}
}


// AmountAndDirection34 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct AmountAndDirection34 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveOrHistoricCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sgn") )]
	pub sgn: bool,
}

impl AmountAndDirection34 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.amt.validate()?;
		Ok(())
	}
}


// AmountAndDirection35 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct AmountAndDirection35 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtDbtInd") )]
	pub cdt_dbt_ind: CreditDebitCode,
}

impl AmountAndDirection35 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.amt < 0.000000 {
			return Err(ValidationError::new(1003, "amt is less than the minimum value of 0.000000".to_string()));
		}
		self.cdt_dbt_ind.validate()?;
		Ok(())
	}
}


// AmountAndDirection5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct AmountAndDirection5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtDbt", skip_serializing_if = "Option::is_none") )]
	pub cdt_dbt: Option<CreditDebitCode>,
}

impl AmountAndDirection5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.amt.validate()?;
		if let Some(ref val) = self.cdt_dbt { val.validate()? }
		Ok(())
	}
}


// AmountAndQuantityBreakdown1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct AmountAndQuantityBreakdown1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "LotNb", skip_serializing_if = "Option::is_none") )]
	pub lot_nb: Option<GenericIdentification37>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LotAmt", skip_serializing_if = "Option::is_none") )]
	pub lot_amt: Option<AmountAndDirection5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LotQty", skip_serializing_if = "Option::is_none") )]
	pub lot_qty: Option<FinancialInstrumentQuantity1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshSubBalTp", skip_serializing_if = "Option::is_none") )]
	pub csh_sub_bal_tp: Option<GenericIdentification30>,
}

impl AmountAndQuantityBreakdown1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.lot_nb { val.validate()? }
		if let Some(ref val) = self.lot_amt { val.validate()? }
		if let Some(ref val) = self.lot_qty { val.validate()? }
		if let Some(ref val) = self.csh_sub_bal_tp { val.validate()? }
		Ok(())
	}
}


// AmountOrRate3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct AmountOrRate3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt", skip_serializing_if = "Option::is_none") )]
	pub amt: Option<ActiveCurrencyAnd13DecimalAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rate", skip_serializing_if = "Option::is_none") )]
	pub rate: Option<f64>,
}

impl AmountOrRate3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.amt { val.validate()? }
		Ok(())
	}
}


// AmountRangeBoundary1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct AmountRangeBoundary1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BdryAmt") )]
	pub bdry_amt: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Incl") )]
	pub incl: bool,
}

impl AmountRangeBoundary1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.bdry_amt < 0.000000 {
			return Err(ValidationError::new(1003, "bdry_amt is less than the minimum value of 0.000000".to_string()));
		}
		Ok(())
	}
}


// AmountType4Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct AmountType4Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstdAmt", skip_serializing_if = "Option::is_none") )]
	pub instd_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EqvtAmt", skip_serializing_if = "Option::is_none") )]
	pub eqvt_amt: Option<EquivalentAmount2>,
}

impl AmountType4Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.instd_amt { val.validate()? }
		if let Some(ref val) = self.eqvt_amt { val.validate()? }
		Ok(())
	}
}


// AttendanceContext1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum AttendanceContext1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ATTD") )]
	CodeATTD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SATT") )]
	CodeSATT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UATT") )]
	CodeUATT,
}

impl AttendanceContext1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AuthenticationEntity1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum AuthenticationEntity1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ICCD") )]
	CodeICCD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AGNT") )]
	CodeAGNT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MERC") )]
	CodeMERC,
}

impl AuthenticationEntity1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// AuthenticationMethod1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum AuthenticationMethod1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "UKNW") )]
	CodeUKNW,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BYPS") )]
	CodeBYPS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NPIN") )]
	CodeNPIN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FPIN") )]
	CodeFPIN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CPSG") )]
	CodeCPSG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PPSG") )]
	CodePPSG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MANU") )]
	CodeMANU,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MERC") )]
	CodeMERC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SCRT") )]
	CodeSCRT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SNCT") )]
	CodeSNCT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SCNL") )]
	CodeSCNL,
}

impl AuthenticationMethod1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// BalanceAdjustment1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BalanceAdjustment1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: BalanceAdjustmentType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Desc") )]
	pub desc: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BalAmt") )]
	pub bal_amt: AmountAndDirection34,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AvrgAmt", skip_serializing_if = "Option::is_none") )]
	pub avrg_amt: Option<AmountAndDirection34>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ErrDt", skip_serializing_if = "Option::is_none") )]
	pub err_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstngDt") )]
	pub pstng_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Days", skip_serializing_if = "Option::is_none") )]
	pub days: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EarngsAdjstmntAmt", skip_serializing_if = "Option::is_none") )]
	pub earngs_adjstmnt_amt: Option<AmountAndDirection34>,
}

impl BalanceAdjustment1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.tp.validate()?;
		if self.desc.chars().count() < 1 {
			return Err(ValidationError::new(1001, "desc is shorter than the minimum length of 1".to_string()));
		}
		if self.desc.chars().count() > 105 {
			return Err(ValidationError::new(1002, "desc exceeds the maximum length of 105".to_string()));
		}
		self.bal_amt.validate()?;
		if let Some(ref val) = self.avrg_amt { val.validate()? }
		if let Some(ref val) = self.earngs_adjstmnt_amt { val.validate()? }
		Ok(())
	}
}


// BalanceAdjustmentType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum BalanceAdjustmentType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "LDGR") )]
	CodeLDGR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FLOT") )]
	CodeFLOT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CLLD") )]
	CodeCLLD,
}

impl BalanceAdjustmentType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// BalanceCounterparty1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum BalanceCounterparty1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "BILA") )]
	CodeBILA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MULT") )]
	CodeMULT,
}

impl BalanceCounterparty1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// BalanceRestrictionType1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BalanceRestrictionType1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: GenericIdentification1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Desc", skip_serializing_if = "Option::is_none") )]
	pub desc: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrcgTp", skip_serializing_if = "Option::is_none") )]
	pub prcg_tp: Option<ProcessingType1Choice>,
}

impl BalanceRestrictionType1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.tp.validate()?;
		if let Some(ref val) = self.desc {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "desc is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "desc exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.prcg_tp { val.validate()? }
		Ok(())
	}
}


// BalanceStatus1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum BalanceStatus1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "PDNG") )]
	CodePDNG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "STLD") )]
	CodeSTLD,
}

impl BalanceStatus1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// BalanceStatus2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BalanceStatus2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Bal") )]
	pub bal: ActiveCurrencyAndAmount,
}

impl BalanceStatus2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.bal.validate()?;
		Ok(())
	}
}


// BalanceSubType1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BalanceSubType1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl BalanceSubType1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// BalanceType10Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BalanceType10Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl BalanceType10Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// BalanceType11Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BalanceType11Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl BalanceType11Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// BalanceType13 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BalanceType13 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdOrPrtry") )]
	pub cd_or_prtry: BalanceType10Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubTp", skip_serializing_if = "Option::is_none") )]
	pub sub_tp: Option<BalanceSubType1Choice>,
}

impl BalanceType13 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.cd_or_prtry.validate()?;
		if let Some(ref val) = self.sub_tp { val.validate()? }
		Ok(())
	}
}


// BalanceType9Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BalanceType9Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<SystemBalanceType2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl BalanceType9Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// BankTransactionCodeStructure4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BankTransactionCodeStructure4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Domn", skip_serializing_if = "Option::is_none") )]
	pub domn: Option<BankTransactionCodeStructure5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<ProprietaryBankTransactionCodeStructure1>,
}

impl BankTransactionCodeStructure4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.domn { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// BankTransactionCodeStructure5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BankTransactionCodeStructure5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd") )]
	pub cd: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Fmly") )]
	pub fmly: BankTransactionCodeStructure6,
}

impl BankTransactionCodeStructure5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.cd.chars().count() < 1 {
			return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
		}
		if self.cd.chars().count() > 4 {
			return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
		}
		self.fmly.validate()?;
		Ok(())
	}
}


// BankTransactionCodeStructure6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BankTransactionCodeStructure6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd") )]
	pub cd: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubFmlyCd") )]
	pub sub_fmly_cd: String,
}

impl BankTransactionCodeStructure6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.cd.chars().count() < 1 {
			return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
		}
		if self.cd.chars().count() > 4 {
			return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
		}
		if self.sub_fmly_cd.chars().count() < 1 {
			return Err(ValidationError::new(1001, "sub_fmly_cd is shorter than the minimum length of 1".to_string()));
		}
		if self.sub_fmly_cd.chars().count() > 4 {
			return Err(ValidationError::new(1002, "sub_fmly_cd exceeds the maximum length of 4".to_string()));
		}
		Ok(())
	}
}


// BatchInformation2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BatchInformation2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgId", skip_serializing_if = "Option::is_none") )]
	pub msg_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtInfId", skip_serializing_if = "Option::is_none") )]
	pub pmt_inf_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfTxs", skip_serializing_if = "Option::is_none") )]
	pub nb_of_txs: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlAmt", skip_serializing_if = "Option::is_none") )]
	pub ttl_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtDbtInd", skip_serializing_if = "Option::is_none") )]
	pub cdt_dbt_ind: Option<CreditDebitCode>,
}

impl BatchInformation2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.msg_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "msg_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "msg_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.pmt_inf_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "pmt_inf_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "pmt_inf_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.nb_of_txs {
			let pattern = Regex::new("[0-9]{1,15}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "nb_of_txs does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.ttl_amt { val.validate()? }
		if let Some(ref val) = self.cdt_dbt_ind { val.validate()? }
		Ok(())
	}
}


// BilateralLimit4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BilateralLimit4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPtyId") )]
	pub ctr_pty_id: BranchAndFinancialInstitutionIdentification8,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LmtAmt") )]
	pub lmt_amt: Amount2Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtDbtInd") )]
	pub cdt_dbt_ind: CreditDebitCode,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BilBal", skip_serializing_if = "Option::is_none") )]
	pub bil_bal: Option<Vec<CashBalance11>>,
}

impl BilateralLimit4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.ctr_pty_id.validate()?;
		self.lmt_amt.validate()?;
		self.cdt_dbt_ind.validate()?;
		if let Some(ref vec) = self.bil_bal { for item in vec { item.validate()? } }
		Ok(())
	}
}


// BillingBalance1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BillingBalance1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: BillingBalanceType1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val") )]
	pub val: AmountAndDirection34,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CcyTp", skip_serializing_if = "Option::is_none") )]
	pub ccy_tp: Option<BillingCurrencyType1Code>,
}

impl BillingBalance1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.tp.validate()?;
		self.val.validate()?;
		if let Some(ref val) = self.ccy_tp { val.validate()? }
		Ok(())
	}
}


// BillingBalanceType1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BillingBalanceType1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl BillingBalanceType1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// BillingChargeMethod1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum BillingChargeMethod1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "UPRC") )]
	CodeUPRC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "STAM") )]
	CodeSTAM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BCHG") )]
	CodeBCHG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DPRC") )]
	CodeDPRC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FCHG") )]
	CodeFCHG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LPRC") )]
	CodeLPRC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MCHG") )]
	CodeMCHG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MXRD") )]
	CodeMXRD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TIR1") )]
	CodeTIR1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TIR2") )]
	CodeTIR2,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TIR3") )]
	CodeTIR3,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TIR4") )]
	CodeTIR4,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TIR5") )]
	CodeTIR5,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TIR6") )]
	CodeTIR6,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TIR7") )]
	CodeTIR7,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TIR8") )]
	CodeTIR8,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TIR9") )]
	CodeTIR9,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TPRC") )]
	CodeTPRC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ZPRC") )]
	CodeZPRC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BBSE") )]
	CodeBBSE,
}

impl BillingChargeMethod1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// BillingCompensation1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BillingCompensation1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: BillingCompensationType1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val") )]
	pub val: AmountAndDirection34,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CcyTp", skip_serializing_if = "Option::is_none") )]
	pub ccy_tp: Option<BillingCurrencyType2Code>,
}

impl BillingCompensation1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.tp.validate()?;
		self.val.validate()?;
		if let Some(ref val) = self.ccy_tp { val.validate()? }
		Ok(())
	}
}


// BillingCompensationType1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BillingCompensationType1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl BillingCompensationType1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// BillingCurrencyType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum BillingCurrencyType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ACCT") )]
	CodeACCT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "STLM") )]
	CodeSTLM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PRCG") )]
	CodePRCG,
}

impl BillingCurrencyType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// BillingCurrencyType2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum BillingCurrencyType2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ACCT") )]
	CodeACCT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "STLM") )]
	CodeSTLM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PRCG") )]
	CodePRCG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "HOST") )]
	CodeHOST,
}

impl BillingCurrencyType2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// BillingMethod1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BillingMethod1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SvcChrgHstAmt") )]
	pub svc_chrg_hst_amt: AmountAndDirection34,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SvcTax") )]
	pub svc_tax: BillingServicesAmount1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlChrg") )]
	pub ttl_chrg: BillingServicesAmount2,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TaxId") )]
	pub tax_id: Vec<BillingServicesTax1>,
}

impl BillingMethod1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.svc_chrg_hst_amt.validate()?;
		self.svc_tax.validate()?;
		self.ttl_chrg.validate()?;
		for item in &self.tax_id { item.validate()? }
		Ok(())
	}
}


// BillingMethod1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BillingMethod1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MtdA", skip_serializing_if = "Option::is_none") )]
	pub mtd_a: Option<BillingMethod1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MtdB", skip_serializing_if = "Option::is_none") )]
	pub mtd_b: Option<BillingMethod2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MtdD", skip_serializing_if = "Option::is_none") )]
	pub mtd_d: Option<BillingMethod3>,
}

impl BillingMethod1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.mtd_a { val.validate()? }
		if let Some(ref val) = self.mtd_b { val.validate()? }
		if let Some(ref val) = self.mtd_d { val.validate()? }
		Ok(())
	}
}


// BillingMethod2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BillingMethod2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SvcChrgHstAmt") )]
	pub svc_chrg_hst_amt: AmountAndDirection34,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SvcTax") )]
	pub svc_tax: BillingServicesAmount1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TaxId") )]
	pub tax_id: Vec<BillingServicesTax1>,
}

impl BillingMethod2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.svc_chrg_hst_amt.validate()?;
		self.svc_tax.validate()?;
		for item in &self.tax_id { item.validate()? }
		Ok(())
	}
}


// BillingMethod3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BillingMethod3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SvcTaxPricAmt") )]
	pub svc_tax_pric_amt: AmountAndDirection34,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TaxId") )]
	pub tax_id: Vec<BillingServicesTax2>,
}

impl BillingMethod3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.svc_tax_pric_amt.validate()?;
		for item in &self.tax_id { item.validate()? }
		Ok(())
	}
}


// BillingMethod4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BillingMethod4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SvcDtl") )]
	pub svc_dtl: Vec<BillingServiceParameters2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TaxClctn") )]
	pub tax_clctn: TaxCalculation1,
}

impl BillingMethod4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		for item in &self.svc_dtl { item.validate()? }
		self.tax_clctn.validate()?;
		Ok(())
	}
}


// BillingPrice1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BillingPrice1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ccy", skip_serializing_if = "Option::is_none") )]
	pub ccy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnitPric", skip_serializing_if = "Option::is_none") )]
	pub unit_pric: Option<AmountAndDirection34>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Mtd", skip_serializing_if = "Option::is_none") )]
	pub mtd: Option<BillingChargeMethod1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rule", skip_serializing_if = "Option::is_none") )]
	pub rule: Option<String>,
}

impl BillingPrice1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ccy does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.unit_pric { val.validate()? }
		if let Some(ref val) = self.mtd { val.validate()? }
		if let Some(ref val) = self.rule {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "rule is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 20 {
				return Err(ValidationError::new(1002, "rule exceeds the maximum length of 20".to_string()));
			}
		}
		Ok(())
	}
}


// BillingRate1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BillingRate1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: BillingRateIdentification1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val") )]
	pub val: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DaysInPrd", skip_serializing_if = "Option::is_none") )]
	pub days_in_prd: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DaysInYr", skip_serializing_if = "Option::is_none") )]
	pub days_in_yr: Option<f64>,
}

impl BillingRate1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.id.validate()?;
		Ok(())
	}
}


// BillingRateIdentification1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BillingRateIdentification1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl BillingRateIdentification1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// BillingService2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BillingService2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SvcDtl") )]
	pub svc_dtl: BillingServiceParameters3,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pric", skip_serializing_if = "Option::is_none") )]
	pub pric: Option<BillingPrice1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtMtd") )]
	pub pmt_mtd: ServicePaymentMethod1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlChrgPric") )]
	pub orgnl_chrg_pric: AmountAndDirection34,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlChrgSttlmAmt", skip_serializing_if = "Option::is_none") )]
	pub orgnl_chrg_sttlm_amt: Option<AmountAndDirection34>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BalReqrdAcctAmt", skip_serializing_if = "Option::is_none") )]
	pub bal_reqrd_acct_amt: Option<AmountAndDirection34>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TaxDsgnt") )]
	pub tax_dsgnt: ServiceTaxDesignation1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TaxClctn", skip_serializing_if = "Option::is_none") )]
	pub tax_clctn: Option<BillingMethod1Choice>,
}

impl BillingService2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.svc_dtl.validate()?;
		if let Some(ref val) = self.pric { val.validate()? }
		self.pmt_mtd.validate()?;
		self.orgnl_chrg_pric.validate()?;
		if let Some(ref val) = self.orgnl_chrg_sttlm_amt { val.validate()? }
		if let Some(ref val) = self.bal_reqrd_acct_amt { val.validate()? }
		self.tax_dsgnt.validate()?;
		if let Some(ref val) = self.tax_clctn { val.validate()? }
		Ok(())
	}
}


// BillingServiceAdjustment1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BillingServiceAdjustment1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: ServiceAdjustmentType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Desc") )]
	pub desc: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: AmountAndDirection34,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BalReqrdAmt", skip_serializing_if = "Option::is_none") )]
	pub bal_reqrd_amt: Option<AmountAndDirection34>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ErrDt", skip_serializing_if = "Option::is_none") )]
	pub err_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AdjstmntId", skip_serializing_if = "Option::is_none") )]
	pub adjstmnt_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubSvc", skip_serializing_if = "Option::is_none") )]
	pub sub_svc: Option<BillingSubServiceIdentification1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PricChng", skip_serializing_if = "Option::is_none") )]
	pub pric_chng: Option<AmountAndDirection34>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlPric", skip_serializing_if = "Option::is_none") )]
	pub orgnl_pric: Option<AmountAndDirection34>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NewPric", skip_serializing_if = "Option::is_none") )]
	pub new_pric: Option<AmountAndDirection34>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VolChng", skip_serializing_if = "Option::is_none") )]
	pub vol_chng: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlVol", skip_serializing_if = "Option::is_none") )]
	pub orgnl_vol: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NewVol", skip_serializing_if = "Option::is_none") )]
	pub new_vol: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlChrgAmt", skip_serializing_if = "Option::is_none") )]
	pub orgnl_chrg_amt: Option<AmountAndDirection34>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NewChrgAmt", skip_serializing_if = "Option::is_none") )]
	pub new_chrg_amt: Option<AmountAndDirection34>,
}

impl BillingServiceAdjustment1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.tp.validate()?;
		if self.desc.chars().count() < 1 {
			return Err(ValidationError::new(1001, "desc is shorter than the minimum length of 1".to_string()));
		}
		if self.desc.chars().count() > 140 {
			return Err(ValidationError::new(1002, "desc exceeds the maximum length of 140".to_string()));
		}
		self.amt.validate()?;
		if let Some(ref val) = self.bal_reqrd_amt { val.validate()? }
		if let Some(ref val) = self.adjstmnt_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "adjstmnt_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "adjstmnt_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.sub_svc { val.validate()? }
		if let Some(ref val) = self.pric_chng { val.validate()? }
		if let Some(ref val) = self.orgnl_pric { val.validate()? }
		if let Some(ref val) = self.new_pric { val.validate()? }
		if let Some(ref val) = self.orgnl_chrg_amt { val.validate()? }
		if let Some(ref val) = self.new_chrg_amt { val.validate()? }
		Ok(())
	}
}


// BillingServiceCommonIdentification1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BillingServiceCommonIdentification1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr") )]
	pub issr: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
}

impl BillingServiceCommonIdentification1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.issr.chars().count() < 1 {
			return Err(ValidationError::new(1001, "issr is shorter than the minimum length of 1".to_string()));
		}
		if self.issr.chars().count() > 6 {
			return Err(ValidationError::new(1002, "issr exceeds the maximum length of 6".to_string()));
		}
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 8 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 8".to_string()));
		}
		Ok(())
	}
}


// BillingServiceIdentification2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BillingServiceIdentification2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubSvc", skip_serializing_if = "Option::is_none") )]
	pub sub_svc: Option<BillingSubServiceIdentification1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Desc") )]
	pub desc: String,
}

impl BillingServiceIdentification2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.sub_svc { val.validate()? }
		if self.desc.chars().count() < 1 {
			return Err(ValidationError::new(1001, "desc is shorter than the minimum length of 1".to_string()));
		}
		if self.desc.chars().count() > 70 {
			return Err(ValidationError::new(1002, "desc exceeds the maximum length of 70".to_string()));
		}
		Ok(())
	}
}


// BillingServiceIdentification3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BillingServiceIdentification3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubSvc", skip_serializing_if = "Option::is_none") )]
	pub sub_svc: Option<BillingSubServiceIdentification1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Desc") )]
	pub desc: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CmonCd", skip_serializing_if = "Option::is_none") )]
	pub cmon_cd: Option<BillingServiceCommonIdentification1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BkTxCd", skip_serializing_if = "Option::is_none") )]
	pub bk_tx_cd: Option<BankTransactionCodeStructure4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SvcTp", skip_serializing_if = "Option::is_none") )]
	pub svc_tp: Option<String>,
}

impl BillingServiceIdentification3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.sub_svc { val.validate()? }
		if self.desc.chars().count() < 1 {
			return Err(ValidationError::new(1001, "desc is shorter than the minimum length of 1".to_string()));
		}
		if self.desc.chars().count() > 70 {
			return Err(ValidationError::new(1002, "desc exceeds the maximum length of 70".to_string()));
		}
		if let Some(ref val) = self.cmon_cd { val.validate()? }
		if let Some(ref val) = self.bk_tx_cd { val.validate()? }
		if let Some(ref val) = self.svc_tp {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "svc_tp is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 12 {
				return Err(ValidationError::new(1002, "svc_tp exceeds the maximum length of 12".to_string()));
			}
		}
		Ok(())
	}
}


// BillingServiceParameters2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BillingServiceParameters2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BkSvc") )]
	pub bk_svc: BillingServiceIdentification2,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Vol", skip_serializing_if = "Option::is_none") )]
	pub vol: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnitPric", skip_serializing_if = "Option::is_none") )]
	pub unit_pric: Option<AmountAndDirection34>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SvcChrgAmt") )]
	pub svc_chrg_amt: AmountAndDirection34,
}

impl BillingServiceParameters2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.bk_svc.validate()?;
		if let Some(ref val) = self.unit_pric { val.validate()? }
		self.svc_chrg_amt.validate()?;
		Ok(())
	}
}


// BillingServiceParameters3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BillingServiceParameters3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BkSvc") )]
	pub bk_svc: BillingServiceIdentification3,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Vol", skip_serializing_if = "Option::is_none") )]
	pub vol: Option<f64>,
}

impl BillingServiceParameters3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.bk_svc.validate()?;
		Ok(())
	}
}


// BillingServicesAmount1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BillingServicesAmount1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "HstAmt") )]
	pub hst_amt: AmountAndDirection34,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PricgAmt", skip_serializing_if = "Option::is_none") )]
	pub pricg_amt: Option<AmountAndDirection34>,
}

impl BillingServicesAmount1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.hst_amt.validate()?;
		if let Some(ref val) = self.pricg_amt { val.validate()? }
		Ok(())
	}
}


// BillingServicesAmount2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BillingServicesAmount2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "HstAmt") )]
	pub hst_amt: AmountAndDirection34,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttlmAmt", skip_serializing_if = "Option::is_none") )]
	pub sttlm_amt: Option<AmountAndDirection34>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PricgAmt", skip_serializing_if = "Option::is_none") )]
	pub pricg_amt: Option<AmountAndDirection34>,
}

impl BillingServicesAmount2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.hst_amt.validate()?;
		if let Some(ref val) = self.sttlm_amt { val.validate()? }
		if let Some(ref val) = self.pricg_amt { val.validate()? }
		Ok(())
	}
}


// BillingServicesAmount3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BillingServicesAmount3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SrcAmt") )]
	pub src_amt: AmountAndDirection34,
	#[cfg_attr( feature = "derive_serde", serde(rename = "HstAmt") )]
	pub hst_amt: AmountAndDirection34,
}

impl BillingServicesAmount3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.src_amt.validate()?;
		self.hst_amt.validate()?;
		Ok(())
	}
}


// BillingServicesTax1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BillingServicesTax1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nb") )]
	pub nb: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Desc", skip_serializing_if = "Option::is_none") )]
	pub desc: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rate") )]
	pub rate: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "HstAmt") )]
	pub hst_amt: AmountAndDirection34,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PricgAmt", skip_serializing_if = "Option::is_none") )]
	pub pricg_amt: Option<AmountAndDirection34>,
}

impl BillingServicesTax1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.nb.chars().count() < 1 {
			return Err(ValidationError::new(1001, "nb is shorter than the minimum length of 1".to_string()));
		}
		if self.nb.chars().count() > 35 {
			return Err(ValidationError::new(1002, "nb exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.desc {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "desc is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 40 {
				return Err(ValidationError::new(1002, "desc exceeds the maximum length of 40".to_string()));
			}
		}
		self.hst_amt.validate()?;
		if let Some(ref val) = self.pricg_amt { val.validate()? }
		Ok(())
	}
}


// BillingServicesTax2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BillingServicesTax2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nb") )]
	pub nb: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Desc", skip_serializing_if = "Option::is_none") )]
	pub desc: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rate") )]
	pub rate: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PricgAmt") )]
	pub pricg_amt: AmountAndDirection34,
}

impl BillingServicesTax2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.nb.chars().count() < 1 {
			return Err(ValidationError::new(1001, "nb is shorter than the minimum length of 1".to_string()));
		}
		if self.nb.chars().count() > 35 {
			return Err(ValidationError::new(1002, "nb exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.desc {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "desc is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 40 {
				return Err(ValidationError::new(1002, "desc exceeds the maximum length of 40".to_string()));
			}
		}
		self.pricg_amt.validate()?;
		Ok(())
	}
}


// BillingServicesTax3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BillingServicesTax3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nb") )]
	pub nb: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Desc", skip_serializing_if = "Option::is_none") )]
	pub desc: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rate") )]
	pub rate: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlTaxAmt") )]
	pub ttl_tax_amt: AmountAndDirection34,
}

impl BillingServicesTax3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.nb.chars().count() < 1 {
			return Err(ValidationError::new(1001, "nb is shorter than the minimum length of 1".to_string()));
		}
		if self.nb.chars().count() > 35 {
			return Err(ValidationError::new(1002, "nb exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.desc {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "desc is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 40 {
				return Err(ValidationError::new(1002, "desc exceeds the maximum length of 40".to_string()));
			}
		}
		self.ttl_tax_amt.validate()?;
		Ok(())
	}
}


// BillingStatement5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BillingStatement5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "StmtId") )]
	pub stmt_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrToDt") )]
	pub fr_to_dt: DatePeriod1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CreDtTm") )]
	pub cre_dt_tm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sts") )]
	pub sts: BillingStatementStatus1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctChrtcs") )]
	pub acct_chrtcs: CashAccountCharacteristics5,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RateData", skip_serializing_if = "Option::is_none") )]
	pub rate_data: Option<Vec<BillingRate1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CcyXchg", skip_serializing_if = "Option::is_none") )]
	pub ccy_xchg: Option<Vec<CurrencyExchange6>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Bal", skip_serializing_if = "Option::is_none") )]
	pub bal: Option<Vec<BillingBalance1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Compstn", skip_serializing_if = "Option::is_none") )]
	pub compstn: Option<Vec<BillingCompensation1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Svc", skip_serializing_if = "Option::is_none") )]
	pub svc: Option<Vec<BillingService2>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TaxRgn", skip_serializing_if = "Option::is_none") )]
	pub tax_rgn: Option<Vec<BillingTaxRegion3>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BalAdjstmnt", skip_serializing_if = "Option::is_none") )]
	pub bal_adjstmnt: Option<Vec<BalanceAdjustment1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SvcAdjstmnt", skip_serializing_if = "Option::is_none") )]
	pub svc_adjstmnt: Option<Vec<BillingServiceAdjustment1>>,
}

impl BillingStatement5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.stmt_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "stmt_id is shorter than the minimum length of 1".to_string()));
		}
		if self.stmt_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "stmt_id exceeds the maximum length of 35".to_string()));
		}
		self.fr_to_dt.validate()?;
		self.sts.validate()?;
		self.acct_chrtcs.validate()?;
		if let Some(ref vec) = self.rate_data { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.ccy_xchg { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.bal { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.compstn { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.svc { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.tax_rgn { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.bal_adjstmnt { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.svc_adjstmnt { for item in vec { item.validate()? } }
		Ok(())
	}
}


// BillingStatementStatus1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum BillingStatementStatus1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ORGN") )]
	CodeORGN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RPLC") )]
	CodeRPLC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TEST") )]
	CodeTEST,
}

impl BillingStatementStatus1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// BillingSubServiceIdentification1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BillingSubServiceIdentification1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr") )]
	pub issr: BillingSubServiceQualifier1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
}

impl BillingSubServiceIdentification1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.issr.validate()?;
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
		}
		Ok(())
	}
}


// BillingSubServiceQualifier1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BillingSubServiceQualifier1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<BillingSubServiceQualifier1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl BillingSubServiceQualifier1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// BillingSubServiceQualifier1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum BillingSubServiceQualifier1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "LBOX") )]
	CodeLBOX,
	#[cfg_attr( feature = "derive_serde", serde(rename = "STOR") )]
	CodeSTOR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BILA") )]
	CodeBILA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SEQN") )]
	CodeSEQN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MACT") )]
	CodeMACT,
}

impl BillingSubServiceQualifier1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// BillingTaxCalculationMethod1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum BillingTaxCalculationMethod1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "NTAX") )]
	CodeNTAX,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MTDA") )]
	CodeMTDA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MTDB") )]
	CodeMTDB,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MTDC") )]
	CodeMTDC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MTDD") )]
	CodeMTDD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UDFD") )]
	CodeUDFD,
}

impl BillingTaxCalculationMethod1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// BillingTaxIdentification3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BillingTaxIdentification3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "VATRegnNb", skip_serializing_if = "Option::is_none") )]
	pub vat_regn_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TaxRegnNb", skip_serializing_if = "Option::is_none") )]
	pub tax_regn_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TaxCtct", skip_serializing_if = "Option::is_none") )]
	pub tax_ctct: Option<Contact13>,
}

impl BillingTaxIdentification3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.vat_regn_nb {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "vat_regn_nb is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "vat_regn_nb exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.tax_regn_nb {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tax_regn_nb is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "tax_regn_nb exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.tax_ctct { val.validate()? }
		Ok(())
	}
}


// BillingTaxRegion3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BillingTaxRegion3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RgnNb") )]
	pub rgn_nb: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RgnNm") )]
	pub rgn_nm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CstmrTaxId") )]
	pub cstmr_tax_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PtDt", skip_serializing_if = "Option::is_none") )]
	pub pt_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SndgFI", skip_serializing_if = "Option::is_none") )]
	pub sndg_fi: Option<BillingTaxIdentification3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InvcNb", skip_serializing_if = "Option::is_none") )]
	pub invc_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MtdC", skip_serializing_if = "Option::is_none") )]
	pub mtd_c: Option<BillingMethod4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttlmAmt") )]
	pub sttlm_amt: AmountAndDirection34,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TaxDueToRgn") )]
	pub tax_due_to_rgn: AmountAndDirection34,
}

impl BillingTaxRegion3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.rgn_nb.chars().count() < 1 {
			return Err(ValidationError::new(1001, "rgn_nb is shorter than the minimum length of 1".to_string()));
		}
		if self.rgn_nb.chars().count() > 40 {
			return Err(ValidationError::new(1002, "rgn_nb exceeds the maximum length of 40".to_string()));
		}
		if self.rgn_nm.chars().count() < 1 {
			return Err(ValidationError::new(1001, "rgn_nm is shorter than the minimum length of 1".to_string()));
		}
		if self.rgn_nm.chars().count() > 40 {
			return Err(ValidationError::new(1002, "rgn_nm exceeds the maximum length of 40".to_string()));
		}
		if self.cstmr_tax_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "cstmr_tax_id is shorter than the minimum length of 1".to_string()));
		}
		if self.cstmr_tax_id.chars().count() > 40 {
			return Err(ValidationError::new(1002, "cstmr_tax_id exceeds the maximum length of 40".to_string()));
		}
		if let Some(ref val) = self.sndg_fi { val.validate()? }
		if let Some(ref val) = self.invc_nb {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "invc_nb is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 40 {
				return Err(ValidationError::new(1002, "invc_nb exceeds the maximum length of 40".to_string()));
			}
		}
		if let Some(ref val) = self.mtd_c { val.validate()? }
		self.sttlm_amt.validate()?;
		self.tax_due_to_rgn.validate()?;
		Ok(())
	}
}


// BookingConfirmation1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BookingConfirmation1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveOrHistoricCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtDbtInd") )]
	pub cdt_dbt_ind: CreditDebitCode,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XchgRate", skip_serializing_if = "Option::is_none") )]
	pub xchg_rate: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Acct") )]
	pub acct: CashAccount40,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BookgDt", skip_serializing_if = "Option::is_none") )]
	pub bookg_dt: Option<DateAndDateTime2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ValDt") )]
	pub val_dt: DateAndDateTime2Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Refs") )]
	pub refs: TransactionReferences6,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Chrgs", skip_serializing_if = "Option::is_none") )]
	pub chrgs: Option<Charges6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn", skip_serializing_if = "Option::is_none") )]
	pub rsn: Option<String>,
}

impl BookingConfirmation1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.amt.validate()?;
		self.cdt_dbt_ind.validate()?;
		self.acct.validate()?;
		if let Some(ref val) = self.bookg_dt { val.validate()? }
		self.val_dt.validate()?;
		self.refs.validate()?;
		if let Some(ref val) = self.chrgs { val.validate()? }
		if let Some(ref val) = self.rsn {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "rsn is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "rsn exceeds the maximum length of 140".to_string()));
			}
		}
		Ok(())
	}
}


// BranchAndFinancialInstitutionIdentification6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BranchAndFinancialInstitutionIdentification6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FinInstnId") )]
	pub fin_instn_id: FinancialInstitutionIdentification18,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BrnchId", skip_serializing_if = "Option::is_none") )]
	pub brnch_id: Option<BranchData3>,
}

impl BranchAndFinancialInstitutionIdentification6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.fin_instn_id.validate()?;
		if let Some(ref val) = self.brnch_id { val.validate()? }
		Ok(())
	}
}


// BranchAndFinancialInstitutionIdentification8 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BranchAndFinancialInstitutionIdentification8 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FinInstnId") )]
	pub fin_instn_id: FinancialInstitutionIdentification23,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BrnchId", skip_serializing_if = "Option::is_none") )]
	pub brnch_id: Option<BranchData5>,
}

impl BranchAndFinancialInstitutionIdentification8 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.fin_instn_id.validate()?;
		if let Some(ref val) = self.brnch_id { val.validate()? }
		Ok(())
	}
}


// BranchData3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BranchData3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LEI", skip_serializing_if = "Option::is_none") )]
	pub lei: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm", skip_serializing_if = "Option::is_none") )]
	pub nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstlAdr", skip_serializing_if = "Option::is_none") )]
	pub pstl_adr: Option<PostalAddress24>,
}

impl BranchData3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.lei {
			let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "lei does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "nm exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.pstl_adr { val.validate()? }
		Ok(())
	}
}


// BranchData5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BranchData5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LEI", skip_serializing_if = "Option::is_none") )]
	pub lei: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm", skip_serializing_if = "Option::is_none") )]
	pub nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstlAdr", skip_serializing_if = "Option::is_none") )]
	pub pstl_adr: Option<PostalAddress27>,
}

impl BranchData5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.lei {
			let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "lei does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "nm exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.pstl_adr { val.validate()? }
		Ok(())
	}
}


// BreakdownByCountry2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BreakdownByCountry2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ctry") )]
	pub ctry: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshInFcst", skip_serializing_if = "Option::is_none") )]
	pub csh_in_fcst: Option<Vec<CashInForecast5>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshOutFcst", skip_serializing_if = "Option::is_none") )]
	pub csh_out_fcst: Option<Vec<CashOutForecast5>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NetCshFcst", skip_serializing_if = "Option::is_none") )]
	pub net_csh_fcst: Option<Vec<NetCashForecast4>>,
}

impl BreakdownByCountry2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z]{2,2}").unwrap();
		if !pattern.is_match(&self.ctry) {
			return Err(ValidationError::new(1005, "ctry does not match the required pattern".to_string()));
		}
		if let Some(ref vec) = self.csh_in_fcst { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.csh_out_fcst { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.net_csh_fcst { for item in vec { item.validate()? } }
		Ok(())
	}
}


// BreakdownByCurrency2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BreakdownByCurrency2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ccy") )]
	pub ccy: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshOutFcst", skip_serializing_if = "Option::is_none") )]
	pub csh_out_fcst: Option<Vec<CashOutForecast5>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshInFcst", skip_serializing_if = "Option::is_none") )]
	pub csh_in_fcst: Option<Vec<CashInForecast5>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NetCshFcst", skip_serializing_if = "Option::is_none") )]
	pub net_csh_fcst: Option<Vec<NetCashForecast4>>,
}

impl BreakdownByCurrency2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z]{3,3}").unwrap();
		if !pattern.is_match(&self.ccy) {
			return Err(ValidationError::new(1005, "ccy does not match the required pattern".to_string()));
		}
		if let Some(ref vec) = self.csh_out_fcst { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.csh_in_fcst { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.net_csh_fcst { for item in vec { item.validate()? } }
		Ok(())
	}
}


// BreakdownByParty3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BreakdownByParty3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pty") )]
	pub pty: InvestmentAccount42,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlParams", skip_serializing_if = "Option::is_none") )]
	pub addtl_params: Option<AdditionalParameters1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshInFcst", skip_serializing_if = "Option::is_none") )]
	pub csh_in_fcst: Option<Vec<CashInForecast5>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshOutFcst", skip_serializing_if = "Option::is_none") )]
	pub csh_out_fcst: Option<Vec<CashOutForecast5>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NetCshFcst", skip_serializing_if = "Option::is_none") )]
	pub net_csh_fcst: Option<Vec<NetCashForecast4>>,
}

impl BreakdownByParty3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.pty.validate()?;
		if let Some(ref val) = self.addtl_params { val.validate()? }
		if let Some(ref vec) = self.csh_in_fcst { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.csh_out_fcst { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.net_csh_fcst { for item in vec { item.validate()? } }
		Ok(())
	}
}


// BreakdownByUserDefinedParameter3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BreakdownByUserDefinedParameter3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pty", skip_serializing_if = "Option::is_none") )]
	pub pty: Option<InvestmentAccount42>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ctry", skip_serializing_if = "Option::is_none") )]
	pub ctry: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ccy", skip_serializing_if = "Option::is_none") )]
	pub ccy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UsrDfnd", skip_serializing_if = "Option::is_none") )]
	pub usr_dfnd: Option<DataFormat2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshInFcst", skip_serializing_if = "Option::is_none") )]
	pub csh_in_fcst: Option<Vec<CashInForecast5>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshOutFcst", skip_serializing_if = "Option::is_none") )]
	pub csh_out_fcst: Option<Vec<CashOutForecast5>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NetCshFcst", skip_serializing_if = "Option::is_none") )]
	pub net_csh_fcst: Option<Vec<NetCashForecast4>>,
}

impl BreakdownByUserDefinedParameter3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.pty { val.validate()? }
		if let Some(ref val) = self.ctry {
			let pattern = Regex::new("[A-Z]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ctry does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ccy does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.usr_dfnd { val.validate()? }
		if let Some(ref vec) = self.csh_in_fcst { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.csh_out_fcst { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.net_csh_fcst { for item in vec { item.validate()? } }
		Ok(())
	}
}


// BusinessDay8 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BusinessDay8 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SysId") )]
	pub sys_id: Vec<SystemIdentification2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BizDayOrErr") )]
	pub biz_day_or_err: BusinessDayReportOrError10Choice,
}

impl BusinessDay8 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		for item in &self.sys_id { item.validate()? }
		self.biz_day_or_err.validate()?;
		Ok(())
	}
}


// BusinessDay9 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BusinessDay9 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SysDt", skip_serializing_if = "Option::is_none") )]
	pub sys_dt: Option<DateAndDateTime2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SysSts", skip_serializing_if = "Option::is_none") )]
	pub sys_sts: Option<SystemStatus3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SysInfPerCcy", skip_serializing_if = "Option::is_none") )]
	pub sys_inf_per_ccy: Option<Vec<SystemAvailabilityAndEvents3>>,
}

impl BusinessDay9 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.sys_dt { val.validate()? }
		if let Some(ref val) = self.sys_sts { val.validate()? }
		if let Some(ref vec) = self.sys_inf_per_ccy { for item in vec { item.validate()? } }
		Ok(())
	}
}


// BusinessDayCriteria2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BusinessDayCriteria2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NewQryNm", skip_serializing_if = "Option::is_none") )]
	pub new_qry_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SchCrit", skip_serializing_if = "Option::is_none") )]
	pub sch_crit: Option<Vec<BusinessDaySearchCriteria2>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RtrCrit", skip_serializing_if = "Option::is_none") )]
	pub rtr_crit: Option<BusinessDayReturnCriteria2>,
}

impl BusinessDayCriteria2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.new_qry_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "new_qry_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "new_qry_nm exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref vec) = self.sch_crit { for item in vec { item.validate()? } }
		if let Some(ref val) = self.rtr_crit { val.validate()? }
		Ok(())
	}
}


// BusinessDayCriteria3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BusinessDayCriteria3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "QryNm", skip_serializing_if = "Option::is_none") )]
	pub qry_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NewCrit", skip_serializing_if = "Option::is_none") )]
	pub new_crit: Option<BusinessDayCriteria2>,
}

impl BusinessDayCriteria3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.qry_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "qry_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "qry_nm exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.new_crit { val.validate()? }
		Ok(())
	}
}


// BusinessDayQuery2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BusinessDayQuery2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "QryTp", skip_serializing_if = "Option::is_none") )]
	pub qry_tp: Option<QueryType2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Crit", skip_serializing_if = "Option::is_none") )]
	pub crit: Option<BusinessDayCriteria3Choice>,
}

impl BusinessDayQuery2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.qry_tp { val.validate()? }
		if let Some(ref val) = self.crit { val.validate()? }
		Ok(())
	}
}


// BusinessDayReportOrError10Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BusinessDayReportOrError10Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BizDayInf", skip_serializing_if = "Option::is_none") )]
	pub biz_day_inf: Option<BusinessDay9>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BizErr", skip_serializing_if = "Option::is_none") )]
	pub biz_err: Option<Vec<ErrorHandling5>>,
}

impl BusinessDayReportOrError10Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.biz_day_inf { val.validate()? }
		if let Some(ref vec) = self.biz_err { for item in vec { item.validate()? } }
		Ok(())
	}
}


// BusinessDayReportOrError9Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BusinessDayReportOrError9Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BizRpt", skip_serializing_if = "Option::is_none") )]
	pub biz_rpt: Option<Vec<BusinessDay8>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OprlErr", skip_serializing_if = "Option::is_none") )]
	pub oprl_err: Option<Vec<ErrorHandling5>>,
}

impl BusinessDayReportOrError9Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.biz_rpt { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.oprl_err { for item in vec { item.validate()? } }
		Ok(())
	}
}


// BusinessDayReturnCriteria2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BusinessDayReturnCriteria2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SysDtInd", skip_serializing_if = "Option::is_none") )]
	pub sys_dt_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SysStsInd", skip_serializing_if = "Option::is_none") )]
	pub sys_sts_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SysCcyInd", skip_serializing_if = "Option::is_none") )]
	pub sys_ccy_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClsrPrdInd", skip_serializing_if = "Option::is_none") )]
	pub clsr_prd_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EvtInd", skip_serializing_if = "Option::is_none") )]
	pub evt_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SsnPrdInd", skip_serializing_if = "Option::is_none") )]
	pub ssn_prd_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EvtTpInd", skip_serializing_if = "Option::is_none") )]
	pub evt_tp_ind: Option<bool>,
}

impl BusinessDayReturnCriteria2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// BusinessDaySearchCriteria2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BusinessDaySearchCriteria2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SysDt", skip_serializing_if = "Option::is_none") )]
	pub sys_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SysId", skip_serializing_if = "Option::is_none") )]
	pub sys_id: Option<Vec<SystemIdentification2Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SysCcy", skip_serializing_if = "Option::is_none") )]
	pub sys_ccy: Option<Vec<String>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EvtTp", skip_serializing_if = "Option::is_none") )]
	pub evt_tp: Option<SystemEventType2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClsrPrd", skip_serializing_if = "Option::is_none") )]
	pub clsr_prd: Option<DateTimePeriod1Choice>,
}

impl BusinessDaySearchCriteria2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.sys_id { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.sys_ccy {
			for item in vec {
				let pattern = Regex::new("[A-Z]{3,3}").unwrap();
				if !pattern.is_match(&item) {
					return Err(ValidationError::new(1005, "sys_ccy does not match the required pattern".to_string()));
				}
			}
		}
		if let Some(ref val) = self.evt_tp { val.validate()? }
		if let Some(ref val) = self.clsr_prd { val.validate()? }
		Ok(())
	}
}


// BusinessInformationCriteria1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BusinessInformationCriteria1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NewQryNm", skip_serializing_if = "Option::is_none") )]
	pub new_qry_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SchCrit", skip_serializing_if = "Option::is_none") )]
	pub sch_crit: Option<Vec<GeneralBusinessInformationSearchCriteria1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RtrCrit", skip_serializing_if = "Option::is_none") )]
	pub rtr_crit: Option<GeneralBusinessInformationReturnCriteria1>,
}

impl BusinessInformationCriteria1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.new_qry_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "new_qry_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "new_qry_nm exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref vec) = self.sch_crit { for item in vec { item.validate()? } }
		if let Some(ref val) = self.rtr_crit { val.validate()? }
		Ok(())
	}
}


// BusinessInformationQueryDefinition3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct BusinessInformationQueryDefinition3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "QryTp", skip_serializing_if = "Option::is_none") )]
	pub qry_tp: Option<QueryType2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GnlBizInfCrit", skip_serializing_if = "Option::is_none") )]
	pub gnl_biz_inf_crit: Option<GeneralBusinessInformationCriteriaDefinition1Choice>,
}

impl BusinessInformationQueryDefinition3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.qry_tp { val.validate()? }
		if let Some(ref val) = self.gnl_biz_inf_crit { val.validate()? }
		Ok(())
	}
}


// CSCManagement1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum CSCManagement1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "PRST") )]
	CodePRST,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BYPS") )]
	CodeBYPS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UNRD") )]
	CodeUNRD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NCSC") )]
	CodeNCSC,
}

impl CSCManagement1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// CallIn1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum CallIn1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "CFAV") )]
	CodeCFAV,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CFST") )]
	CodeCFST,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CFCC") )]
	CodeCFCC,
}

impl CallIn1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// CancellationIndividualStatus1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum CancellationIndividualStatus1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "RJCR") )]
	CodeRJCR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ACCR") )]
	CodeACCR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PDCR") )]
	CodePDCR,
}

impl CancellationIndividualStatus1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// CancellationProcessingStatus3Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum CancellationProcessingStatus3Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "CANP") )]
	CodeCANP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "REJT") )]
	CodeREJT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "REPR") )]
	CodeREPR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PACK") )]
	CodePACK,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DEND") )]
	CodeDEND,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CAND") )]
	CodeCAND,
}

impl CancellationProcessingStatus3Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// CancellationProcessingStatus9Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CancellationProcessingStatus9Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<CancellationProcessingStatus3Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification30>,
}

impl CancellationProcessingStatus9Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// CancellationReason10 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CancellationReason10 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd") )]
	pub cd: CancellationReason21Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlRsnInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_rsn_inf: Option<String>,
}

impl CancellationReason10 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.cd.validate()?;
		if let Some(ref val) = self.addtl_rsn_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_rsn_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 210 {
				return Err(ValidationError::new(1002, "addtl_rsn_inf exceeds the maximum length of 210".to_string()));
			}
		}
		Ok(())
	}
}


// CancellationReason19Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CancellationReason19Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<CancelledStatusReason13Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification30>,
}

impl CancellationReason19Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// CancellationReason21Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CancellationReason21Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<CancelledStatusReason5Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification30>,
}

impl CancellationReason21Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// CancellationReason33Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CancellationReason33Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl CancellationReason33Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// CancellationReason9 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CancellationReason9 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd") )]
	pub cd: CancellationReason19Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlRsnInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_rsn_inf: Option<String>,
}

impl CancellationReason9 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.cd.validate()?;
		if let Some(ref val) = self.addtl_rsn_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_rsn_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 210 {
				return Err(ValidationError::new(1002, "addtl_rsn_inf exceeds the maximum length of 210".to_string()));
			}
		}
		Ok(())
	}
}


// CancellationStatus14Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CancellationStatus14Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NoSpcfdRsn", skip_serializing_if = "Option::is_none") )]
	pub no_spcfd_rsn: Option<NoReasonCode>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn", skip_serializing_if = "Option::is_none") )]
	pub rsn: Option<Vec<CancellationReason9>>,
}

impl CancellationStatus14Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.no_spcfd_rsn { val.validate()? }
		if let Some(ref vec) = self.rsn { for item in vec { item.validate()? } }
		Ok(())
	}
}


// CancellationStatus15Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CancellationStatus15Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NoSpcfdRsn", skip_serializing_if = "Option::is_none") )]
	pub no_spcfd_rsn: Option<NoReasonCode>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn", skip_serializing_if = "Option::is_none") )]
	pub rsn: Option<Vec<CancellationReason10>>,
}

impl CancellationStatus15Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.no_spcfd_rsn { val.validate()? }
		if let Some(ref vec) = self.rsn { for item in vec { item.validate()? } }
		Ok(())
	}
}


// CancellationStatusReason3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CancellationStatusReason3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl CancellationStatusReason3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// CancellationStatusReason5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CancellationStatusReason5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Orgtr", skip_serializing_if = "Option::is_none") )]
	pub orgtr: Option<PartyIdentification272>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn", skip_serializing_if = "Option::is_none") )]
	pub rsn: Option<CancellationStatusReason3Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_inf: Option<Vec<String>>,
}

impl CancellationStatusReason5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.orgtr { val.validate()? }
		if let Some(ref val) = self.rsn { val.validate()? }
		if let Some(ref vec) = self.addtl_inf {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "addtl_inf is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 105 {
					return Err(ValidationError::new(1002, "addtl_inf exceeds the maximum length of 105".to_string()));
				}
			}
		}
		Ok(())
	}
}


// CancelledStatusReason13Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum CancelledStatusReason13Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "CANI") )]
	CodeCANI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CANS") )]
	CodeCANS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CSUB") )]
	CodeCSUB,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CXLR") )]
	CodeCXLR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CANT") )]
	CodeCANT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CANZ") )]
	CodeCANZ,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CORP") )]
	CodeCORP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SCEX") )]
	CodeSCEX,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CTHP") )]
	CodeCTHP,
}

impl CancelledStatusReason13Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// CancelledStatusReason1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum CancelledStatusReason1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "CANI") )]
	CodeCANI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CANS") )]
	CodeCANS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CSUB") )]
	CodeCSUB,
}

impl CancelledStatusReason1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// CancelledStatusReason5Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum CancelledStatusReason5Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "CANI") )]
	CodeCANI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
}

impl CancelledStatusReason5Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// CardAggregated2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CardAggregated2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlSvc", skip_serializing_if = "Option::is_none") )]
	pub addtl_svc: Option<CardPaymentServiceType2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxCtgy", skip_serializing_if = "Option::is_none") )]
	pub tx_ctgy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SaleRcncltnId", skip_serializing_if = "Option::is_none") )]
	pub sale_rcncltn_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SeqNbRg", skip_serializing_if = "Option::is_none") )]
	pub seq_nb_rg: Option<CardSequenceNumberRange1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxDtRg", skip_serializing_if = "Option::is_none") )]
	pub tx_dt_rg: Option<DateOrDateTimePeriod1Choice>,
}

impl CardAggregated2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.addtl_svc { val.validate()? }
		if let Some(ref val) = self.tx_ctgy {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tx_ctgy is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "tx_ctgy exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.sale_rcncltn_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "sale_rcncltn_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "sale_rcncltn_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.seq_nb_rg { val.validate()? }
		if let Some(ref val) = self.tx_dt_rg { val.validate()? }
		Ok(())
	}
}


// CardDataReading1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum CardDataReading1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "TAGC") )]
	CodeTAGC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PHYS") )]
	CodePHYS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BRCD") )]
	CodeBRCD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MGST") )]
	CodeMGST,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CICC") )]
	CodeCICC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DFLE") )]
	CodeDFLE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CTLS") )]
	CodeCTLS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ECTL") )]
	CodeECTL,
}

impl CardDataReading1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// CardEntry5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CardEntry5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Card", skip_serializing_if = "Option::is_none") )]
	pub card: Option<PaymentCard4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "POI", skip_serializing_if = "Option::is_none") )]
	pub poi: Option<PointOfInteraction1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AggtdNtry", skip_serializing_if = "Option::is_none") )]
	pub aggtd_ntry: Option<CardAggregated2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrePdAcct", skip_serializing_if = "Option::is_none") )]
	pub pre_pd_acct: Option<CashAccount40>,
}

impl CardEntry5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.card { val.validate()? }
		if let Some(ref val) = self.poi { val.validate()? }
		if let Some(ref val) = self.aggtd_ntry { val.validate()? }
		if let Some(ref val) = self.pre_pd_acct { val.validate()? }
		Ok(())
	}
}


// CardIndividualTransaction2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CardIndividualTransaction2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ICCRltdData", skip_serializing_if = "Option::is_none") )]
	pub icc_rltd_data: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtCntxt", skip_serializing_if = "Option::is_none") )]
	pub pmt_cntxt: Option<PaymentContext3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlSvc", skip_serializing_if = "Option::is_none") )]
	pub addtl_svc: Option<CardPaymentServiceType2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxCtgy", skip_serializing_if = "Option::is_none") )]
	pub tx_ctgy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SaleRcncltnId", skip_serializing_if = "Option::is_none") )]
	pub sale_rcncltn_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SaleRefNb", skip_serializing_if = "Option::is_none") )]
	pub sale_ref_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RePresntmntRsn", skip_serializing_if = "Option::is_none") )]
	pub re_presntmnt_rsn: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SeqNb", skip_serializing_if = "Option::is_none") )]
	pub seq_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxId", skip_serializing_if = "Option::is_none") )]
	pub tx_id: Option<TransactionIdentifier1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pdct", skip_serializing_if = "Option::is_none") )]
	pub pdct: Option<Product2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VldtnDt", skip_serializing_if = "Option::is_none") )]
	pub vldtn_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VldtnSeqNb", skip_serializing_if = "Option::is_none") )]
	pub vldtn_seq_nb: Option<String>,
}

impl CardIndividualTransaction2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.icc_rltd_data {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "icc_rltd_data is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 1025 {
				return Err(ValidationError::new(1002, "icc_rltd_data exceeds the maximum length of 1025".to_string()));
			}
		}
		if let Some(ref val) = self.pmt_cntxt { val.validate()? }
		if let Some(ref val) = self.addtl_svc { val.validate()? }
		if let Some(ref val) = self.tx_ctgy {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tx_ctgy is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "tx_ctgy exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.sale_rcncltn_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "sale_rcncltn_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "sale_rcncltn_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.sale_ref_nb {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "sale_ref_nb is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "sale_ref_nb exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.re_presntmnt_rsn {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "re_presntmnt_rsn is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "re_presntmnt_rsn exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.seq_nb {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "seq_nb is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "seq_nb exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.tx_id { val.validate()? }
		if let Some(ref val) = self.pdct { val.validate()? }
		if let Some(ref val) = self.vldtn_seq_nb {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "vldtn_seq_nb is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "vldtn_seq_nb exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// CardPaymentServiceType2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum CardPaymentServiceType2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "AGGR") )]
	CodeAGGR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DCCV") )]
	CodeDCCV,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GRTT") )]
	CodeGRTT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INSP") )]
	CodeINSP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LOYT") )]
	CodeLOYT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NRES") )]
	CodeNRES,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PUCO") )]
	CodePUCO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RECP") )]
	CodeRECP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SOAF") )]
	CodeSOAF,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UNAF") )]
	CodeUNAF,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VCAU") )]
	CodeVCAU,
}

impl CardPaymentServiceType2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// CardSecurityInformation1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CardSecurityInformation1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CSCMgmt") )]
	pub csc_mgmt: CSCManagement1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CSCVal", skip_serializing_if = "Option::is_none") )]
	pub csc_val: Option<String>,
}

impl CardSecurityInformation1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.csc_mgmt.validate()?;
		if let Some(ref val) = self.csc_val {
			let pattern = Regex::new("[0-9]{3,4}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "csc_val does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// CardSequenceNumberRange1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CardSequenceNumberRange1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrstTx", skip_serializing_if = "Option::is_none") )]
	pub frst_tx: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LastTx", skip_serializing_if = "Option::is_none") )]
	pub last_tx: Option<String>,
}

impl CardSequenceNumberRange1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.frst_tx {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "frst_tx is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "frst_tx exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.last_tx {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "last_tx is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "last_tx exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// CardTransaction18 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CardTransaction18 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Card", skip_serializing_if = "Option::is_none") )]
	pub card: Option<PaymentCard4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "POI", skip_serializing_if = "Option::is_none") )]
	pub poi: Option<PointOfInteraction1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tx", skip_serializing_if = "Option::is_none") )]
	pub tx: Option<CardTransaction3Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrePdAcct", skip_serializing_if = "Option::is_none") )]
	pub pre_pd_acct: Option<CashAccount40>,
}

impl CardTransaction18 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.card { val.validate()? }
		if let Some(ref val) = self.poi { val.validate()? }
		if let Some(ref val) = self.tx { val.validate()? }
		if let Some(ref val) = self.pre_pd_acct { val.validate()? }
		Ok(())
	}
}


// CardTransaction3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CardTransaction3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Aggtd", skip_serializing_if = "Option::is_none") )]
	pub aggtd: Option<CardAggregated2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Indv", skip_serializing_if = "Option::is_none") )]
	pub indv: Option<CardIndividualTransaction2>,
}

impl CardTransaction3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.aggtd { val.validate()? }
		if let Some(ref val) = self.indv { val.validate()? }
		Ok(())
	}
}


// CardholderAuthentication2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CardholderAuthentication2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AuthntcnMtd") )]
	pub authntcn_mtd: AuthenticationMethod1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AuthntcnNtty") )]
	pub authntcn_ntty: AuthenticationEntity1Code,
}

impl CardholderAuthentication2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.authntcn_mtd.validate()?;
		self.authntcn_ntty.validate()?;
		Ok(())
	}
}


// CardholderVerificationCapability1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum CardholderVerificationCapability1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "MNSG") )]
	CodeMNSG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NPIN") )]
	CodeNPIN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FCPN") )]
	CodeFCPN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FEPN") )]
	CodeFEPN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FDSG") )]
	CodeFDSG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FBIO") )]
	CodeFBIO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MNVR") )]
	CodeMNVR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FBIG") )]
	CodeFBIG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "APKI") )]
	CodeAPKI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PKIS") )]
	CodePKIS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CHDT") )]
	CodeCHDT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SCEC") )]
	CodeSCEC,
}

impl CardholderVerificationCapability1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// Case6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Case6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cretr") )]
	pub cretr: Party50Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReopCaseIndctn", skip_serializing_if = "Option::is_none") )]
	pub reop_case_indctn: Option<bool>,
}

impl Case6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
		}
		self.cretr.validate()?;
		Ok(())
	}
}


// CaseAssignment6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CaseAssignment6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Assgnr") )]
	pub assgnr: Party50Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Assgne") )]
	pub assgne: Party50Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CreDtTm") )]
	pub cre_dt_tm: String,
}

impl CaseAssignment6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
		}
		self.assgnr.validate()?;
		self.assgne.validate()?;
		Ok(())
	}
}


// CaseForwardingNotification3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CaseForwardingNotification3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Justfn") )]
	pub justfn: CaseForwardingNotification3Code,
}

impl CaseForwardingNotification3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.justfn.validate()?;
		Ok(())
	}
}


// CaseForwardingNotification3Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum CaseForwardingNotification3Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "FTHI") )]
	CodeFTHI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CANC") )]
	CodeCANC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MODI") )]
	CodeMODI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DTAU") )]
	CodeDTAU,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SAIN") )]
	CodeSAIN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MINE") )]
	CodeMINE,
}

impl CaseForwardingNotification3Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// CaseStatus2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CaseStatus2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtTm") )]
	pub dt_tm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CaseSts") )]
	pub case_sts: CaseStatus2Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn", skip_serializing_if = "Option::is_none") )]
	pub rsn: Option<String>,
}

impl CaseStatus2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.case_sts.validate()?;
		if let Some(ref val) = self.rsn {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "rsn is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "rsn exceeds the maximum length of 140".to_string()));
			}
		}
		Ok(())
	}
}


// CaseStatus2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum CaseStatus2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "CLSD") )]
	CodeCLSD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ASGN") )]
	CodeASGN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INVE") )]
	CodeINVE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UKNW") )]
	CodeUKNW,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ODUE") )]
	CodeODUE,
}

impl CaseStatus2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// CashAccount40 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CashAccount40 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<AccountIdentification4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<CashAccountType2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ccy", skip_serializing_if = "Option::is_none") )]
	pub ccy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm", skip_serializing_if = "Option::is_none") )]
	pub nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prxy", skip_serializing_if = "Option::is_none") )]
	pub prxy: Option<ProxyAccountIdentification1>,
}

impl CashAccount40 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.id { val.validate()? }
		if let Some(ref val) = self.tp { val.validate()? }
		if let Some(ref val) = self.ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ccy does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 70 {
				return Err(ValidationError::new(1002, "nm exceeds the maximum length of 70".to_string()));
			}
		}
		if let Some(ref val) = self.prxy { val.validate()? }
		Ok(())
	}
}


// CashAccount43 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CashAccount43 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<AccountIdentification4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<CashAccountType2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ccy", skip_serializing_if = "Option::is_none") )]
	pub ccy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm", skip_serializing_if = "Option::is_none") )]
	pub nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prxy", skip_serializing_if = "Option::is_none") )]
	pub prxy: Option<ProxyAccountIdentification1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ownr", skip_serializing_if = "Option::is_none") )]
	pub ownr: Option<PartyIdentification272>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Svcr", skip_serializing_if = "Option::is_none") )]
	pub svcr: Option<BranchAndFinancialInstitutionIdentification8>,
}

impl CashAccount43 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.id { val.validate()? }
		if let Some(ref val) = self.tp { val.validate()? }
		if let Some(ref val) = self.ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ccy does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 70 {
				return Err(ValidationError::new(1002, "nm exceeds the maximum length of 70".to_string()));
			}
		}
		if let Some(ref val) = self.prxy { val.validate()? }
		if let Some(ref val) = self.ownr { val.validate()? }
		if let Some(ref val) = self.svcr { val.validate()? }
		Ok(())
	}
}


// CashAccountAndEntry5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CashAccountAndEntry5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Acct") )]
	pub acct: CashAccount43,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ntry", skip_serializing_if = "Option::is_none") )]
	pub ntry: Option<CashEntry2>,
}

impl CashAccountAndEntry5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.acct.validate()?;
		if let Some(ref val) = self.ntry { val.validate()? }
		Ok(())
	}
}


// CashAccountCharacteristics5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CashAccountCharacteristics5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctLvl") )]
	pub acct_lvl: AccountLevel2Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshAcct") )]
	pub csh_acct: CashAccount40,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctSvcr", skip_serializing_if = "Option::is_none") )]
	pub acct_svcr: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrntAcct", skip_serializing_if = "Option::is_none") )]
	pub prnt_acct: Option<ParentCashAccount5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CompstnMtd") )]
	pub compstn_mtd: CompensationMethod1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtAcct", skip_serializing_if = "Option::is_none") )]
	pub dbt_acct: Option<AccountIdentification4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DelydDbtDt", skip_serializing_if = "Option::is_none") )]
	pub delyd_dbt_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttlmAdvc", skip_serializing_if = "Option::is_none") )]
	pub sttlm_advc: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctBalCcyCd") )]
	pub acct_bal_ccy_cd: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttlmCcyCd", skip_serializing_if = "Option::is_none") )]
	pub sttlm_ccy_cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "HstCcyCd", skip_serializing_if = "Option::is_none") )]
	pub hst_ccy_cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tax", skip_serializing_if = "Option::is_none") )]
	pub tax: Option<AccountTax1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctSvcrCtct") )]
	pub acct_svcr_ctct: Contact13,
}

impl CashAccountCharacteristics5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.acct_lvl.validate()?;
		self.csh_acct.validate()?;
		if let Some(ref val) = self.acct_svcr { val.validate()? }
		if let Some(ref val) = self.prnt_acct { val.validate()? }
		self.compstn_mtd.validate()?;
		if let Some(ref val) = self.dbt_acct { val.validate()? }
		if let Some(ref val) = self.sttlm_advc {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "sttlm_advc is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 105 {
				return Err(ValidationError::new(1002, "sttlm_advc exceeds the maximum length of 105".to_string()));
			}
		}
		let pattern = Regex::new("[A-Z]{3,3}").unwrap();
		if !pattern.is_match(&self.acct_bal_ccy_cd) {
			return Err(ValidationError::new(1005, "acct_bal_ccy_cd does not match the required pattern".to_string()));
		}
		if let Some(ref val) = self.sttlm_ccy_cd {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "sttlm_ccy_cd does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.hst_ccy_cd {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "hst_ccy_cd does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.tax { val.validate()? }
		self.acct_svcr_ctct.validate()?;
		Ok(())
	}
}


// CashAccountData1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CashAccountData1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm", skip_serializing_if = "Option::is_none") )]
	pub nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<CashAccountType2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ccy", skip_serializing_if = "Option::is_none") )]
	pub ccy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prxy", skip_serializing_if = "Option::is_none") )]
	pub prxy: Option<ProxyAccountIdentification1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CurMulLmt", skip_serializing_if = "Option::is_none") )]
	pub cur_mul_lmt: Option<Limit5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ownr", skip_serializing_if = "Option::is_none") )]
	pub ownr: Option<PartyIdentification272>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Svcr", skip_serializing_if = "Option::is_none") )]
	pub svcr: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MulBal", skip_serializing_if = "Option::is_none") )]
	pub mul_bal: Option<Vec<CashBalance13>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CurBilLmt", skip_serializing_if = "Option::is_none") )]
	pub cur_bil_lmt: Option<Vec<BilateralLimit4>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StgOrdr", skip_serializing_if = "Option::is_none") )]
	pub stg_ordr: Option<Vec<StandingOrder11>>,
}

impl CashAccountData1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 70 {
				return Err(ValidationError::new(1002, "nm exceeds the maximum length of 70".to_string()));
			}
		}
		if let Some(ref val) = self.tp { val.validate()? }
		if let Some(ref val) = self.ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ccy does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.prxy { val.validate()? }
		if let Some(ref val) = self.cur_mul_lmt { val.validate()? }
		if let Some(ref val) = self.ownr { val.validate()? }
		if let Some(ref val) = self.svcr { val.validate()? }
		if let Some(ref vec) = self.mul_bal { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.cur_bil_lmt { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.stg_ordr { for item in vec { item.validate()? } }
		Ok(())
	}
}


// CashAccountEntrySearch8 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CashAccountEntrySearch8 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctId", skip_serializing_if = "Option::is_none") )]
	pub acct_id: Option<Vec<AccountIdentificationSearchCriteria2Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtryAmt", skip_serializing_if = "Option::is_none") )]
	pub ntry_amt: Option<Vec<ActiveOrHistoricAmountRange2Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtryAmtCcy", skip_serializing_if = "Option::is_none") )]
	pub ntry_amt_ccy: Option<Vec<String>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtDbtInd", skip_serializing_if = "Option::is_none") )]
	pub cdt_dbt_ind: Option<CreditDebitCode>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtrySts", skip_serializing_if = "Option::is_none") )]
	pub ntry_sts: Option<Vec<EntryStatus1Code>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtryDt", skip_serializing_if = "Option::is_none") )]
	pub ntry_dt: Option<Vec<DateAndDateTimeSearch3Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctOwnr", skip_serializing_if = "Option::is_none") )]
	pub acct_ownr: Option<PartyIdentification272>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctSvcr", skip_serializing_if = "Option::is_none") )]
	pub acct_svcr: Option<BranchAndFinancialInstitutionIdentification8>,
}

impl CashAccountEntrySearch8 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.acct_id { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.ntry_amt { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.ntry_amt_ccy {
			for item in vec {
				let pattern = Regex::new("[A-Z]{3,3}").unwrap();
				if !pattern.is_match(&item) {
					return Err(ValidationError::new(1005, "ntry_amt_ccy does not match the required pattern".to_string()));
				}
			}
		}
		if let Some(ref val) = self.cdt_dbt_ind { val.validate()? }
		if let Some(ref vec) = self.ntry_sts { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.ntry_dt { for item in vec { item.validate()? } }
		if let Some(ref val) = self.acct_ownr { val.validate()? }
		if let Some(ref val) = self.acct_svcr { val.validate()? }
		Ok(())
	}
}


// CashAccountReturnCriteria5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CashAccountReturnCriteria5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NmInd", skip_serializing_if = "Option::is_none") )]
	pub nm_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CcyInd", skip_serializing_if = "Option::is_none") )]
	pub ccy_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TpInd", skip_serializing_if = "Option::is_none") )]
	pub tp_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MulLmtInd", skip_serializing_if = "Option::is_none") )]
	pub mul_lmt_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MulBalRtrCrit", skip_serializing_if = "Option::is_none") )]
	pub mul_bal_rtr_crit: Option<CashBalanceReturnCriteria2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BilLmtInd", skip_serializing_if = "Option::is_none") )]
	pub bil_lmt_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BilBalRtrCrit", skip_serializing_if = "Option::is_none") )]
	pub bil_bal_rtr_crit: Option<CashBalanceReturnCriteria2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StgOrdrInd", skip_serializing_if = "Option::is_none") )]
	pub stg_ordr_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctOwnrInd", skip_serializing_if = "Option::is_none") )]
	pub acct_ownr_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctSvcrInd", skip_serializing_if = "Option::is_none") )]
	pub acct_svcr_ind: Option<bool>,
}

impl CashAccountReturnCriteria5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.mul_bal_rtr_crit { val.validate()? }
		if let Some(ref val) = self.bil_bal_rtr_crit { val.validate()? }
		Ok(())
	}
}


// CashAccountSearchCriteria8 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CashAccountSearchCriteria8 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctId", skip_serializing_if = "Option::is_none") )]
	pub acct_id: Option<Vec<AccountIdentificationSearchCriteria2Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<Vec<CashAccountType2Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ccy", skip_serializing_if = "Option::is_none") )]
	pub ccy: Option<Vec<String>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Bal", skip_serializing_if = "Option::is_none") )]
	pub bal: Option<Vec<CashBalance14>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctOwnr", skip_serializing_if = "Option::is_none") )]
	pub acct_ownr: Option<PartyIdentification272>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctSvcr", skip_serializing_if = "Option::is_none") )]
	pub acct_svcr: Option<BranchAndFinancialInstitutionIdentification8>,
}

impl CashAccountSearchCriteria8 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.acct_id { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.tp { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.ccy {
			for item in vec {
				let pattern = Regex::new("[A-Z]{3,3}").unwrap();
				if !pattern.is_match(&item) {
					return Err(ValidationError::new(1005, "ccy does not match the required pattern".to_string()));
				}
			}
		}
		if let Some(ref vec) = self.bal { for item in vec { item.validate()? } }
		if let Some(ref val) = self.acct_ownr { val.validate()? }
		if let Some(ref val) = self.acct_svcr { val.validate()? }
		Ok(())
	}
}


// CashAccountType2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CashAccountType2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl CashAccountType2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// CashAvailability1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CashAvailability1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dt") )]
	pub dt: CashAvailabilityDate1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveOrHistoricCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtDbtInd") )]
	pub cdt_dbt_ind: CreditDebitCode,
}

impl CashAvailability1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.dt.validate()?;
		self.amt.validate()?;
		self.cdt_dbt_ind.validate()?;
		Ok(())
	}
}


// CashAvailabilityDate1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CashAvailabilityDate1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfDays", skip_serializing_if = "Option::is_none") )]
	pub nb_of_days: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ActlDt", skip_serializing_if = "Option::is_none") )]
	pub actl_dt: Option<String>,
}

impl CashAvailabilityDate1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.nb_of_days {
			let pattern = Regex::new("[\\+]{0,1}[0-9]{1,15}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "nb_of_days does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// CashBalance11 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CashBalance11 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtDbtInd") )]
	pub cdt_dbt_ind: CreditDebitCode,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<BalanceType9Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sts", skip_serializing_if = "Option::is_none") )]
	pub sts: Option<BalanceStatus1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ValDt", skip_serializing_if = "Option::is_none") )]
	pub val_dt: Option<DateAndDateTime2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfPmts", skip_serializing_if = "Option::is_none") )]
	pub nb_of_pmts: Option<f64>,
}

impl CashBalance11 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.amt < 0.000000 {
			return Err(ValidationError::new(1003, "amt is less than the minimum value of 0.000000".to_string()));
		}
		self.cdt_dbt_ind.validate()?;
		if let Some(ref val) = self.tp { val.validate()? }
		if let Some(ref val) = self.sts { val.validate()? }
		if let Some(ref val) = self.val_dt { val.validate()? }
		Ok(())
	}
}


// CashBalance13 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CashBalance13 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtDbtInd") )]
	pub cdt_dbt_ind: CreditDebitCode,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<BalanceType11Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sts", skip_serializing_if = "Option::is_none") )]
	pub sts: Option<BalanceStatus1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ValDt", skip_serializing_if = "Option::is_none") )]
	pub val_dt: Option<DateAndDateTime2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrcgDt", skip_serializing_if = "Option::is_none") )]
	pub prcg_dt: Option<DateAndDateTime2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfPmts", skip_serializing_if = "Option::is_none") )]
	pub nb_of_pmts: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RstrctnTp", skip_serializing_if = "Option::is_none") )]
	pub rstrctn_tp: Option<BalanceRestrictionType1>,
}

impl CashBalance13 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.amt < 0.000000 {
			return Err(ValidationError::new(1003, "amt is less than the minimum value of 0.000000".to_string()));
		}
		self.cdt_dbt_ind.validate()?;
		if let Some(ref val) = self.tp { val.validate()? }
		if let Some(ref val) = self.sts { val.validate()? }
		if let Some(ref val) = self.val_dt { val.validate()? }
		if let Some(ref val) = self.prcg_dt { val.validate()? }
		if let Some(ref val) = self.rstrctn_tp { val.validate()? }
		Ok(())
	}
}


// CashBalance14 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CashBalance14 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<Vec<BalanceType11Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPtyTp") )]
	pub ctr_pty_tp: BalanceCounterparty1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPtyId", skip_serializing_if = "Option::is_none") )]
	pub ctr_pty_id: Option<Vec<BranchAndFinancialInstitutionIdentification8>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ValDt", skip_serializing_if = "Option::is_none") )]
	pub val_dt: Option<Vec<DateAndDateTimeSearch4Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrcgDt", skip_serializing_if = "Option::is_none") )]
	pub prcg_dt: Option<DateAndDateTimeSearch4Choice>,
}

impl CashBalance14 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.tp { for item in vec { item.validate()? } }
		self.ctr_pty_tp.validate()?;
		if let Some(ref vec) = self.ctr_pty_id { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.val_dt { for item in vec { item.validate()? } }
		if let Some(ref val) = self.prcg_dt { val.validate()? }
		Ok(())
	}
}


// CashBalance8 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CashBalance8 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: BalanceType13,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtLine", skip_serializing_if = "Option::is_none") )]
	pub cdt_line: Option<Vec<CreditLine3>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveOrHistoricCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtDbtInd") )]
	pub cdt_dbt_ind: CreditDebitCode,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dt") )]
	pub dt: DateAndDateTime2Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Avlbty", skip_serializing_if = "Option::is_none") )]
	pub avlbty: Option<Vec<CashAvailability1>>,
}

impl CashBalance8 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.tp.validate()?;
		if let Some(ref vec) = self.cdt_line { for item in vec { item.validate()? } }
		self.amt.validate()?;
		self.cdt_dbt_ind.validate()?;
		self.dt.validate()?;
		if let Some(ref vec) = self.avlbty { for item in vec { item.validate()? } }
		Ok(())
	}
}


// CashBalanceReturnCriteria2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CashBalanceReturnCriteria2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TpInd") )]
	pub tp_ind: bool,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StsInd") )]
	pub sts_ind: bool,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ValDtInd") )]
	pub val_dt_ind: bool,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrcgDtInd") )]
	pub prcg_dt_ind: bool,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfPmtsInd") )]
	pub nb_of_pmts_ind: bool,
}

impl CashBalanceReturnCriteria2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// CashBalanceType3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CashBalanceType3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification30>,
}

impl CashBalanceType3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// CashDeposit1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CashDeposit1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NoteDnmtn") )]
	pub note_dnmtn: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfNotes") )]
	pub nb_of_notes: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveCurrencyAndAmount,
}

impl CashDeposit1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.note_dnmtn.validate()?;
		let pattern = Regex::new("[0-9]{1,15}").unwrap();
		if !pattern.is_match(&self.nb_of_notes) {
			return Err(ValidationError::new(1005, "nb_of_notes does not match the required pattern".to_string()));
		}
		self.amt.validate()?;
		Ok(())
	}
}


// CashEntry2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CashEntry2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt", skip_serializing_if = "Option::is_none") )]
	pub amt: Option<ActiveCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dt", skip_serializing_if = "Option::is_none") )]
	pub dt: Option<DateAndDateTime2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sts", skip_serializing_if = "Option::is_none") )]
	pub sts: Option<EntryStatus1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StmtId", skip_serializing_if = "Option::is_none") )]
	pub stmt_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctSvcrRef", skip_serializing_if = "Option::is_none") )]
	pub acct_svcr_ref: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlNtryInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_ntry_inf: Option<Vec<String>>,
}

impl CashEntry2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.amt { val.validate()? }
		if let Some(ref val) = self.dt { val.validate()? }
		if let Some(ref val) = self.sts { val.validate()? }
		if let Some(ref val) = self.id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.stmt_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "stmt_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "stmt_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref vec) = self.addtl_ntry_inf {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "addtl_ntry_inf is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 140 {
					return Err(ValidationError::new(1002, "addtl_ntry_inf exceeds the maximum length of 140".to_string()));
				}
			}
		}
		Ok(())
	}
}


// CashInForecast5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CashInForecast5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshSttlmDt") )]
	pub csh_sttlm_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubTtlAmt", skip_serializing_if = "Option::is_none") )]
	pub sub_ttl_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubTtlUnitsNb", skip_serializing_if = "Option::is_none") )]
	pub sub_ttl_units_nb: Option<FinancialInstrumentQuantity1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XcptnlCshFlowInd", skip_serializing_if = "Option::is_none") )]
	pub xcptnl_csh_flow_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshInBrkdwnDtls", skip_serializing_if = "Option::is_none") )]
	pub csh_in_brkdwn_dtls: Option<Vec<FundCashInBreakdown3>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlBal", skip_serializing_if = "Option::is_none") )]
	pub addtl_bal: Option<FundBalance1>,
}

impl CashInForecast5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.sub_ttl_amt { val.validate()? }
		if let Some(ref val) = self.sub_ttl_units_nb { val.validate()? }
		if let Some(ref vec) = self.csh_in_brkdwn_dtls { for item in vec { item.validate()? } }
		if let Some(ref val) = self.addtl_bal { val.validate()? }
		Ok(())
	}
}


// CashInForecast6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CashInForecast6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshSttlmDt") )]
	pub csh_sttlm_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubTtlAmt", skip_serializing_if = "Option::is_none") )]
	pub sub_ttl_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubTtlUnitsNb", skip_serializing_if = "Option::is_none") )]
	pub sub_ttl_units_nb: Option<FinancialInstrumentQuantity1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XcptnlCshFlowInd", skip_serializing_if = "Option::is_none") )]
	pub xcptnl_csh_flow_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlBal", skip_serializing_if = "Option::is_none") )]
	pub addtl_bal: Option<FundBalance1>,
}

impl CashInForecast6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.sub_ttl_amt { val.validate()? }
		if let Some(ref val) = self.sub_ttl_units_nb { val.validate()? }
		if let Some(ref val) = self.addtl_bal { val.validate()? }
		Ok(())
	}
}


// CashInOutForecast7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CashInOutForecast7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshSttlmDt", skip_serializing_if = "Option::is_none") )]
	pub csh_sttlm_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveOrHistoricCurrencyAndAmount,
}

impl CashInOutForecast7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.amt.validate()?;
		Ok(())
	}
}


// CashOutForecast5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CashOutForecast5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshSttlmDt") )]
	pub csh_sttlm_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubTtlAmt", skip_serializing_if = "Option::is_none") )]
	pub sub_ttl_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubTtlUnitsNb", skip_serializing_if = "Option::is_none") )]
	pub sub_ttl_units_nb: Option<FinancialInstrumentQuantity1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XcptnlCshFlowInd", skip_serializing_if = "Option::is_none") )]
	pub xcptnl_csh_flow_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshOutBrkdwnDtls", skip_serializing_if = "Option::is_none") )]
	pub csh_out_brkdwn_dtls: Option<Vec<FundCashOutBreakdown3>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlBal", skip_serializing_if = "Option::is_none") )]
	pub addtl_bal: Option<FundBalance1>,
}

impl CashOutForecast5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.sub_ttl_amt { val.validate()? }
		if let Some(ref val) = self.sub_ttl_units_nb { val.validate()? }
		if let Some(ref vec) = self.csh_out_brkdwn_dtls { for item in vec { item.validate()? } }
		if let Some(ref val) = self.addtl_bal { val.validate()? }
		Ok(())
	}
}


// CashOutForecast6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CashOutForecast6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshSttlmDt") )]
	pub csh_sttlm_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubTtlAmt", skip_serializing_if = "Option::is_none") )]
	pub sub_ttl_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubTtlUnitsNb", skip_serializing_if = "Option::is_none") )]
	pub sub_ttl_units_nb: Option<FinancialInstrumentQuantity1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XcptnlCshFlowInd", skip_serializing_if = "Option::is_none") )]
	pub xcptnl_csh_flow_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlBal", skip_serializing_if = "Option::is_none") )]
	pub addtl_bal: Option<FundBalance1>,
}

impl CashOutForecast6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.sub_ttl_amt { val.validate()? }
		if let Some(ref val) = self.sub_ttl_units_nb { val.validate()? }
		if let Some(ref val) = self.addtl_bal { val.validate()? }
		Ok(())
	}
}


// CashPaymentStatus2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum CashPaymentStatus2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "PDNG") )]
	CodePDNG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FINL") )]
	CodeFINL,
}

impl CashPaymentStatus2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// CashSubBalanceTypeAndQuantityBreakdown3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CashSubBalanceTypeAndQuantityBreakdown3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: CashBalanceType3Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "QtyBrkdwn", skip_serializing_if = "Option::is_none") )]
	pub qty_brkdwn: Option<Vec<AmountAndQuantityBreakdown1>>,
}

impl CashSubBalanceTypeAndQuantityBreakdown3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.tp.validate()?;
		if let Some(ref vec) = self.qty_brkdwn { for item in vec { item.validate()? } }
		Ok(())
	}
}


// CategoryPurpose1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CategoryPurpose1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl CategoryPurpose1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// CharacterSearch1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CharacterSearch1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "EQ", skip_serializing_if = "Option::is_none") )]
	pub eq: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NEQ", skip_serializing_if = "Option::is_none") )]
	pub neq: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CT", skip_serializing_if = "Option::is_none") )]
	pub ct: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NCT", skip_serializing_if = "Option::is_none") )]
	pub nct: Option<String>,
}

impl CharacterSearch1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.eq {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "eq is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "eq exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.neq {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "neq is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "neq exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.ct {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "ct is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "ct exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.nct {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nct is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "nct exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// Charge26 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Charge26 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: ChargeType4Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgApld") )]
	pub chrg_apld: AmountOrRate3Choice,
}

impl Charge26 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.tp.validate()?;
		self.chrg_apld.validate()?;
		Ok(())
	}
}


// ChargeBearerType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum ChargeBearerType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "DEBT") )]
	CodeDEBT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CRED") )]
	CodeCRED,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SHAR") )]
	CodeSHAR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SLEV") )]
	CodeSLEV,
}

impl ChargeBearerType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ChargeType12Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum ChargeType12Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "BEND") )]
	CodeBEND,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DISC") )]
	CodeDISC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FEND") )]
	CodeFEND,
	#[cfg_attr( feature = "derive_serde", serde(rename = "POST") )]
	CodePOST,
	#[cfg_attr( feature = "derive_serde", serde(rename = "REGF") )]
	CodeREGF,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SHIP") )]
	CodeSHIP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SPCN") )]
	CodeSPCN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TRAN") )]
	CodeTRAN,
}

impl ChargeType12Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ChargeType3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ChargeType3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification3>,
}

impl ChargeType3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// ChargeType4Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ChargeType4Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<ChargeType12Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification47>,
}

impl ChargeType4Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// Charges14 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Charges14 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveOrHistoricCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Agt") )]
	pub agt: BranchAndFinancialInstitutionIdentification8,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AgtAcct", skip_serializing_if = "Option::is_none") )]
	pub agt_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<ChargeType3Choice>,
}

impl Charges14 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.amt.validate()?;
		self.agt.validate()?;
		if let Some(ref val) = self.agt_acct { val.validate()? }
		if let Some(ref val) = self.tp { val.validate()? }
		Ok(())
	}
}


// Charges15 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Charges15 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlChrgsAndTaxAmt", skip_serializing_if = "Option::is_none") )]
	pub ttl_chrgs_and_tax_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rcrd", skip_serializing_if = "Option::is_none") )]
	pub rcrd: Option<Vec<ChargesRecord8>>,
}

impl Charges15 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ttl_chrgs_and_tax_amt { val.validate()? }
		if let Some(ref vec) = self.rcrd { for item in vec { item.validate()? } }
		Ok(())
	}
}


// Charges3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Charges3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sngl", skip_serializing_if = "Option::is_none") )]
	pub sngl: Option<ChargesRecord9>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PerTx", skip_serializing_if = "Option::is_none") )]
	pub per_tx: Option<ChargesPerTransaction3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PerTp", skip_serializing_if = "Option::is_none") )]
	pub per_tp: Option<Vec<ChargesPerType3>>,
}

impl Charges3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.sngl { val.validate()? }
		if let Some(ref val) = self.per_tx { val.validate()? }
		if let Some(ref vec) = self.per_tp { for item in vec { item.validate()? } }
		Ok(())
	}
}


// Charges4Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Charges4Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sngl", skip_serializing_if = "Option::is_none") )]
	pub sngl: Option<ChargesRecord10>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PerTx", skip_serializing_if = "Option::is_none") )]
	pub per_tx: Option<ChargesPerTransaction4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PerTp", skip_serializing_if = "Option::is_none") )]
	pub per_tp: Option<Vec<ChargesPerType4>>,
}

impl Charges4Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.sngl { val.validate()? }
		if let Some(ref val) = self.per_tx { val.validate()? }
		if let Some(ref vec) = self.per_tp { for item in vec { item.validate()? } }
		Ok(())
	}
}


// Charges6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Charges6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlChrgsAndTaxAmt", skip_serializing_if = "Option::is_none") )]
	pub ttl_chrgs_and_tax_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rcrd", skip_serializing_if = "Option::is_none") )]
	pub rcrd: Option<Vec<ChargesRecord3>>,
}

impl Charges6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ttl_chrgs_and_tax_amt { val.validate()? }
		if let Some(ref vec) = self.rcrd { for item in vec { item.validate()? } }
		Ok(())
	}
}


// ChargesBreakdown1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ChargesBreakdown1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtDbtInd", skip_serializing_if = "Option::is_none") )]
	pub cdt_dbt_ind: Option<CreditDebitCode>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<ChargeType3Choice>,
}

impl ChargesBreakdown1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.amt.validate()?;
		if let Some(ref val) = self.cdt_dbt_ind { val.validate()? }
		if let Some(ref val) = self.tp { val.validate()? }
		Ok(())
	}
}


// ChargesPerTransaction3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ChargesPerTransaction3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgsId", skip_serializing_if = "Option::is_none") )]
	pub chrgs_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlChrgsPerTx", skip_serializing_if = "Option::is_none") )]
	pub ttl_chrgs_per_tx: Option<TotalCharges7>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgsAcctAgt", skip_serializing_if = "Option::is_none") )]
	pub chrgs_acct_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgsAcctAgtAcct", skip_serializing_if = "Option::is_none") )]
	pub chrgs_acct_agt_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rcrd") )]
	pub rcrd: Vec<ChargesPerTransactionRecord3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_inf: Option<String>,
}

impl ChargesPerTransaction3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.chrgs_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "chrgs_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "chrgs_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.ttl_chrgs_per_tx { val.validate()? }
		if let Some(ref val) = self.chrgs_acct_agt { val.validate()? }
		if let Some(ref val) = self.chrgs_acct_agt_acct { val.validate()? }
		for item in &self.rcrd { item.validate()? }
		if let Some(ref val) = self.addtl_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "addtl_inf exceeds the maximum length of 140".to_string()));
			}
		}
		Ok(())
	}
}


// ChargesPerTransaction4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ChargesPerTransaction4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgsId", skip_serializing_if = "Option::is_none") )]
	pub chrgs_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlChrgsPerTx", skip_serializing_if = "Option::is_none") )]
	pub ttl_chrgs_per_tx: Option<TotalCharges7>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgsAcct", skip_serializing_if = "Option::is_none") )]
	pub chrgs_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgsAcctOwnr", skip_serializing_if = "Option::is_none") )]
	pub chrgs_acct_ownr: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rcrd") )]
	pub rcrd: Vec<ChargesPerTransactionRecord4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_inf: Option<String>,
}

impl ChargesPerTransaction4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.chrgs_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "chrgs_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "chrgs_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.ttl_chrgs_per_tx { val.validate()? }
		if let Some(ref val) = self.chrgs_acct { val.validate()? }
		if let Some(ref val) = self.chrgs_acct_ownr { val.validate()? }
		for item in &self.rcrd { item.validate()? }
		if let Some(ref val) = self.addtl_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "addtl_inf exceeds the maximum length of 140".to_string()));
			}
		}
		Ok(())
	}
}


// ChargesPerTransactionRecord3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ChargesPerTransactionRecord3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RcrdId", skip_serializing_if = "Option::is_none") )]
	pub rcrd_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgsRqstr", skip_serializing_if = "Option::is_none") )]
	pub chrgs_rqstr: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UndrlygTx") )]
	pub undrlyg_tx: TransactionReferences7,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlChrgsPerRcrd", skip_serializing_if = "Option::is_none") )]
	pub ttl_chrgs_per_rcrd: Option<TotalCharges8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgsBrkdwn") )]
	pub chrgs_brkdwn: Vec<ChargesBreakdown1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ValDt", skip_serializing_if = "Option::is_none") )]
	pub val_dt: Option<DateAndDateTime2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtrAgt", skip_serializing_if = "Option::is_none") )]
	pub dbtr_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtrAgtAcct", skip_serializing_if = "Option::is_none") )]
	pub dbtr_agt_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgsAcctAgt", skip_serializing_if = "Option::is_none") )]
	pub chrgs_acct_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgsAcctAgtAcct", skip_serializing_if = "Option::is_none") )]
	pub chrgs_acct_agt_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstrForInstdAgt", skip_serializing_if = "Option::is_none") )]
	pub instr_for_instd_agt: Option<InstructionForInstructedAgent1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_inf: Option<String>,
}

impl ChargesPerTransactionRecord3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.rcrd_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "rcrd_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "rcrd_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.chrgs_rqstr { val.validate()? }
		self.undrlyg_tx.validate()?;
		if let Some(ref val) = self.ttl_chrgs_per_rcrd { val.validate()? }
		for item in &self.chrgs_brkdwn { item.validate()? }
		if let Some(ref val) = self.val_dt { val.validate()? }
		if let Some(ref val) = self.dbtr_agt { val.validate()? }
		if let Some(ref val) = self.dbtr_agt_acct { val.validate()? }
		if let Some(ref val) = self.chrgs_acct_agt { val.validate()? }
		if let Some(ref val) = self.chrgs_acct_agt_acct { val.validate()? }
		if let Some(ref val) = self.instr_for_instd_agt { val.validate()? }
		if let Some(ref val) = self.addtl_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "addtl_inf exceeds the maximum length of 140".to_string()));
			}
		}
		Ok(())
	}
}


// ChargesPerTransactionRecord4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ChargesPerTransactionRecord4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RcrdId", skip_serializing_if = "Option::is_none") )]
	pub rcrd_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgsRqstr", skip_serializing_if = "Option::is_none") )]
	pub chrgs_rqstr: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UndrlygTx") )]
	pub undrlyg_tx: TransactionReferences7,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlChrgsPerRcrd", skip_serializing_if = "Option::is_none") )]
	pub ttl_chrgs_per_rcrd: Option<TotalCharges8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgsBrkdwn") )]
	pub chrgs_brkdwn: Vec<ChargesBreakdown1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ValDt", skip_serializing_if = "Option::is_none") )]
	pub val_dt: Option<DateAndDateTime2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtrAgt", skip_serializing_if = "Option::is_none") )]
	pub dbtr_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtrAgtAcct", skip_serializing_if = "Option::is_none") )]
	pub dbtr_agt_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgsAcct", skip_serializing_if = "Option::is_none") )]
	pub chrgs_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgsAcctOwnr", skip_serializing_if = "Option::is_none") )]
	pub chrgs_acct_ownr: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstrForInstdAgt", skip_serializing_if = "Option::is_none") )]
	pub instr_for_instd_agt: Option<InstructionForInstructedAgent1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_inf: Option<String>,
}

impl ChargesPerTransactionRecord4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.rcrd_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "rcrd_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "rcrd_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.chrgs_rqstr { val.validate()? }
		self.undrlyg_tx.validate()?;
		if let Some(ref val) = self.ttl_chrgs_per_rcrd { val.validate()? }
		for item in &self.chrgs_brkdwn { item.validate()? }
		if let Some(ref val) = self.val_dt { val.validate()? }
		if let Some(ref val) = self.dbtr_agt { val.validate()? }
		if let Some(ref val) = self.dbtr_agt_acct { val.validate()? }
		if let Some(ref val) = self.chrgs_acct { val.validate()? }
		if let Some(ref val) = self.chrgs_acct_ownr { val.validate()? }
		if let Some(ref val) = self.instr_for_instd_agt { val.validate()? }
		if let Some(ref val) = self.addtl_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "addtl_inf exceeds the maximum length of 140".to_string()));
			}
		}
		Ok(())
	}
}


// ChargesPerType3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ChargesPerType3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgsId", skip_serializing_if = "Option::is_none") )]
	pub chrgs_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlChrgsPerChrgTp", skip_serializing_if = "Option::is_none") )]
	pub ttl_chrgs_per_chrg_tp: Option<TotalCharges7>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgsAcctAgt", skip_serializing_if = "Option::is_none") )]
	pub chrgs_acct_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgsAcctAgtAcct", skip_serializing_if = "Option::is_none") )]
	pub chrgs_acct_agt_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: ChargeType3Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rcrd") )]
	pub rcrd: Vec<ChargesPerTypeRecord3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_inf: Option<String>,
}

impl ChargesPerType3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.chrgs_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "chrgs_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "chrgs_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.ttl_chrgs_per_chrg_tp { val.validate()? }
		if let Some(ref val) = self.chrgs_acct_agt { val.validate()? }
		if let Some(ref val) = self.chrgs_acct_agt_acct { val.validate()? }
		self.tp.validate()?;
		for item in &self.rcrd { item.validate()? }
		if let Some(ref val) = self.addtl_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "addtl_inf exceeds the maximum length of 140".to_string()));
			}
		}
		Ok(())
	}
}


// ChargesPerType4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ChargesPerType4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgsId", skip_serializing_if = "Option::is_none") )]
	pub chrgs_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlChrgsPerChrgTp", skip_serializing_if = "Option::is_none") )]
	pub ttl_chrgs_per_chrg_tp: Option<TotalCharges7>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgsAcct", skip_serializing_if = "Option::is_none") )]
	pub chrgs_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgsAcctOwnr", skip_serializing_if = "Option::is_none") )]
	pub chrgs_acct_ownr: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: ChargeType3Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rcrd") )]
	pub rcrd: Vec<ChargesPerTypeRecord4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_inf: Option<String>,
}

impl ChargesPerType4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.chrgs_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "chrgs_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "chrgs_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.ttl_chrgs_per_chrg_tp { val.validate()? }
		if let Some(ref val) = self.chrgs_acct { val.validate()? }
		if let Some(ref val) = self.chrgs_acct_ownr { val.validate()? }
		self.tp.validate()?;
		for item in &self.rcrd { item.validate()? }
		if let Some(ref val) = self.addtl_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "addtl_inf exceeds the maximum length of 140".to_string()));
			}
		}
		Ok(())
	}
}


// ChargesPerTypeRecord3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ChargesPerTypeRecord3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RcrdId", skip_serializing_if = "Option::is_none") )]
	pub rcrd_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgsRqstr", skip_serializing_if = "Option::is_none") )]
	pub chrgs_rqstr: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UndrlygTx") )]
	pub undrlyg_tx: TransactionReferences7,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtDbtInd", skip_serializing_if = "Option::is_none") )]
	pub cdt_dbt_ind: Option<CreditDebitCode>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ValDt", skip_serializing_if = "Option::is_none") )]
	pub val_dt: Option<DateAndDateTime2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtrAgt", skip_serializing_if = "Option::is_none") )]
	pub dbtr_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtrAgtAcct", skip_serializing_if = "Option::is_none") )]
	pub dbtr_agt_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgsAcctAgt", skip_serializing_if = "Option::is_none") )]
	pub chrgs_acct_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgsAcctAgtAcct", skip_serializing_if = "Option::is_none") )]
	pub chrgs_acct_agt_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstrForInstdAgt", skip_serializing_if = "Option::is_none") )]
	pub instr_for_instd_agt: Option<InstructionForInstructedAgent1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_inf: Option<String>,
}

impl ChargesPerTypeRecord3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.rcrd_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "rcrd_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "rcrd_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.chrgs_rqstr { val.validate()? }
		self.undrlyg_tx.validate()?;
		self.amt.validate()?;
		if let Some(ref val) = self.cdt_dbt_ind { val.validate()? }
		if let Some(ref val) = self.val_dt { val.validate()? }
		if let Some(ref val) = self.dbtr_agt { val.validate()? }
		if let Some(ref val) = self.dbtr_agt_acct { val.validate()? }
		if let Some(ref val) = self.chrgs_acct_agt { val.validate()? }
		if let Some(ref val) = self.chrgs_acct_agt_acct { val.validate()? }
		if let Some(ref val) = self.instr_for_instd_agt { val.validate()? }
		if let Some(ref val) = self.addtl_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "addtl_inf exceeds the maximum length of 140".to_string()));
			}
		}
		Ok(())
	}
}


// ChargesPerTypeRecord4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ChargesPerTypeRecord4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RcrdId", skip_serializing_if = "Option::is_none") )]
	pub rcrd_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgsRqstr", skip_serializing_if = "Option::is_none") )]
	pub chrgs_rqstr: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UndrlygTx") )]
	pub undrlyg_tx: TransactionReferences7,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtDbtInd", skip_serializing_if = "Option::is_none") )]
	pub cdt_dbt_ind: Option<CreditDebitCode>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ValDt", skip_serializing_if = "Option::is_none") )]
	pub val_dt: Option<DateAndDateTime2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtrAgt", skip_serializing_if = "Option::is_none") )]
	pub dbtr_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtrAgtAcct", skip_serializing_if = "Option::is_none") )]
	pub dbtr_agt_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgsAcct", skip_serializing_if = "Option::is_none") )]
	pub chrgs_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgsAcctOwnr", skip_serializing_if = "Option::is_none") )]
	pub chrgs_acct_ownr: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstrForInstdAgt", skip_serializing_if = "Option::is_none") )]
	pub instr_for_instd_agt: Option<InstructionForInstructedAgent1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_inf: Option<String>,
}

impl ChargesPerTypeRecord4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.rcrd_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "rcrd_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "rcrd_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.chrgs_rqstr { val.validate()? }
		self.undrlyg_tx.validate()?;
		self.amt.validate()?;
		if let Some(ref val) = self.cdt_dbt_ind { val.validate()? }
		if let Some(ref val) = self.val_dt { val.validate()? }
		if let Some(ref val) = self.dbtr_agt { val.validate()? }
		if let Some(ref val) = self.dbtr_agt_acct { val.validate()? }
		if let Some(ref val) = self.chrgs_acct { val.validate()? }
		if let Some(ref val) = self.chrgs_acct_ownr { val.validate()? }
		if let Some(ref val) = self.instr_for_instd_agt { val.validate()? }
		if let Some(ref val) = self.addtl_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "addtl_inf exceeds the maximum length of 140".to_string()));
			}
		}
		Ok(())
	}
}


// ChargesRecord10 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ChargesRecord10 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgsId", skip_serializing_if = "Option::is_none") )]
	pub chrgs_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RcrdId", skip_serializing_if = "Option::is_none") )]
	pub rcrd_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgsRqstr", skip_serializing_if = "Option::is_none") )]
	pub chrgs_rqstr: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UndrlygTx") )]
	pub undrlyg_tx: TransactionReferences7,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtDbtInd", skip_serializing_if = "Option::is_none") )]
	pub cdt_dbt_ind: Option<CreditDebitCode>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ValDt", skip_serializing_if = "Option::is_none") )]
	pub val_dt: Option<DateAndDateTime2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtrAgt", skip_serializing_if = "Option::is_none") )]
	pub dbtr_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtrAgtAcct", skip_serializing_if = "Option::is_none") )]
	pub dbtr_agt_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgsAcct", skip_serializing_if = "Option::is_none") )]
	pub chrgs_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgsAcctOwnr", skip_serializing_if = "Option::is_none") )]
	pub chrgs_acct_ownr: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<ChargeType3Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstrForInstdAgt", skip_serializing_if = "Option::is_none") )]
	pub instr_for_instd_agt: Option<InstructionForInstructedAgent1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_inf: Option<String>,
}

impl ChargesRecord10 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.chrgs_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "chrgs_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "chrgs_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.rcrd_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "rcrd_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "rcrd_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.chrgs_rqstr { val.validate()? }
		self.undrlyg_tx.validate()?;
		self.amt.validate()?;
		if let Some(ref val) = self.cdt_dbt_ind { val.validate()? }
		if let Some(ref val) = self.val_dt { val.validate()? }
		if let Some(ref val) = self.dbtr_agt { val.validate()? }
		if let Some(ref val) = self.dbtr_agt_acct { val.validate()? }
		if let Some(ref val) = self.chrgs_acct { val.validate()? }
		if let Some(ref val) = self.chrgs_acct_ownr { val.validate()? }
		if let Some(ref val) = self.tp { val.validate()? }
		if let Some(ref val) = self.instr_for_instd_agt { val.validate()? }
		if let Some(ref val) = self.addtl_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "addtl_inf exceeds the maximum length of 140".to_string()));
			}
		}
		Ok(())
	}
}


// ChargesRecord3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ChargesRecord3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveOrHistoricCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtDbtInd", skip_serializing_if = "Option::is_none") )]
	pub cdt_dbt_ind: Option<CreditDebitCode>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgInclInd", skip_serializing_if = "Option::is_none") )]
	pub chrg_incl_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<ChargeType3Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rate", skip_serializing_if = "Option::is_none") )]
	pub rate: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Br", skip_serializing_if = "Option::is_none") )]
	pub br: Option<ChargeBearerType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Agt", skip_serializing_if = "Option::is_none") )]
	pub agt: Option<BranchAndFinancialInstitutionIdentification6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tax", skip_serializing_if = "Option::is_none") )]
	pub tax: Option<TaxCharges2>,
}

impl ChargesRecord3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.amt.validate()?;
		if let Some(ref val) = self.cdt_dbt_ind { val.validate()? }
		if let Some(ref val) = self.tp { val.validate()? }
		if let Some(ref val) = self.br { val.validate()? }
		if let Some(ref val) = self.agt { val.validate()? }
		if let Some(ref val) = self.tax { val.validate()? }
		Ok(())
	}
}


// ChargesRecord8 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ChargesRecord8 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveOrHistoricCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtDbtInd", skip_serializing_if = "Option::is_none") )]
	pub cdt_dbt_ind: Option<CreditDebitCode>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgInclInd", skip_serializing_if = "Option::is_none") )]
	pub chrg_incl_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<ChargeType3Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rate", skip_serializing_if = "Option::is_none") )]
	pub rate: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Br", skip_serializing_if = "Option::is_none") )]
	pub br: Option<ChargeBearerType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Agt", skip_serializing_if = "Option::is_none") )]
	pub agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tax", skip_serializing_if = "Option::is_none") )]
	pub tax: Option<TaxCharges2>,
}

impl ChargesRecord8 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.amt.validate()?;
		if let Some(ref val) = self.cdt_dbt_ind { val.validate()? }
		if let Some(ref val) = self.tp { val.validate()? }
		if let Some(ref val) = self.br { val.validate()? }
		if let Some(ref val) = self.agt { val.validate()? }
		if let Some(ref val) = self.tax { val.validate()? }
		Ok(())
	}
}


// ChargesRecord9 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ChargesRecord9 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgsId", skip_serializing_if = "Option::is_none") )]
	pub chrgs_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RcrdId", skip_serializing_if = "Option::is_none") )]
	pub rcrd_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgsRqstr", skip_serializing_if = "Option::is_none") )]
	pub chrgs_rqstr: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UndrlygTx") )]
	pub undrlyg_tx: TransactionReferences7,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtDbtInd", skip_serializing_if = "Option::is_none") )]
	pub cdt_dbt_ind: Option<CreditDebitCode>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ValDt", skip_serializing_if = "Option::is_none") )]
	pub val_dt: Option<DateAndDateTime2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtrAgt", skip_serializing_if = "Option::is_none") )]
	pub dbtr_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtrAgtAcct", skip_serializing_if = "Option::is_none") )]
	pub dbtr_agt_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgsAcctAgt", skip_serializing_if = "Option::is_none") )]
	pub chrgs_acct_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgsAcctAgtAcct", skip_serializing_if = "Option::is_none") )]
	pub chrgs_acct_agt_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<ChargeType3Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstrForInstdAgt", skip_serializing_if = "Option::is_none") )]
	pub instr_for_instd_agt: Option<InstructionForInstructedAgent1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_inf: Option<String>,
}

impl ChargesRecord9 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.chrgs_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "chrgs_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "chrgs_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.rcrd_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "rcrd_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "rcrd_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.chrgs_rqstr { val.validate()? }
		self.undrlyg_tx.validate()?;
		self.amt.validate()?;
		if let Some(ref val) = self.cdt_dbt_ind { val.validate()? }
		if let Some(ref val) = self.val_dt { val.validate()? }
		if let Some(ref val) = self.dbtr_agt { val.validate()? }
		if let Some(ref val) = self.dbtr_agt_acct { val.validate()? }
		if let Some(ref val) = self.chrgs_acct_agt { val.validate()? }
		if let Some(ref val) = self.chrgs_acct_agt_acct { val.validate()? }
		if let Some(ref val) = self.tp { val.validate()? }
		if let Some(ref val) = self.instr_for_instd_agt { val.validate()? }
		if let Some(ref val) = self.addtl_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "addtl_inf exceeds the maximum length of 140".to_string()));
			}
		}
		Ok(())
	}
}


// Cheque17 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Cheque17 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstrId", skip_serializing_if = "Option::is_none") )]
	pub instr_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChqNb") )]
	pub chq_nb: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IsseDt") )]
	pub isse_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StlDt", skip_serializing_if = "Option::is_none") )]
	pub stl_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ValDt", skip_serializing_if = "Option::is_none") )]
	pub val_dt: Option<DateAndDateTime2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pyer", skip_serializing_if = "Option::is_none") )]
	pub pyer: Option<PartyIdentification272>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PyerAcct", skip_serializing_if = "Option::is_none") )]
	pub pyer_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DrwrAgt", skip_serializing_if = "Option::is_none") )]
	pub drwr_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DrwrAgtAcct", skip_serializing_if = "Option::is_none") )]
	pub drwr_agt_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pyee") )]
	pub pyee: PartyIdentification272,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PyeeAcct", skip_serializing_if = "Option::is_none") )]
	pub pyee_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstrForChqAgt", skip_serializing_if = "Option::is_none") )]
	pub instr_for_chq_agt: Option<Vec<InstructionForChequeAgent1>>,
}

impl Cheque17 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.instr_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "instr_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "instr_id exceeds the maximum length of 35".to_string()));
			}
		}
		if self.chq_nb.chars().count() < 1 {
			return Err(ValidationError::new(1001, "chq_nb is shorter than the minimum length of 1".to_string()));
		}
		if self.chq_nb.chars().count() > 35 {
			return Err(ValidationError::new(1002, "chq_nb exceeds the maximum length of 35".to_string()));
		}
		self.amt.validate()?;
		if let Some(ref val) = self.val_dt { val.validate()? }
		if let Some(ref val) = self.pyer { val.validate()? }
		if let Some(ref val) = self.pyer_acct { val.validate()? }
		if let Some(ref val) = self.drwr_agt { val.validate()? }
		if let Some(ref val) = self.drwr_agt_acct { val.validate()? }
		self.pyee.validate()?;
		if let Some(ref val) = self.pyee_acct { val.validate()? }
		if let Some(ref vec) = self.instr_for_chq_agt { for item in vec { item.validate()? } }
		Ok(())
	}
}


// Cheque18 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Cheque18 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstrId", skip_serializing_if = "Option::is_none") )]
	pub instr_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlInstrId", skip_serializing_if = "Option::is_none") )]
	pub orgnl_instr_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChqNb") )]
	pub chq_nb: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IsseDt") )]
	pub isse_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StlDt", skip_serializing_if = "Option::is_none") )]
	pub stl_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FctvDt", skip_serializing_if = "Option::is_none") )]
	pub fctv_dt: Option<DateAndDateTime2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DrwrAgt", skip_serializing_if = "Option::is_none") )]
	pub drwr_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DrwrAgtAcct", skip_serializing_if = "Option::is_none") )]
	pub drwr_agt_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pyee", skip_serializing_if = "Option::is_none") )]
	pub pyee: Option<PartyIdentification272>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PyeeAcct", skip_serializing_if = "Option::is_none") )]
	pub pyee_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChqCxlOrStopSts") )]
	pub chq_cxl_or_stop_sts: ChequeCancellationStatus1,
}

impl Cheque18 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.instr_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "instr_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "instr_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.orgnl_instr_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_instr_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_instr_id exceeds the maximum length of 35".to_string()));
			}
		}
		if self.chq_nb.chars().count() < 1 {
			return Err(ValidationError::new(1001, "chq_nb is shorter than the minimum length of 1".to_string()));
		}
		if self.chq_nb.chars().count() > 35 {
			return Err(ValidationError::new(1002, "chq_nb exceeds the maximum length of 35".to_string()));
		}
		self.amt.validate()?;
		if let Some(ref val) = self.fctv_dt { val.validate()? }
		if let Some(ref val) = self.drwr_agt { val.validate()? }
		if let Some(ref val) = self.drwr_agt_acct { val.validate()? }
		if let Some(ref val) = self.pyee { val.validate()? }
		if let Some(ref val) = self.pyee_acct { val.validate()? }
		self.chq_cxl_or_stop_sts.validate()?;
		Ok(())
	}
}


// Cheque20 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Cheque20 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstrId", skip_serializing_if = "Option::is_none") )]
	pub instr_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlInstrId", skip_serializing_if = "Option::is_none") )]
	pub orgnl_instr_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChqNb") )]
	pub chq_nb: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IsseDt") )]
	pub isse_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StlDt", skip_serializing_if = "Option::is_none") )]
	pub stl_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FctvDt", skip_serializing_if = "Option::is_none") )]
	pub fctv_dt: Option<DateAndDateTime2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DrwrAgt", skip_serializing_if = "Option::is_none") )]
	pub drwr_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DrwrAgtAcct", skip_serializing_if = "Option::is_none") )]
	pub drwr_agt_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pyee", skip_serializing_if = "Option::is_none") )]
	pub pyee: Option<PartyIdentification272>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PyeeAcct", skip_serializing_if = "Option::is_none") )]
	pub pyee_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChqCxlOrStopRsn", skip_serializing_if = "Option::is_none") )]
	pub chq_cxl_or_stop_rsn: Option<ChequeCancellationReason1>,
}

impl Cheque20 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.instr_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "instr_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "instr_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.orgnl_instr_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_instr_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_instr_id exceeds the maximum length of 35".to_string()));
			}
		}
		if self.chq_nb.chars().count() < 1 {
			return Err(ValidationError::new(1001, "chq_nb is shorter than the minimum length of 1".to_string()));
		}
		if self.chq_nb.chars().count() > 35 {
			return Err(ValidationError::new(1002, "chq_nb exceeds the maximum length of 35".to_string()));
		}
		self.amt.validate()?;
		if let Some(ref val) = self.fctv_dt { val.validate()? }
		if let Some(ref val) = self.drwr_agt { val.validate()? }
		if let Some(ref val) = self.drwr_agt_acct { val.validate()? }
		if let Some(ref val) = self.pyee { val.validate()? }
		if let Some(ref val) = self.pyee_acct { val.validate()? }
		if let Some(ref val) = self.chq_cxl_or_stop_rsn { val.validate()? }
		Ok(())
	}
}


// ChequeCancellationReason1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ChequeCancellationReason1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Orgtr", skip_serializing_if = "Option::is_none") )]
	pub orgtr: Option<ChequePartyRole1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn") )]
	pub rsn: ChequeCancellationReason1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_inf: Option<String>,
}

impl ChequeCancellationReason1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.orgtr { val.validate()? }
		self.rsn.validate()?;
		if let Some(ref val) = self.addtl_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "addtl_inf exceeds the maximum length of 140".to_string()));
			}
		}
		Ok(())
	}
}


// ChequeCancellationReason1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ChequeCancellationReason1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl ChequeCancellationReason1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// ChequeCancellationStatus1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ChequeCancellationStatus1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Orgtr", skip_serializing_if = "Option::is_none") )]
	pub orgtr: Option<ChequePartyRole1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sts") )]
	pub sts: ChequeCancellationStatus1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_inf: Option<String>,
}

impl ChequeCancellationStatus1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.orgtr { val.validate()? }
		self.sts.validate()?;
		if let Some(ref val) = self.addtl_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "addtl_inf exceeds the maximum length of 140".to_string()));
			}
		}
		Ok(())
	}
}


// ChequeCancellationStatus1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ChequeCancellationStatus1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl ChequeCancellationStatus1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// ChequePartyRole1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum ChequePartyRole1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "DWEA") )]
	CodeDWEA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DWRA") )]
	CodeDWRA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PAYE") )]
	CodePAYE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PAYR") )]
	CodePAYR,
}

impl ChequePartyRole1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ClaimNonReceipt3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ClaimNonReceipt3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtPrcd") )]
	pub dt_prcd: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlNxtAgt", skip_serializing_if = "Option::is_none") )]
	pub orgnl_nxt_agt: Option<BranchAndFinancialInstitutionIdentification8>,
}

impl ClaimNonReceipt3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.orgnl_nxt_agt { val.validate()? }
		Ok(())
	}
}


// ClaimNonReceipt3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ClaimNonReceipt3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Accptd", skip_serializing_if = "Option::is_none") )]
	pub accptd: Option<ClaimNonReceipt3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rjctd", skip_serializing_if = "Option::is_none") )]
	pub rjctd: Option<ClaimNonReceiptRejectReason1Choice>,
}

impl ClaimNonReceipt3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.accptd { val.validate()? }
		if let Some(ref val) = self.rjctd { val.validate()? }
		Ok(())
	}
}


// ClaimNonReceiptRejectReason1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ClaimNonReceiptRejectReason1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl ClaimNonReceiptRejectReason1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// ClearingChannel2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum ClearingChannel2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "RTGS") )]
	CodeRTGS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RTNS") )]
	CodeRTNS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MPNS") )]
	CodeMPNS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BOOK") )]
	CodeBOOK,
}

impl ClearingChannel2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ClearingSystemIdentification2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ClearingSystemIdentification2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl ClearingSystemIdentification2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 5 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 5".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// ClearingSystemIdentification3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ClearingSystemIdentification3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl ClearingSystemIdentification3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 3 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 3".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// ClearingSystemMemberIdentification2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ClearingSystemMemberIdentification2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrSysId", skip_serializing_if = "Option::is_none") )]
	pub clr_sys_id: Option<ClearingSystemIdentification2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MmbId") )]
	pub mmb_id: String,
}

impl ClearingSystemMemberIdentification2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.clr_sys_id { val.validate()? }
		if self.mmb_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "mmb_id is shorter than the minimum length of 1".to_string()));
		}
		if self.mmb_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "mmb_id exceeds the maximum length of 35".to_string()));
		}
		Ok(())
	}
}


// ClosureReason2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ClosureReason2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<SystemClosureReason1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl ClosureReason2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// Commission21 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Commission21 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ComssnTp") )]
	pub comssn_tp: CommissionType5Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ComssnApld") )]
	pub comssn_apld: AmountOrRate3Choice,
}

impl Commission21 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.comssn_tp.validate()?;
		self.comssn_apld.validate()?;
		Ok(())
	}
}


// CommissionType5Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CommissionType5Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<CommissionType6Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification47>,
}

impl CommissionType5Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// CommissionType6Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum CommissionType6Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "FEND") )]
	CodeFEND,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BEND") )]
	CodeBEND,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CDPL") )]
	CodeCDPL,
}

impl CommissionType6Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// CommunicationAddress10 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CommunicationAddress10 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstlAdr") )]
	pub pstl_adr: LongPostalAddress1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PhneNb") )]
	pub phne_nb: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FaxNb", skip_serializing_if = "Option::is_none") )]
	pub fax_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EmailAdr", skip_serializing_if = "Option::is_none") )]
	pub email_adr: Option<String>,
}

impl CommunicationAddress10 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.pstl_adr.validate()?;
		let pattern = Regex::new("\\+[0-9]{1,3}-[0-9()+\\-]{1,30}").unwrap();
		if !pattern.is_match(&self.phne_nb) {
			return Err(ValidationError::new(1005, "phne_nb does not match the required pattern".to_string()));
		}
		if let Some(ref val) = self.fax_nb {
			let pattern = Regex::new("\\+[0-9]{1,3}-[0-9()+\\-]{1,30}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "fax_nb does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.email_adr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "email_adr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 2048 {
				return Err(ValidationError::new(1002, "email_adr exceeds the maximum length of 2048".to_string()));
			}
		}
		Ok(())
	}
}


// CommunicationAddress8 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CommunicationAddress8 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstlAdr") )]
	pub pstl_adr: LongPostalAddress1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PhneNb") )]
	pub phne_nb: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FaxNb", skip_serializing_if = "Option::is_none") )]
	pub fax_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EmailAdr", skip_serializing_if = "Option::is_none") )]
	pub email_adr: Option<String>,
}

impl CommunicationAddress8 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.pstl_adr.validate()?;
		let pattern = Regex::new("\\+[0-9]{1,3}-[0-9()+\\-]{1,30}").unwrap();
		if !pattern.is_match(&self.phne_nb) {
			return Err(ValidationError::new(1005, "phne_nb does not match the required pattern".to_string()));
		}
		if let Some(ref val) = self.fax_nb {
			let pattern = Regex::new("\\+[0-9]{1,3}-[0-9()+\\-]{1,30}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "fax_nb does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.email_adr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "email_adr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 256 {
				return Err(ValidationError::new(1002, "email_adr exceeds the maximum length of 256".to_string()));
			}
		}
		Ok(())
	}
}


// Compensation5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Compensation5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtrAgt") )]
	pub dbtr_agt: BranchAndFinancialInstitutionIdentification8,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtrAgtAcct", skip_serializing_if = "Option::is_none") )]
	pub dbtr_agt_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtrAgt") )]
	pub cdtr_agt: BranchAndFinancialInstitutionIdentification8,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtrAgtAcct", skip_serializing_if = "Option::is_none") )]
	pub cdtr_agt_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn") )]
	pub rsn: CompensationReason1Choice,
}

impl Compensation5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.amt.validate()?;
		self.dbtr_agt.validate()?;
		if let Some(ref val) = self.dbtr_agt_acct { val.validate()? }
		self.cdtr_agt.validate()?;
		if let Some(ref val) = self.cdtr_agt_acct { val.validate()? }
		self.rsn.validate()?;
		Ok(())
	}
}


// CompensationMethod1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum CompensationMethod1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "NOCP") )]
	CodeNOCP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DBTD") )]
	CodeDBTD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INVD") )]
	CodeINVD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DDBT") )]
	CodeDDBT,
}

impl CompensationMethod1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// CompensationReason1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CompensationReason1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl CompensationReason1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// CompensationRequest1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CompensationRequest1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CompstnAcct", skip_serializing_if = "Option::is_none") )]
	pub compstn_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prd") )]
	pub prd: DatePeriod2,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt", skip_serializing_if = "Option::is_none") )]
	pub amt: Option<ActiveCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XpctdValDt", skip_serializing_if = "Option::is_none") )]
	pub xpctd_val_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstRate", skip_serializing_if = "Option::is_none") )]
	pub intrst_rate: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn", skip_serializing_if = "Option::is_none") )]
	pub rsn: Option<Vec<String>>,
}

impl CompensationRequest1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.compstn_acct { val.validate()? }
		self.prd.validate()?;
		if let Some(ref val) = self.amt { val.validate()? }
		if let Some(ref vec) = self.rsn {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "rsn is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 140 {
					return Err(ValidationError::new(1002, "rsn exceeds the maximum length of 140".to_string()));
				}
			}
		}
		Ok(())
	}
}


// CompensationResponse1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CompensationResponse1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Grantd") )]
	pub grantd: bool,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InitlAmt", skip_serializing_if = "Option::is_none") )]
	pub initl_amt: Option<ActiveCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PdChrgs", skip_serializing_if = "Option::is_none") )]
	pub pd_chrgs: Option<ActiveCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AmtDue", skip_serializing_if = "Option::is_none") )]
	pub amt_due: Option<ActiveCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XpctdValDt", skip_serializing_if = "Option::is_none") )]
	pub xpctd_val_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prd", skip_serializing_if = "Option::is_none") )]
	pub prd: Option<DatePeriod2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrstRate", skip_serializing_if = "Option::is_none") )]
	pub intrst_rate: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn", skip_serializing_if = "Option::is_none") )]
	pub rsn: Option<String>,
}

impl CompensationResponse1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.initl_amt { val.validate()? }
		if let Some(ref val) = self.pd_chrgs { val.validate()? }
		if let Some(ref val) = self.amt_due { val.validate()? }
		if let Some(ref val) = self.prd { val.validate()? }
		if let Some(ref val) = self.rsn {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "rsn is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "rsn exceeds the maximum length of 140".to_string()));
			}
		}
		Ok(())
	}
}


// Contact13 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Contact13 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NmPrfx", skip_serializing_if = "Option::is_none") )]
	pub nm_prfx: Option<NamePrefix2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm", skip_serializing_if = "Option::is_none") )]
	pub nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PhneNb", skip_serializing_if = "Option::is_none") )]
	pub phne_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MobNb", skip_serializing_if = "Option::is_none") )]
	pub mob_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FaxNb", skip_serializing_if = "Option::is_none") )]
	pub fax_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "URLAdr", skip_serializing_if = "Option::is_none") )]
	pub url_adr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EmailAdr", skip_serializing_if = "Option::is_none") )]
	pub email_adr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EmailPurp", skip_serializing_if = "Option::is_none") )]
	pub email_purp: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "JobTitl", skip_serializing_if = "Option::is_none") )]
	pub job_titl: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rspnsblty", skip_serializing_if = "Option::is_none") )]
	pub rspnsblty: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dept", skip_serializing_if = "Option::is_none") )]
	pub dept: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<Vec<OtherContact1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrefrdMtd", skip_serializing_if = "Option::is_none") )]
	pub prefrd_mtd: Option<PreferredContactMethod2Code>,
}

impl Contact13 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.nm_prfx { val.validate()? }
		if let Some(ref val) = self.nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "nm exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.phne_nb {
			let pattern = Regex::new("\\+[0-9]{1,3}-[0-9()+\\-]{1,30}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "phne_nb does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.mob_nb {
			let pattern = Regex::new("\\+[0-9]{1,3}-[0-9()+\\-]{1,30}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "mob_nb does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.fax_nb {
			let pattern = Regex::new("\\+[0-9]{1,3}-[0-9()+\\-]{1,30}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "fax_nb does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.url_adr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "url_adr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 2048 {
				return Err(ValidationError::new(1002, "url_adr exceeds the maximum length of 2048".to_string()));
			}
		}
		if let Some(ref val) = self.email_adr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "email_adr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 256 {
				return Err(ValidationError::new(1002, "email_adr exceeds the maximum length of 256".to_string()));
			}
		}
		if let Some(ref val) = self.email_purp {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "email_purp is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "email_purp exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.job_titl {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "job_titl is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "job_titl exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.rspnsblty {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "rspnsblty is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "rspnsblty exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.dept {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "dept is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 70 {
				return Err(ValidationError::new(1002, "dept exceeds the maximum length of 70".to_string()));
			}
		}
		if let Some(ref vec) = self.othr { for item in vec { item.validate()? } }
		if let Some(ref val) = self.prefrd_mtd { val.validate()? }
		Ok(())
	}
}


// Contact4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Contact4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NmPrfx", skip_serializing_if = "Option::is_none") )]
	pub nm_prfx: Option<NamePrefix2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm", skip_serializing_if = "Option::is_none") )]
	pub nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PhneNb", skip_serializing_if = "Option::is_none") )]
	pub phne_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MobNb", skip_serializing_if = "Option::is_none") )]
	pub mob_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FaxNb", skip_serializing_if = "Option::is_none") )]
	pub fax_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EmailAdr", skip_serializing_if = "Option::is_none") )]
	pub email_adr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EmailPurp", skip_serializing_if = "Option::is_none") )]
	pub email_purp: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "JobTitl", skip_serializing_if = "Option::is_none") )]
	pub job_titl: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rspnsblty", skip_serializing_if = "Option::is_none") )]
	pub rspnsblty: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dept", skip_serializing_if = "Option::is_none") )]
	pub dept: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<Vec<OtherContact1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrefrdMtd", skip_serializing_if = "Option::is_none") )]
	pub prefrd_mtd: Option<PreferredContactMethod1Code>,
}

impl Contact4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.nm_prfx { val.validate()? }
		if let Some(ref val) = self.nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "nm exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.phne_nb {
			let pattern = Regex::new("\\+[0-9]{1,3}-[0-9()+\\-]{1,30}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "phne_nb does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.mob_nb {
			let pattern = Regex::new("\\+[0-9]{1,3}-[0-9()+\\-]{1,30}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "mob_nb does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.fax_nb {
			let pattern = Regex::new("\\+[0-9]{1,3}-[0-9()+\\-]{1,30}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "fax_nb does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.email_adr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "email_adr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 2048 {
				return Err(ValidationError::new(1002, "email_adr exceeds the maximum length of 2048".to_string()));
			}
		}
		if let Some(ref val) = self.email_purp {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "email_purp is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "email_purp exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.job_titl {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "job_titl is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "job_titl exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.rspnsblty {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "rspnsblty is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "rspnsblty exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.dept {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "dept is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 70 {
				return Err(ValidationError::new(1002, "dept exceeds the maximum length of 70".to_string()));
			}
		}
		if let Some(ref vec) = self.othr { for item in vec { item.validate()? } }
		if let Some(ref val) = self.prefrd_mtd { val.validate()? }
		Ok(())
	}
}


// ContactIdentificationAndAddress1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ContactIdentificationAndAddress1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm", skip_serializing_if = "Option::is_none") )]
	pub nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Role") )]
	pub role: PaymentRole1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ComAdr") )]
	pub com_adr: CommunicationAddress8,
}

impl ContactIdentificationAndAddress1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "nm exceeds the maximum length of 35".to_string()));
			}
		}
		self.role.validate()?;
		self.com_adr.validate()?;
		Ok(())
	}
}


// ContactIdentificationAndAddress2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ContactIdentificationAndAddress2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm", skip_serializing_if = "Option::is_none") )]
	pub nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Role") )]
	pub role: PaymentRole1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ComAdr") )]
	pub com_adr: CommunicationAddress10,
}

impl ContactIdentificationAndAddress2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "nm exceeds the maximum length of 35".to_string()));
			}
		}
		self.role.validate()?;
		self.com_adr.validate()?;
		Ok(())
	}
}


// ControlData1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ControlData1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfTxs") )]
	pub nb_of_txs: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrlSum", skip_serializing_if = "Option::is_none") )]
	pub ctrl_sum: Option<f64>,
}

impl ControlData1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[0-9]{1,15}").unwrap();
		if !pattern.is_match(&self.nb_of_txs) {
			return Err(ValidationError::new(1005, "nb_of_txs does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// CopyDuplicate1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum CopyDuplicate1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "CODU") )]
	CodeCODU,
	#[cfg_attr( feature = "derive_serde", serde(rename = "COPY") )]
	CodeCOPY,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DUPL") )]
	CodeDUPL,
}

impl CopyDuplicate1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// CorporateAction9 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CorporateAction9 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "EvtTp") )]
	pub evt_tp: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EvtId") )]
	pub evt_id: String,
}

impl CorporateAction9 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.evt_tp.chars().count() < 1 {
			return Err(ValidationError::new(1001, "evt_tp is shorter than the minimum length of 1".to_string()));
		}
		if self.evt_tp.chars().count() > 35 {
			return Err(ValidationError::new(1002, "evt_tp exceeds the maximum length of 35".to_string()));
		}
		if self.evt_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "evt_id is shorter than the minimum length of 1".to_string()));
		}
		if self.evt_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "evt_id exceeds the maximum length of 35".to_string()));
		}
		Ok(())
	}
}


// CorrectiveGroupInformation1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CorrectiveGroupInformation1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgId") )]
	pub msg_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgNmId") )]
	pub msg_nm_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CreDtTm", skip_serializing_if = "Option::is_none") )]
	pub cre_dt_tm: Option<String>,
}

impl CorrectiveGroupInformation1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.msg_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "msg_id is shorter than the minimum length of 1".to_string()));
		}
		if self.msg_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "msg_id exceeds the maximum length of 35".to_string()));
		}
		if self.msg_nm_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "msg_nm_id is shorter than the minimum length of 1".to_string()));
		}
		if self.msg_nm_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "msg_nm_id exceeds the maximum length of 35".to_string()));
		}
		Ok(())
	}
}


// CorrectiveInterbankTransaction3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CorrectiveInterbankTransaction3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "GrpHdr", skip_serializing_if = "Option::is_none") )]
	pub grp_hdr: Option<CorrectiveGroupInformation1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstrId", skip_serializing_if = "Option::is_none") )]
	pub instr_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EndToEndId", skip_serializing_if = "Option::is_none") )]
	pub end_to_end_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxId", skip_serializing_if = "Option::is_none") )]
	pub tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UETR", skip_serializing_if = "Option::is_none") )]
	pub uetr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrBkSttlmAmt") )]
	pub intr_bk_sttlm_amt: ActiveOrHistoricCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrBkSttlmDt") )]
	pub intr_bk_sttlm_dt: String,
}

impl CorrectiveInterbankTransaction3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.grp_hdr { val.validate()? }
		if let Some(ref val) = self.instr_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "instr_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "instr_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.end_to_end_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "end_to_end_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "end_to_end_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.uetr {
			let pattern = Regex::new("[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "uetr does not match the required pattern".to_string()));
			}
		}
		self.intr_bk_sttlm_amt.validate()?;
		Ok(())
	}
}


// CorrectivePaymentInitiation5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CorrectivePaymentInitiation5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "GrpHdr", skip_serializing_if = "Option::is_none") )]
	pub grp_hdr: Option<CorrectiveGroupInformation1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtInfId", skip_serializing_if = "Option::is_none") )]
	pub pmt_inf_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstrId", skip_serializing_if = "Option::is_none") )]
	pub instr_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EndToEndId", skip_serializing_if = "Option::is_none") )]
	pub end_to_end_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UETR", skip_serializing_if = "Option::is_none") )]
	pub uetr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstdAmt") )]
	pub instd_amt: ActiveOrHistoricCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReqdExctnDt", skip_serializing_if = "Option::is_none") )]
	pub reqd_exctn_dt: Option<DateAndDateTime2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReqdColltnDt", skip_serializing_if = "Option::is_none") )]
	pub reqd_colltn_dt: Option<String>,
}

impl CorrectivePaymentInitiation5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.grp_hdr { val.validate()? }
		if let Some(ref val) = self.pmt_inf_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "pmt_inf_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "pmt_inf_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.instr_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "instr_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "instr_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.end_to_end_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "end_to_end_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "end_to_end_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.uetr {
			let pattern = Regex::new("[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "uetr does not match the required pattern".to_string()));
			}
		}
		self.instd_amt.validate()?;
		if let Some(ref val) = self.reqd_exctn_dt { val.validate()? }
		Ok(())
	}
}


// CorrectiveTransaction5Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CorrectiveTransaction5Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Initn", skip_serializing_if = "Option::is_none") )]
	pub initn: Option<CorrectivePaymentInitiation5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrBk", skip_serializing_if = "Option::is_none") )]
	pub intr_bk: Option<CorrectiveInterbankTransaction3>,
}

impl CorrectiveTransaction5Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.initn { val.validate()? }
		if let Some(ref val) = self.intr_bk { val.validate()? }
		Ok(())
	}
}


// CreditDebitCode ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum CreditDebitCode {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "CRDT") )]
	CodeCRDT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DBIT") )]
	CodeDBIT,
}

impl CreditDebitCode {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// CreditLine3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CreditLine3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Incl") )]
	pub incl: bool,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<CreditLineType1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt", skip_serializing_if = "Option::is_none") )]
	pub amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dt", skip_serializing_if = "Option::is_none") )]
	pub dt: Option<DateAndDateTime2Choice>,
}

impl CreditLine3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tp { val.validate()? }
		if let Some(ref val) = self.amt { val.validate()? }
		if let Some(ref val) = self.dt { val.validate()? }
		Ok(())
	}
}


// CreditLineType1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CreditLineType1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl CreditLineType1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// CreditTransferMandateData1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CreditTransferMandateData1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MndtId", skip_serializing_if = "Option::is_none") )]
	pub mndt_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<MandateTypeInformation2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtOfSgntr", skip_serializing_if = "Option::is_none") )]
	pub dt_of_sgntr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtOfVrfctn", skip_serializing_if = "Option::is_none") )]
	pub dt_of_vrfctn: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ElctrncSgntr", skip_serializing_if = "Option::is_none") )]
	pub elctrnc_sgntr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrstPmtDt", skip_serializing_if = "Option::is_none") )]
	pub frst_pmt_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FnlPmtDt", skip_serializing_if = "Option::is_none") )]
	pub fnl_pmt_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Frqcy", skip_serializing_if = "Option::is_none") )]
	pub frqcy: Option<Frequency36Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn", skip_serializing_if = "Option::is_none") )]
	pub rsn: Option<MandateSetupReason1Choice>,
}

impl CreditTransferMandateData1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.mndt_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "mndt_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "mndt_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.tp { val.validate()? }
		if let Some(ref val) = self.elctrnc_sgntr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "elctrnc_sgntr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 10240 {
				return Err(ValidationError::new(1002, "elctrnc_sgntr exceeds the maximum length of 10240".to_string()));
			}
		}
		if let Some(ref val) = self.frqcy { val.validate()? }
		if let Some(ref val) = self.rsn { val.validate()? }
		Ok(())
	}
}


// CreditorReferenceInformation2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CreditorReferenceInformation2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<CreditorReferenceType2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ref", skip_serializing_if = "Option::is_none") )]
	pub ref_attr: Option<String>,
}

impl CreditorReferenceInformation2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tp { val.validate()? }
		if let Some(ref val) = self.ref_attr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "ref_attr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "ref_attr exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// CreditorReferenceInformation3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CreditorReferenceInformation3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<CreditorReferenceType3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ref", skip_serializing_if = "Option::is_none") )]
	pub ref_attr: Option<String>,
}

impl CreditorReferenceInformation3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tp { val.validate()? }
		if let Some(ref val) = self.ref_attr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "ref_attr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "ref_attr exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// CreditorReferenceType1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CreditorReferenceType1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<DocumentType3Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl CreditorReferenceType1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// CreditorReferenceType2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CreditorReferenceType2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdOrPrtry") )]
	pub cd_or_prtry: CreditorReferenceType1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr", skip_serializing_if = "Option::is_none") )]
	pub issr: Option<String>,
}

impl CreditorReferenceType2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.cd_or_prtry.validate()?;
		if let Some(ref val) = self.issr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "issr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "issr exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// CreditorReferenceType2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CreditorReferenceType2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl CreditorReferenceType2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// CreditorReferenceType3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CreditorReferenceType3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdOrPrtry") )]
	pub cd_or_prtry: CreditorReferenceType2Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr", skip_serializing_if = "Option::is_none") )]
	pub issr: Option<String>,
}

impl CreditorReferenceType3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.cd_or_prtry.validate()?;
		if let Some(ref val) = self.issr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "issr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "issr exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// CurrencyCriteriaDefinition1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CurrencyCriteriaDefinition1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "QryNm", skip_serializing_if = "Option::is_none") )]
	pub qry_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NewCrit", skip_serializing_if = "Option::is_none") )]
	pub new_crit: Option<CurrencyExchangeCriteria2>,
}

impl CurrencyCriteriaDefinition1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.qry_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "qry_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "qry_nm exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.new_crit { val.validate()? }
		Ok(())
	}
}


// CurrencyDesignation1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CurrencyDesignation1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CcyDsgnt", skip_serializing_if = "Option::is_none") )]
	pub ccy_dsgnt: Option<CurrencyDesignation1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Lctn", skip_serializing_if = "Option::is_none") )]
	pub lctn: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_inf: Option<String>,
}

impl CurrencyDesignation1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ccy_dsgnt { val.validate()? }
		if let Some(ref val) = self.lctn {
			let pattern = Regex::new("[A-Z]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "lctn does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.addtl_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 350 {
				return Err(ValidationError::new(1002, "addtl_inf exceeds the maximum length of 350".to_string()));
			}
		}
		Ok(())
	}
}


// CurrencyDesignation1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum CurrencyDesignation1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ONSH") )]
	CodeONSH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OFFS") )]
	CodeOFFS,
}

impl CurrencyDesignation1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// CurrencyExchange20 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CurrencyExchange20 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "XchgRate") )]
	pub xchg_rate: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "QtdCcy") )]
	pub qtd_ccy: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "QtnDt") )]
	pub qtn_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LwLmt", skip_serializing_if = "Option::is_none") )]
	pub lw_lmt: Option<ExchangeRateOrPercentage1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "HghLmt", skip_serializing_if = "Option::is_none") )]
	pub hgh_lmt: Option<ExchangeRateOrPercentage1Choice>,
}

impl CurrencyExchange20 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z]{3,3}").unwrap();
		if !pattern.is_match(&self.qtd_ccy) {
			return Err(ValidationError::new(1005, "qtd_ccy does not match the required pattern".to_string()));
		}
		if let Some(ref val) = self.lw_lmt { val.validate()? }
		if let Some(ref val) = self.hgh_lmt { val.validate()? }
		Ok(())
	}
}


// CurrencyExchange24 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CurrencyExchange24 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SrcCcy") )]
	pub src_ccy: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TrgtCcy", skip_serializing_if = "Option::is_none") )]
	pub trgt_ccy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnitCcy", skip_serializing_if = "Option::is_none") )]
	pub unit_ccy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XchgRate") )]
	pub xchg_rate: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrctId", skip_serializing_if = "Option::is_none") )]
	pub ctrct_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "QtnDt", skip_serializing_if = "Option::is_none") )]
	pub qtn_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XchgRateBase", skip_serializing_if = "Option::is_none") )]
	pub xchg_rate_base: Option<f64>,
}

impl CurrencyExchange24 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z]{3,3}").unwrap();
		if !pattern.is_match(&self.src_ccy) {
			return Err(ValidationError::new(1005, "src_ccy does not match the required pattern".to_string()));
		}
		if let Some(ref val) = self.trgt_ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "trgt_ccy does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.unit_ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "unit_ccy does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.ctrct_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "ctrct_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "ctrct_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.xchg_rate_base {
			if *val < 1.000000 {
				return Err(ValidationError::new(1003, "xchg_rate_base is less than the minimum value of 1.000000".to_string()));
			}
		}
		Ok(())
	}
}


// CurrencyExchange6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CurrencyExchange6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SrcCcy") )]
	pub src_ccy: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TrgtCcy") )]
	pub trgt_ccy: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XchgRate") )]
	pub xchg_rate: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Desc", skip_serializing_if = "Option::is_none") )]
	pub desc: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnitCcy", skip_serializing_if = "Option::is_none") )]
	pub unit_ccy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cmnts", skip_serializing_if = "Option::is_none") )]
	pub cmnts: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "QtnDt", skip_serializing_if = "Option::is_none") )]
	pub qtn_dt: Option<String>,
}

impl CurrencyExchange6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z]{3,3}").unwrap();
		if !pattern.is_match(&self.src_ccy) {
			return Err(ValidationError::new(1005, "src_ccy does not match the required pattern".to_string()));
		}
		let pattern = Regex::new("[A-Z]{3,3}").unwrap();
		if !pattern.is_match(&self.trgt_ccy) {
			return Err(ValidationError::new(1005, "trgt_ccy does not match the required pattern".to_string()));
		}
		if let Some(ref val) = self.desc {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "desc is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 40 {
				return Err(ValidationError::new(1002, "desc exceeds the maximum length of 40".to_string()));
			}
		}
		if let Some(ref val) = self.unit_ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "unit_ccy does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.cmnts {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cmnts is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 70 {
				return Err(ValidationError::new(1002, "cmnts exceeds the maximum length of 70".to_string()));
			}
		}
		Ok(())
	}
}


// CurrencyExchangeCriteria2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CurrencyExchangeCriteria2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NewQryNm", skip_serializing_if = "Option::is_none") )]
	pub new_qry_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SchCrit") )]
	pub sch_crit: Vec<CurrencyExchangeSearchCriteria1>,
}

impl CurrencyExchangeCriteria2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.new_qry_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "new_qry_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "new_qry_nm exceeds the maximum length of 35".to_string()));
			}
		}
		for item in &self.sch_crit { item.validate()? }
		Ok(())
	}
}


// CurrencyExchangeReport4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CurrencyExchangeReport4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CcyRef") )]
	pub ccy_ref: CurrencySourceTarget1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CcyXchgOrErr") )]
	pub ccy_xchg_or_err: ExchangeRateReportOrError4Choice,
}

impl CurrencyExchangeReport4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.ccy_ref.validate()?;
		self.ccy_xchg_or_err.validate()?;
		Ok(())
	}
}


// CurrencyExchangeSearchCriteria1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CurrencyExchangeSearchCriteria1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SrcCcy") )]
	pub src_ccy: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TrgtCcy") )]
	pub trgt_ccy: String,
}

impl CurrencyExchangeSearchCriteria1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z]{3,3}").unwrap();
		if !pattern.is_match(&self.src_ccy) {
			return Err(ValidationError::new(1005, "src_ccy does not match the required pattern".to_string()));
		}
		let pattern = Regex::new("[A-Z]{3,3}").unwrap();
		if !pattern.is_match(&self.trgt_ccy) {
			return Err(ValidationError::new(1005, "trgt_ccy does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// CurrencyFactors1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CurrencyFactors1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ccy") )]
	pub ccy: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ShrtPosLmt") )]
	pub shrt_pos_lmt: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MinPayInAmt") )]
	pub min_pay_in_amt: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VoltlyMrgn") )]
	pub voltly_mrgn: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rate", skip_serializing_if = "Option::is_none") )]
	pub rate: Option<AgreedRate2>,
}

impl CurrencyFactors1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z]{3,3}").unwrap();
		if !pattern.is_match(&self.ccy) {
			return Err(ValidationError::new(1005, "ccy does not match the required pattern".to_string()));
		}
		if self.shrt_pos_lmt < 0.000000 {
			return Err(ValidationError::new(1003, "shrt_pos_lmt is less than the minimum value of 0.000000".to_string()));
		}
		if self.min_pay_in_amt < 0.000000 {
			return Err(ValidationError::new(1003, "min_pay_in_amt is less than the minimum value of 0.000000".to_string()));
		}
		if let Some(ref val) = self.rate { val.validate()? }
		Ok(())
	}
}


// CurrencyQueryDefinition3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CurrencyQueryDefinition3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "QryTp", skip_serializing_if = "Option::is_none") )]
	pub qry_tp: Option<QueryType2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CcyCrit", skip_serializing_if = "Option::is_none") )]
	pub ccy_crit: Option<CurrencyCriteriaDefinition1Choice>,
}

impl CurrencyQueryDefinition3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.qry_tp { val.validate()? }
		if let Some(ref val) = self.ccy_crit { val.validate()? }
		Ok(())
	}
}


// CurrencySourceTarget1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CurrencySourceTarget1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SrcCcy") )]
	pub src_ccy: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TrgtCcy") )]
	pub trgt_ccy: String,
}

impl CurrencySourceTarget1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z]{3,3}").unwrap();
		if !pattern.is_match(&self.src_ccy) {
			return Err(ValidationError::new(1005, "src_ccy does not match the required pattern".to_string()));
		}
		let pattern = Regex::new("[A-Z]{3,3}").unwrap();
		if !pattern.is_match(&self.trgt_ccy) {
			return Err(ValidationError::new(1005, "trgt_ccy does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// CurrentAndDefaultReservation6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CurrentAndDefaultReservation6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CurRsvatn", skip_serializing_if = "Option::is_none") )]
	pub cur_rsvatn: Option<Vec<ReservationReport8>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DfltRsvatn", skip_serializing_if = "Option::is_none") )]
	pub dflt_rsvatn: Option<Vec<ReservationReport8>>,
}

impl CurrentAndDefaultReservation6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.cur_rsvatn { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.dflt_rsvatn { for item in vec { item.validate()? } }
		Ok(())
	}
}


// CurrentOrDefaultReservation4Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct CurrentOrDefaultReservation4Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cur", skip_serializing_if = "Option::is_none") )]
	pub cur: Option<ReservationIdentification4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dflt", skip_serializing_if = "Option::is_none") )]
	pub dflt: Option<ReservationIdentification4>,
}

impl CurrentOrDefaultReservation4Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cur { val.validate()? }
		if let Some(ref val) = self.dflt { val.validate()? }
		Ok(())
	}
}


// DataFormat2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct DataFormat2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Strd", skip_serializing_if = "Option::is_none") )]
	pub strd: Option<GenericIdentification1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ustrd", skip_serializing_if = "Option::is_none") )]
	pub ustrd: Option<String>,
}

impl DataFormat2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.strd { val.validate()? }
		if let Some(ref val) = self.ustrd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "ustrd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "ustrd exceeds the maximum length of 140".to_string()));
			}
		}
		Ok(())
	}
}


// DateAndDateTime2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct DateAndDateTime2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dt", skip_serializing_if = "Option::is_none") )]
	pub dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtTm", skip_serializing_if = "Option::is_none") )]
	pub dt_tm: Option<String>,
}

impl DateAndDateTime2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// DateAndDateTimeChoice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct DateAndDateTimeChoice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dt", skip_serializing_if = "Option::is_none") )]
	pub dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtTm", skip_serializing_if = "Option::is_none") )]
	pub dt_tm: Option<String>,
}

impl DateAndDateTimeChoice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// DateAndDateTimeSearch3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct DateAndDateTimeSearch3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtTmSch", skip_serializing_if = "Option::is_none") )]
	pub dt_tm_sch: Option<DateTimePeriod1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtSch", skip_serializing_if = "Option::is_none") )]
	pub dt_sch: Option<DatePeriodSearch1Choice>,
}

impl DateAndDateTimeSearch3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.dt_tm_sch { val.validate()? }
		if let Some(ref val) = self.dt_sch { val.validate()? }
		Ok(())
	}
}


// DateAndDateTimeSearch4Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct DateAndDateTimeSearch4Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtTm", skip_serializing_if = "Option::is_none") )]
	pub dt_tm: Option<DateTimeSearch2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dt", skip_serializing_if = "Option::is_none") )]
	pub dt: Option<DatePeriodSearch1Choice>,
}

impl DateAndDateTimeSearch4Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.dt_tm { val.validate()? }
		if let Some(ref val) = self.dt { val.validate()? }
		Ok(())
	}
}


// DateAndDateTimeSearch5Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct DateAndDateTimeSearch5Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dt", skip_serializing_if = "Option::is_none") )]
	pub dt: Option<DatePeriodSearch1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtTm", skip_serializing_if = "Option::is_none") )]
	pub dt_tm: Option<DateTimeSearch2Choice>,
}

impl DateAndDateTimeSearch5Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.dt { val.validate()? }
		if let Some(ref val) = self.dt_tm { val.validate()? }
		Ok(())
	}
}


// DateAndPeriod2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct DateAndPeriod2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dt", skip_serializing_if = "Option::is_none") )]
	pub dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prd", skip_serializing_if = "Option::is_none") )]
	pub prd: Option<Period2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrDt", skip_serializing_if = "Option::is_none") )]
	pub fr_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ToDt", skip_serializing_if = "Option::is_none") )]
	pub to_dt: Option<String>,
}

impl DateAndPeriod2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.prd { val.validate()? }
		Ok(())
	}
}


// DateAndPlaceOfBirth1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct DateAndPlaceOfBirth1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BirthDt") )]
	pub birth_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrvcOfBirth", skip_serializing_if = "Option::is_none") )]
	pub prvc_of_birth: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CityOfBirth") )]
	pub city_of_birth: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtryOfBirth") )]
	pub ctry_of_birth: String,
}

impl DateAndPlaceOfBirth1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.prvc_of_birth {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prvc_of_birth is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prvc_of_birth exceeds the maximum length of 35".to_string()));
			}
		}
		if self.city_of_birth.chars().count() < 1 {
			return Err(ValidationError::new(1001, "city_of_birth is shorter than the minimum length of 1".to_string()));
		}
		if self.city_of_birth.chars().count() > 35 {
			return Err(ValidationError::new(1002, "city_of_birth exceeds the maximum length of 35".to_string()));
		}
		let pattern = Regex::new("[A-Z]{2,2}").unwrap();
		if !pattern.is_match(&self.ctry_of_birth) {
			return Err(ValidationError::new(1005, "ctry_of_birth does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// DateAndType1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct DateAndType1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: DateType2Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dt") )]
	pub dt: String,
}

impl DateAndType1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.tp.validate()?;
		Ok(())
	}
}


// DateOrDateTimePeriod1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct DateOrDateTimePeriod1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dt", skip_serializing_if = "Option::is_none") )]
	pub dt: Option<DatePeriod2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtTm", skip_serializing_if = "Option::is_none") )]
	pub dt_tm: Option<DateTimePeriod1>,
}

impl DateOrDateTimePeriod1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.dt { val.validate()? }
		if let Some(ref val) = self.dt_tm { val.validate()? }
		Ok(())
	}
}


// DatePeriod1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct DatePeriod1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrDt", skip_serializing_if = "Option::is_none") )]
	pub fr_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ToDt") )]
	pub to_dt: String,
}

impl DatePeriod1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// DatePeriod2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct DatePeriod2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrDt") )]
	pub fr_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ToDt") )]
	pub to_dt: String,
}

impl DatePeriod2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// DatePeriod2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct DatePeriod2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrDt", skip_serializing_if = "Option::is_none") )]
	pub fr_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ToDt", skip_serializing_if = "Option::is_none") )]
	pub to_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrToDt", skip_serializing_if = "Option::is_none") )]
	pub fr_to_dt: Option<DatePeriod2>,
}

impl DatePeriod2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.fr_to_dt { val.validate()? }
		Ok(())
	}
}


// DatePeriod3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct DatePeriod3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrDt") )]
	pub fr_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ToDt", skip_serializing_if = "Option::is_none") )]
	pub to_dt: Option<String>,
}

impl DatePeriod3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// DatePeriod5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct DatePeriod5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CurValDt") )]
	pub cur_val_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReqdValDt") )]
	pub reqd_val_dt: String,
}

impl DatePeriod5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// DatePeriodSearch1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct DatePeriodSearch1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrDt", skip_serializing_if = "Option::is_none") )]
	pub fr_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ToDt", skip_serializing_if = "Option::is_none") )]
	pub to_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrToDt", skip_serializing_if = "Option::is_none") )]
	pub fr_to_dt: Option<DatePeriod2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EQDt", skip_serializing_if = "Option::is_none") )]
	pub eq_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NEQDt", skip_serializing_if = "Option::is_none") )]
	pub neq_dt: Option<String>,
}

impl DatePeriodSearch1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.fr_to_dt { val.validate()? }
		Ok(())
	}
}


// DateTimePeriod1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct DateTimePeriod1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrDtTm") )]
	pub fr_dt_tm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ToDtTm") )]
	pub to_dt_tm: String,
}

impl DateTimePeriod1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// DateTimePeriod1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct DateTimePeriod1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrDtTm", skip_serializing_if = "Option::is_none") )]
	pub fr_dt_tm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ToDtTm", skip_serializing_if = "Option::is_none") )]
	pub to_dt_tm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtTmRg", skip_serializing_if = "Option::is_none") )]
	pub dt_tm_rg: Option<DateTimePeriod1>,
}

impl DateTimePeriod1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.dt_tm_rg { val.validate()? }
		Ok(())
	}
}


// DateTimeSearch2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct DateTimeSearch2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrDtTm", skip_serializing_if = "Option::is_none") )]
	pub fr_dt_tm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ToDtTm", skip_serializing_if = "Option::is_none") )]
	pub to_dt_tm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrToDtTm", skip_serializing_if = "Option::is_none") )]
	pub fr_to_dt_tm: Option<DateTimePeriod1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EQDtTm", skip_serializing_if = "Option::is_none") )]
	pub eq_dt_tm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NEQDtTm", skip_serializing_if = "Option::is_none") )]
	pub neq_dt_tm: Option<String>,
}

impl DateTimeSearch2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.fr_to_dt_tm { val.validate()? }
		Ok(())
	}
}


// DateType2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct DateType2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl DateType2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// DebitAuthorisation2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct DebitAuthorisation2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CxlRsn") )]
	pub cxl_rsn: CancellationReason33Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AmtToDbt", skip_serializing_if = "Option::is_none") )]
	pub amt_to_dbt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ValDtToDbt", skip_serializing_if = "Option::is_none") )]
	pub val_dt_to_dbt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlCxlRsnInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_cxl_rsn_inf: Option<Vec<String>>,
}

impl DebitAuthorisation2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.cxl_rsn.validate()?;
		if let Some(ref val) = self.amt_to_dbt { val.validate()? }
		if let Some(ref vec) = self.addtl_cxl_rsn_inf {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "addtl_cxl_rsn_inf is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 105 {
					return Err(ValidationError::new(1002, "addtl_cxl_rsn_inf exceeds the maximum length of 105".to_string()));
				}
			}
		}
		Ok(())
	}
}


// DebitAuthorisation3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct DebitAuthorisation3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CxlRsn") )]
	pub cxl_rsn: CancellationReason33Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AmtToDbt", skip_serializing_if = "Option::is_none") )]
	pub amt_to_dbt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Acct", skip_serializing_if = "Option::is_none") )]
	pub acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ValDtToDbt", skip_serializing_if = "Option::is_none") )]
	pub val_dt_to_dbt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlCxlRsnInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_cxl_rsn_inf: Option<Vec<String>>,
}

impl DebitAuthorisation3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.cxl_rsn.validate()?;
		if let Some(ref val) = self.amt_to_dbt { val.validate()? }
		if let Some(ref val) = self.acct { val.validate()? }
		if let Some(ref vec) = self.addtl_cxl_rsn_inf {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "addtl_cxl_rsn_inf is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 140 {
					return Err(ValidationError::new(1002, "addtl_cxl_rsn_inf exceeds the maximum length of 140".to_string()));
				}
			}
		}
		Ok(())
	}
}


// DebitAuthorisationConfirmation2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct DebitAuthorisationConfirmation2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtAuthstn") )]
	pub dbt_authstn: bool,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AmtToDbt", skip_serializing_if = "Option::is_none") )]
	pub amt_to_dbt: Option<ActiveCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ValDtToDbt", skip_serializing_if = "Option::is_none") )]
	pub val_dt_to_dbt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn", skip_serializing_if = "Option::is_none") )]
	pub rsn: Option<String>,
}

impl DebitAuthorisationConfirmation2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.amt_to_dbt { val.validate()? }
		if let Some(ref val) = self.rsn {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "rsn is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "rsn exceeds the maximum length of 140".to_string()));
			}
		}
		Ok(())
	}
}


// DebitAuthorisationConfirmation3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct DebitAuthorisationConfirmation3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtAuthstn") )]
	pub dbt_authstn: bool,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AmtToDbt", skip_serializing_if = "Option::is_none") )]
	pub amt_to_dbt: Option<ActiveCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Acct", skip_serializing_if = "Option::is_none") )]
	pub acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ValDtToDbt", skip_serializing_if = "Option::is_none") )]
	pub val_dt_to_dbt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CmonTxId", skip_serializing_if = "Option::is_none") )]
	pub cmon_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn", skip_serializing_if = "Option::is_none") )]
	pub rsn: Option<String>,
}

impl DebitAuthorisationConfirmation3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.amt_to_dbt { val.validate()? }
		if let Some(ref val) = self.acct { val.validate()? }
		if let Some(ref val) = self.cmon_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cmon_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 52 {
				return Err(ValidationError::new(1002, "cmon_tx_id exceeds the maximum length of 52".to_string()));
			}
		}
		if let Some(ref val) = self.rsn {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "rsn is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "rsn exceeds the maximum length of 140".to_string()));
			}
		}
		Ok(())
	}
}


// DeniedReason11 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct DeniedReason11 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd") )]
	pub cd: DeniedReason16Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlRsnInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_rsn_inf: Option<String>,
}

impl DeniedReason11 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.cd.validate()?;
		if let Some(ref val) = self.addtl_rsn_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_rsn_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 210 {
				return Err(ValidationError::new(1002, "addtl_rsn_inf exceeds the maximum length of 210".to_string()));
			}
		}
		Ok(())
	}
}


// DeniedReason16Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct DeniedReason16Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<DeniedReason4Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification30>,
}

impl DeniedReason16Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// DeniedReason4Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum DeniedReason4Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ADEA") )]
	CodeADEA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DCAN") )]
	CodeDCAN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DPRG") )]
	CodeDPRG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DREP") )]
	CodeDREP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DSET") )]
	CodeDSET,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LATE") )]
	CodeLATE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CDRG") )]
	CodeCDRG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CDCY") )]
	CodeCDCY,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CDRE") )]
	CodeCDRE,
}

impl DeniedReason4Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// DeniedStatus16Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct DeniedStatus16Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NoSpcfdRsn", skip_serializing_if = "Option::is_none") )]
	pub no_spcfd_rsn: Option<NoReasonCode>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn", skip_serializing_if = "Option::is_none") )]
	pub rsn: Option<Vec<DeniedReason11>>,
}

impl DeniedStatus16Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.no_spcfd_rsn { val.validate()? }
		if let Some(ref vec) = self.rsn { for item in vec { item.validate()? } }
		Ok(())
	}
}


// DiscountAmountAndType1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct DiscountAmountAndType1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<DiscountAmountType1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveOrHistoricCurrencyAndAmount,
}

impl DiscountAmountAndType1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tp { val.validate()? }
		self.amt.validate()?;
		Ok(())
	}
}


// DiscountAmountType1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct DiscountAmountType1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl DiscountAmountType1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// DisplayCapabilities1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct DisplayCapabilities1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DispTp") )]
	pub disp_tp: UserInterface2Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfLines") )]
	pub nb_of_lines: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LineWidth") )]
	pub line_width: String,
}

impl DisplayCapabilities1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.disp_tp.validate()?;
		let pattern = Regex::new("[0-9]{1,3}").unwrap();
		if !pattern.is_match(&self.nb_of_lines) {
			return Err(ValidationError::new(1005, "nb_of_lines does not match the required pattern".to_string()));
		}
		let pattern = Regex::new("[0-9]{1,3}").unwrap();
		if !pattern.is_match(&self.line_width) {
			return Err(ValidationError::new(1005, "line_width does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// DistributionPolicy1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum DistributionPolicy1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "DIST") )]
	CodeDIST,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ACCU") )]
	CodeACCU,
}

impl DistributionPolicy1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// Document12 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Document12 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: DocumentType1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IsseDt") )]
	pub isse_dt: DateAndDateTime2Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm", skip_serializing_if = "Option::is_none") )]
	pub nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LangCd", skip_serializing_if = "Option::is_none") )]
	pub lang_cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Frmt") )]
	pub frmt: DocumentFormat1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FileNm", skip_serializing_if = "Option::is_none") )]
	pub file_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DgtlSgntr", skip_serializing_if = "Option::is_none") )]
	pub dgtl_sgntr: Option<PartyAndSignature3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nclsr") )]
	pub nclsr: String,
}

impl Document12 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.tp.validate()?;
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
		}
		self.isse_dt.validate()?;
		if let Some(ref val) = self.nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "nm exceeds the maximum length of 140".to_string()));
			}
		}
		self.frmt.validate()?;
		if let Some(ref val) = self.file_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "file_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "file_nm exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.dgtl_sgntr { val.validate()? }
		if self.nclsr.chars().count() < 1 {
			return Err(ValidationError::new(1001, "nclsr is shorter than the minimum length of 1".to_string()));
		}
		if self.nclsr.chars().count() > 10485760 {
			return Err(ValidationError::new(1002, "nclsr exceeds the maximum length of 10485760".to_string()));
		}
		Ok(())
	}
}


// DocumentAdjustment1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct DocumentAdjustment1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveOrHistoricCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtDbtInd", skip_serializing_if = "Option::is_none") )]
	pub cdt_dbt_ind: Option<CreditDebitCode>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn", skip_serializing_if = "Option::is_none") )]
	pub rsn: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_inf: Option<String>,
}

impl DocumentAdjustment1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.amt.validate()?;
		if let Some(ref val) = self.cdt_dbt_ind { val.validate()? }
		if let Some(ref val) = self.rsn {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "rsn is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "rsn exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.addtl_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "addtl_inf exceeds the maximum length of 140".to_string()));
			}
		}
		Ok(())
	}
}


// DocumentAmount1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct DocumentAmount1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: DocumentAmountType1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveOrHistoricCurrencyAndAmount,
}

impl DocumentAmount1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.tp.validate()?;
		self.amt.validate()?;
		Ok(())
	}
}


// DocumentAmountType1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct DocumentAmountType1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl DocumentAmountType1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// DocumentFormat1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct DocumentFormat1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification1>,
}

impl DocumentFormat1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// DocumentIdentification51 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct DocumentIdentification51 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CreDtTm", skip_serializing_if = "Option::is_none") )]
	pub cre_dt_tm: Option<DateAndDateTime2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CpyDplct", skip_serializing_if = "Option::is_none") )]
	pub cpy_dplct: Option<CopyDuplicate1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgOrgtr", skip_serializing_if = "Option::is_none") )]
	pub msg_orgtr: Option<PartyIdentification136>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgRcpt", skip_serializing_if = "Option::is_none") )]
	pub msg_rcpt: Option<PartyIdentification136>,
}

impl DocumentIdentification51 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.cre_dt_tm { val.validate()? }
		if let Some(ref val) = self.cpy_dplct { val.validate()? }
		if let Some(ref val) = self.msg_orgtr { val.validate()? }
		if let Some(ref val) = self.msg_rcpt { val.validate()? }
		Ok(())
	}
}


// DocumentLineIdentification1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct DocumentLineIdentification1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<DocumentLineType1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nb", skip_serializing_if = "Option::is_none") )]
	pub nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RltdDt", skip_serializing_if = "Option::is_none") )]
	pub rltd_dt: Option<String>,
}

impl DocumentLineIdentification1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tp { val.validate()? }
		if let Some(ref val) = self.nb {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nb is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "nb exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// DocumentLineInformation1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct DocumentLineInformation1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: Vec<DocumentLineIdentification1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Desc", skip_serializing_if = "Option::is_none") )]
	pub desc: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt", skip_serializing_if = "Option::is_none") )]
	pub amt: Option<RemittanceAmount3>,
}

impl DocumentLineInformation1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		for item in &self.id { item.validate()? }
		if let Some(ref val) = self.desc {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "desc is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 2048 {
				return Err(ValidationError::new(1002, "desc exceeds the maximum length of 2048".to_string()));
			}
		}
		if let Some(ref val) = self.amt { val.validate()? }
		Ok(())
	}
}


// DocumentLineInformation2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct DocumentLineInformation2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: Vec<DocumentLineIdentification1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Desc", skip_serializing_if = "Option::is_none") )]
	pub desc: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt", skip_serializing_if = "Option::is_none") )]
	pub amt: Option<RemittanceAmount4>,
}

impl DocumentLineInformation2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		for item in &self.id { item.validate()? }
		if let Some(ref val) = self.desc {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "desc is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 2048 {
				return Err(ValidationError::new(1002, "desc exceeds the maximum length of 2048".to_string()));
			}
		}
		if let Some(ref val) = self.amt { val.validate()? }
		Ok(())
	}
}


// DocumentLineType1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct DocumentLineType1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdOrPrtry") )]
	pub cd_or_prtry: DocumentLineType1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr", skip_serializing_if = "Option::is_none") )]
	pub issr: Option<String>,
}

impl DocumentLineType1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.cd_or_prtry.validate()?;
		if let Some(ref val) = self.issr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "issr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "issr exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// DocumentLineType1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct DocumentLineType1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl DocumentLineType1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// DocumentNumber5Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct DocumentNumber5Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ShrtNb", skip_serializing_if = "Option::is_none") )]
	pub shrt_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LngNb", skip_serializing_if = "Option::is_none") )]
	pub lng_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrtryNb", skip_serializing_if = "Option::is_none") )]
	pub prtry_nb: Option<GenericIdentification36>,
}

impl DocumentNumber5Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.shrt_nb {
			let pattern = Regex::new("[0-9]{3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "shrt_nb does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.lng_nb {
			let pattern = Regex::new("[a-z]{4}\\.[0-9]{3}\\.[0-9]{3}\\.[0-9]{2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "lng_nb does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.prtry_nb { val.validate()? }
		Ok(())
	}
}


// DocumentType1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct DocumentType1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdOrPrtry") )]
	pub cd_or_prtry: DocumentType2Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr", skip_serializing_if = "Option::is_none") )]
	pub issr: Option<String>,
}

impl DocumentType1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.cd_or_prtry.validate()?;
		if let Some(ref val) = self.issr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "issr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "issr exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// DocumentType1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct DocumentType1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification1>,
}

impl DocumentType1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// DocumentType2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct DocumentType2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl DocumentType2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// DocumentType3Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum DocumentType3Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "RADM") )]
	CodeRADM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RPIN") )]
	CodeRPIN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FXDR") )]
	CodeFXDR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DISP") )]
	CodeDISP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PUOR") )]
	CodePUOR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SCOR") )]
	CodeSCOR,
}

impl DocumentType3Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// DocumentType6Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum DocumentType6Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "MSIN") )]
	CodeMSIN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CNFA") )]
	CodeCNFA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DNFA") )]
	CodeDNFA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CINV") )]
	CodeCINV,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CREN") )]
	CodeCREN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DEBN") )]
	CodeDEBN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "HIRI") )]
	CodeHIRI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SBIN") )]
	CodeSBIN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CMCN") )]
	CodeCMCN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SOAC") )]
	CodeSOAC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DISP") )]
	CodeDISP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BOLD") )]
	CodeBOLD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VCHR") )]
	CodeVCHR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AROI") )]
	CodeAROI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TSUT") )]
	CodeTSUT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PUOR") )]
	CodePUOR,
}

impl DocumentType6Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// Entry2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum Entry2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "TRIA") )]
	CodeTRIA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OFFI") )]
	CodeOFFI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "REQU") )]
	CodeREQU,
}

impl Entry2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// EntryDetails13 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct EntryDetails13 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Btch", skip_serializing_if = "Option::is_none") )]
	pub btch: Option<BatchInformation2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxDtls", skip_serializing_if = "Option::is_none") )]
	pub tx_dtls: Option<Vec<EntryTransaction14>>,
}

impl EntryDetails13 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.btch { val.validate()? }
		if let Some(ref vec) = self.tx_dtls { for item in vec { item.validate()? } }
		Ok(())
	}
}


// EntryStatus1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct EntryStatus1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl EntryStatus1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// EntryStatus1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum EntryStatus1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "BOOK") )]
	CodeBOOK,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PDNG") )]
	CodePDNG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FUTR") )]
	CodeFUTR,
}

impl EntryStatus1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// EntryTransaction14 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct EntryTransaction14 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Refs", skip_serializing_if = "Option::is_none") )]
	pub refs: Option<TransactionReferences6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt", skip_serializing_if = "Option::is_none") )]
	pub amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtDbtInd", skip_serializing_if = "Option::is_none") )]
	pub cdt_dbt_ind: Option<CreditDebitCode>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AmtDtls", skip_serializing_if = "Option::is_none") )]
	pub amt_dtls: Option<AmountAndCurrencyExchange4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Avlbty", skip_serializing_if = "Option::is_none") )]
	pub avlbty: Option<Vec<CashAvailability1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BkTxCd", skip_serializing_if = "Option::is_none") )]
	pub bk_tx_cd: Option<BankTransactionCodeStructure4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Chrgs", skip_serializing_if = "Option::is_none") )]
	pub chrgs: Option<Charges15>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Intrst", skip_serializing_if = "Option::is_none") )]
	pub intrst: Option<TransactionInterest4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RltdPties", skip_serializing_if = "Option::is_none") )]
	pub rltd_pties: Option<TransactionParties12>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RltdAgts", skip_serializing_if = "Option::is_none") )]
	pub rltd_agts: Option<TransactionAgents6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LclInstrm", skip_serializing_if = "Option::is_none") )]
	pub lcl_instrm: Option<LocalInstrument2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtTpInf", skip_serializing_if = "Option::is_none") )]
	pub pmt_tp_inf: Option<PaymentTypeInformation27>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Purp", skip_serializing_if = "Option::is_none") )]
	pub purp: Option<Purpose2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RltdRmtInf", skip_serializing_if = "Option::is_none") )]
	pub rltd_rmt_inf: Option<Vec<RemittanceLocation8>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RmtInf", skip_serializing_if = "Option::is_none") )]
	pub rmt_inf: Option<RemittanceInformation22>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RltdDts", skip_serializing_if = "Option::is_none") )]
	pub rltd_dts: Option<TransactionDates3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RltdPric", skip_serializing_if = "Option::is_none") )]
	pub rltd_pric: Option<TransactionPrice4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RltdQties", skip_serializing_if = "Option::is_none") )]
	pub rltd_qties: Option<Vec<TransactionQuantities3Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FinInstrmId", skip_serializing_if = "Option::is_none") )]
	pub fin_instrm_id: Option<SecurityIdentification19>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tax", skip_serializing_if = "Option::is_none") )]
	pub tax: Option<TaxData1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RtrInf", skip_serializing_if = "Option::is_none") )]
	pub rtr_inf: Option<PaymentReturnReason8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CorpActn", skip_serializing_if = "Option::is_none") )]
	pub corp_actn: Option<CorporateAction9>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SfkpgAcct", skip_serializing_if = "Option::is_none") )]
	pub sfkpg_acct: Option<SecuritiesAccount19>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshDpst", skip_serializing_if = "Option::is_none") )]
	pub csh_dpst: Option<Vec<CashDeposit1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CardTx", skip_serializing_if = "Option::is_none") )]
	pub card_tx: Option<CardTransaction18>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlTxInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_tx_inf: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl EntryTransaction14 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.refs { val.validate()? }
		if let Some(ref val) = self.amt { val.validate()? }
		if let Some(ref val) = self.cdt_dbt_ind { val.validate()? }
		if let Some(ref val) = self.amt_dtls { val.validate()? }
		if let Some(ref vec) = self.avlbty { for item in vec { item.validate()? } }
		if let Some(ref val) = self.bk_tx_cd { val.validate()? }
		if let Some(ref val) = self.chrgs { val.validate()? }
		if let Some(ref val) = self.intrst { val.validate()? }
		if let Some(ref val) = self.rltd_pties { val.validate()? }
		if let Some(ref val) = self.rltd_agts { val.validate()? }
		if let Some(ref val) = self.lcl_instrm { val.validate()? }
		if let Some(ref val) = self.pmt_tp_inf { val.validate()? }
		if let Some(ref val) = self.purp { val.validate()? }
		if let Some(ref vec) = self.rltd_rmt_inf { for item in vec { item.validate()? } }
		if let Some(ref val) = self.rmt_inf { val.validate()? }
		if let Some(ref val) = self.rltd_dts { val.validate()? }
		if let Some(ref val) = self.rltd_pric { val.validate()? }
		if let Some(ref vec) = self.rltd_qties { for item in vec { item.validate()? } }
		if let Some(ref val) = self.fin_instrm_id { val.validate()? }
		if let Some(ref val) = self.tax { val.validate()? }
		if let Some(ref val) = self.rtr_inf { val.validate()? }
		if let Some(ref val) = self.corp_actn { val.validate()? }
		if let Some(ref val) = self.sfkpg_acct { val.validate()? }
		if let Some(ref vec) = self.csh_dpst { for item in vec { item.validate()? } }
		if let Some(ref val) = self.card_tx { val.validate()? }
		if let Some(ref val) = self.addtl_tx_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_tx_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 500 {
				return Err(ValidationError::new(1002, "addtl_tx_inf exceeds the maximum length of 500".to_string()));
			}
		}
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// EquivalentAmount2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct EquivalentAmount2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveOrHistoricCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CcyOfTrf") )]
	pub ccy_of_trf: String,
}

impl EquivalentAmount2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.amt.validate()?;
		let pattern = Regex::new("[A-Z]{3,3}").unwrap();
		if !pattern.is_match(&self.ccy_of_trf) {
			return Err(ValidationError::new(1005, "ccy_of_trf does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// ErrorHandling1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ErrorHandling1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<ErrorHandling1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl ErrorHandling1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 4".to_string()));
			}
			let pattern = Regex::new("[a-zA-Z0-9]{1,4}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "prtry does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// ErrorHandling1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum ErrorHandling1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "X020") )]
	CodeX020,
	#[cfg_attr( feature = "derive_serde", serde(rename = "X030") )]
	CodeX030,
	#[cfg_attr( feature = "derive_serde", serde(rename = "X050") )]
	CodeX050,
}

impl ErrorHandling1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ErrorHandling3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ErrorHandling3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Err") )]
	pub err: ErrorHandling1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Desc", skip_serializing_if = "Option::is_none") )]
	pub desc: Option<String>,
}

impl ErrorHandling3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.err.validate()?;
		if let Some(ref val) = self.desc {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "desc is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "desc exceeds the maximum length of 140".to_string()));
			}
		}
		Ok(())
	}
}


// ErrorHandling3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ErrorHandling3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl ErrorHandling3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// ErrorHandling5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ErrorHandling5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Err") )]
	pub err: ErrorHandling3Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Desc", skip_serializing_if = "Option::is_none") )]
	pub desc: Option<String>,
}

impl ErrorHandling5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.err.validate()?;
		if let Some(ref val) = self.desc {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "desc is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "desc exceeds the maximum length of 140".to_string()));
			}
		}
		Ok(())
	}
}


// EstimatedFundCashForecast5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct EstimatedFundCashForecast5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradDtTm") )]
	pub trad_dt_tm: DateAndDateTimeChoice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrvsTradDtTm", skip_serializing_if = "Option::is_none") )]
	pub prvs_trad_dt_tm: Option<DateAndDateTimeChoice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FinInstrmDtls") )]
	pub fin_instrm_dtls: FinancialInstrument9,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EstmtdTtlNAV", skip_serializing_if = "Option::is_none") )]
	pub estmtd_ttl_nav: Option<Vec<ActiveOrHistoricCurrencyAndAmount>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrvsTtlNAV", skip_serializing_if = "Option::is_none") )]
	pub prvs_ttl_nav: Option<Vec<ActiveOrHistoricCurrencyAndAmount>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EstmtdTtlUnitsNb", skip_serializing_if = "Option::is_none") )]
	pub estmtd_ttl_units_nb: Option<FinancialInstrumentQuantity1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrvsTtlUnitsNb", skip_serializing_if = "Option::is_none") )]
	pub prvs_ttl_units_nb: Option<FinancialInstrumentQuantity1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EstmtdTtlNAVChngRate", skip_serializing_if = "Option::is_none") )]
	pub estmtd_ttl_nav_chng_rate: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InvstmtCcy", skip_serializing_if = "Option::is_none") )]
	pub invstmt_ccy: Option<Vec<String>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CcySts", skip_serializing_if = "Option::is_none") )]
	pub ccy_sts: Option<CurrencyDesignation1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XcptnlNetCshFlowInd") )]
	pub xcptnl_net_csh_flow_ind: bool,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pric", skip_serializing_if = "Option::is_none") )]
	pub pric: Option<UnitPrice19>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FXRate", skip_serializing_if = "Option::is_none") )]
	pub fx_rate: Option<ForeignExchangeTerms19>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EstmtdPctgOfShrClssTtlNAV", skip_serializing_if = "Option::is_none") )]
	pub estmtd_pctg_of_shr_clss_ttl_nav: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BrkdwnByPty", skip_serializing_if = "Option::is_none") )]
	pub brkdwn_by_pty: Option<Vec<BreakdownByParty3>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BrkdwnByCtry", skip_serializing_if = "Option::is_none") )]
	pub brkdwn_by_ctry: Option<Vec<BreakdownByCountry2>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BrkdwnByCcy", skip_serializing_if = "Option::is_none") )]
	pub brkdwn_by_ccy: Option<Vec<BreakdownByCurrency2>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BrkdwnByUsrDfndParam", skip_serializing_if = "Option::is_none") )]
	pub brkdwn_by_usr_dfnd_param: Option<Vec<BreakdownByUserDefinedParameter3>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EstmtdNetCshFcstDtls", skip_serializing_if = "Option::is_none") )]
	pub estmtd_net_csh_fcst_dtls: Option<Vec<NetCashForecast4>>,
}

impl EstimatedFundCashForecast5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
		}
		self.trad_dt_tm.validate()?;
		if let Some(ref val) = self.prvs_trad_dt_tm { val.validate()? }
		self.fin_instrm_dtls.validate()?;
		if let Some(ref vec) = self.estmtd_ttl_nav { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.prvs_ttl_nav { for item in vec { item.validate()? } }
		if let Some(ref val) = self.estmtd_ttl_units_nb { val.validate()? }
		if let Some(ref val) = self.prvs_ttl_units_nb { val.validate()? }
		if let Some(ref vec) = self.invstmt_ccy {
			for item in vec {
				let pattern = Regex::new("[A-Z]{3,3}").unwrap();
				if !pattern.is_match(&item) {
					return Err(ValidationError::new(1005, "invstmt_ccy does not match the required pattern".to_string()));
				}
			}
		}
		if let Some(ref val) = self.ccy_sts { val.validate()? }
		if let Some(ref val) = self.pric { val.validate()? }
		if let Some(ref val) = self.fx_rate { val.validate()? }
		if let Some(ref vec) = self.brkdwn_by_pty { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.brkdwn_by_ctry { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.brkdwn_by_ccy { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.brkdwn_by_usr_dfnd_param { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.estmtd_net_csh_fcst_dtls { for item in vec { item.validate()? } }
		Ok(())
	}
}


// EstimatedFundCashForecast6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct EstimatedFundCashForecast6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradDtTm") )]
	pub trad_dt_tm: DateAndDateTimeChoice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrvsTradDtTm", skip_serializing_if = "Option::is_none") )]
	pub prvs_trad_dt_tm: Option<DateAndDateTimeChoice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FinInstrmDtls") )]
	pub fin_instrm_dtls: FinancialInstrument9,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EstmtdTtlNAV", skip_serializing_if = "Option::is_none") )]
	pub estmtd_ttl_nav: Option<Vec<ActiveOrHistoricCurrencyAndAmount>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrvsTtlNAV", skip_serializing_if = "Option::is_none") )]
	pub prvs_ttl_nav: Option<Vec<ActiveOrHistoricCurrencyAndAmount>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EstmtdTtlUnitsNb", skip_serializing_if = "Option::is_none") )]
	pub estmtd_ttl_units_nb: Option<FinancialInstrumentQuantity1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrvsTtlUnitsNb", skip_serializing_if = "Option::is_none") )]
	pub prvs_ttl_units_nb: Option<FinancialInstrumentQuantity1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EstmtdTtlNAVChngRate", skip_serializing_if = "Option::is_none") )]
	pub estmtd_ttl_nav_chng_rate: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InvstmtCcy", skip_serializing_if = "Option::is_none") )]
	pub invstmt_ccy: Option<Vec<String>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CcySts", skip_serializing_if = "Option::is_none") )]
	pub ccy_sts: Option<CurrencyDesignation1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XcptnlNetCshFlowInd") )]
	pub xcptnl_net_csh_flow_ind: bool,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pric", skip_serializing_if = "Option::is_none") )]
	pub pric: Option<UnitPrice19>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FXRate", skip_serializing_if = "Option::is_none") )]
	pub fx_rate: Option<ForeignExchangeTerms19>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EstmtdPctgOfShrClssTtlNAV", skip_serializing_if = "Option::is_none") )]
	pub estmtd_pctg_of_shr_clss_ttl_nav: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EstmtdCshInFcstDtls", skip_serializing_if = "Option::is_none") )]
	pub estmtd_csh_in_fcst_dtls: Option<Vec<CashInForecast6>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EstmtdCshOutFcstDtls", skip_serializing_if = "Option::is_none") )]
	pub estmtd_csh_out_fcst_dtls: Option<Vec<CashOutForecast6>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EstmtdNetCshFcstDtls", skip_serializing_if = "Option::is_none") )]
	pub estmtd_net_csh_fcst_dtls: Option<Vec<NetCashForecast4>>,
}

impl EstimatedFundCashForecast6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
		}
		self.trad_dt_tm.validate()?;
		if let Some(ref val) = self.prvs_trad_dt_tm { val.validate()? }
		self.fin_instrm_dtls.validate()?;
		if let Some(ref vec) = self.estmtd_ttl_nav { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.prvs_ttl_nav { for item in vec { item.validate()? } }
		if let Some(ref val) = self.estmtd_ttl_units_nb { val.validate()? }
		if let Some(ref val) = self.prvs_ttl_units_nb { val.validate()? }
		if let Some(ref vec) = self.invstmt_ccy {
			for item in vec {
				let pattern = Regex::new("[A-Z]{3,3}").unwrap();
				if !pattern.is_match(&item) {
					return Err(ValidationError::new(1005, "invstmt_ccy does not match the required pattern".to_string()));
				}
			}
		}
		if let Some(ref val) = self.ccy_sts { val.validate()? }
		if let Some(ref val) = self.pric { val.validate()? }
		if let Some(ref val) = self.fx_rate { val.validate()? }
		if let Some(ref vec) = self.estmtd_csh_in_fcst_dtls { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.estmtd_csh_out_fcst_dtls { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.estmtd_net_csh_fcst_dtls { for item in vec { item.validate()? } }
		Ok(())
	}
}


// EventFrequency7Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum EventFrequency7Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "YEAR") )]
	CodeYEAR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ADHO") )]
	CodeADHO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MNTH") )]
	CodeMNTH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DAIL") )]
	CodeDAIL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INDA") )]
	CodeINDA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "WEEK") )]
	CodeWEEK,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SEMI") )]
	CodeSEMI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "QUTR") )]
	CodeQUTR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TOMN") )]
	CodeTOMN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TOWK") )]
	CodeTOWK,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TWMN") )]
	CodeTWMN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OVNG") )]
	CodeOVNG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ONDE") )]
	CodeONDE,
}

impl EventFrequency7Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// EventType1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct EventType1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl EventType1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// ExchangeRateOrPercentage1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ExchangeRateOrPercentage1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rate", skip_serializing_if = "Option::is_none") )]
	pub rate: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pctg", skip_serializing_if = "Option::is_none") )]
	pub pctg: Option<f64>,
}

impl ExchangeRateOrPercentage1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ExchangeRateReportOrError3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ExchangeRateReportOrError3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CcyXchgRpt", skip_serializing_if = "Option::is_none") )]
	pub ccy_xchg_rpt: Option<Vec<CurrencyExchangeReport4>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OprlErr", skip_serializing_if = "Option::is_none") )]
	pub oprl_err: Option<Vec<ErrorHandling3>>,
}

impl ExchangeRateReportOrError3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.ccy_xchg_rpt { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.oprl_err { for item in vec { item.validate()? } }
		Ok(())
	}
}


// ExchangeRateReportOrError4Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ExchangeRateReportOrError4Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BizErr", skip_serializing_if = "Option::is_none") )]
	pub biz_err: Option<Vec<ErrorHandling3>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CcyXchg", skip_serializing_if = "Option::is_none") )]
	pub ccy_xchg: Option<CurrencyExchange20>,
}

impl ExchangeRateReportOrError4Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.biz_err { for item in vec { item.validate()? } }
		if let Some(ref val) = self.ccy_xchg { val.validate()? }
		Ok(())
	}
}


// ExecutionType1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ExecutionType1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tm", skip_serializing_if = "Option::is_none") )]
	pub tm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Evt", skip_serializing_if = "Option::is_none") )]
	pub evt: Option<EventType1Choice>,
}

impl ExecutionType1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.evt { val.validate()? }
		Ok(())
	}
}


// Extension1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Extension1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PlcAndNm") )]
	pub plc_and_nm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Txt") )]
	pub txt: String,
}

impl Extension1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.plc_and_nm.chars().count() < 1 {
			return Err(ValidationError::new(1001, "plc_and_nm is shorter than the minimum length of 1".to_string()));
		}
		if self.plc_and_nm.chars().count() > 350 {
			return Err(ValidationError::new(1002, "plc_and_nm exceeds the maximum length of 350".to_string()));
		}
		if self.txt.chars().count() < 1 {
			return Err(ValidationError::new(1001, "txt is shorter than the minimum length of 1".to_string()));
		}
		if self.txt.chars().count() > 350 {
			return Err(ValidationError::new(1002, "txt exceeds the maximum length of 350".to_string()));
		}
		Ok(())
	}
}


// FailingReason3Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum FailingReason3Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "AWMO") )]
	CodeAWMO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BYIY") )]
	CodeBYIY,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CLAT") )]
	CodeCLAT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ADEA") )]
	CodeADEA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CANR") )]
	CodeCANR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CAIS") )]
	CodeCAIS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OBJT") )]
	CodeOBJT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AWSH") )]
	CodeAWSH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PHSE") )]
	CodePHSE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "STCD") )]
	CodeSTCD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DOCY") )]
	CodeDOCY,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MLAT") )]
	CodeMLAT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DOCC") )]
	CodeDOCC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BLOC") )]
	CodeBLOC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CHAS") )]
	CodeCHAS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NEWI") )]
	CodeNEWI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CLAC") )]
	CodeCLAC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MUNO") )]
	CodeMUNO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GLOB") )]
	CodeGLOB,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PREA") )]
	CodePREA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PART") )]
	CodePART,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NOFX") )]
	CodeNOFX,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CMON") )]
	CodeCMON,
	#[cfg_attr( feature = "derive_serde", serde(rename = "YCOL") )]
	CodeYCOL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "COLL") )]
	CodeCOLL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DEPO") )]
	CodeDEPO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FLIM") )]
	CodeFLIM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INCA") )]
	CodeINCA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LINK") )]
	CodeLINK,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LACK") )]
	CodeLACK,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LALO") )]
	CodeLALO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MONY") )]
	CodeMONY,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NCON") )]
	CodeNCON,
	#[cfg_attr( feature = "derive_serde", serde(rename = "REFS") )]
	CodeREFS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SDUT") )]
	CodeSDUT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BATC") )]
	CodeBATC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CYCL") )]
	CodeCYCL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SBLO") )]
	CodeSBLO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CPEC") )]
	CodeCPEC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MINO") )]
	CodeMINO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IAAD") )]
	CodeIAAD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PHCK") )]
	CodePHCK,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BENO") )]
	CodeBENO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BOTH") )]
	CodeBOTH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CLHT") )]
	CodeCLHT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DENO") )]
	CodeDENO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DISA") )]
	CodeDISA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DKNY") )]
	CodeDKNY,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FROZ") )]
	CodeFROZ,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LAAW") )]
	CodeLAAW,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LATE") )]
	CodeLATE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LIQU") )]
	CodeLIQU,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PRCY") )]
	CodePRCY,
	#[cfg_attr( feature = "derive_serde", serde(rename = "REGT") )]
	CodeREGT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SETS") )]
	CodeSETS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CERT") )]
	CodeCERT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PRSY") )]
	CodePRSY,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INBC") )]
	CodeINBC,
}

impl FailingReason3Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// FailingReason7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct FailingReason7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd") )]
	pub cd: FailingReason7Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlRsnInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_rsn_inf: Option<String>,
}

impl FailingReason7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.cd.validate()?;
		if let Some(ref val) = self.addtl_rsn_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_rsn_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 210 {
				return Err(ValidationError::new(1002, "addtl_rsn_inf exceeds the maximum length of 210".to_string()));
			}
		}
		Ok(())
	}
}


// FailingReason7Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct FailingReason7Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<FailingReason3Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification30>,
}

impl FailingReason7Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// FailingStatus9Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct FailingStatus9Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NoSpcfdRsn", skip_serializing_if = "Option::is_none") )]
	pub no_spcfd_rsn: Option<NoReasonCode>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn", skip_serializing_if = "Option::is_none") )]
	pub rsn: Option<Vec<FailingReason7>>,
}

impl FailingStatus9Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.no_spcfd_rsn { val.validate()? }
		if let Some(ref vec) = self.rsn { for item in vec { item.validate()? } }
		Ok(())
	}
}


// FileData1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct FileData1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<DocumentType1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IsseDt", skip_serializing_if = "Option::is_none") )]
	pub isse_dt: Option<DateAndDateTime2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Frmt", skip_serializing_if = "Option::is_none") )]
	pub frmt: Option<DocumentFormat1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FileNm", skip_serializing_if = "Option::is_none") )]
	pub file_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtwkRef", skip_serializing_if = "Option::is_none") )]
	pub ntwk_ref: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FileLctnElctrncAdr", skip_serializing_if = "Option::is_none") )]
	pub file_lctn_elctrnc_adr: Option<String>,
}

impl FileData1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tp { val.validate()? }
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.isse_dt { val.validate()? }
		if let Some(ref val) = self.frmt { val.validate()? }
		if let Some(ref val) = self.file_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "file_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "file_nm exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.ntwk_ref {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "ntwk_ref is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "ntwk_ref exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.file_lctn_elctrnc_adr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "file_lctn_elctrnc_adr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 2048 {
				return Err(ValidationError::new(1002, "file_lctn_elctrnc_adr exceeds the maximum length of 2048".to_string()));
			}
		}
		Ok(())
	}
}


// FinalStatus1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum FinalStatus1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "STLD") )]
	CodeSTLD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RJTD") )]
	CodeRJTD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CAND") )]
	CodeCAND,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FNLD") )]
	CodeFNLD,
}

impl FinalStatus1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// FinalStatusCode ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum FinalStatusCode {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "STLD") )]
	CodeSTLD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RJTD") )]
	CodeRJTD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CAND") )]
	CodeCAND,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FNLD") )]
	CodeFNLD,
}

impl FinalStatusCode {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// FinancialIdentificationSchemeName1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct FinancialIdentificationSchemeName1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl FinancialIdentificationSchemeName1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// FinancialInstitutionIdentification18 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct FinancialInstitutionIdentification18 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BICFI", skip_serializing_if = "Option::is_none") )]
	pub bicfi: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrSysMmbId", skip_serializing_if = "Option::is_none") )]
	pub clr_sys_mmb_id: Option<ClearingSystemMemberIdentification2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LEI", skip_serializing_if = "Option::is_none") )]
	pub lei: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm", skip_serializing_if = "Option::is_none") )]
	pub nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstlAdr", skip_serializing_if = "Option::is_none") )]
	pub pstl_adr: Option<PostalAddress24>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<GenericFinancialIdentification1>,
}

impl FinancialInstitutionIdentification18 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.bicfi {
			let pattern = Regex::new("[A-Z0-9]{4,4}[A-Z]{2,2}[A-Z0-9]{2,2}([A-Z0-9]{3,3}){0,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "bicfi does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.clr_sys_mmb_id { val.validate()? }
		if let Some(ref val) = self.lei {
			let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "lei does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "nm exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.pstl_adr { val.validate()? }
		if let Some(ref val) = self.othr { val.validate()? }
		Ok(())
	}
}


// FinancialInstitutionIdentification19 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct FinancialInstitutionIdentification19 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BICFI", skip_serializing_if = "Option::is_none") )]
	pub bicfi: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrSysMmbId", skip_serializing_if = "Option::is_none") )]
	pub clr_sys_mmb_id: Option<ClearingSystemMemberIdentification2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LEI", skip_serializing_if = "Option::is_none") )]
	pub lei: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<GenericFinancialIdentification1>,
}

impl FinancialInstitutionIdentification19 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.bicfi {
			let pattern = Regex::new("[A-Z0-9]{4,4}[A-Z]{2,2}[A-Z0-9]{2,2}([A-Z0-9]{3,3}){0,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "bicfi does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.clr_sys_mmb_id { val.validate()? }
		if let Some(ref val) = self.lei {
			let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "lei does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.othr { val.validate()? }
		Ok(())
	}
}


// FinancialInstitutionIdentification23 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct FinancialInstitutionIdentification23 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BICFI", skip_serializing_if = "Option::is_none") )]
	pub bicfi: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrSysMmbId", skip_serializing_if = "Option::is_none") )]
	pub clr_sys_mmb_id: Option<ClearingSystemMemberIdentification2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LEI", skip_serializing_if = "Option::is_none") )]
	pub lei: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm", skip_serializing_if = "Option::is_none") )]
	pub nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstlAdr", skip_serializing_if = "Option::is_none") )]
	pub pstl_adr: Option<PostalAddress27>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<GenericFinancialIdentification1>,
}

impl FinancialInstitutionIdentification23 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.bicfi {
			let pattern = Regex::new("[A-Z0-9]{4,4}[A-Z]{2,2}[A-Z0-9]{2,2}([A-Z0-9]{3,3}){0,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "bicfi does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.clr_sys_mmb_id { val.validate()? }
		if let Some(ref val) = self.lei {
			let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "lei does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "nm exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.pstl_adr { val.validate()? }
		if let Some(ref val) = self.othr { val.validate()? }
		Ok(())
	}
}


// FinancialInstrument9 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct FinancialInstrument9 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: SecurityIdentification3Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm", skip_serializing_if = "Option::is_none") )]
	pub nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryId", skip_serializing_if = "Option::is_none") )]
	pub splmtry_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReqdNAVCcy", skip_serializing_if = "Option::is_none") )]
	pub reqd_nav_ccy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClssTp", skip_serializing_if = "Option::is_none") )]
	pub clss_tp: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SctiesForm", skip_serializing_if = "Option::is_none") )]
	pub scties_form: Option<FormOfSecurity1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DstrbtnPlcy", skip_serializing_if = "Option::is_none") )]
	pub dstrbtn_plcy: Option<DistributionPolicy1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DualFndInd") )]
	pub dual_fnd_ind: bool,
}

impl FinancialInstrument9 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.id.validate()?;
		if let Some(ref val) = self.nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 350 {
				return Err(ValidationError::new(1002, "nm exceeds the maximum length of 350".to_string()));
			}
		}
		if let Some(ref val) = self.splmtry_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "splmtry_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "splmtry_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.reqd_nav_ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "reqd_nav_ccy does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.clss_tp {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "clss_tp is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "clss_tp exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.scties_form { val.validate()? }
		if let Some(ref val) = self.dstrbtn_plcy { val.validate()? }
		Ok(())
	}
}


// FinancialInstrumentQuantity1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct FinancialInstrumentQuantity1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Unit") )]
	pub unit: f64,
}

impl FinancialInstrumentQuantity1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// FinancialInstrumentQuantity1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct FinancialInstrumentQuantity1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Unit", skip_serializing_if = "Option::is_none") )]
	pub unit: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FaceAmt", skip_serializing_if = "Option::is_none") )]
	pub face_amt: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AmtsdVal", skip_serializing_if = "Option::is_none") )]
	pub amtsd_val: Option<f64>,
}

impl FinancialInstrumentQuantity1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.face_amt {
			if *val < 0.000000 {
				return Err(ValidationError::new(1003, "face_amt is less than the minimum value of 0.000000".to_string()));
			}
		}
		if let Some(ref val) = self.amtsd_val {
			if *val < 0.000000 {
				return Err(ValidationError::new(1003, "amtsd_val is less than the minimum value of 0.000000".to_string()));
			}
		}
		Ok(())
	}
}


// FloorLimitType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum FloorLimitType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "CRED") )]
	CodeCRED,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DEBT") )]
	CodeDEBT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BOTH") )]
	CodeBOTH,
}

impl FloorLimitType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// FlowDirectionType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum FlowDirectionType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "INCG") )]
	CodeINCG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OUTG") )]
	CodeOUTG,
}

impl FlowDirectionType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ForeignExchangeTerms19 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ForeignExchangeTerms19 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnitCcy") )]
	pub unit_ccy: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "QtdCcy") )]
	pub qtd_ccy: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XchgRate") )]
	pub xchg_rate: f64,
}

impl ForeignExchangeTerms19 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z]{3,3}").unwrap();
		if !pattern.is_match(&self.unit_ccy) {
			return Err(ValidationError::new(1005, "unit_ccy does not match the required pattern".to_string()));
		}
		let pattern = Regex::new("[A-Z]{3,3}").unwrap();
		if !pattern.is_match(&self.qtd_ccy) {
			return Err(ValidationError::new(1005, "qtd_ccy does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// FormOfSecurity1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum FormOfSecurity1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "BEAR") )]
	CodeBEAR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "REGD") )]
	CodeREGD,
}

impl FormOfSecurity1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// Frequency22Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Frequency22Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<EventFrequency7Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification30>,
}

impl Frequency22Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// Frequency2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum Frequency2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "YEAR") )]
	CodeYEAR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MNTH") )]
	CodeMNTH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "QURT") )]
	CodeQURT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MIAN") )]
	CodeMIAN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "WEEK") )]
	CodeWEEK,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DAIL") )]
	CodeDAIL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ADHO") )]
	CodeADHO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INDA") )]
	CodeINDA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OVNG") )]
	CodeOVNG,
}

impl Frequency2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// Frequency36Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Frequency36Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<Frequency6Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prd", skip_serializing_if = "Option::is_none") )]
	pub prd: Option<FrequencyPeriod1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PtInTm", skip_serializing_if = "Option::is_none") )]
	pub pt_in_tm: Option<FrequencyAndMoment1>,
}

impl Frequency36Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tp { val.validate()? }
		if let Some(ref val) = self.prd { val.validate()? }
		if let Some(ref val) = self.pt_in_tm { val.validate()? }
		Ok(())
	}
}


// Frequency6Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum Frequency6Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "YEAR") )]
	CodeYEAR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MNTH") )]
	CodeMNTH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "QURT") )]
	CodeQURT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MIAN") )]
	CodeMIAN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "WEEK") )]
	CodeWEEK,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DAIL") )]
	CodeDAIL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ADHO") )]
	CodeADHO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INDA") )]
	CodeINDA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FRTN") )]
	CodeFRTN,
}

impl Frequency6Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// FrequencyAndMoment1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct FrequencyAndMoment1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: Frequency6Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PtInTm") )]
	pub pt_in_tm: String,
}

impl FrequencyAndMoment1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.tp.validate()?;
		let pattern = Regex::new("[0-9]{2}").unwrap();
		if !pattern.is_match(&self.pt_in_tm) {
			return Err(ValidationError::new(1005, "pt_in_tm does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// FrequencyPeriod1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct FrequencyPeriod1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: Frequency6Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CntPerPrd") )]
	pub cnt_per_prd: f64,
}

impl FrequencyPeriod1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.tp.validate()?;
		Ok(())
	}
}


// FromToAmountRange1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct FromToAmountRange1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrAmt") )]
	pub fr_amt: AmountRangeBoundary1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ToAmt") )]
	pub to_amt: AmountRangeBoundary1,
}

impl FromToAmountRange1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.fr_amt.validate()?;
		self.to_amt.validate()?;
		Ok(())
	}
}


// FromToPercentageRange1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct FromToPercentageRange1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Fr") )]
	pub fr: PercentageRangeBoundary1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "To") )]
	pub to: PercentageRangeBoundary1,
}

impl FromToPercentageRange1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.fr.validate()?;
		self.to.validate()?;
		Ok(())
	}
}


// Fund1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Fund1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm", skip_serializing_if = "Option::is_none") )]
	pub nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LglNttyIdr", skip_serializing_if = "Option::is_none") )]
	pub lgl_ntty_idr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<OtherIdentification4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ccy", skip_serializing_if = "Option::is_none") )]
	pub ccy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradDtTm", skip_serializing_if = "Option::is_none") )]
	pub trad_dt_tm: Option<DateAndDateTimeChoice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrvsTradDtTm", skip_serializing_if = "Option::is_none") )]
	pub prvs_trad_dt_tm: Option<DateAndDateTimeChoice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EstmtdTtlNAV", skip_serializing_if = "Option::is_none") )]
	pub estmtd_ttl_nav: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrvsTtlNAV", skip_serializing_if = "Option::is_none") )]
	pub prvs_ttl_nav: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EstmtdTtlUnitsNb", skip_serializing_if = "Option::is_none") )]
	pub estmtd_ttl_units_nb: Option<FinancialInstrumentQuantity1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrvsTtlUnitsNb", skip_serializing_if = "Option::is_none") )]
	pub prvs_ttl_units_nb: Option<FinancialInstrumentQuantity1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EstmtdPctgOfFndTtlNAV", skip_serializing_if = "Option::is_none") )]
	pub estmtd_pctg_of_fnd_ttl_nav: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EstmtdCshInFcstDtls", skip_serializing_if = "Option::is_none") )]
	pub estmtd_csh_in_fcst_dtls: Option<Vec<CashInOutForecast7>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EstmtdCshOutFcstDtls", skip_serializing_if = "Option::is_none") )]
	pub estmtd_csh_out_fcst_dtls: Option<Vec<CashInOutForecast7>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EstmtdNetCshFcstDtls", skip_serializing_if = "Option::is_none") )]
	pub estmtd_net_csh_fcst_dtls: Option<Vec<NetCashForecast5>>,
}

impl Fund1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 350 {
				return Err(ValidationError::new(1002, "nm exceeds the maximum length of 350".to_string()));
			}
		}
		if let Some(ref val) = self.lgl_ntty_idr {
			let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "lgl_ntty_idr does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.id { val.validate()? }
		if let Some(ref val) = self.ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ccy does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.trad_dt_tm { val.validate()? }
		if let Some(ref val) = self.prvs_trad_dt_tm { val.validate()? }
		if let Some(ref val) = self.estmtd_ttl_nav { val.validate()? }
		if let Some(ref val) = self.prvs_ttl_nav { val.validate()? }
		if let Some(ref val) = self.estmtd_ttl_units_nb { val.validate()? }
		if let Some(ref val) = self.prvs_ttl_units_nb { val.validate()? }
		if let Some(ref vec) = self.estmtd_csh_in_fcst_dtls { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.estmtd_csh_out_fcst_dtls { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.estmtd_net_csh_fcst_dtls { for item in vec { item.validate()? } }
		Ok(())
	}
}


// Fund2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Fund2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm", skip_serializing_if = "Option::is_none") )]
	pub nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LglNttyIdr", skip_serializing_if = "Option::is_none") )]
	pub lgl_ntty_idr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<OtherIdentification4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ccy", skip_serializing_if = "Option::is_none") )]
	pub ccy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradDtTm", skip_serializing_if = "Option::is_none") )]
	pub trad_dt_tm: Option<DateAndDateTimeChoice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrvsTradDtTm", skip_serializing_if = "Option::is_none") )]
	pub prvs_trad_dt_tm: Option<DateAndDateTimeChoice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlNAV", skip_serializing_if = "Option::is_none") )]
	pub ttl_nav: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrvsTtlNAV", skip_serializing_if = "Option::is_none") )]
	pub prvs_ttl_nav: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlUnitsNb", skip_serializing_if = "Option::is_none") )]
	pub ttl_units_nb: Option<FinancialInstrumentQuantity1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrvsTtlUnitsNb", skip_serializing_if = "Option::is_none") )]
	pub prvs_ttl_units_nb: Option<FinancialInstrumentQuantity1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PctgOfFndTtlNAV", skip_serializing_if = "Option::is_none") )]
	pub pctg_of_fnd_ttl_nav: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshInFcstDtls", skip_serializing_if = "Option::is_none") )]
	pub csh_in_fcst_dtls: Option<Vec<CashInOutForecast7>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshOutFcstDtls", skip_serializing_if = "Option::is_none") )]
	pub csh_out_fcst_dtls: Option<Vec<CashInOutForecast7>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NetCshFcstDtls", skip_serializing_if = "Option::is_none") )]
	pub net_csh_fcst_dtls: Option<Vec<NetCashForecast5>>,
}

impl Fund2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 350 {
				return Err(ValidationError::new(1002, "nm exceeds the maximum length of 350".to_string()));
			}
		}
		if let Some(ref val) = self.lgl_ntty_idr {
			let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "lgl_ntty_idr does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.id { val.validate()? }
		if let Some(ref val) = self.ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ccy does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.trad_dt_tm { val.validate()? }
		if let Some(ref val) = self.prvs_trad_dt_tm { val.validate()? }
		if let Some(ref val) = self.ttl_nav { val.validate()? }
		if let Some(ref val) = self.prvs_ttl_nav { val.validate()? }
		if let Some(ref val) = self.ttl_units_nb { val.validate()? }
		if let Some(ref val) = self.prvs_ttl_units_nb { val.validate()? }
		if let Some(ref vec) = self.csh_in_fcst_dtls { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.csh_out_fcst_dtls { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.net_csh_fcst_dtls { for item in vec { item.validate()? } }
		Ok(())
	}
}


// Fund3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Fund3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm", skip_serializing_if = "Option::is_none") )]
	pub nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LglNttyIdr", skip_serializing_if = "Option::is_none") )]
	pub lgl_ntty_idr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<OtherIdentification4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ccy", skip_serializing_if = "Option::is_none") )]
	pub ccy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EstmtdTtlNAV", skip_serializing_if = "Option::is_none") )]
	pub estmtd_ttl_nav: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrvsTtlNAV", skip_serializing_if = "Option::is_none") )]
	pub prvs_ttl_nav: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EstmtdTtlUnitsNb", skip_serializing_if = "Option::is_none") )]
	pub estmtd_ttl_units_nb: Option<FinancialInstrumentQuantity1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrvsTtlUnitsNb", skip_serializing_if = "Option::is_none") )]
	pub prvs_ttl_units_nb: Option<FinancialInstrumentQuantity1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EstmtdPctgOfFndTtlNAV", skip_serializing_if = "Option::is_none") )]
	pub estmtd_pctg_of_fnd_ttl_nav: Option<f64>,
}

impl Fund3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 350 {
				return Err(ValidationError::new(1002, "nm exceeds the maximum length of 350".to_string()));
			}
		}
		if let Some(ref val) = self.lgl_ntty_idr {
			let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "lgl_ntty_idr does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.id { val.validate()? }
		if let Some(ref val) = self.ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ccy does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.estmtd_ttl_nav { val.validate()? }
		if let Some(ref val) = self.prvs_ttl_nav { val.validate()? }
		if let Some(ref val) = self.estmtd_ttl_units_nb { val.validate()? }
		if let Some(ref val) = self.prvs_ttl_units_nb { val.validate()? }
		Ok(())
	}
}


// Fund4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Fund4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm", skip_serializing_if = "Option::is_none") )]
	pub nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LglNttyIdr", skip_serializing_if = "Option::is_none") )]
	pub lgl_ntty_idr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<OtherIdentification4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ccy", skip_serializing_if = "Option::is_none") )]
	pub ccy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlNAV", skip_serializing_if = "Option::is_none") )]
	pub ttl_nav: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrvsTtlNAV", skip_serializing_if = "Option::is_none") )]
	pub prvs_ttl_nav: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlUnitsNb", skip_serializing_if = "Option::is_none") )]
	pub ttl_units_nb: Option<FinancialInstrumentQuantity1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrvsTtlUnitsNb", skip_serializing_if = "Option::is_none") )]
	pub prvs_ttl_units_nb: Option<FinancialInstrumentQuantity1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PctgOfFndTtlNAV", skip_serializing_if = "Option::is_none") )]
	pub pctg_of_fnd_ttl_nav: Option<f64>,
}

impl Fund4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 350 {
				return Err(ValidationError::new(1002, "nm exceeds the maximum length of 350".to_string()));
			}
		}
		if let Some(ref val) = self.lgl_ntty_idr {
			let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "lgl_ntty_idr does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.id { val.validate()? }
		if let Some(ref val) = self.ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ccy does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.ttl_nav { val.validate()? }
		if let Some(ref val) = self.prvs_ttl_nav { val.validate()? }
		if let Some(ref val) = self.ttl_units_nb { val.validate()? }
		if let Some(ref val) = self.prvs_ttl_units_nb { val.validate()? }
		Ok(())
	}
}


// FundBalance1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct FundBalance1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlUnitsFrUnitOrdrs", skip_serializing_if = "Option::is_none") )]
	pub ttl_units_fr_unit_ordrs: Option<FinancialInstrumentQuantity1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlUnitsFrCshOrdrs", skip_serializing_if = "Option::is_none") )]
	pub ttl_units_fr_csh_ordrs: Option<FinancialInstrumentQuantity1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlCshFrUnitOrdrs", skip_serializing_if = "Option::is_none") )]
	pub ttl_csh_fr_unit_ordrs: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlCshFrCshOrdrs", skip_serializing_if = "Option::is_none") )]
	pub ttl_csh_fr_csh_ordrs: Option<ActiveOrHistoricCurrencyAndAmount>,
}

impl FundBalance1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ttl_units_fr_unit_ordrs { val.validate()? }
		if let Some(ref val) = self.ttl_units_fr_csh_ordrs { val.validate()? }
		if let Some(ref val) = self.ttl_csh_fr_unit_ordrs { val.validate()? }
		if let Some(ref val) = self.ttl_csh_fr_csh_ordrs { val.validate()? }
		Ok(())
	}
}


// FundCashForecast6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct FundCashForecast6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradDtTm") )]
	pub trad_dt_tm: DateAndDateTimeChoice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrvsTradDtTm", skip_serializing_if = "Option::is_none") )]
	pub prvs_trad_dt_tm: Option<DateAndDateTimeChoice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FinInstrmDtls") )]
	pub fin_instrm_dtls: FinancialInstrument9,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlNAV", skip_serializing_if = "Option::is_none") )]
	pub ttl_nav: Option<Vec<ActiveOrHistoricCurrencyAndAmount>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrvsTtlNAV", skip_serializing_if = "Option::is_none") )]
	pub prvs_ttl_nav: Option<Vec<ActiveOrHistoricCurrencyAndAmount>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlUnitsNb", skip_serializing_if = "Option::is_none") )]
	pub ttl_units_nb: Option<FinancialInstrumentQuantity1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrvsTtlUnitsNb", skip_serializing_if = "Option::is_none") )]
	pub prvs_ttl_units_nb: Option<FinancialInstrumentQuantity1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlNAVChngRate", skip_serializing_if = "Option::is_none") )]
	pub ttl_nav_chng_rate: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InvstmtCcy", skip_serializing_if = "Option::is_none") )]
	pub invstmt_ccy: Option<Vec<String>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CcySts", skip_serializing_if = "Option::is_none") )]
	pub ccy_sts: Option<CurrencyDesignation1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XcptnlNetCshFlowInd") )]
	pub xcptnl_net_csh_flow_ind: bool,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pric", skip_serializing_if = "Option::is_none") )]
	pub pric: Option<UnitPrice19>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FXRate", skip_serializing_if = "Option::is_none") )]
	pub fx_rate: Option<ForeignExchangeTerms19>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PctgOfShrClssTtlNAV", skip_serializing_if = "Option::is_none") )]
	pub pctg_of_shr_clss_ttl_nav: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BrkdwnByPty", skip_serializing_if = "Option::is_none") )]
	pub brkdwn_by_pty: Option<Vec<BreakdownByParty3>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BrkdwnByCtry", skip_serializing_if = "Option::is_none") )]
	pub brkdwn_by_ctry: Option<Vec<BreakdownByCountry2>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BrkdwnByCcy", skip_serializing_if = "Option::is_none") )]
	pub brkdwn_by_ccy: Option<Vec<BreakdownByCurrency2>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BrkdwnByUsrDfndParam", skip_serializing_if = "Option::is_none") )]
	pub brkdwn_by_usr_dfnd_param: Option<Vec<BreakdownByUserDefinedParameter3>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NetCshFcstDtls", skip_serializing_if = "Option::is_none") )]
	pub net_csh_fcst_dtls: Option<Vec<NetCashForecast4>>,
}

impl FundCashForecast6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
		}
		self.trad_dt_tm.validate()?;
		if let Some(ref val) = self.prvs_trad_dt_tm { val.validate()? }
		self.fin_instrm_dtls.validate()?;
		if let Some(ref vec) = self.ttl_nav { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.prvs_ttl_nav { for item in vec { item.validate()? } }
		if let Some(ref val) = self.ttl_units_nb { val.validate()? }
		if let Some(ref val) = self.prvs_ttl_units_nb { val.validate()? }
		if let Some(ref vec) = self.invstmt_ccy {
			for item in vec {
				let pattern = Regex::new("[A-Z]{3,3}").unwrap();
				if !pattern.is_match(&item) {
					return Err(ValidationError::new(1005, "invstmt_ccy does not match the required pattern".to_string()));
				}
			}
		}
		if let Some(ref val) = self.ccy_sts { val.validate()? }
		if let Some(ref val) = self.pric { val.validate()? }
		if let Some(ref val) = self.fx_rate { val.validate()? }
		if let Some(ref vec) = self.brkdwn_by_pty { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.brkdwn_by_ctry { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.brkdwn_by_ccy { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.brkdwn_by_usr_dfnd_param { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.net_csh_fcst_dtls { for item in vec { item.validate()? } }
		Ok(())
	}
}


// FundCashForecast7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct FundCashForecast7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradDtTm") )]
	pub trad_dt_tm: DateAndDateTimeChoice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrvsTradDtTm", skip_serializing_if = "Option::is_none") )]
	pub prvs_trad_dt_tm: Option<DateAndDateTimeChoice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FinInstrmDtls") )]
	pub fin_instrm_dtls: FinancialInstrument9,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlNAV", skip_serializing_if = "Option::is_none") )]
	pub ttl_nav: Option<Vec<ActiveOrHistoricCurrencyAndAmount>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrvsTtlNAV", skip_serializing_if = "Option::is_none") )]
	pub prvs_ttl_nav: Option<Vec<ActiveOrHistoricCurrencyAndAmount>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlUnitsNb", skip_serializing_if = "Option::is_none") )]
	pub ttl_units_nb: Option<FinancialInstrumentQuantity1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrvsTtlUnitsNb", skip_serializing_if = "Option::is_none") )]
	pub prvs_ttl_units_nb: Option<FinancialInstrumentQuantity1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlNAVChngRate", skip_serializing_if = "Option::is_none") )]
	pub ttl_nav_chng_rate: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InvstmtCcy", skip_serializing_if = "Option::is_none") )]
	pub invstmt_ccy: Option<Vec<String>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CcySts", skip_serializing_if = "Option::is_none") )]
	pub ccy_sts: Option<CurrencyDesignation1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XcptnlNetCshFlowInd") )]
	pub xcptnl_net_csh_flow_ind: bool,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pric", skip_serializing_if = "Option::is_none") )]
	pub pric: Option<UnitPrice19>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FXRate", skip_serializing_if = "Option::is_none") )]
	pub fx_rate: Option<ForeignExchangeTerms19>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PctgOfShrClssTtlNAV", skip_serializing_if = "Option::is_none") )]
	pub pctg_of_shr_clss_ttl_nav: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshInFcstDtls", skip_serializing_if = "Option::is_none") )]
	pub csh_in_fcst_dtls: Option<Vec<CashInForecast6>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshOutFcstDtls", skip_serializing_if = "Option::is_none") )]
	pub csh_out_fcst_dtls: Option<Vec<CashOutForecast6>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NetCshFcstDtls", skip_serializing_if = "Option::is_none") )]
	pub net_csh_fcst_dtls: Option<Vec<NetCashForecast4>>,
}

impl FundCashForecast7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
		}
		self.trad_dt_tm.validate()?;
		if let Some(ref val) = self.prvs_trad_dt_tm { val.validate()? }
		self.fin_instrm_dtls.validate()?;
		if let Some(ref vec) = self.ttl_nav { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.prvs_ttl_nav { for item in vec { item.validate()? } }
		if let Some(ref val) = self.ttl_units_nb { val.validate()? }
		if let Some(ref val) = self.prvs_ttl_units_nb { val.validate()? }
		if let Some(ref vec) = self.invstmt_ccy {
			for item in vec {
				let pattern = Regex::new("[A-Z]{3,3}").unwrap();
				if !pattern.is_match(&item) {
					return Err(ValidationError::new(1005, "invstmt_ccy does not match the required pattern".to_string()));
				}
			}
		}
		if let Some(ref val) = self.ccy_sts { val.validate()? }
		if let Some(ref val) = self.pric { val.validate()? }
		if let Some(ref val) = self.fx_rate { val.validate()? }
		if let Some(ref vec) = self.csh_in_fcst_dtls { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.csh_out_fcst_dtls { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.net_csh_fcst_dtls { for item in vec { item.validate()? } }
		Ok(())
	}
}


// FundCashInBreakdown3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct FundCashInBreakdown3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt", skip_serializing_if = "Option::is_none") )]
	pub amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnitsNb", skip_serializing_if = "Option::is_none") )]
	pub units_nb: Option<FinancialInstrumentQuantity1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NewAmtInd", skip_serializing_if = "Option::is_none") )]
	pub new_amt_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InvstmtFndTxInTp") )]
	pub invstmt_fnd_tx_in_tp: InvestmentFundTransactionInType1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlOrdrQtyTp") )]
	pub orgnl_ordr_qty_tp: QuantityType1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgDtls", skip_serializing_if = "Option::is_none") )]
	pub chrg_dtls: Option<Vec<Charge26>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ComssnDtls", skip_serializing_if = "Option::is_none") )]
	pub comssn_dtls: Option<Vec<Commission21>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttlmCcy", skip_serializing_if = "Option::is_none") )]
	pub sttlm_ccy: Option<String>,
}

impl FundCashInBreakdown3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.amt { val.validate()? }
		if let Some(ref val) = self.units_nb { val.validate()? }
		self.invstmt_fnd_tx_in_tp.validate()?;
		self.orgnl_ordr_qty_tp.validate()?;
		if let Some(ref vec) = self.chrg_dtls { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.comssn_dtls { for item in vec { item.validate()? } }
		if let Some(ref val) = self.sttlm_ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "sttlm_ccy does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// FundCashOutBreakdown3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct FundCashOutBreakdown3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt", skip_serializing_if = "Option::is_none") )]
	pub amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnitsNb", skip_serializing_if = "Option::is_none") )]
	pub units_nb: Option<FinancialInstrumentQuantity1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NewAmtInd", skip_serializing_if = "Option::is_none") )]
	pub new_amt_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InvstmtFndTxOutTp") )]
	pub invstmt_fnd_tx_out_tp: InvestmentFundTransactionOutType1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlOrdrQtyTp") )]
	pub orgnl_ordr_qty_tp: QuantityType1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgDtls", skip_serializing_if = "Option::is_none") )]
	pub chrg_dtls: Option<Vec<Charge26>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ComssnDtls", skip_serializing_if = "Option::is_none") )]
	pub comssn_dtls: Option<Vec<Commission21>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttlmCcy", skip_serializing_if = "Option::is_none") )]
	pub sttlm_ccy: Option<String>,
}

impl FundCashOutBreakdown3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.amt { val.validate()? }
		if let Some(ref val) = self.units_nb { val.validate()? }
		self.invstmt_fnd_tx_out_tp.validate()?;
		self.orgnl_ordr_qty_tp.validate()?;
		if let Some(ref vec) = self.chrg_dtls { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.comssn_dtls { for item in vec { item.validate()? } }
		if let Some(ref val) = self.sttlm_ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "sttlm_ccy does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// FundConfirmedCashForecastReport3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct FundConfirmedCashForecastReport3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FndOrSubFndDtls", skip_serializing_if = "Option::is_none") )]
	pub fnd_or_sub_fnd_dtls: Option<Vec<Fund2>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FndCshFcstDtls", skip_serializing_if = "Option::is_none") )]
	pub fnd_csh_fcst_dtls: Option<Vec<FundCashForecast7>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CnsltdNetCshFcst", skip_serializing_if = "Option::is_none") )]
	pub cnsltd_net_csh_fcst: Option<NetCashForecast3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Xtnsn", skip_serializing_if = "Option::is_none") )]
	pub xtnsn: Option<Vec<Extension1>>,
}

impl FundConfirmedCashForecastReport3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.fnd_or_sub_fnd_dtls { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.fnd_csh_fcst_dtls { for item in vec { item.validate()? } }
		if let Some(ref val) = self.cnsltd_net_csh_fcst { val.validate()? }
		if let Some(ref vec) = self.xtnsn { for item in vec { item.validate()? } }
		Ok(())
	}
}


// FundDetailedConfirmedCashForecastReport3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct FundDetailedConfirmedCashForecastReport3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FndOrSubFndDtls", skip_serializing_if = "Option::is_none") )]
	pub fnd_or_sub_fnd_dtls: Option<Fund4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FndCshFcstDtls") )]
	pub fnd_csh_fcst_dtls: Vec<FundCashForecast6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CnsltdNetCshFcst", skip_serializing_if = "Option::is_none") )]
	pub cnsltd_net_csh_fcst: Option<NetCashForecast3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Xtnsn", skip_serializing_if = "Option::is_none") )]
	pub xtnsn: Option<Vec<Extension1>>,
}

impl FundDetailedConfirmedCashForecastReport3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.fnd_or_sub_fnd_dtls { val.validate()? }
		for item in &self.fnd_csh_fcst_dtls { item.validate()? }
		if let Some(ref val) = self.cnsltd_net_csh_fcst { val.validate()? }
		if let Some(ref vec) = self.xtnsn { for item in vec { item.validate()? } }
		Ok(())
	}
}


// Garnishment3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Garnishment3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: GarnishmentType1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Grnshee", skip_serializing_if = "Option::is_none") )]
	pub grnshee: Option<PartyIdentification135>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GrnshmtAdmstr", skip_serializing_if = "Option::is_none") )]
	pub grnshmt_admstr: Option<PartyIdentification135>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RefNb", skip_serializing_if = "Option::is_none") )]
	pub ref_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dt", skip_serializing_if = "Option::is_none") )]
	pub dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RmtdAmt", skip_serializing_if = "Option::is_none") )]
	pub rmtd_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FmlyMdclInsrncInd", skip_serializing_if = "Option::is_none") )]
	pub fmly_mdcl_insrnc_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MplyeeTermntnInd", skip_serializing_if = "Option::is_none") )]
	pub mplyee_termntn_ind: Option<bool>,
}

impl Garnishment3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.tp.validate()?;
		if let Some(ref val) = self.grnshee { val.validate()? }
		if let Some(ref val) = self.grnshmt_admstr { val.validate()? }
		if let Some(ref val) = self.ref_nb {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "ref_nb is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "ref_nb exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.rmtd_amt { val.validate()? }
		Ok(())
	}
}


// Garnishment4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Garnishment4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: GarnishmentType1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Grnshee", skip_serializing_if = "Option::is_none") )]
	pub grnshee: Option<PartyIdentification272>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GrnshmtAdmstr", skip_serializing_if = "Option::is_none") )]
	pub grnshmt_admstr: Option<PartyIdentification272>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RefNb", skip_serializing_if = "Option::is_none") )]
	pub ref_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dt", skip_serializing_if = "Option::is_none") )]
	pub dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RmtdAmt", skip_serializing_if = "Option::is_none") )]
	pub rmtd_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FmlyMdclInsrncInd", skip_serializing_if = "Option::is_none") )]
	pub fmly_mdcl_insrnc_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MplyeeTermntnInd", skip_serializing_if = "Option::is_none") )]
	pub mplyee_termntn_ind: Option<bool>,
}

impl Garnishment4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.tp.validate()?;
		if let Some(ref val) = self.grnshee { val.validate()? }
		if let Some(ref val) = self.grnshmt_admstr { val.validate()? }
		if let Some(ref val) = self.ref_nb {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "ref_nb is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "ref_nb exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.rmtd_amt { val.validate()? }
		Ok(())
	}
}


// GarnishmentType1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct GarnishmentType1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdOrPrtry") )]
	pub cd_or_prtry: GarnishmentType1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr", skip_serializing_if = "Option::is_none") )]
	pub issr: Option<String>,
}

impl GarnishmentType1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.cd_or_prtry.validate()?;
		if let Some(ref val) = self.issr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "issr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "issr exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// GarnishmentType1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct GarnishmentType1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl GarnishmentType1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// GeneralBusinessInformation1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct GeneralBusinessInformation1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Qlfr", skip_serializing_if = "Option::is_none") )]
	pub qlfr: Option<InformationQualifierType1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sbjt", skip_serializing_if = "Option::is_none") )]
	pub sbjt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SbjtDtls", skip_serializing_if = "Option::is_none") )]
	pub sbjt_dtls: Option<String>,
}

impl GeneralBusinessInformation1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.qlfr { val.validate()? }
		if let Some(ref val) = self.sbjt {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "sbjt is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "sbjt exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.sbjt_dtls {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "sbjt_dtls is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 350 {
				return Err(ValidationError::new(1002, "sbjt_dtls exceeds the maximum length of 350".to_string()));
			}
		}
		Ok(())
	}
}


// GeneralBusinessInformationCriteriaDefinition1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct GeneralBusinessInformationCriteriaDefinition1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "QryNm", skip_serializing_if = "Option::is_none") )]
	pub qry_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NewCrit", skip_serializing_if = "Option::is_none") )]
	pub new_crit: Option<BusinessInformationCriteria1>,
}

impl GeneralBusinessInformationCriteriaDefinition1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.qry_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "qry_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "qry_nm exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.new_crit { val.validate()? }
		Ok(())
	}
}


// GeneralBusinessInformationReturnCriteria1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct GeneralBusinessInformationReturnCriteria1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "QlfrInd", skip_serializing_if = "Option::is_none") )]
	pub qlfr_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SbjtInd", skip_serializing_if = "Option::is_none") )]
	pub sbjt_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SbjtDtlsInd", skip_serializing_if = "Option::is_none") )]
	pub sbjt_dtls_ind: Option<bool>,
}

impl GeneralBusinessInformationReturnCriteria1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// GeneralBusinessInformationSearchCriteria1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct GeneralBusinessInformationSearchCriteria1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ref", skip_serializing_if = "Option::is_none") )]
	pub ref_attr: Option<Vec<String>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sbjt", skip_serializing_if = "Option::is_none") )]
	pub sbjt: Option<Vec<CharacterSearch1Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Qlfr", skip_serializing_if = "Option::is_none") )]
	pub qlfr: Option<Vec<InformationQualifierType1>>,
}

impl GeneralBusinessInformationSearchCriteria1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.ref_attr {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "ref_attr is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 35 {
					return Err(ValidationError::new(1002, "ref_attr exceeds the maximum length of 35".to_string()));
				}
			}
		}
		if let Some(ref vec) = self.sbjt { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.qlfr { for item in vec { item.validate()? } }
		Ok(())
	}
}


// GeneralBusinessOrError7Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct GeneralBusinessOrError7Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OprlErr", skip_serializing_if = "Option::is_none") )]
	pub oprl_err: Option<Vec<ErrorHandling5>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BizRpt", skip_serializing_if = "Option::is_none") )]
	pub biz_rpt: Option<Vec<GeneralBusinessReport6>>,
}

impl GeneralBusinessOrError7Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.oprl_err { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.biz_rpt { for item in vec { item.validate()? } }
		Ok(())
	}
}


// GeneralBusinessOrError8Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct GeneralBusinessOrError8Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BizErr", skip_serializing_if = "Option::is_none") )]
	pub biz_err: Option<Vec<ErrorHandling5>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GnlBiz", skip_serializing_if = "Option::is_none") )]
	pub gnl_biz: Option<GeneralBusinessInformation1>,
}

impl GeneralBusinessOrError8Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.biz_err { for item in vec { item.validate()? } }
		if let Some(ref val) = self.gnl_biz { val.validate()? }
		Ok(())
	}
}


// GeneralBusinessReport6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct GeneralBusinessReport6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BizInfRef") )]
	pub biz_inf_ref: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GnlBizOrErr") )]
	pub gnl_biz_or_err: GeneralBusinessOrError8Choice,
}

impl GeneralBusinessReport6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.biz_inf_ref.chars().count() < 1 {
			return Err(ValidationError::new(1001, "biz_inf_ref is shorter than the minimum length of 1".to_string()));
		}
		if self.biz_inf_ref.chars().count() > 35 {
			return Err(ValidationError::new(1002, "biz_inf_ref exceeds the maximum length of 35".to_string()));
		}
		self.gnl_biz_or_err.validate()?;
		Ok(())
	}
}


// GenericAccountIdentification1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct GenericAccountIdentification1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SchmeNm", skip_serializing_if = "Option::is_none") )]
	pub schme_nm: Option<AccountSchemeName1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr", skip_serializing_if = "Option::is_none") )]
	pub issr: Option<String>,
}

impl GenericAccountIdentification1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 34 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 34".to_string()));
		}
		if let Some(ref val) = self.schme_nm { val.validate()? }
		if let Some(ref val) = self.issr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "issr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "issr exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// GenericFinancialIdentification1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct GenericFinancialIdentification1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SchmeNm", skip_serializing_if = "Option::is_none") )]
	pub schme_nm: Option<FinancialIdentificationSchemeName1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr", skip_serializing_if = "Option::is_none") )]
	pub issr: Option<String>,
}

impl GenericFinancialIdentification1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.schme_nm { val.validate()? }
		if let Some(ref val) = self.issr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "issr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "issr exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// GenericIdentification1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct GenericIdentification1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SchmeNm", skip_serializing_if = "Option::is_none") )]
	pub schme_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr", skip_serializing_if = "Option::is_none") )]
	pub issr: Option<String>,
}

impl GenericIdentification1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.schme_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "schme_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "schme_nm exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.issr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "issr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "issr exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// GenericIdentification3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct GenericIdentification3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr", skip_serializing_if = "Option::is_none") )]
	pub issr: Option<String>,
}

impl GenericIdentification3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.issr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "issr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "issr exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// GenericIdentification30 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct GenericIdentification30 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr") )]
	pub issr: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SchmeNm", skip_serializing_if = "Option::is_none") )]
	pub schme_nm: Option<String>,
}

impl GenericIdentification30 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[a-zA-Z0-9]{4}").unwrap();
		if !pattern.is_match(&self.id) {
			return Err(ValidationError::new(1005, "id does not match the required pattern".to_string()));
		}
		if self.issr.chars().count() < 1 {
			return Err(ValidationError::new(1001, "issr is shorter than the minimum length of 1".to_string()));
		}
		if self.issr.chars().count() > 35 {
			return Err(ValidationError::new(1002, "issr exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.schme_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "schme_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "schme_nm exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// GenericIdentification32 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct GenericIdentification32 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<PartyType3Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr", skip_serializing_if = "Option::is_none") )]
	pub issr: Option<PartyType4Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ShrtNm", skip_serializing_if = "Option::is_none") )]
	pub shrt_nm: Option<String>,
}

impl GenericIdentification32 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.tp { val.validate()? }
		if let Some(ref val) = self.issr { val.validate()? }
		if let Some(ref val) = self.shrt_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "shrt_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "shrt_nm exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// GenericIdentification36 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct GenericIdentification36 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr") )]
	pub issr: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SchmeNm", skip_serializing_if = "Option::is_none") )]
	pub schme_nm: Option<String>,
}

impl GenericIdentification36 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
		}
		if self.issr.chars().count() < 1 {
			return Err(ValidationError::new(1001, "issr is shorter than the minimum length of 1".to_string()));
		}
		if self.issr.chars().count() > 35 {
			return Err(ValidationError::new(1002, "issr exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.schme_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "schme_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "schme_nm exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// GenericIdentification37 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct GenericIdentification37 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr", skip_serializing_if = "Option::is_none") )]
	pub issr: Option<String>,
}

impl GenericIdentification37 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.issr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "issr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "issr exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// GenericIdentification47 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct GenericIdentification47 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr") )]
	pub issr: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SchmeNm", skip_serializing_if = "Option::is_none") )]
	pub schme_nm: Option<String>,
}

impl GenericIdentification47 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[a-zA-Z0-9]{4}").unwrap();
		if !pattern.is_match(&self.id) {
			return Err(ValidationError::new(1005, "id does not match the required pattern".to_string()));
		}
		if self.issr.chars().count() < 1 {
			return Err(ValidationError::new(1001, "issr is shorter than the minimum length of 1".to_string()));
		}
		if self.issr.chars().count() > 4 {
			return Err(ValidationError::new(1002, "issr exceeds the maximum length of 4".to_string()));
		}
		let pattern = Regex::new("[a-zA-Z0-9]{1,4}").unwrap();
		if !pattern.is_match(&self.issr) {
			return Err(ValidationError::new(1005, "issr does not match the required pattern".to_string()));
		}
		if let Some(ref val) = self.schme_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "schme_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "schme_nm exceeds the maximum length of 4".to_string()));
			}
			let pattern = Regex::new("[a-zA-Z0-9]{1,4}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "schme_nm does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// GenericOrganisationIdentification1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct GenericOrganisationIdentification1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SchmeNm", skip_serializing_if = "Option::is_none") )]
	pub schme_nm: Option<OrganisationIdentificationSchemeName1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr", skip_serializing_if = "Option::is_none") )]
	pub issr: Option<String>,
}

impl GenericOrganisationIdentification1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.schme_nm { val.validate()? }
		if let Some(ref val) = self.issr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "issr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "issr exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// GenericOrganisationIdentification3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct GenericOrganisationIdentification3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SchmeNm", skip_serializing_if = "Option::is_none") )]
	pub schme_nm: Option<OrganisationIdentificationSchemeName1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr", skip_serializing_if = "Option::is_none") )]
	pub issr: Option<String>,
}

impl GenericOrganisationIdentification3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 256 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 256".to_string()));
		}
		if let Some(ref val) = self.schme_nm { val.validate()? }
		if let Some(ref val) = self.issr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "issr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "issr exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// GenericPersonIdentification1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct GenericPersonIdentification1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SchmeNm", skip_serializing_if = "Option::is_none") )]
	pub schme_nm: Option<PersonIdentificationSchemeName1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr", skip_serializing_if = "Option::is_none") )]
	pub issr: Option<String>,
}

impl GenericPersonIdentification1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.schme_nm { val.validate()? }
		if let Some(ref val) = self.issr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "issr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "issr exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// GenericPersonIdentification2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct GenericPersonIdentification2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SchmeNm", skip_serializing_if = "Option::is_none") )]
	pub schme_nm: Option<PersonIdentificationSchemeName1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr", skip_serializing_if = "Option::is_none") )]
	pub issr: Option<String>,
}

impl GenericPersonIdentification2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 256 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 256".to_string()));
		}
		if let Some(ref val) = self.schme_nm { val.validate()? }
		if let Some(ref val) = self.issr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "issr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "issr exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// GroupCancellationStatus1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum GroupCancellationStatus1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "PACR") )]
	CodePACR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RJCR") )]
	CodeRJCR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ACCR") )]
	CodeACCR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PDCR") )]
	CodePDCR,
}

impl GroupCancellationStatus1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// GroupHeader103 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct GroupHeader103 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgId") )]
	pub msg_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CreDtTm") )]
	pub cre_dt_tm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfChqs") )]
	pub nb_of_chqs: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrlSum", skip_serializing_if = "Option::is_none") )]
	pub ctrl_sum: Option<f64>,
}

impl GroupHeader103 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.msg_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "msg_id is shorter than the minimum length of 1".to_string()));
		}
		if self.msg_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "msg_id exceeds the maximum length of 35".to_string()));
		}
		let pattern = Regex::new("[0-9]{1,15}").unwrap();
		if !pattern.is_match(&self.nb_of_chqs) {
			return Err(ValidationError::new(1005, "nb_of_chqs does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// GroupHeader115 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct GroupHeader115 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgId") )]
	pub msg_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CreDtTm") )]
	pub cre_dt_tm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgsRqstr", skip_serializing_if = "Option::is_none") )]
	pub chrgs_rqstr: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlChrgs", skip_serializing_if = "Option::is_none") )]
	pub ttl_chrgs: Option<TotalCharges7>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgsAcctAgt", skip_serializing_if = "Option::is_none") )]
	pub chrgs_acct_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgsAcctAgtAcct", skip_serializing_if = "Option::is_none") )]
	pub chrgs_acct_agt_acct: Option<CashAccount40>,
}

impl GroupHeader115 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.msg_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "msg_id is shorter than the minimum length of 1".to_string()));
		}
		if self.msg_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "msg_id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.chrgs_rqstr { val.validate()? }
		if let Some(ref val) = self.ttl_chrgs { val.validate()? }
		if let Some(ref val) = self.chrgs_acct_agt { val.validate()? }
		if let Some(ref val) = self.chrgs_acct_agt_acct { val.validate()? }
		Ok(())
	}
}


// GroupHeader116 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct GroupHeader116 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgId") )]
	pub msg_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CreDtTm") )]
	pub cre_dt_tm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgRcpt", skip_serializing_if = "Option::is_none") )]
	pub msg_rcpt: Option<PartyIdentification272>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgPgntn", skip_serializing_if = "Option::is_none") )]
	pub msg_pgntn: Option<Pagination1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlBizQry", skip_serializing_if = "Option::is_none") )]
	pub orgnl_biz_qry: Option<OriginalBusinessQuery1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_inf: Option<String>,
}

impl GroupHeader116 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.msg_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "msg_id is shorter than the minimum length of 1".to_string()));
		}
		if self.msg_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "msg_id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.msg_rcpt { val.validate()? }
		if let Some(ref val) = self.msg_pgntn { val.validate()? }
		if let Some(ref val) = self.orgnl_biz_qry { val.validate()? }
		if let Some(ref val) = self.addtl_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 500 {
				return Err(ValidationError::new(1002, "addtl_inf exceeds the maximum length of 500".to_string()));
			}
		}
		Ok(())
	}
}


// GroupHeader117 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct GroupHeader117 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgId") )]
	pub msg_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CreDtTm") )]
	pub cre_dt_tm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgSndr", skip_serializing_if = "Option::is_none") )]
	pub msg_sndr: Option<Party50Choice>,
}

impl GroupHeader117 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.msg_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "msg_id is shorter than the minimum length of 1".to_string()));
		}
		if self.msg_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "msg_id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.msg_sndr { val.validate()? }
		Ok(())
	}
}


// GroupHeader121 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct GroupHeader121 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgId") )]
	pub msg_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CreDtTm") )]
	pub cre_dt_tm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgRcpt", skip_serializing_if = "Option::is_none") )]
	pub msg_rcpt: Option<Party50Choice>,
}

impl GroupHeader121 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.msg_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "msg_id is shorter than the minimum length of 1".to_string()));
		}
		if self.msg_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "msg_id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.msg_rcpt { val.validate()? }
		Ok(())
	}
}


// GroupHeader126 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct GroupHeader126 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgId") )]
	pub msg_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CreDtTm") )]
	pub cre_dt_tm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgsRqstr", skip_serializing_if = "Option::is_none") )]
	pub chrgs_rqstr: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlChrgs", skip_serializing_if = "Option::is_none") )]
	pub ttl_chrgs: Option<TotalCharges7>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgsAcct", skip_serializing_if = "Option::is_none") )]
	pub chrgs_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgsAcctOwnr", skip_serializing_if = "Option::is_none") )]
	pub chrgs_acct_ownr: Option<BranchAndFinancialInstitutionIdentification8>,
}

impl GroupHeader126 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.msg_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "msg_id is shorter than the minimum length of 1".to_string()));
		}
		if self.msg_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "msg_id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.chrgs_rqstr { val.validate()? }
		if let Some(ref val) = self.ttl_chrgs { val.validate()? }
		if let Some(ref val) = self.chrgs_acct { val.validate()? }
		if let Some(ref val) = self.chrgs_acct_ownr { val.validate()? }
		Ok(())
	}
}


// IdentificationSource3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct IdentificationSource3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl IdentificationSource3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// IdentificationSource5Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct IdentificationSource5Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DmstIdSrc", skip_serializing_if = "Option::is_none") )]
	pub dmst_id_src: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrtryIdSrc", skip_serializing_if = "Option::is_none") )]
	pub prtry_id_src: Option<String>,
}

impl IdentificationSource5Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.dmst_id_src {
			let pattern = Regex::new("[A-Z]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "dmst_id_src does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.prtry_id_src {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry_id_src is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry_id_src exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// ImpliedCurrencyAmountRange1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ImpliedCurrencyAmountRange1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrAmt", skip_serializing_if = "Option::is_none") )]
	pub fr_amt: Option<AmountRangeBoundary1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ToAmt", skip_serializing_if = "Option::is_none") )]
	pub to_amt: Option<AmountRangeBoundary1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrToAmt", skip_serializing_if = "Option::is_none") )]
	pub fr_to_amt: Option<FromToAmountRange1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EQAmt", skip_serializing_if = "Option::is_none") )]
	pub eq_amt: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NEQAmt", skip_serializing_if = "Option::is_none") )]
	pub neq_amt: Option<f64>,
}

impl ImpliedCurrencyAmountRange1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.fr_amt { val.validate()? }
		if let Some(ref val) = self.to_amt { val.validate()? }
		if let Some(ref val) = self.fr_to_amt { val.validate()? }
		if let Some(ref val) = self.eq_amt {
			if *val < 0.000000 {
				return Err(ValidationError::new(1003, "eq_amt is less than the minimum value of 0.000000".to_string()));
			}
		}
		if let Some(ref val) = self.neq_amt {
			if *val < 0.000000 {
				return Err(ValidationError::new(1003, "neq_amt is less than the minimum value of 0.000000".to_string()));
			}
		}
		Ok(())
	}
}


// ImpliedCurrencyAndAmountRange1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ImpliedCurrencyAndAmountRange1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ImpliedCurrencyAmountRange1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtDbtInd", skip_serializing_if = "Option::is_none") )]
	pub cdt_dbt_ind: Option<CreditDebitCode>,
}

impl ImpliedCurrencyAndAmountRange1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.amt.validate()?;
		if let Some(ref val) = self.cdt_dbt_ind { val.validate()? }
		Ok(())
	}
}


// IncorrectData1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct IncorrectData1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl IncorrectData1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// InformationQualifierType1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct InformationQualifierType1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "IsFrmtd", skip_serializing_if = "Option::is_none") )]
	pub is_frmtd: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prty", skip_serializing_if = "Option::is_none") )]
	pub prty: Option<Priority1Code>,
}

impl InformationQualifierType1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.prty { val.validate()? }
		Ok(())
	}
}


// Instruction1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum Instruction1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "PBEN") )]
	CodePBEN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TTIL") )]
	CodeTTIL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TFRO") )]
	CodeTFRO,
}

impl Instruction1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// Instruction4Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum Instruction4Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "PHOA") )]
	CodePHOA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TELA") )]
	CodeTELA,
}

impl Instruction4Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// InstructionForAssignee1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct InstructionForAssignee1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstrInf", skip_serializing_if = "Option::is_none") )]
	pub instr_inf: Option<String>,
}

impl InstructionForAssignee1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.instr_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "instr_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "instr_inf exceeds the maximum length of 140".to_string()));
			}
		}
		Ok(())
	}
}


// InstructionForChequeAgent1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct InstructionForChequeAgent1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstrInf", skip_serializing_if = "Option::is_none") )]
	pub instr_inf: Option<String>,
}

impl InstructionForChequeAgent1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.instr_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "instr_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "instr_inf exceeds the maximum length of 140".to_string()));
			}
		}
		Ok(())
	}
}


// InstructionForCreditorAgent3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct InstructionForCreditorAgent3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstrInf", skip_serializing_if = "Option::is_none") )]
	pub instr_inf: Option<String>,
}

impl InstructionForCreditorAgent3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.instr_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "instr_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "instr_inf exceeds the maximum length of 140".to_string()));
			}
		}
		Ok(())
	}
}


// InstructionForInstructedAgent1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct InstructionForInstructedAgent1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstrInf", skip_serializing_if = "Option::is_none") )]
	pub instr_inf: Option<String>,
}

impl InstructionForInstructedAgent1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.instr_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "instr_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "instr_inf exceeds the maximum length of 140".to_string()));
			}
		}
		Ok(())
	}
}


// InstructionForNextAgent1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct InstructionForNextAgent1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<Instruction4Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstrInf", skip_serializing_if = "Option::is_none") )]
	pub instr_inf: Option<String>,
}

impl InstructionForNextAgent1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.instr_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "instr_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "instr_inf exceeds the maximum length of 140".to_string()));
			}
		}
		Ok(())
	}
}


// InstructionStatusReturnCriteria1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct InstructionStatusReturnCriteria1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtInstrStsInd") )]
	pub pmt_instr_sts_ind: bool,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtInstrStsDtTmInd", skip_serializing_if = "Option::is_none") )]
	pub pmt_instr_sts_dt_tm_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtInstrStsRsnInd", skip_serializing_if = "Option::is_none") )]
	pub pmt_instr_sts_rsn_ind: Option<bool>,
}

impl InstructionStatusReturnCriteria1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// InstructionStatusSearch5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct InstructionStatusSearch5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtInstrSts", skip_serializing_if = "Option::is_none") )]
	pub pmt_instr_sts: Option<PaymentStatusCodeSearch2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtInstrStsDtTm", skip_serializing_if = "Option::is_none") )]
	pub pmt_instr_sts_dt_tm: Option<DateTimePeriod1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrtryStsRsn", skip_serializing_if = "Option::is_none") )]
	pub prtry_sts_rsn: Option<String>,
}

impl InstructionStatusSearch5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.pmt_instr_sts { val.validate()? }
		if let Some(ref val) = self.pmt_instr_sts_dt_tm { val.validate()? }
		if let Some(ref val) = self.prtry_sts_rsn {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry_sts_rsn is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "prtry_sts_rsn exceeds the maximum length of 4".to_string()));
			}
			let pattern = Regex::new("[a-zA-Z0-9]{1,4}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "prtry_sts_rsn does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// InterestRecord2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct InterestRecord2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveOrHistoricCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtDbtInd") )]
	pub cdt_dbt_ind: CreditDebitCode,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<InterestType1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rate", skip_serializing_if = "Option::is_none") )]
	pub rate: Option<Rate4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrToDt", skip_serializing_if = "Option::is_none") )]
	pub fr_to_dt: Option<DateTimePeriod1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn", skip_serializing_if = "Option::is_none") )]
	pub rsn: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tax", skip_serializing_if = "Option::is_none") )]
	pub tax: Option<TaxCharges2>,
}

impl InterestRecord2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.amt.validate()?;
		self.cdt_dbt_ind.validate()?;
		if let Some(ref val) = self.tp { val.validate()? }
		if let Some(ref val) = self.rate { val.validate()? }
		if let Some(ref val) = self.fr_to_dt { val.validate()? }
		if let Some(ref val) = self.rsn {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "rsn is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "rsn exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.tax { val.validate()? }
		Ok(())
	}
}


// InterestType1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct InterestType1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<InterestType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl InterestType1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// InterestType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum InterestType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "INDY") )]
	CodeINDY,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OVRN") )]
	CodeOVRN,
}

impl InterestType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// IntraBalance5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct IntraBalance5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttlmAmt") )]
	pub sttlm_amt: Amount2Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttlmDt") )]
	pub sttlm_dt: DateAndDateTime2Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BalFr") )]
	pub bal_fr: CashSubBalanceTypeAndQuantityBreakdown3,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BalTo") )]
	pub bal_to: CashSubBalanceTypeAndQuantityBreakdown3,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshSubBalId", skip_serializing_if = "Option::is_none") )]
	pub csh_sub_bal_id: Option<GenericIdentification37>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prty", skip_serializing_if = "Option::is_none") )]
	pub prty: Option<PriorityNumeric4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstrPrcgAddtlDtls", skip_serializing_if = "Option::is_none") )]
	pub instr_prcg_addtl_dtls: Option<String>,
}

impl IntraBalance5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.sttlm_amt.validate()?;
		self.sttlm_dt.validate()?;
		self.bal_fr.validate()?;
		self.bal_to.validate()?;
		if let Some(ref val) = self.csh_sub_bal_id { val.validate()? }
		if let Some(ref val) = self.prty { val.validate()? }
		if let Some(ref val) = self.instr_prcg_addtl_dtls {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "instr_prcg_addtl_dtls is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 350 {
				return Err(ValidationError::new(1002, "instr_prcg_addtl_dtls exceeds the maximum length of 350".to_string()));
			}
		}
		Ok(())
	}
}


// IntraBalance6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct IntraBalance6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttldAmt", skip_serializing_if = "Option::is_none") )]
	pub sttld_amt: Option<Amount2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrevslySttldAmt", skip_serializing_if = "Option::is_none") )]
	pub prevsly_sttld_amt: Option<Amount2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RmngSttlmAmt", skip_serializing_if = "Option::is_none") )]
	pub rmng_sttlm_amt: Option<Amount2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttlmDt") )]
	pub sttlm_dt: DateAndDateTime2Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BalFr") )]
	pub bal_fr: CashSubBalanceTypeAndQuantityBreakdown3,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BalTo") )]
	pub bal_to: CashSubBalanceTypeAndQuantityBreakdown3,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshSubBalId", skip_serializing_if = "Option::is_none") )]
	pub csh_sub_bal_id: Option<GenericIdentification37>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstrPrcgAddtlDtls", skip_serializing_if = "Option::is_none") )]
	pub instr_prcg_addtl_dtls: Option<String>,
}

impl IntraBalance6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.sttld_amt { val.validate()? }
		if let Some(ref val) = self.prevsly_sttld_amt { val.validate()? }
		if let Some(ref val) = self.rmng_sttlm_amt { val.validate()? }
		self.sttlm_dt.validate()?;
		self.bal_fr.validate()?;
		self.bal_to.validate()?;
		if let Some(ref val) = self.csh_sub_bal_id { val.validate()? }
		if let Some(ref val) = self.instr_prcg_addtl_dtls {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "instr_prcg_addtl_dtls is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 350 {
				return Err(ValidationError::new(1002, "instr_prcg_addtl_dtls exceeds the maximum length of 350".to_string()));
			}
		}
		Ok(())
	}
}


// IntraBalanceCancellation7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct IntraBalanceCancellation7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshAcct", skip_serializing_if = "Option::is_none") )]
	pub csh_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshAcctOwnr", skip_serializing_if = "Option::is_none") )]
	pub csh_acct_ownr: Option<SystemPartyIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshAcctSvcr", skip_serializing_if = "Option::is_none") )]
	pub csh_acct_svcr: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrcgSts", skip_serializing_if = "Option::is_none") )]
	pub prcg_sts: Option<ProcessingStatus69Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cxl") )]
	pub cxl: Vec<IntraBalanceCancellation8>,
}

impl IntraBalanceCancellation7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.csh_acct { val.validate()? }
		if let Some(ref val) = self.csh_acct_ownr { val.validate()? }
		if let Some(ref val) = self.csh_acct_svcr { val.validate()? }
		if let Some(ref val) = self.prcg_sts { val.validate()? }
		for item in &self.cxl { item.validate()? }
		Ok(())
	}
}


// IntraBalanceCancellation8 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct IntraBalanceCancellation8 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshAcct", skip_serializing_if = "Option::is_none") )]
	pub csh_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshAcctOwnr", skip_serializing_if = "Option::is_none") )]
	pub csh_acct_ownr: Option<SystemPartyIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshAcctSvcr", skip_serializing_if = "Option::is_none") )]
	pub csh_acct_svcr: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrcgSts", skip_serializing_if = "Option::is_none") )]
	pub prcg_sts: Option<ProcessingStatus69Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReqRef") )]
	pub req_ref: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StsDt", skip_serializing_if = "Option::is_none") )]
	pub sts_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxId", skip_serializing_if = "Option::is_none") )]
	pub tx_id: Option<References14>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UndrlygIntraBal", skip_serializing_if = "Option::is_none") )]
	pub undrlyg_intra_bal: Option<IntraBalance5>,
}

impl IntraBalanceCancellation8 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.csh_acct { val.validate()? }
		if let Some(ref val) = self.csh_acct_ownr { val.validate()? }
		if let Some(ref val) = self.csh_acct_svcr { val.validate()? }
		if let Some(ref val) = self.prcg_sts { val.validate()? }
		if self.req_ref.chars().count() < 1 {
			return Err(ValidationError::new(1001, "req_ref is shorter than the minimum length of 1".to_string()));
		}
		if self.req_ref.chars().count() > 35 {
			return Err(ValidationError::new(1002, "req_ref exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.tx_id { val.validate()? }
		if let Some(ref val) = self.undrlyg_intra_bal { val.validate()? }
		Ok(())
	}
}


// IntraBalanceModification7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct IntraBalanceModification7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshAcct", skip_serializing_if = "Option::is_none") )]
	pub csh_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshAcctOwnr", skip_serializing_if = "Option::is_none") )]
	pub csh_acct_ownr: Option<SystemPartyIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshAcctSvcr", skip_serializing_if = "Option::is_none") )]
	pub csh_acct_svcr: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrcgSts", skip_serializing_if = "Option::is_none") )]
	pub prcg_sts: Option<ProcessingStatus71Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Mod") )]
	pub mod_attr: Vec<IntraBalanceModification8>,
}

impl IntraBalanceModification7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.csh_acct { val.validate()? }
		if let Some(ref val) = self.csh_acct_ownr { val.validate()? }
		if let Some(ref val) = self.csh_acct_svcr { val.validate()? }
		if let Some(ref val) = self.prcg_sts { val.validate()? }
		for item in &self.mod_attr { item.validate()? }
		Ok(())
	}
}


// IntraBalanceModification8 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct IntraBalanceModification8 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshAcct", skip_serializing_if = "Option::is_none") )]
	pub csh_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshAcctOwnr", skip_serializing_if = "Option::is_none") )]
	pub csh_acct_ownr: Option<SystemPartyIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshAcctSvcr", skip_serializing_if = "Option::is_none") )]
	pub csh_acct_svcr: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrcgSts", skip_serializing_if = "Option::is_none") )]
	pub prcg_sts: Option<ProcessingStatus71Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReqRef") )]
	pub req_ref: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StsDt", skip_serializing_if = "Option::is_none") )]
	pub sts_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReqDtls", skip_serializing_if = "Option::is_none") )]
	pub req_dtls: Option<RequestDetails22>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UndrlygIntraBal", skip_serializing_if = "Option::is_none") )]
	pub undrlyg_intra_bal: Option<IntraBalance5>,
}

impl IntraBalanceModification8 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.csh_acct { val.validate()? }
		if let Some(ref val) = self.csh_acct_ownr { val.validate()? }
		if let Some(ref val) = self.csh_acct_svcr { val.validate()? }
		if let Some(ref val) = self.prcg_sts { val.validate()? }
		if self.req_ref.chars().count() < 1 {
			return Err(ValidationError::new(1001, "req_ref is shorter than the minimum length of 1".to_string()));
		}
		if self.req_ref.chars().count() > 35 {
			return Err(ValidationError::new(1002, "req_ref exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.req_dtls { val.validate()? }
		if let Some(ref val) = self.undrlyg_intra_bal { val.validate()? }
		Ok(())
	}
}


// IntraBalanceMovement6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct IntraBalanceMovement6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BalFr") )]
	pub bal_fr: CashSubBalanceTypeAndQuantityBreakdown3,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BalTo") )]
	pub bal_to: CashSubBalanceTypeAndQuantityBreakdown3,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttlmAmt") )]
	pub sttlm_amt: Amount2Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttldAmt", skip_serializing_if = "Option::is_none") )]
	pub sttld_amt: Option<Amount2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrevslySttldAmt", skip_serializing_if = "Option::is_none") )]
	pub prevsly_sttld_amt: Option<Amount2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RmngSttlmAmt", skip_serializing_if = "Option::is_none") )]
	pub rmng_sttlm_amt: Option<Amount2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntnddSttlmDt") )]
	pub intndd_sttlm_dt: DateAndDateTime2Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FctvSttlmDt", skip_serializing_if = "Option::is_none") )]
	pub fctv_sttlm_dt: Option<DateAndDateTime2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StsDt", skip_serializing_if = "Option::is_none") )]
	pub sts_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshSubBalId", skip_serializing_if = "Option::is_none") )]
	pub csh_sub_bal_id: Option<GenericIdentification37>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Lnkgs", skip_serializing_if = "Option::is_none") )]
	pub lnkgs: Option<Vec<Linkages57>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prty", skip_serializing_if = "Option::is_none") )]
	pub prty: Option<PriorityNumeric4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgOrgtr", skip_serializing_if = "Option::is_none") )]
	pub msg_orgtr: Option<SystemPartyIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CreDtTm") )]
	pub cre_dt_tm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstrPrcgAddtlDtls", skip_serializing_if = "Option::is_none") )]
	pub instr_prcg_addtl_dtls: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl IntraBalanceMovement6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.bal_fr.validate()?;
		self.bal_to.validate()?;
		self.sttlm_amt.validate()?;
		if let Some(ref val) = self.sttld_amt { val.validate()? }
		if let Some(ref val) = self.prevsly_sttld_amt { val.validate()? }
		if let Some(ref val) = self.rmng_sttlm_amt { val.validate()? }
		self.intndd_sttlm_dt.validate()?;
		if let Some(ref val) = self.fctv_sttlm_dt { val.validate()? }
		if let Some(ref val) = self.csh_sub_bal_id { val.validate()? }
		if let Some(ref vec) = self.lnkgs { for item in vec { item.validate()? } }
		if let Some(ref val) = self.prty { val.validate()? }
		if let Some(ref val) = self.msg_orgtr { val.validate()? }
		if let Some(ref val) = self.instr_prcg_addtl_dtls {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "instr_prcg_addtl_dtls is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 350 {
				return Err(ValidationError::new(1002, "instr_prcg_addtl_dtls exceeds the maximum length of 350".to_string()));
			}
		}
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// IntraBalanceMovement7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct IntraBalanceMovement7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshAcct", skip_serializing_if = "Option::is_none") )]
	pub csh_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshAcctOwnr", skip_serializing_if = "Option::is_none") )]
	pub csh_acct_ownr: Option<SystemPartyIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshAcctSvcr", skip_serializing_if = "Option::is_none") )]
	pub csh_acct_svcr: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StsAndRsn", skip_serializing_if = "Option::is_none") )]
	pub sts_and_rsn: Option<IntraBalanceStatusAndReason2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctOwnrTxId") )]
	pub acct_ownr_tx_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctSvcrTxId", skip_serializing_if = "Option::is_none") )]
	pub acct_svcr_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MktInfrstrctrTxId", skip_serializing_if = "Option::is_none") )]
	pub mkt_infrstrctr_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrcrTxId", skip_serializing_if = "Option::is_none") )]
	pub prcr_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PoolId", skip_serializing_if = "Option::is_none") )]
	pub pool_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CorpActnEvtId", skip_serializing_if = "Option::is_none") )]
	pub corp_actn_evt_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MvmntDtls", skip_serializing_if = "Option::is_none") )]
	pub mvmnt_dtls: Option<IntraBalanceMovement6>,
}

impl IntraBalanceMovement7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.csh_acct { val.validate()? }
		if let Some(ref val) = self.csh_acct_ownr { val.validate()? }
		if let Some(ref val) = self.csh_acct_svcr { val.validate()? }
		if let Some(ref val) = self.sts_and_rsn { val.validate()? }
		if self.acct_ownr_tx_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "acct_ownr_tx_id is shorter than the minimum length of 1".to_string()));
		}
		if self.acct_ownr_tx_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "acct_ownr_tx_id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.acct_svcr_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "acct_svcr_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "acct_svcr_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.mkt_infrstrctr_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "mkt_infrstrctr_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "mkt_infrstrctr_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.prcr_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prcr_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prcr_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.pool_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "pool_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "pool_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.corp_actn_evt_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "corp_actn_evt_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "corp_actn_evt_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.mvmnt_dtls { val.validate()? }
		Ok(())
	}
}


// IntraBalanceMovements4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct IntraBalanceMovements4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshAcct", skip_serializing_if = "Option::is_none") )]
	pub csh_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshAcctOwnr", skip_serializing_if = "Option::is_none") )]
	pub csh_acct_ownr: Option<SystemPartyIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshAcctSvcr", skip_serializing_if = "Option::is_none") )]
	pub csh_acct_svcr: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StsAndRsn", skip_serializing_if = "Option::is_none") )]
	pub sts_and_rsn: Option<IntraBalanceStatusAndReason2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Mvmnt") )]
	pub mvmnt: Vec<IntraBalanceMovement7>,
}

impl IntraBalanceMovements4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.csh_acct { val.validate()? }
		if let Some(ref val) = self.csh_acct_ownr { val.validate()? }
		if let Some(ref val) = self.csh_acct_svcr { val.validate()? }
		if let Some(ref val) = self.sts_and_rsn { val.validate()? }
		for item in &self.mvmnt { item.validate()? }
		Ok(())
	}
}


// IntraBalanceOrOperationalError10Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct IntraBalanceOrOperationalError10Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cxls", skip_serializing_if = "Option::is_none") )]
	pub cxls: Option<Vec<IntraBalanceCancellation7>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OprlErr", skip_serializing_if = "Option::is_none") )]
	pub oprl_err: Option<Vec<ErrorHandling5>>,
}

impl IntraBalanceOrOperationalError10Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.cxls { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.oprl_err { for item in vec { item.validate()? } }
		Ok(())
	}
}


// IntraBalanceOrOperationalError11Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct IntraBalanceOrOperationalError11Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Mvmnts", skip_serializing_if = "Option::is_none") )]
	pub mvmnts: Option<Vec<IntraBalanceMovements4>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OprlErr", skip_serializing_if = "Option::is_none") )]
	pub oprl_err: Option<Vec<ErrorHandling5>>,
}

impl IntraBalanceOrOperationalError11Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.mvmnts { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.oprl_err { for item in vec { item.validate()? } }
		Ok(())
	}
}


// IntraBalanceOrOperationalError12Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct IntraBalanceOrOperationalError12Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Mods", skip_serializing_if = "Option::is_none") )]
	pub mods: Option<Vec<IntraBalanceModification7>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OprlErr", skip_serializing_if = "Option::is_none") )]
	pub oprl_err: Option<Vec<ErrorHandling5>>,
}

impl IntraBalanceOrOperationalError12Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.mods { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.oprl_err { for item in vec { item.validate()? } }
		Ok(())
	}
}


// IntraBalancePending5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct IntraBalancePending5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "StsAndRsn", skip_serializing_if = "Option::is_none") )]
	pub sts_and_rsn: Option<PendingStatusAndReason2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Mvmnt") )]
	pub mvmnt: Vec<IntraBalancePending6>,
}

impl IntraBalancePending5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.sts_and_rsn { val.validate()? }
		for item in &self.mvmnt { item.validate()? }
		Ok(())
	}
}


// IntraBalancePending6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct IntraBalancePending6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "StsAndRsn", skip_serializing_if = "Option::is_none") )]
	pub sts_and_rsn: Option<PendingStatusAndReason2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctOwnrTxId") )]
	pub acct_ownr_tx_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctSvcrTxId", skip_serializing_if = "Option::is_none") )]
	pub acct_svcr_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MktInfrstrctrTxId", skip_serializing_if = "Option::is_none") )]
	pub mkt_infrstrctr_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrcrTxId", skip_serializing_if = "Option::is_none") )]
	pub prcr_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PoolId", skip_serializing_if = "Option::is_none") )]
	pub pool_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CorpActnEvtId", skip_serializing_if = "Option::is_none") )]
	pub corp_actn_evt_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BalFr") )]
	pub bal_fr: CashSubBalanceTypeAndQuantityBreakdown3,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BalTo") )]
	pub bal_to: CashSubBalanceTypeAndQuantityBreakdown3,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttlmAmt") )]
	pub sttlm_amt: Amount2Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntnddSttlmDt") )]
	pub intndd_sttlm_dt: DateAndDateTime2Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StsDt", skip_serializing_if = "Option::is_none") )]
	pub sts_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshSubBalId", skip_serializing_if = "Option::is_none") )]
	pub csh_sub_bal_id: Option<GenericIdentification37>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Lnkgs", skip_serializing_if = "Option::is_none") )]
	pub lnkgs: Option<Vec<Linkages57>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prty", skip_serializing_if = "Option::is_none") )]
	pub prty: Option<PriorityNumeric4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgOrgtr", skip_serializing_if = "Option::is_none") )]
	pub msg_orgtr: Option<SystemPartyIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CreDtTm") )]
	pub cre_dt_tm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstrPrcgAddtlDtls", skip_serializing_if = "Option::is_none") )]
	pub instr_prcg_addtl_dtls: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl IntraBalancePending6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.sts_and_rsn { val.validate()? }
		if self.acct_ownr_tx_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "acct_ownr_tx_id is shorter than the minimum length of 1".to_string()));
		}
		if self.acct_ownr_tx_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "acct_ownr_tx_id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.acct_svcr_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "acct_svcr_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "acct_svcr_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.mkt_infrstrctr_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "mkt_infrstrctr_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "mkt_infrstrctr_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.prcr_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prcr_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prcr_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.pool_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "pool_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "pool_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.corp_actn_evt_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "corp_actn_evt_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "corp_actn_evt_id exceeds the maximum length of 35".to_string()));
			}
		}
		self.bal_fr.validate()?;
		self.bal_to.validate()?;
		self.sttlm_amt.validate()?;
		self.intndd_sttlm_dt.validate()?;
		if let Some(ref val) = self.csh_sub_bal_id { val.validate()? }
		if let Some(ref vec) = self.lnkgs { for item in vec { item.validate()? } }
		if let Some(ref val) = self.prty { val.validate()? }
		if let Some(ref val) = self.msg_orgtr { val.validate()? }
		if let Some(ref val) = self.instr_prcg_addtl_dtls {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "instr_prcg_addtl_dtls is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 350 {
				return Err(ValidationError::new(1002, "instr_prcg_addtl_dtls exceeds the maximum length of 350".to_string()));
			}
		}
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// IntraBalancePosting5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct IntraBalancePosting5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BalFr") )]
	pub bal_fr: CashSubBalanceTypeAndQuantityBreakdown3,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Mvmnt") )]
	pub mvmnt: Vec<IntraBalancePosting6>,
}

impl IntraBalancePosting5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.bal_fr.validate()?;
		for item in &self.mvmnt { item.validate()? }
		Ok(())
	}
}


// IntraBalancePosting6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct IntraBalancePosting6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctOwnrTxId") )]
	pub acct_ownr_tx_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctSvcrTxId", skip_serializing_if = "Option::is_none") )]
	pub acct_svcr_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MktInfrstrctrTxId", skip_serializing_if = "Option::is_none") )]
	pub mkt_infrstrctr_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrcrTxId", skip_serializing_if = "Option::is_none") )]
	pub prcr_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PoolId", skip_serializing_if = "Option::is_none") )]
	pub pool_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CorpActnEvtId", skip_serializing_if = "Option::is_none") )]
	pub corp_actn_evt_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BalTo") )]
	pub bal_to: CashSubBalanceTypeAndQuantityBreakdown3,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttldAmt") )]
	pub sttld_amt: Amount2Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrevslySttldAmt", skip_serializing_if = "Option::is_none") )]
	pub prevsly_sttld_amt: Option<Amount2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RmngSttlmAmt", skip_serializing_if = "Option::is_none") )]
	pub rmng_sttlm_amt: Option<Amount2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FctvSttlmDt") )]
	pub fctv_sttlm_dt: DateAndDateTime2Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StsDt", skip_serializing_if = "Option::is_none") )]
	pub sts_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshSubBalId", skip_serializing_if = "Option::is_none") )]
	pub csh_sub_bal_id: Option<GenericIdentification37>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Lnkgs", skip_serializing_if = "Option::is_none") )]
	pub lnkgs: Option<Vec<Linkages57>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prty", skip_serializing_if = "Option::is_none") )]
	pub prty: Option<PriorityNumeric4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgOrgtr", skip_serializing_if = "Option::is_none") )]
	pub msg_orgtr: Option<SystemPartyIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CreDtTm") )]
	pub cre_dt_tm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstrPrcgAddtlDtls", skip_serializing_if = "Option::is_none") )]
	pub instr_prcg_addtl_dtls: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl IntraBalancePosting6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.acct_ownr_tx_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "acct_ownr_tx_id is shorter than the minimum length of 1".to_string()));
		}
		if self.acct_ownr_tx_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "acct_ownr_tx_id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.acct_svcr_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "acct_svcr_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "acct_svcr_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.mkt_infrstrctr_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "mkt_infrstrctr_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "mkt_infrstrctr_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.prcr_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prcr_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prcr_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.pool_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "pool_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "pool_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.corp_actn_evt_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "corp_actn_evt_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "corp_actn_evt_id exceeds the maximum length of 35".to_string()));
			}
		}
		self.bal_to.validate()?;
		self.sttld_amt.validate()?;
		if let Some(ref val) = self.prevsly_sttld_amt { val.validate()? }
		if let Some(ref val) = self.rmng_sttlm_amt { val.validate()? }
		self.fctv_sttlm_dt.validate()?;
		if let Some(ref val) = self.csh_sub_bal_id { val.validate()? }
		if let Some(ref vec) = self.lnkgs { for item in vec { item.validate()? } }
		if let Some(ref val) = self.prty { val.validate()? }
		if let Some(ref val) = self.msg_orgtr { val.validate()? }
		if let Some(ref val) = self.instr_prcg_addtl_dtls {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "instr_prcg_addtl_dtls is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 350 {
				return Err(ValidationError::new(1002, "instr_prcg_addtl_dtls exceeds the maximum length of 350".to_string()));
			}
		}
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// IntraBalanceQueryCriteria10 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct IntraBalanceQueryCriteria10 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CxlReqId", skip_serializing_if = "Option::is_none") )]
	pub cxl_req_id: Option<Vec<String>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrcgSts", skip_serializing_if = "Option::is_none") )]
	pub prcg_sts: Option<Vec<CancellationProcessingStatus9Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshAcct", skip_serializing_if = "Option::is_none") )]
	pub csh_acct: Option<Vec<AccountIdentificationSearchCriteria2Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshAcctOwnr", skip_serializing_if = "Option::is_none") )]
	pub csh_acct_ownr: Option<Vec<SystemPartyIdentification8>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshAcctSvcr", skip_serializing_if = "Option::is_none") )]
	pub csh_acct_svcr: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgOrgtr", skip_serializing_if = "Option::is_none") )]
	pub msg_orgtr: Option<Vec<SystemPartyIdentification8>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CreDtTm", skip_serializing_if = "Option::is_none") )]
	pub cre_dt_tm: Option<DateAndDateTimeSearch5Choice>,
}

impl IntraBalanceQueryCriteria10 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.cxl_req_id {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "cxl_req_id is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 35 {
					return Err(ValidationError::new(1002, "cxl_req_id exceeds the maximum length of 35".to_string()));
				}
			}
		}
		if let Some(ref vec) = self.prcg_sts { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.csh_acct { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.csh_acct_ownr { for item in vec { item.validate()? } }
		if let Some(ref val) = self.csh_acct_svcr { val.validate()? }
		if let Some(ref vec) = self.msg_orgtr { for item in vec { item.validate()? } }
		if let Some(ref val) = self.cre_dt_tm { val.validate()? }
		Ok(())
	}
}


// IntraBalanceQueryCriteria11 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct IntraBalanceQueryCriteria11 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Refs", skip_serializing_if = "Option::is_none") )]
	pub refs: Option<Vec<References36Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sts", skip_serializing_if = "Option::is_none") )]
	pub sts: Option<IntraBalanceQueryStatus3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshAcct", skip_serializing_if = "Option::is_none") )]
	pub csh_acct: Option<Vec<AccountIdentificationSearchCriteria2Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshAcctOwnr", skip_serializing_if = "Option::is_none") )]
	pub csh_acct_ownr: Option<Vec<SystemPartyIdentification8>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshAcctSvcr", skip_serializing_if = "Option::is_none") )]
	pub csh_acct_svcr: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BalTp", skip_serializing_if = "Option::is_none") )]
	pub bal_tp: Option<Vec<IntraBalanceType3>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshSubBalId", skip_serializing_if = "Option::is_none") )]
	pub csh_sub_bal_id: Option<Vec<GenericIdentification37>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttlmAmt", skip_serializing_if = "Option::is_none") )]
	pub sttlm_amt: Option<ImpliedCurrencyAmountRange1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttldAmt", skip_serializing_if = "Option::is_none") )]
	pub sttld_amt: Option<ImpliedCurrencyAmountRange1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttlmCcy", skip_serializing_if = "Option::is_none") )]
	pub sttlm_ccy: Option<Vec<String>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntnddSttlmDt", skip_serializing_if = "Option::is_none") )]
	pub intndd_sttlm_dt: Option<DateAndDateTimeSearch5Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FctvSttlmDt", skip_serializing_if = "Option::is_none") )]
	pub fctv_sttlm_dt: Option<DateAndDateTimeSearch5Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prty", skip_serializing_if = "Option::is_none") )]
	pub prty: Option<Vec<PriorityNumeric4Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgOrgtr", skip_serializing_if = "Option::is_none") )]
	pub msg_orgtr: Option<Vec<SystemPartyIdentification8>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CreDtTm", skip_serializing_if = "Option::is_none") )]
	pub cre_dt_tm: Option<DateAndDateTimeSearch5Choice>,
}

impl IntraBalanceQueryCriteria11 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.refs { for item in vec { item.validate()? } }
		if let Some(ref val) = self.sts { val.validate()? }
		if let Some(ref vec) = self.csh_acct { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.csh_acct_ownr { for item in vec { item.validate()? } }
		if let Some(ref val) = self.csh_acct_svcr { val.validate()? }
		if let Some(ref vec) = self.bal_tp { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.csh_sub_bal_id { for item in vec { item.validate()? } }
		if let Some(ref val) = self.sttlm_amt { val.validate()? }
		if let Some(ref val) = self.sttld_amt { val.validate()? }
		if let Some(ref vec) = self.sttlm_ccy {
			for item in vec {
				let pattern = Regex::new("[A-Z]{3,3}").unwrap();
				if !pattern.is_match(&item) {
					return Err(ValidationError::new(1005, "sttlm_ccy does not match the required pattern".to_string()));
				}
			}
		}
		if let Some(ref val) = self.intndd_sttlm_dt { val.validate()? }
		if let Some(ref val) = self.fctv_sttlm_dt { val.validate()? }
		if let Some(ref vec) = self.prty { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.msg_orgtr { for item in vec { item.validate()? } }
		if let Some(ref val) = self.cre_dt_tm { val.validate()? }
		Ok(())
	}
}


// IntraBalanceQueryCriteria12 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct IntraBalanceQueryCriteria12 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ModReqId", skip_serializing_if = "Option::is_none") )]
	pub mod_req_id: Option<Vec<String>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrcgSts", skip_serializing_if = "Option::is_none") )]
	pub prcg_sts: Option<Vec<ModificationProcessingStatus9Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshAcct", skip_serializing_if = "Option::is_none") )]
	pub csh_acct: Option<Vec<AccountIdentificationSearchCriteria2Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshAcctOwnr", skip_serializing_if = "Option::is_none") )]
	pub csh_acct_ownr: Option<Vec<SystemPartyIdentification8>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshAcctSvcr", skip_serializing_if = "Option::is_none") )]
	pub csh_acct_svcr: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgOrgtr", skip_serializing_if = "Option::is_none") )]
	pub msg_orgtr: Option<Vec<SystemPartyIdentification8>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CreDtTm", skip_serializing_if = "Option::is_none") )]
	pub cre_dt_tm: Option<DateAndDateTimeSearch5Choice>,
}

impl IntraBalanceQueryCriteria12 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.mod_req_id {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "mod_req_id is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 35 {
					return Err(ValidationError::new(1002, "mod_req_id exceeds the maximum length of 35".to_string()));
				}
			}
		}
		if let Some(ref vec) = self.prcg_sts { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.csh_acct { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.csh_acct_ownr { for item in vec { item.validate()? } }
		if let Some(ref val) = self.csh_acct_svcr { val.validate()? }
		if let Some(ref vec) = self.msg_orgtr { for item in vec { item.validate()? } }
		if let Some(ref val) = self.cre_dt_tm { val.validate()? }
		Ok(())
	}
}


// IntraBalanceQueryDefinition10 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct IntraBalanceQueryDefinition10 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "QryTp") )]
	pub qry_tp: MovementResponseType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SchCrit") )]
	pub sch_crit: IntraBalanceQueryCriteria10,
}

impl IntraBalanceQueryDefinition10 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.qry_tp.validate()?;
		self.sch_crit.validate()?;
		Ok(())
	}
}


// IntraBalanceQueryDefinition11 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct IntraBalanceQueryDefinition11 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "QryTp") )]
	pub qry_tp: MovementResponseType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SchCrit") )]
	pub sch_crit: IntraBalanceQueryCriteria11,
}

impl IntraBalanceQueryDefinition11 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.qry_tp.validate()?;
		self.sch_crit.validate()?;
		Ok(())
	}
}


// IntraBalanceQueryDefinition12 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct IntraBalanceQueryDefinition12 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "QryTp") )]
	pub qry_tp: MovementResponseType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SchCrit") )]
	pub sch_crit: IntraBalanceQueryCriteria12,
}

impl IntraBalanceQueryDefinition12 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.qry_tp.validate()?;
		self.sch_crit.validate()?;
		Ok(())
	}
}


// IntraBalanceQueryStatus3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct IntraBalanceQueryStatus3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: IntraBalanceStatusType2,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtPrd", skip_serializing_if = "Option::is_none") )]
	pub dt_prd: Option<DateAndDateTimeSearch5Choice>,
}

impl IntraBalanceQueryStatus3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.tp.validate()?;
		if let Some(ref val) = self.dt_prd { val.validate()? }
		Ok(())
	}
}


// IntraBalanceReport5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct IntraBalanceReport5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptNb", skip_serializing_if = "Option::is_none") )]
	pub rpt_nb: Option<Number3Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "QryRef", skip_serializing_if = "Option::is_none") )]
	pub qry_ref: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptId", skip_serializing_if = "Option::is_none") )]
	pub rpt_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptDtTm", skip_serializing_if = "Option::is_none") )]
	pub rpt_dt_tm: Option<DateAndDateTime2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptPrd", skip_serializing_if = "Option::is_none") )]
	pub rpt_prd: Option<Period7Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "QryTp", skip_serializing_if = "Option::is_none") )]
	pub qry_tp: Option<MovementResponseType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Frqcy", skip_serializing_if = "Option::is_none") )]
	pub frqcy: Option<Frequency22Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UpdTp") )]
	pub upd_tp: UpdateType15Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ActvtyInd") )]
	pub actvty_ind: bool,
}

impl IntraBalanceReport5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.rpt_nb { val.validate()? }
		if let Some(ref val) = self.qry_ref {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "qry_ref is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "qry_ref exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.rpt_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "rpt_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "rpt_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.rpt_dt_tm { val.validate()? }
		if let Some(ref val) = self.rpt_prd { val.validate()? }
		if let Some(ref val) = self.qry_tp { val.validate()? }
		if let Some(ref val) = self.frqcy { val.validate()? }
		self.upd_tp.validate()?;
		Ok(())
	}
}


// IntraBalanceReport6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct IntraBalanceReport6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptNb", skip_serializing_if = "Option::is_none") )]
	pub rpt_nb: Option<Number3Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "QryRef", skip_serializing_if = "Option::is_none") )]
	pub qry_ref: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptId", skip_serializing_if = "Option::is_none") )]
	pub rpt_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptDtTm", skip_serializing_if = "Option::is_none") )]
	pub rpt_dt_tm: Option<DateAndDateTime2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptPrd", skip_serializing_if = "Option::is_none") )]
	pub rpt_prd: Option<Period7Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Frqcy", skip_serializing_if = "Option::is_none") )]
	pub frqcy: Option<Frequency22Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UpdTp") )]
	pub upd_tp: UpdateType15Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ActvtyInd") )]
	pub actvty_ind: bool,
}

impl IntraBalanceReport6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.rpt_nb { val.validate()? }
		if let Some(ref val) = self.qry_ref {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "qry_ref is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "qry_ref exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.rpt_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "rpt_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "rpt_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.rpt_dt_tm { val.validate()? }
		if let Some(ref val) = self.rpt_prd { val.validate()? }
		if let Some(ref val) = self.frqcy { val.validate()? }
		self.upd_tp.validate()?;
		Ok(())
	}
}


// IntraBalanceStatusAndReason2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct IntraBalanceStatusAndReason2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrcgSts", skip_serializing_if = "Option::is_none") )]
	pub prcg_sts: Option<Vec<ProcessingStatus67Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttlmSts", skip_serializing_if = "Option::is_none") )]
	pub sttlm_sts: Option<Vec<SettlementStatus16Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sttld", skip_serializing_if = "Option::is_none") )]
	pub sttld: Option<ProprietaryReason4>,
}

impl IntraBalanceStatusAndReason2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.prcg_sts { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.sttlm_sts { for item in vec { item.validate()? } }
		if let Some(ref val) = self.sttld { val.validate()? }
		Ok(())
	}
}


// IntraBalanceStatusType2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct IntraBalanceStatusType2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrcgSts", skip_serializing_if = "Option::is_none") )]
	pub prcg_sts: Option<Vec<ProcessingStatus68Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttlmSts", skip_serializing_if = "Option::is_none") )]
	pub sttlm_sts: Option<Vec<SettlementStatus26Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sttld", skip_serializing_if = "Option::is_none") )]
	pub sttld: Option<ProprietaryReason4>,
}

impl IntraBalanceStatusType2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.prcg_sts { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.sttlm_sts { for item in vec { item.validate()? } }
		if let Some(ref val) = self.sttld { val.validate()? }
		Ok(())
	}
}


// IntraBalanceType3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct IntraBalanceType3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BalFr", skip_serializing_if = "Option::is_none") )]
	pub bal_fr: Option<CashSubBalanceTypeAndQuantityBreakdown3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BalTo", skip_serializing_if = "Option::is_none") )]
	pub bal_to: Option<CashSubBalanceTypeAndQuantityBreakdown3>,
}

impl IntraBalanceType3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.bal_fr { val.validate()? }
		if let Some(ref val) = self.bal_to { val.validate()? }
		Ok(())
	}
}


// InvestigationActionReason1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct InvestigationActionReason1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Orgtr", skip_serializing_if = "Option::is_none") )]
	pub orgtr: Option<PartyIdentification135>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn") )]
	pub rsn: InvestigationActionReason1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_inf: Option<Vec<String>>,
}

impl InvestigationActionReason1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.orgtr { val.validate()? }
		self.rsn.validate()?;
		if let Some(ref vec) = self.addtl_inf {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "addtl_inf is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 105 {
					return Err(ValidationError::new(1002, "addtl_inf exceeds the maximum length of 105".to_string()));
				}
			}
		}
		Ok(())
	}
}


// InvestigationActionReason1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct InvestigationActionReason1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl InvestigationActionReason1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// InvestigationData2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct InvestigationData2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlInvstgtnSeq", skip_serializing_if = "Option::is_none") )]
	pub orgnl_invstgtn_seq: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlInvstgtnRsn", skip_serializing_if = "Option::is_none") )]
	pub orgnl_invstgtn_rsn: Option<InvestigationReason1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlInvstgtnRsnSubTp", skip_serializing_if = "Option::is_none") )]
	pub orgnl_invstgtn_rsn_sub_tp: Option<InvestigationReasonSubType1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RspnData") )]
	pub rspn_data: InvestigationDataRecord1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RltdInvstgtnData", skip_serializing_if = "Option::is_none") )]
	pub rltd_invstgtn_data: Option<RelatedInvestigationData1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NclsdFile", skip_serializing_if = "Option::is_none") )]
	pub nclsd_file: Option<Vec<Document12>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RltdFileData", skip_serializing_if = "Option::is_none") )]
	pub rltd_file_data: Option<Vec<FileData1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RspnOrgtr", skip_serializing_if = "Option::is_none") )]
	pub rspn_orgtr: Option<Party40Choice>,
}

impl InvestigationData2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.orgnl_invstgtn_rsn { val.validate()? }
		if let Some(ref val) = self.orgnl_invstgtn_rsn_sub_tp { val.validate()? }
		self.rspn_data.validate()?;
		if let Some(ref val) = self.rltd_invstgtn_data { val.validate()? }
		if let Some(ref vec) = self.nclsd_file { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.rltd_file_data { for item in vec { item.validate()? } }
		if let Some(ref val) = self.rspn_orgtr { val.validate()? }
		Ok(())
	}
}


// InvestigationDataRecord1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct InvestigationDataRecord1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtAuthstn", skip_serializing_if = "Option::is_none") )]
	pub dbt_authstn: Option<DebitAuthorisationConfirmation3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Compstn", skip_serializing_if = "Option::is_none") )]
	pub compstn: Option<CompensationResponse1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Valtn", skip_serializing_if = "Option::is_none") )]
	pub valtn: Option<AdjustmentCompensation1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Conf", skip_serializing_if = "Option::is_none") )]
	pub conf: Option<BookingConfirmation1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxSts", skip_serializing_if = "Option::is_none") )]
	pub tx_sts: Option<PaymentTransactionStatus1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxData", skip_serializing_if = "Option::is_none") )]
	pub tx_data: Option<Vec<TransactionAmendment1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RspnNrrtv", skip_serializing_if = "Option::is_none") )]
	pub rspn_nrrtv: Option<String>,
}

impl InvestigationDataRecord1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.dbt_authstn { val.validate()? }
		if let Some(ref val) = self.compstn { val.validate()? }
		if let Some(ref val) = self.valtn { val.validate()? }
		if let Some(ref val) = self.conf { val.validate()? }
		if let Some(ref val) = self.tx_sts { val.validate()? }
		if let Some(ref vec) = self.tx_data { for item in vec { item.validate()? } }
		if let Some(ref val) = self.rspn_nrrtv {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "rspn_nrrtv is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 500 {
				return Err(ValidationError::new(1002, "rspn_nrrtv exceeds the maximum length of 500".to_string()));
			}
		}
		Ok(())
	}
}


// InvestigationLocationData1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct InvestigationLocationData1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Mtd") )]
	pub mtd: InvestigationLocationMethod1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ElctrncAdr", skip_serializing_if = "Option::is_none") )]
	pub elctrnc_adr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstlAdr", skip_serializing_if = "Option::is_none") )]
	pub pstl_adr: Option<NameAndAddress16>,
}

impl InvestigationLocationData1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.mtd.validate()?;
		if let Some(ref val) = self.elctrnc_adr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "elctrnc_adr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 2048 {
				return Err(ValidationError::new(1002, "elctrnc_adr exceeds the maximum length of 2048".to_string()));
			}
		}
		if let Some(ref val) = self.pstl_adr { val.validate()? }
		Ok(())
	}
}


// InvestigationLocationMethod1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum InvestigationLocationMethod1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "EDIC") )]
	CodeEDIC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EMAL") )]
	CodeEMAL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FAXI") )]
	CodeFAXI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "POST") )]
	CodePOST,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SMSM") )]
	CodeSMSM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "URID") )]
	CodeURID,
}

impl InvestigationLocationMethod1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// InvestigationReason1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct InvestigationReason1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl InvestigationReason1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// InvestigationReason2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct InvestigationReason2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Seq", skip_serializing_if = "Option::is_none") )]
	pub seq: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn") )]
	pub rsn: InvestigationReason1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RsnSubTp", skip_serializing_if = "Option::is_none") )]
	pub rsn_sub_tp: Option<InvestigationReasonSubType1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlReqData", skip_serializing_if = "Option::is_none") )]
	pub addtl_req_data: Option<AdditionalRequestData1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RltdInvstgtnData", skip_serializing_if = "Option::is_none") )]
	pub rltd_invstgtn_data: Option<RelatedInvestigationData1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NclsdFile", skip_serializing_if = "Option::is_none") )]
	pub nclsd_file: Option<Vec<Document12>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RltdFileData", skip_serializing_if = "Option::is_none") )]
	pub rltd_file_data: Option<Vec<FileData1>>,
}

impl InvestigationReason2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.rsn.validate()?;
		if let Some(ref val) = self.rsn_sub_tp { val.validate()? }
		if let Some(ref val) = self.addtl_req_data { val.validate()? }
		if let Some(ref val) = self.rltd_invstgtn_data { val.validate()? }
		if let Some(ref vec) = self.nclsd_file { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.rltd_file_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// InvestigationReasonSubType1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct InvestigationReasonSubType1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl InvestigationReasonSubType1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// InvestigationRejection1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum InvestigationRejection1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "NFND") )]
	CodeNFND,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NAUT") )]
	CodeNAUT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UKNW") )]
	CodeUKNW,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PCOR") )]
	CodePCOR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "WMSG") )]
	CodeWMSG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RNCR") )]
	CodeRNCR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MROI") )]
	CodeMROI,
}

impl InvestigationRejection1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// InvestigationRejectionJustification1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct InvestigationRejectionJustification1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RjctnRsn") )]
	pub rjctn_rsn: InvestigationRejection1Code,
}

impl InvestigationRejectionJustification1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.rjctn_rsn.validate()?;
		Ok(())
	}
}


// InvestigationRequest2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct InvestigationRequest2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgId") )]
	pub msg_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RqstrInvstgtnId", skip_serializing_if = "Option::is_none") )]
	pub rqstr_invstgtn_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RspndrInvstgtnId", skip_serializing_if = "Option::is_none") )]
	pub rspndr_invstgtn_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EIR", skip_serializing_if = "Option::is_none") )]
	pub eir: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReqActn", skip_serializing_if = "Option::is_none") )]
	pub req_actn: Option<InvestigationRequestAction1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InvstgtnTp") )]
	pub invstgtn_tp: InvestigationType1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InvstgtnSubTp", skip_serializing_if = "Option::is_none") )]
	pub invstgtn_sub_tp: Option<InvestigationSubType1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UndrlygInstrm", skip_serializing_if = "Option::is_none") )]
	pub undrlyg_instrm: Option<UnderlyingInvestigationInstrument1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Undrlyg") )]
	pub undrlyg: UnderlyingData2Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rqstr") )]
	pub rqstr: Party40Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rspndr") )]
	pub rspndr: Party40Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReqOrgtr", skip_serializing_if = "Option::is_none") )]
	pub req_orgtr: Option<Party40Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XpctdRspndr", skip_serializing_if = "Option::is_none") )]
	pub xpctd_rspndr: Option<Party40Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SvcLvl", skip_serializing_if = "Option::is_none") )]
	pub svc_lvl: Option<Vec<InvestigationServiceLevel1Choice>>,
}

impl InvestigationRequest2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.msg_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "msg_id is shorter than the minimum length of 1".to_string()));
		}
		if self.msg_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "msg_id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.rqstr_invstgtn_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "rqstr_invstgtn_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "rqstr_invstgtn_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.rspndr_invstgtn_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "rspndr_invstgtn_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "rspndr_invstgtn_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.eir {
			let pattern = Regex::new("[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "eir does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.req_actn { val.validate()? }
		self.invstgtn_tp.validate()?;
		if let Some(ref val) = self.invstgtn_sub_tp { val.validate()? }
		if let Some(ref val) = self.undrlyg_instrm { val.validate()? }
		self.undrlyg.validate()?;
		self.rqstr.validate()?;
		self.rspndr.validate()?;
		if let Some(ref val) = self.req_orgtr { val.validate()? }
		if let Some(ref val) = self.xpctd_rspndr { val.validate()? }
		if let Some(ref vec) = self.svc_lvl { for item in vec { item.validate()? } }
		Ok(())
	}
}


// InvestigationRequest3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct InvestigationRequest3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgId") )]
	pub msg_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RqstrInvstgtnId", skip_serializing_if = "Option::is_none") )]
	pub rqstr_invstgtn_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RspndrInvstgtnId", skip_serializing_if = "Option::is_none") )]
	pub rspndr_invstgtn_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EIR", skip_serializing_if = "Option::is_none") )]
	pub eir: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReqActn", skip_serializing_if = "Option::is_none") )]
	pub req_actn: Option<InvestigationRequestAction1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InvstgtnTp") )]
	pub invstgtn_tp: InvestigationType1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InvstgtnSubTp", skip_serializing_if = "Option::is_none") )]
	pub invstgtn_sub_tp: Option<InvestigationSubType1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UndrlygInstrm", skip_serializing_if = "Option::is_none") )]
	pub undrlyg_instrm: Option<UnderlyingInvestigationInstrument1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Undrlyg", skip_serializing_if = "Option::is_none") )]
	pub undrlyg: Option<UnderlyingData2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rqstr") )]
	pub rqstr: Party40Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rspndr") )]
	pub rspndr: Party40Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReqOrgtr", skip_serializing_if = "Option::is_none") )]
	pub req_orgtr: Option<Party40Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XpctdRspndr", skip_serializing_if = "Option::is_none") )]
	pub xpctd_rspndr: Option<Party40Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SvcLvl", skip_serializing_if = "Option::is_none") )]
	pub svc_lvl: Option<Vec<InvestigationServiceLevel1Choice>>,
}

impl InvestigationRequest3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.msg_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "msg_id is shorter than the minimum length of 1".to_string()));
		}
		if self.msg_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "msg_id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.rqstr_invstgtn_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "rqstr_invstgtn_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "rqstr_invstgtn_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.rspndr_invstgtn_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "rspndr_invstgtn_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "rspndr_invstgtn_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.eir {
			let pattern = Regex::new("[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "eir does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.req_actn { val.validate()? }
		self.invstgtn_tp.validate()?;
		if let Some(ref val) = self.invstgtn_sub_tp { val.validate()? }
		if let Some(ref val) = self.undrlyg_instrm { val.validate()? }
		if let Some(ref val) = self.undrlyg { val.validate()? }
		self.rqstr.validate()?;
		self.rspndr.validate()?;
		if let Some(ref val) = self.req_orgtr { val.validate()? }
		if let Some(ref val) = self.xpctd_rspndr { val.validate()? }
		if let Some(ref vec) = self.svc_lvl { for item in vec { item.validate()? } }
		Ok(())
	}
}


// InvestigationRequestAction1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct InvestigationRequestAction1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Actn") )]
	pub actn: InvestigationRequestAction1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ActnRsn", skip_serializing_if = "Option::is_none") )]
	pub actn_rsn: Option<InvestigationActionReason1>,
}

impl InvestigationRequestAction1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.actn.validate()?;
		if let Some(ref val) = self.actn_rsn { val.validate()? }
		Ok(())
	}
}


// InvestigationRequestAction1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct InvestigationRequestAction1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl InvestigationRequestAction1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// InvestigationResponse3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct InvestigationResponse3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgId") )]
	pub msg_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RspndrInvstgtnId", skip_serializing_if = "Option::is_none") )]
	pub rspndr_invstgtn_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InvstgtnSts") )]
	pub invstgtn_sts: InvestigationStatus2,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NxtRspndr", skip_serializing_if = "Option::is_none") )]
	pub nxt_rspndr: Option<Party40Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InvstgtnData", skip_serializing_if = "Option::is_none") )]
	pub invstgtn_data: Option<Vec<InvestigationData2>>,
}

impl InvestigationResponse3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.msg_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "msg_id is shorter than the minimum length of 1".to_string()));
		}
		if self.msg_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "msg_id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.rspndr_invstgtn_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "rspndr_invstgtn_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "rspndr_invstgtn_id exceeds the maximum length of 35".to_string()));
			}
		}
		self.invstgtn_sts.validate()?;
		if let Some(ref val) = self.nxt_rspndr { val.validate()? }
		if let Some(ref vec) = self.invstgtn_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// InvestigationServiceLevel1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct InvestigationServiceLevel1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl InvestigationServiceLevel1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// InvestigationStatus2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct InvestigationStatus2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sts") )]
	pub sts: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StsRsn", skip_serializing_if = "Option::is_none") )]
	pub sts_rsn: Option<InvestigationStatusReason1Choice>,
}

impl InvestigationStatus2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.sts.chars().count() < 1 {
			return Err(ValidationError::new(1001, "sts is shorter than the minimum length of 1".to_string()));
		}
		if self.sts.chars().count() > 4 {
			return Err(ValidationError::new(1002, "sts exceeds the maximum length of 4".to_string()));
		}
		if let Some(ref val) = self.sts_rsn { val.validate()? }
		Ok(())
	}
}


// InvestigationStatus6Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct InvestigationStatus6Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Conf", skip_serializing_if = "Option::is_none") )]
	pub conf: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RjctdMod", skip_serializing_if = "Option::is_none") )]
	pub rjctd_mod: Option<Vec<ModificationStatusReason1Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DplctOf", skip_serializing_if = "Option::is_none") )]
	pub dplct_of: Option<Case6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AssgnmtCxlConf", skip_serializing_if = "Option::is_none") )]
	pub assgnmt_cxl_conf: Option<bool>,
}

impl InvestigationStatus6Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.conf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "conf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "conf exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref vec) = self.rjctd_mod { for item in vec { item.validate()? } }
		if let Some(ref val) = self.dplct_of { val.validate()? }
		Ok(())
	}
}


// InvestigationStatusReason1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct InvestigationStatusReason1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl InvestigationStatusReason1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// InvestigationSubType1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct InvestigationSubType1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl InvestigationSubType1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// InvestigationType1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct InvestigationType1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl InvestigationType1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// InvestmentAccount42 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct InvestmentAccount42 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctId", skip_serializing_if = "Option::is_none") )]
	pub acct_id: Option<AccountIdentification1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OwnrId", skip_serializing_if = "Option::is_none") )]
	pub ownr_id: Option<PartyIdentification2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctSvcr", skip_serializing_if = "Option::is_none") )]
	pub acct_svcr: Option<PartyIdentification2Choice>,
}

impl InvestmentAccount42 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.acct_id { val.validate()? }
		if let Some(ref val) = self.ownr_id { val.validate()? }
		if let Some(ref val) = self.acct_svcr { val.validate()? }
		Ok(())
	}
}


// InvestmentFundTransactionInType1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct InvestmentFundTransactionInType1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<InvestmentFundTransactionInType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification47>,
}

impl InvestmentFundTransactionInType1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// InvestmentFundTransactionInType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum InvestmentFundTransactionInType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "SUBS") )]
	CodeSUBS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SWII") )]
	CodeSWII,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INSP") )]
	CodeINSP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CROI") )]
	CodeCROI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RDIV") )]
	CodeRDIV,
}

impl InvestmentFundTransactionInType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// InvestmentFundTransactionOutType1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct InvestmentFundTransactionOutType1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<InvestmentFundTransactionOutType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification47>,
}

impl InvestmentFundTransactionOutType1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// InvestmentFundTransactionOutType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum InvestmentFundTransactionOutType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "REDM") )]
	CodeREDM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SWIO") )]
	CodeSWIO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INSP") )]
	CodeINSP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CROO") )]
	CodeCROO,
}

impl InvestmentFundTransactionOutType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// Limit10 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Limit10 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: Amount2Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtDbtInd", skip_serializing_if = "Option::is_none") )]
	pub cdt_dbt_ind: Option<CreditDebitCode>,
}

impl Limit10 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.amt.validate()?;
		if let Some(ref val) = self.cdt_dbt_ind { val.validate()? }
		Ok(())
	}
}


// Limit2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Limit2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveOrHistoricCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtDbtInd") )]
	pub cdt_dbt_ind: FloorLimitType1Code,
}

impl Limit2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.amt.validate()?;
		self.cdt_dbt_ind.validate()?;
		Ok(())
	}
}


// Limit5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Limit5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: Amount2Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtDbtInd") )]
	pub cdt_dbt_ind: CreditDebitCode,
}

impl Limit5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.amt.validate()?;
		self.cdt_dbt_ind.validate()?;
		Ok(())
	}
}


// Limit7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Limit7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: Amount2Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtDbtInd", skip_serializing_if = "Option::is_none") )]
	pub cdt_dbt_ind: Option<CreditDebitCode>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sts", skip_serializing_if = "Option::is_none") )]
	pub sts: Option<LimitStatus1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StartDtTm", skip_serializing_if = "Option::is_none") )]
	pub start_dt_tm: Option<DateAndDateTime2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UsdAmt", skip_serializing_if = "Option::is_none") )]
	pub usd_amt: Option<Amount2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UsdAmtCdtDbtInd", skip_serializing_if = "Option::is_none") )]
	pub usd_amt_cdt_dbt_ind: Option<CreditDebitCode>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UsdPctg", skip_serializing_if = "Option::is_none") )]
	pub usd_pctg: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RmngAmt", skip_serializing_if = "Option::is_none") )]
	pub rmng_amt: Option<Amount2Choice>,
}

impl Limit7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.amt.validate()?;
		if let Some(ref val) = self.cdt_dbt_ind { val.validate()? }
		if let Some(ref val) = self.sts { val.validate()? }
		if let Some(ref val) = self.start_dt_tm { val.validate()? }
		if let Some(ref val) = self.usd_amt { val.validate()? }
		if let Some(ref val) = self.usd_amt_cdt_dbt_ind { val.validate()? }
		if let Some(ref val) = self.rmng_amt { val.validate()? }
		Ok(())
	}
}


// Limit8 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Limit8 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "StartDtTm", skip_serializing_if = "Option::is_none") )]
	pub start_dt_tm: Option<DateAndDateTime2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: Amount2Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtDbtInd", skip_serializing_if = "Option::is_none") )]
	pub cdt_dbt_ind: Option<CreditDebitCode>,
}

impl Limit8 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.start_dt_tm { val.validate()? }
		self.amt.validate()?;
		if let Some(ref val) = self.cdt_dbt_ind { val.validate()? }
		Ok(())
	}
}


// LimitCriteria7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct LimitCriteria7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NewQryNm", skip_serializing_if = "Option::is_none") )]
	pub new_qry_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SchCrit", skip_serializing_if = "Option::is_none") )]
	pub sch_crit: Option<Vec<LimitSearchCriteria7>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RtrCrit", skip_serializing_if = "Option::is_none") )]
	pub rtr_crit: Option<LimitReturnCriteria2>,
}

impl LimitCriteria7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.new_qry_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "new_qry_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "new_qry_nm exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref vec) = self.sch_crit { for item in vec { item.validate()? } }
		if let Some(ref val) = self.rtr_crit { val.validate()? }
		Ok(())
	}
}


// LimitCriteria7Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct LimitCriteria7Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "QryNm", skip_serializing_if = "Option::is_none") )]
	pub qry_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NewCrit", skip_serializing_if = "Option::is_none") )]
	pub new_crit: Option<LimitCriteria7>,
}

impl LimitCriteria7Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.qry_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "qry_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "qry_nm exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.new_crit { val.validate()? }
		Ok(())
	}
}


// LimitIdentification3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct LimitIdentification3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cur", skip_serializing_if = "Option::is_none") )]
	pub cur: Option<LimitIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dflt", skip_serializing_if = "Option::is_none") )]
	pub dflt: Option<LimitIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AllCur", skip_serializing_if = "Option::is_none") )]
	pub all_cur: Option<LimitIdentification9>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AllDflt", skip_serializing_if = "Option::is_none") )]
	pub all_dflt: Option<LimitIdentification9>,
}

impl LimitIdentification3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cur { val.validate()? }
		if let Some(ref val) = self.dflt { val.validate()? }
		if let Some(ref val) = self.all_cur { val.validate()? }
		if let Some(ref val) = self.all_dflt { val.validate()? }
		Ok(())
	}
}


// LimitIdentification8 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct LimitIdentification8 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SysId", skip_serializing_if = "Option::is_none") )]
	pub sys_id: Option<SystemIdentification2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BilLmtCtrPtyId", skip_serializing_if = "Option::is_none") )]
	pub bil_lmt_ctr_pty_id: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: LimitType1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctOwnr", skip_serializing_if = "Option::is_none") )]
	pub acct_ownr: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctId", skip_serializing_if = "Option::is_none") )]
	pub acct_id: Option<AccountIdentification4Choice>,
}

impl LimitIdentification8 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.sys_id { val.validate()? }
		if let Some(ref val) = self.bil_lmt_ctr_pty_id { val.validate()? }
		self.tp.validate()?;
		if let Some(ref val) = self.acct_ownr { val.validate()? }
		if let Some(ref val) = self.acct_id { val.validate()? }
		Ok(())
	}
}


// LimitIdentification9 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct LimitIdentification9 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SysId", skip_serializing_if = "Option::is_none") )]
	pub sys_id: Option<SystemIdentification2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: LimitType1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctOwnr", skip_serializing_if = "Option::is_none") )]
	pub acct_ownr: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctId", skip_serializing_if = "Option::is_none") )]
	pub acct_id: Option<AccountIdentification4Choice>,
}

impl LimitIdentification9 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.sys_id { val.validate()? }
		self.tp.validate()?;
		if let Some(ref val) = self.acct_ownr { val.validate()? }
		if let Some(ref val) = self.acct_id { val.validate()? }
		Ok(())
	}
}


// LimitOrError4Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct LimitOrError4Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Lmt", skip_serializing_if = "Option::is_none") )]
	pub lmt: Option<Limit7>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BizErr", skip_serializing_if = "Option::is_none") )]
	pub biz_err: Option<Vec<ErrorHandling5>>,
}

impl LimitOrError4Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.lmt { val.validate()? }
		if let Some(ref vec) = self.biz_err { for item in vec { item.validate()? } }
		Ok(())
	}
}


// LimitQuery5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct LimitQuery5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "QryTp", skip_serializing_if = "Option::is_none") )]
	pub qry_tp: Option<QueryType2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LmtCrit", skip_serializing_if = "Option::is_none") )]
	pub lmt_crit: Option<LimitCriteria7Choice>,
}

impl LimitQuery5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.qry_tp { val.validate()? }
		if let Some(ref val) = self.lmt_crit { val.validate()? }
		Ok(())
	}
}


// LimitReport8 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct LimitReport8 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "LmtId") )]
	pub lmt_id: LimitIdentification8,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LmtOrErr") )]
	pub lmt_or_err: LimitOrError4Choice,
}

impl LimitReport8 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.lmt_id.validate()?;
		self.lmt_or_err.validate()?;
		Ok(())
	}
}


// LimitReportOrError5Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct LimitReportOrError5Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BizRpt", skip_serializing_if = "Option::is_none") )]
	pub biz_rpt: Option<Limits8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OprlErr", skip_serializing_if = "Option::is_none") )]
	pub oprl_err: Option<Vec<ErrorHandling5>>,
}

impl LimitReportOrError5Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.biz_rpt { val.validate()? }
		if let Some(ref vec) = self.oprl_err { for item in vec { item.validate()? } }
		Ok(())
	}
}


// LimitReturnCriteria2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct LimitReturnCriteria2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "StartDtTmInd", skip_serializing_if = "Option::is_none") )]
	pub start_dt_tm_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StsInd", skip_serializing_if = "Option::is_none") )]
	pub sts_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UsdAmtInd", skip_serializing_if = "Option::is_none") )]
	pub usd_amt_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UsdPctgInd", skip_serializing_if = "Option::is_none") )]
	pub usd_pctg_ind: Option<bool>,
}

impl LimitReturnCriteria2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// LimitSearchCriteria7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct LimitSearchCriteria7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SysId", skip_serializing_if = "Option::is_none") )]
	pub sys_id: Option<SystemIdentification2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BilLmtCtrPtyId", skip_serializing_if = "Option::is_none") )]
	pub bil_lmt_ctr_pty_id: Option<Vec<BranchAndFinancialInstitutionIdentification8>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DfltLmtTp", skip_serializing_if = "Option::is_none") )]
	pub dflt_lmt_tp: Option<Vec<LimitType1Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CurLmtTp", skip_serializing_if = "Option::is_none") )]
	pub cur_lmt_tp: Option<Vec<LimitType1Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctOwnr", skip_serializing_if = "Option::is_none") )]
	pub acct_ownr: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctId", skip_serializing_if = "Option::is_none") )]
	pub acct_id: Option<AccountIdentification4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UsdAmt", skip_serializing_if = "Option::is_none") )]
	pub usd_amt: Option<ActiveAmountRange3Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UsdPctg", skip_serializing_if = "Option::is_none") )]
	pub usd_pctg: Option<PercentageRange1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LmtCcy", skip_serializing_if = "Option::is_none") )]
	pub lmt_ccy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LmtAmt", skip_serializing_if = "Option::is_none") )]
	pub lmt_amt: Option<ActiveAmountRange3Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LmtVldAsOfDt", skip_serializing_if = "Option::is_none") )]
	pub lmt_vld_as_of_dt: Option<DateAndPeriod2Choice>,
}

impl LimitSearchCriteria7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.sys_id { val.validate()? }
		if let Some(ref vec) = self.bil_lmt_ctr_pty_id { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.dflt_lmt_tp { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.cur_lmt_tp { for item in vec { item.validate()? } }
		if let Some(ref val) = self.acct_ownr { val.validate()? }
		if let Some(ref val) = self.acct_id { val.validate()? }
		if let Some(ref val) = self.usd_amt { val.validate()? }
		if let Some(ref val) = self.usd_pctg { val.validate()? }
		if let Some(ref val) = self.lmt_ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "lmt_ccy does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.lmt_amt { val.validate()? }
		if let Some(ref val) = self.lmt_vld_as_of_dt { val.validate()? }
		Ok(())
	}
}


// LimitStatus1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum LimitStatus1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ENAB") )]
	CodeENAB,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DISA") )]
	CodeDISA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DELD") )]
	CodeDELD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "REQD") )]
	CodeREQD,
}

impl LimitStatus1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// LimitStructure3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct LimitStructure3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CurLmtId", skip_serializing_if = "Option::is_none") )]
	pub cur_lmt_id: Option<LimitIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AllCurLmts", skip_serializing_if = "Option::is_none") )]
	pub all_cur_lmts: Option<LimitIdentification9>,
}

impl LimitStructure3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cur_lmt_id { val.validate()? }
		if let Some(ref val) = self.all_cur_lmts { val.validate()? }
		Ok(())
	}
}


// LimitStructure5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct LimitStructure5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "LmtId") )]
	pub lmt_id: LimitIdentification3Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NewLmtValSet") )]
	pub new_lmt_val_set: Limit8,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OdLmtValSet", skip_serializing_if = "Option::is_none") )]
	pub od_lmt_val_set: Option<Limit10>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LmtValAmdmnt", skip_serializing_if = "Option::is_none") )]
	pub lmt_val_amdmnt: Option<Amount4Choice>,
}

impl LimitStructure5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.lmt_id.validate()?;
		self.new_lmt_val_set.validate()?;
		if let Some(ref val) = self.od_lmt_val_set { val.validate()? }
		if let Some(ref val) = self.lmt_val_amdmnt { val.validate()? }
		Ok(())
	}
}


// LimitStructure6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct LimitStructure6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "LmtId") )]
	pub lmt_id: LimitIdentification8,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StartDtTm", skip_serializing_if = "Option::is_none") )]
	pub start_dt_tm: Option<DateAndDateTime2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: Amount2Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtDbtInd", skip_serializing_if = "Option::is_none") )]
	pub cdt_dbt_ind: Option<CreditDebitCode>,
}

impl LimitStructure6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.lmt_id.validate()?;
		if let Some(ref val) = self.start_dt_tm { val.validate()? }
		self.amt.validate()?;
		if let Some(ref val) = self.cdt_dbt_ind { val.validate()? }
		Ok(())
	}
}


// LimitType1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct LimitType1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<LimitType3Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl LimitType1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// LimitType3Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum LimitType3Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "MULT") )]
	CodeMULT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BILI") )]
	CodeBILI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MAND") )]
	CodeMAND,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DISC") )]
	CodeDISC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NELI") )]
	CodeNELI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INBI") )]
	CodeINBI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GLBL") )]
	CodeGLBL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DIDB") )]
	CodeDIDB,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SPLC") )]
	CodeSPLC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SPLF") )]
	CodeSPLF,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TDLC") )]
	CodeTDLC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TDLF") )]
	CodeTDLF,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UCDT") )]
	CodeUCDT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ACOL") )]
	CodeACOL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EXGT") )]
	CodeEXGT,
}

impl LimitType3Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// Limits8 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Limits8 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CurLmt", skip_serializing_if = "Option::is_none") )]
	pub cur_lmt: Option<Vec<LimitReport8>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DfltLmt", skip_serializing_if = "Option::is_none") )]
	pub dflt_lmt: Option<Vec<LimitReport8>>,
}

impl Limits8 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.cur_lmt { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.dflt_lmt { for item in vec { item.validate()? } }
		Ok(())
	}
}


// LinkageType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum LinkageType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "LINK") )]
	CodeLINK,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UNLK") )]
	CodeUNLK,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SOFT") )]
	CodeSOFT,
}

impl LinkageType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// LinkageType3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct LinkageType3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<LinkageType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification30>,
}

impl LinkageType3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// Linkages57 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Linkages57 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrcgPos", skip_serializing_if = "Option::is_none") )]
	pub prcg_pos: Option<ProcessingPosition7Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgNb", skip_serializing_if = "Option::is_none") )]
	pub msg_nb: Option<DocumentNumber5Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ref") )]
	pub ref_attr: References34Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RefOwnr", skip_serializing_if = "Option::is_none") )]
	pub ref_ownr: Option<PartyIdentification127Choice>,
}

impl Linkages57 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.prcg_pos { val.validate()? }
		if let Some(ref val) = self.msg_nb { val.validate()? }
		self.ref_attr.validate()?;
		if let Some(ref val) = self.ref_ownr { val.validate()? }
		Ok(())
	}
}


// LiquidityCreditTransfer4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct LiquidityCreditTransfer4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "LqdtyTrfId", skip_serializing_if = "Option::is_none") )]
	pub lqdty_trf_id: Option<PaymentIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cdtr", skip_serializing_if = "Option::is_none") )]
	pub cdtr: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtrAcct", skip_serializing_if = "Option::is_none") )]
	pub cdtr_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TrfdAmt") )]
	pub trfd_amt: Amount2Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dbtr", skip_serializing_if = "Option::is_none") )]
	pub dbtr: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtrAcct", skip_serializing_if = "Option::is_none") )]
	pub dbtr_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttlmDt", skip_serializing_if = "Option::is_none") )]
	pub sttlm_dt: Option<String>,
}

impl LiquidityCreditTransfer4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.lqdty_trf_id { val.validate()? }
		if let Some(ref val) = self.cdtr { val.validate()? }
		if let Some(ref val) = self.cdtr_acct { val.validate()? }
		self.trfd_amt.validate()?;
		if let Some(ref val) = self.dbtr { val.validate()? }
		if let Some(ref val) = self.dbtr_acct { val.validate()? }
		Ok(())
	}
}


// LiquidityDebitTransfer4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct LiquidityDebitTransfer4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "LqdtyTrfId", skip_serializing_if = "Option::is_none") )]
	pub lqdty_trf_id: Option<PaymentIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cdtr", skip_serializing_if = "Option::is_none") )]
	pub cdtr: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtrAcct", skip_serializing_if = "Option::is_none") )]
	pub cdtr_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TrfdAmt") )]
	pub trfd_amt: Amount2Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dbtr", skip_serializing_if = "Option::is_none") )]
	pub dbtr: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtrAcct", skip_serializing_if = "Option::is_none") )]
	pub dbtr_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttlmDt", skip_serializing_if = "Option::is_none") )]
	pub sttlm_dt: Option<String>,
}

impl LiquidityDebitTransfer4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.lqdty_trf_id { val.validate()? }
		if let Some(ref val) = self.cdtr { val.validate()? }
		if let Some(ref val) = self.cdtr_acct { val.validate()? }
		self.trfd_amt.validate()?;
		if let Some(ref val) = self.dbtr { val.validate()? }
		if let Some(ref val) = self.dbtr_acct { val.validate()? }
		Ok(())
	}
}


// LocalInstrument2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct LocalInstrument2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl LocalInstrument2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// LongPaymentIdentification4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct LongPaymentIdentification4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxId", skip_serializing_if = "Option::is_none") )]
	pub tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UETR", skip_serializing_if = "Option::is_none") )]
	pub uetr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrBkSttlmAmt") )]
	pub intr_bk_sttlm_amt: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrBkSttlmDt") )]
	pub intr_bk_sttlm_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtMtd", skip_serializing_if = "Option::is_none") )]
	pub pmt_mtd: Option<PaymentOrigin1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstgAgt") )]
	pub instg_agt: BranchAndFinancialInstitutionIdentification8,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstdAgt") )]
	pub instd_agt: BranchAndFinancialInstitutionIdentification8,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtryTp", skip_serializing_if = "Option::is_none") )]
	pub ntry_tp: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EndToEndId", skip_serializing_if = "Option::is_none") )]
	pub end_to_end_id: Option<String>,
}

impl LongPaymentIdentification4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.uetr {
			let pattern = Regex::new("[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "uetr does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.pmt_mtd { val.validate()? }
		self.instg_agt.validate()?;
		self.instd_agt.validate()?;
		if let Some(ref val) = self.ntry_tp {
			let pattern = Regex::new("[BEOVW]{1,1}[0-9]{2,2}|DUM").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ntry_tp does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.end_to_end_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "end_to_end_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "end_to_end_id exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// LongPostalAddress1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct LongPostalAddress1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ustrd", skip_serializing_if = "Option::is_none") )]
	pub ustrd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Strd", skip_serializing_if = "Option::is_none") )]
	pub strd: Option<StructuredLongPostalAddress1>,
}

impl LongPostalAddress1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ustrd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "ustrd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "ustrd exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.strd { val.validate()? }
		Ok(())
	}
}


// MandateClassification1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct MandateClassification1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<MandateClassification1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl MandateClassification1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// MandateClassification1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum MandateClassification1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "FIXE") )]
	CodeFIXE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "USGB") )]
	CodeUSGB,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VARI") )]
	CodeVARI,
}

impl MandateClassification1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// MandateRelatedData2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct MandateRelatedData2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DrctDbtMndt", skip_serializing_if = "Option::is_none") )]
	pub drct_dbt_mndt: Option<MandateRelatedInformation15>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtTrfMndt", skip_serializing_if = "Option::is_none") )]
	pub cdt_trf_mndt: Option<CreditTransferMandateData1>,
}

impl MandateRelatedData2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.drct_dbt_mndt { val.validate()? }
		if let Some(ref val) = self.cdt_trf_mndt { val.validate()? }
		Ok(())
	}
}


// MandateRelatedData3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct MandateRelatedData3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DrctDbtMndt", skip_serializing_if = "Option::is_none") )]
	pub drct_dbt_mndt: Option<MandateRelatedInformation16>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtTrfMndt", skip_serializing_if = "Option::is_none") )]
	pub cdt_trf_mndt: Option<CreditTransferMandateData1>,
}

impl MandateRelatedData3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.drct_dbt_mndt { val.validate()? }
		if let Some(ref val) = self.cdt_trf_mndt { val.validate()? }
		Ok(())
	}
}


// MandateRelatedInformation15 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct MandateRelatedInformation15 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MndtId", skip_serializing_if = "Option::is_none") )]
	pub mndt_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtOfSgntr", skip_serializing_if = "Option::is_none") )]
	pub dt_of_sgntr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AmdmntInd", skip_serializing_if = "Option::is_none") )]
	pub amdmnt_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AmdmntInfDtls", skip_serializing_if = "Option::is_none") )]
	pub amdmnt_inf_dtls: Option<AmendmentInformationDetails14>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ElctrncSgntr", skip_serializing_if = "Option::is_none") )]
	pub elctrnc_sgntr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrstColltnDt", skip_serializing_if = "Option::is_none") )]
	pub frst_colltn_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FnlColltnDt", skip_serializing_if = "Option::is_none") )]
	pub fnl_colltn_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Frqcy", skip_serializing_if = "Option::is_none") )]
	pub frqcy: Option<Frequency36Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn", skip_serializing_if = "Option::is_none") )]
	pub rsn: Option<MandateSetupReason1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TrckgDays", skip_serializing_if = "Option::is_none") )]
	pub trckg_days: Option<String>,
}

impl MandateRelatedInformation15 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.mndt_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "mndt_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "mndt_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.amdmnt_inf_dtls { val.validate()? }
		if let Some(ref val) = self.elctrnc_sgntr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "elctrnc_sgntr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 1025 {
				return Err(ValidationError::new(1002, "elctrnc_sgntr exceeds the maximum length of 1025".to_string()));
			}
		}
		if let Some(ref val) = self.frqcy { val.validate()? }
		if let Some(ref val) = self.rsn { val.validate()? }
		if let Some(ref val) = self.trckg_days {
			let pattern = Regex::new("[0-9]{2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "trckg_days does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// MandateRelatedInformation16 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct MandateRelatedInformation16 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MndtId", skip_serializing_if = "Option::is_none") )]
	pub mndt_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtOfSgntr", skip_serializing_if = "Option::is_none") )]
	pub dt_of_sgntr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AmdmntInd", skip_serializing_if = "Option::is_none") )]
	pub amdmnt_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AmdmntInfDtls", skip_serializing_if = "Option::is_none") )]
	pub amdmnt_inf_dtls: Option<AmendmentInformationDetails15>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ElctrncSgntr", skip_serializing_if = "Option::is_none") )]
	pub elctrnc_sgntr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrstColltnDt", skip_serializing_if = "Option::is_none") )]
	pub frst_colltn_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FnlColltnDt", skip_serializing_if = "Option::is_none") )]
	pub fnl_colltn_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Frqcy", skip_serializing_if = "Option::is_none") )]
	pub frqcy: Option<Frequency36Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn", skip_serializing_if = "Option::is_none") )]
	pub rsn: Option<MandateSetupReason1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TrckgDays", skip_serializing_if = "Option::is_none") )]
	pub trckg_days: Option<String>,
}

impl MandateRelatedInformation16 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.mndt_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "mndt_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "mndt_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.amdmnt_inf_dtls { val.validate()? }
		if let Some(ref val) = self.elctrnc_sgntr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "elctrnc_sgntr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 1025 {
				return Err(ValidationError::new(1002, "elctrnc_sgntr exceeds the maximum length of 1025".to_string()));
			}
		}
		if let Some(ref val) = self.frqcy { val.validate()? }
		if let Some(ref val) = self.rsn { val.validate()? }
		if let Some(ref val) = self.trckg_days {
			let pattern = Regex::new("[0-9]{2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "trckg_days does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// MandateSetupReason1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct MandateSetupReason1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl MandateSetupReason1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 70 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 70".to_string()));
			}
		}
		Ok(())
	}
}


// MandateTypeInformation2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct MandateTypeInformation2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SvcLvl", skip_serializing_if = "Option::is_none") )]
	pub svc_lvl: Option<ServiceLevel8Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LclInstrm", skip_serializing_if = "Option::is_none") )]
	pub lcl_instrm: Option<LocalInstrument2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtgyPurp", skip_serializing_if = "Option::is_none") )]
	pub ctgy_purp: Option<CategoryPurpose1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Clssfctn", skip_serializing_if = "Option::is_none") )]
	pub clssfctn: Option<MandateClassification1Choice>,
}

impl MandateTypeInformation2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.svc_lvl { val.validate()? }
		if let Some(ref val) = self.lcl_instrm { val.validate()? }
		if let Some(ref val) = self.ctgy_purp { val.validate()? }
		if let Some(ref val) = self.clssfctn { val.validate()? }
		Ok(())
	}
}


// MarketInfrastructureIdentification1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct MarketInfrastructureIdentification1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl MarketInfrastructureIdentification1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 3 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 3".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// Member6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Member6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MmbRtrAdr", skip_serializing_if = "Option::is_none") )]
	pub mmb_rtr_adr: Option<Vec<MemberIdentification3Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtctRef", skip_serializing_if = "Option::is_none") )]
	pub ctct_ref: Option<Vec<ContactIdentificationAndAddress1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ComAdr", skip_serializing_if = "Option::is_none") )]
	pub com_adr: Option<CommunicationAddress8>,
}

impl Member6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.mmb_rtr_adr { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.ctct_ref { for item in vec { item.validate()? } }
		if let Some(ref val) = self.com_adr { val.validate()? }
		Ok(())
	}
}


// Member7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Member7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm", skip_serializing_if = "Option::is_none") )]
	pub nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RtrAdr", skip_serializing_if = "Option::is_none") )]
	pub rtr_adr: Option<Vec<MemberIdentification3Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Acct", skip_serializing_if = "Option::is_none") )]
	pub acct: Option<Vec<CashAccount40>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<SystemMemberType1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sts", skip_serializing_if = "Option::is_none") )]
	pub sts: Option<SystemMemberStatus1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtctRef", skip_serializing_if = "Option::is_none") )]
	pub ctct_ref: Option<Vec<ContactIdentificationAndAddress2>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ComAdr", skip_serializing_if = "Option::is_none") )]
	pub com_adr: Option<CommunicationAddress10>,
}

impl Member7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "nm exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref vec) = self.rtr_adr { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.acct { for item in vec { item.validate()? } }
		if let Some(ref val) = self.tp { val.validate()? }
		if let Some(ref val) = self.sts { val.validate()? }
		if let Some(ref vec) = self.ctct_ref { for item in vec { item.validate()? } }
		if let Some(ref val) = self.com_adr { val.validate()? }
		Ok(())
	}
}


// MemberCriteria4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct MemberCriteria4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NewQryNm", skip_serializing_if = "Option::is_none") )]
	pub new_qry_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SchCrit", skip_serializing_if = "Option::is_none") )]
	pub sch_crit: Option<Vec<MemberSearchCriteria4>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RtrCrit", skip_serializing_if = "Option::is_none") )]
	pub rtr_crit: Option<MemberReturnCriteria1>,
}

impl MemberCriteria4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.new_qry_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "new_qry_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "new_qry_nm exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref vec) = self.sch_crit { for item in vec { item.validate()? } }
		if let Some(ref val) = self.rtr_crit { val.validate()? }
		Ok(())
	}
}


// MemberCriteriaDefinition2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct MemberCriteriaDefinition2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "QryNm", skip_serializing_if = "Option::is_none") )]
	pub qry_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NewCrit", skip_serializing_if = "Option::is_none") )]
	pub new_crit: Option<MemberCriteria4>,
}

impl MemberCriteriaDefinition2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.qry_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "qry_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "qry_nm exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.new_crit { val.validate()? }
		Ok(())
	}
}


// MemberIdentification3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct MemberIdentification3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BICFI", skip_serializing_if = "Option::is_none") )]
	pub bicfi: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrSysMmbId", skip_serializing_if = "Option::is_none") )]
	pub clr_sys_mmb_id: Option<ClearingSystemMemberIdentification2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<GenericFinancialIdentification1>,
}

impl MemberIdentification3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.bicfi {
			let pattern = Regex::new("[A-Z0-9]{4,4}[A-Z]{2,2}[A-Z0-9]{2,2}([A-Z0-9]{3,3}){0,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "bicfi does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.clr_sys_mmb_id { val.validate()? }
		if let Some(ref val) = self.othr { val.validate()? }
		Ok(())
	}
}


// MemberQueryDefinition4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct MemberQueryDefinition4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "QryTp", skip_serializing_if = "Option::is_none") )]
	pub qry_tp: Option<QueryType2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MmbCrit", skip_serializing_if = "Option::is_none") )]
	pub mmb_crit: Option<MemberCriteriaDefinition2Choice>,
}

impl MemberQueryDefinition4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.qry_tp { val.validate()? }
		if let Some(ref val) = self.mmb_crit { val.validate()? }
		Ok(())
	}
}


// MemberReport6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct MemberReport6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MmbId") )]
	pub mmb_id: MemberIdentification3Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MmbOrErr") )]
	pub mmb_or_err: MemberReportOrError8Choice,
}

impl MemberReport6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.mmb_id.validate()?;
		self.mmb_or_err.validate()?;
		Ok(())
	}
}


// MemberReportOrError7Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct MemberReportOrError7Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rpt", skip_serializing_if = "Option::is_none") )]
	pub rpt: Option<Vec<MemberReport6>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OprlErr", skip_serializing_if = "Option::is_none") )]
	pub oprl_err: Option<Vec<ErrorHandling3>>,
}

impl MemberReportOrError7Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.rpt { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.oprl_err { for item in vec { item.validate()? } }
		Ok(())
	}
}


// MemberReportOrError8Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct MemberReportOrError8Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Mmb", skip_serializing_if = "Option::is_none") )]
	pub mmb: Option<Member7>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BizErr", skip_serializing_if = "Option::is_none") )]
	pub biz_err: Option<ErrorHandling3>,
}

impl MemberReportOrError8Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.mmb { val.validate()? }
		if let Some(ref val) = self.biz_err { val.validate()? }
		Ok(())
	}
}


// MemberReturnCriteria1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct MemberReturnCriteria1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NmInd", skip_serializing_if = "Option::is_none") )]
	pub nm_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MmbRtrAdrInd", skip_serializing_if = "Option::is_none") )]
	pub mmb_rtr_adr_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctInd", skip_serializing_if = "Option::is_none") )]
	pub acct_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TpInd", skip_serializing_if = "Option::is_none") )]
	pub tp_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StsInd", skip_serializing_if = "Option::is_none") )]
	pub sts_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtctRefInd", skip_serializing_if = "Option::is_none") )]
	pub ctct_ref_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ComAdrInd", skip_serializing_if = "Option::is_none") )]
	pub com_adr_ind: Option<bool>,
}

impl MemberReturnCriteria1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// MemberSearchCriteria4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct MemberSearchCriteria4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<Vec<MemberIdentification3Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<Vec<SystemMemberType1Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sts", skip_serializing_if = "Option::is_none") )]
	pub sts: Option<Vec<SystemMemberStatus1Choice>>,
}

impl MemberSearchCriteria4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.id { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.tp { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.sts { for item in vec { item.validate()? } }
		Ok(())
	}
}


// MemberStatus1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum MemberStatus1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ENBL") )]
	CodeENBL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DSBL") )]
	CodeDSBL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DLTD") )]
	CodeDLTD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "JOIN") )]
	CodeJOIN,
}

impl MemberStatus1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// MessageHeader1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct MessageHeader1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgId") )]
	pub msg_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CreDtTm", skip_serializing_if = "Option::is_none") )]
	pub cre_dt_tm: Option<String>,
}

impl MessageHeader1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.msg_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "msg_id is shorter than the minimum length of 1".to_string()));
		}
		if self.msg_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "msg_id exceeds the maximum length of 35".to_string()));
		}
		Ok(())
	}
}


// MessageHeader4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct MessageHeader4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgId") )]
	pub msg_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CreDtTm", skip_serializing_if = "Option::is_none") )]
	pub cre_dt_tm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReqTp", skip_serializing_if = "Option::is_none") )]
	pub req_tp: Option<RequestType3Choice>,
}

impl MessageHeader4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.msg_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "msg_id is shorter than the minimum length of 1".to_string()));
		}
		if self.msg_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "msg_id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.req_tp { val.validate()? }
		Ok(())
	}
}


// MessageHeader6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct MessageHeader6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgId") )]
	pub msg_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CreDtTm", skip_serializing_if = "Option::is_none") )]
	pub cre_dt_tm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlBizQry", skip_serializing_if = "Option::is_none") )]
	pub orgnl_biz_qry: Option<OriginalBusinessQuery1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "QryNm", skip_serializing_if = "Option::is_none") )]
	pub qry_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReqTp", skip_serializing_if = "Option::is_none") )]
	pub req_tp: Option<RequestType3Choice>,
}

impl MessageHeader6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.msg_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "msg_id is shorter than the minimum length of 1".to_string()));
		}
		if self.msg_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "msg_id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.orgnl_biz_qry { val.validate()? }
		if let Some(ref val) = self.qry_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "qry_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "qry_nm exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.req_tp { val.validate()? }
		Ok(())
	}
}


// MessageHeader7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct MessageHeader7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgId") )]
	pub msg_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CreDtTm", skip_serializing_if = "Option::is_none") )]
	pub cre_dt_tm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReqTp", skip_serializing_if = "Option::is_none") )]
	pub req_tp: Option<RequestType4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlBizQry", skip_serializing_if = "Option::is_none") )]
	pub orgnl_biz_qry: Option<OriginalBusinessQuery1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "QryNm", skip_serializing_if = "Option::is_none") )]
	pub qry_nm: Option<String>,
}

impl MessageHeader7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.msg_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "msg_id is shorter than the minimum length of 1".to_string()));
		}
		if self.msg_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "msg_id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.req_tp { val.validate()? }
		if let Some(ref val) = self.orgnl_biz_qry { val.validate()? }
		if let Some(ref val) = self.qry_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "qry_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "qry_nm exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// MessageHeader8 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct MessageHeader8 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgId") )]
	pub msg_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CreDtTm", skip_serializing_if = "Option::is_none") )]
	pub cre_dt_tm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgPgntn", skip_serializing_if = "Option::is_none") )]
	pub msg_pgntn: Option<Pagination1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlBizQry", skip_serializing_if = "Option::is_none") )]
	pub orgnl_biz_qry: Option<OriginalBusinessQuery1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReqTp", skip_serializing_if = "Option::is_none") )]
	pub req_tp: Option<RequestType4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "QryNm", skip_serializing_if = "Option::is_none") )]
	pub qry_nm: Option<String>,
}

impl MessageHeader8 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.msg_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "msg_id is shorter than the minimum length of 1".to_string()));
		}
		if self.msg_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "msg_id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.msg_pgntn { val.validate()? }
		if let Some(ref val) = self.orgnl_biz_qry { val.validate()? }
		if let Some(ref val) = self.req_tp { val.validate()? }
		if let Some(ref val) = self.qry_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "qry_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "qry_nm exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// MessageHeader9 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct MessageHeader9 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgId") )]
	pub msg_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CreDtTm", skip_serializing_if = "Option::is_none") )]
	pub cre_dt_tm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReqTp", skip_serializing_if = "Option::is_none") )]
	pub req_tp: Option<RequestType4Choice>,
}

impl MessageHeader9 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.msg_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "msg_id is shorter than the minimum length of 1".to_string()));
		}
		if self.msg_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "msg_id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.req_tp { val.validate()? }
		Ok(())
	}
}


// MessageIdentification1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct MessageIdentification1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CreDtTm") )]
	pub cre_dt_tm: String,
}

impl MessageIdentification1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
		}
		Ok(())
	}
}


// MessageIdentification2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct MessageIdentification2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgNmId", skip_serializing_if = "Option::is_none") )]
	pub msg_nm_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgId", skip_serializing_if = "Option::is_none") )]
	pub msg_id: Option<String>,
}

impl MessageIdentification2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.msg_nm_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "msg_nm_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "msg_nm_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.msg_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "msg_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "msg_id exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// MissingCover6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct MissingCover6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MssngCoverInd") )]
	pub mssng_cover_ind: bool,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CoverCrrctn", skip_serializing_if = "Option::is_none") )]
	pub cover_crrctn: Option<SettlementInstruction16>,
}

impl MissingCover6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cover_crrctn { val.validate()? }
		Ok(())
	}
}


// MissingData1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct MissingData1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl MissingData1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// MissingOrIncorrectData1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct MissingOrIncorrectData1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AMLReq", skip_serializing_if = "Option::is_none") )]
	pub aml_req: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MssngInf", skip_serializing_if = "Option::is_none") )]
	pub mssng_inf: Option<Vec<UnableToApplyMissing2>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IncrrctInf", skip_serializing_if = "Option::is_none") )]
	pub incrrct_inf: Option<Vec<UnableToApplyIncorrect2>>,
}

impl MissingOrIncorrectData1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.mssng_inf { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.incrrct_inf { for item in vec { item.validate()? } }
		Ok(())
	}
}


// ModificationProcessingStatus1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum ModificationProcessingStatus1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "PACK") )]
	CodePACK,
	#[cfg_attr( feature = "derive_serde", serde(rename = "REJT") )]
	CodeREJT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MODC") )]
	CodeMODC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DEND") )]
	CodeDEND,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MODP") )]
	CodeMODP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "REPR") )]
	CodeREPR,
}

impl ModificationProcessingStatus1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ModificationProcessingStatus9Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ModificationProcessingStatus9Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<ModificationProcessingStatus1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification30>,
}

impl ModificationProcessingStatus9Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// ModificationStatusReason1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ModificationStatusReason1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl ModificationStatusReason1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// ModificationStatusReason3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ModificationStatusReason3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Orgtr", skip_serializing_if = "Option::is_none") )]
	pub orgtr: Option<PartyIdentification272>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn", skip_serializing_if = "Option::is_none") )]
	pub rsn: Option<ModificationStatusReason1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_inf: Option<Vec<String>>,
}

impl ModificationStatusReason3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.orgtr { val.validate()? }
		if let Some(ref val) = self.rsn { val.validate()? }
		if let Some(ref vec) = self.addtl_inf {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "addtl_inf is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 105 {
					return Err(ValidationError::new(1002, "addtl_inf exceeds the maximum length of 105".to_string()));
				}
			}
		}
		Ok(())
	}
}


// MovementReport1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct MovementReport1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "QryRef", skip_serializing_if = "Option::is_none") )]
	pub qry_ref: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptId", skip_serializing_if = "Option::is_none") )]
	pub rpt_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "QryTp") )]
	pub qry_tp: MovementResponseType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ActvtyInd") )]
	pub actvty_ind: bool,
}

impl MovementReport1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.qry_ref {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "qry_ref is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "qry_ref exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.rpt_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "rpt_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "rpt_id exceeds the maximum length of 35".to_string()));
			}
		}
		self.qry_tp.validate()?;
		Ok(())
	}
}


// MovementResponseType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum MovementResponseType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "FULL") )]
	CodeFULL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "STTS") )]
	CodeSTTS,
}

impl MovementResponseType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// NameAndAddress16 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct NameAndAddress16 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm") )]
	pub nm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Adr") )]
	pub adr: PostalAddress24,
}

impl NameAndAddress16 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.nm.chars().count() < 1 {
			return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
		}
		if self.nm.chars().count() > 140 {
			return Err(ValidationError::new(1002, "nm exceeds the maximum length of 140".to_string()));
		}
		self.adr.validate()?;
		Ok(())
	}
}


// NameAndAddress18 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct NameAndAddress18 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm") )]
	pub nm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Adr") )]
	pub adr: PostalAddress27,
}

impl NameAndAddress18 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.nm.chars().count() < 1 {
			return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
		}
		if self.nm.chars().count() > 140 {
			return Err(ValidationError::new(1002, "nm exceeds the maximum length of 140".to_string()));
		}
		self.adr.validate()?;
		Ok(())
	}
}


// NameAndAddress5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct NameAndAddress5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm") )]
	pub nm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Adr", skip_serializing_if = "Option::is_none") )]
	pub adr: Option<PostalAddress1>,
}

impl NameAndAddress5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.nm.chars().count() < 1 {
			return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
		}
		if self.nm.chars().count() > 350 {
			return Err(ValidationError::new(1002, "nm exceeds the maximum length of 350".to_string()));
		}
		if let Some(ref val) = self.adr { val.validate()? }
		Ok(())
	}
}


// NameAndAddress8 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct NameAndAddress8 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm") )]
	pub nm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Adr", skip_serializing_if = "Option::is_none") )]
	pub adr: Option<PostalAddress1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AltrntvIdr", skip_serializing_if = "Option::is_none") )]
	pub altrntv_idr: Option<Vec<String>>,
}

impl NameAndAddress8 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.nm.chars().count() < 1 {
			return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
		}
		if self.nm.chars().count() > 350 {
			return Err(ValidationError::new(1002, "nm exceeds the maximum length of 350".to_string()));
		}
		if let Some(ref val) = self.adr { val.validate()? }
		if let Some(ref vec) = self.altrntv_idr {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "altrntv_idr is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 35 {
					return Err(ValidationError::new(1002, "altrntv_idr exceeds the maximum length of 35".to_string()));
				}
			}
		}
		Ok(())
	}
}


// NamePrefix2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum NamePrefix2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "DOCT") )]
	CodeDOCT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MADM") )]
	CodeMADM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MISS") )]
	CodeMISS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MIST") )]
	CodeMIST,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MIKS") )]
	CodeMIKS,
}

impl NamePrefix2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// NetCashForecast3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct NetCashForecast3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NetAmt", skip_serializing_if = "Option::is_none") )]
	pub net_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NetUnitsNb", skip_serializing_if = "Option::is_none") )]
	pub net_units_nb: Option<FinancialInstrumentQuantity1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FlowDrctn") )]
	pub flow_drctn: FlowDirectionType1Code,
}

impl NetCashForecast3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.net_amt { val.validate()? }
		if let Some(ref val) = self.net_units_nb { val.validate()? }
		self.flow_drctn.validate()?;
		Ok(())
	}
}


// NetCashForecast4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct NetCashForecast4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshSttlmDt") )]
	pub csh_sttlm_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NetAmt", skip_serializing_if = "Option::is_none") )]
	pub net_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NetUnitsNb", skip_serializing_if = "Option::is_none") )]
	pub net_units_nb: Option<FinancialInstrumentQuantity1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FlowDrctn") )]
	pub flow_drctn: FlowDirectionType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlBal", skip_serializing_if = "Option::is_none") )]
	pub addtl_bal: Option<FundBalance1>,
}

impl NetCashForecast4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.net_amt { val.validate()? }
		if let Some(ref val) = self.net_units_nb { val.validate()? }
		self.flow_drctn.validate()?;
		if let Some(ref val) = self.addtl_bal { val.validate()? }
		Ok(())
	}
}


// NetCashForecast5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct NetCashForecast5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshSttlmDt", skip_serializing_if = "Option::is_none") )]
	pub csh_sttlm_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NetAmt", skip_serializing_if = "Option::is_none") )]
	pub net_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NetUnitsNb", skip_serializing_if = "Option::is_none") )]
	pub net_units_nb: Option<FinancialInstrumentQuantity1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FlowDrctn") )]
	pub flow_drctn: FlowDirectionType1Code,
}

impl NetCashForecast5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.net_amt { val.validate()? }
		if let Some(ref val) = self.net_units_nb { val.validate()? }
		self.flow_drctn.validate()?;
		Ok(())
	}
}


// NetObligation2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct NetObligation2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OblgtnId") )]
	pub oblgtn_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PtcptNetgId") )]
	pub ptcpt_netg_id: NettingIdentification2Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OblgtnDrctn") )]
	pub oblgtn_drctn: PaymentReceipt1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPtyNetgId") )]
	pub ctr_pty_netg_id: NettingIdentification2Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NetSvcCtrPtyId", skip_serializing_if = "Option::is_none") )]
	pub net_svc_ctr_pty_id: Option<PartyIdentification242Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPtySttlmInstrs", skip_serializing_if = "Option::is_none") )]
	pub ctr_pty_sttlm_instrs: Option<SettlementParties120>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxsNb", skip_serializing_if = "Option::is_none") )]
	pub txs_nb: Option<String>,
}

impl NetObligation2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.oblgtn_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "oblgtn_id is shorter than the minimum length of 1".to_string()));
		}
		if self.oblgtn_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "oblgtn_id exceeds the maximum length of 35".to_string()));
		}
		self.amt.validate()?;
		self.ptcpt_netg_id.validate()?;
		self.oblgtn_drctn.validate()?;
		self.ctr_pty_netg_id.validate()?;
		if let Some(ref val) = self.net_svc_ctr_pty_id { val.validate()? }
		if let Some(ref val) = self.ctr_pty_sttlm_instrs { val.validate()? }
		if let Some(ref val) = self.txs_nb {
			let pattern = Regex::new("[0-9]{1,10}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "txs_nb does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// NetReportData2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct NetReportData2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgId") )]
	pub msg_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CreDtTm") )]
	pub cre_dt_tm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NetgCutOffTm") )]
	pub netg_cut_off_tm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptDt") )]
	pub rpt_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ValDt") )]
	pub val_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptTp", skip_serializing_if = "Option::is_none") )]
	pub rpt_tp: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NetRptSvcr", skip_serializing_if = "Option::is_none") )]
	pub net_rpt_svcr: Option<PartyIdentification242Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NetSvcTp", skip_serializing_if = "Option::is_none") )]
	pub net_svc_tp: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgPgntn", skip_serializing_if = "Option::is_none") )]
	pub msg_pgntn: Option<Pagination1>,
}

impl NetReportData2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.msg_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "msg_id is shorter than the minimum length of 1".to_string()));
		}
		if self.msg_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "msg_id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.rpt_tp {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "rpt_tp is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "rpt_tp exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.net_rpt_svcr { val.validate()? }
		if let Some(ref val) = self.net_svc_tp {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "net_svc_tp is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "net_svc_tp exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.msg_pgntn { val.validate()? }
		Ok(())
	}
}


// NettingIdentification2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct NettingIdentification2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradPty", skip_serializing_if = "Option::is_none") )]
	pub trad_pty: Option<PartyIdentification242Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NetgGrpId", skip_serializing_if = "Option::is_none") )]
	pub netg_grp_id: Option<String>,
}

impl NettingIdentification2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.trad_pty { val.validate()? }
		if let Some(ref val) = self.netg_grp_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "netg_grp_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "netg_grp_id exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// NoReasonCode ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum NoReasonCode {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "NORE") )]
	CodeNORE,
}

impl NoReasonCode {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// NotificationCancellationReason1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct NotificationCancellationReason1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl NotificationCancellationReason1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// NotificationCancellationReason2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct NotificationCancellationReason2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Orgtr", skip_serializing_if = "Option::is_none") )]
	pub orgtr: Option<PartyIdentification272>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn", skip_serializing_if = "Option::is_none") )]
	pub rsn: Option<NotificationCancellationReason1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_inf: Option<Vec<String>>,
}

impl NotificationCancellationReason2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.orgtr { val.validate()? }
		if let Some(ref val) = self.rsn { val.validate()? }
		if let Some(ref vec) = self.addtl_inf {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "addtl_inf is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 105 {
					return Err(ValidationError::new(1002, "addtl_inf exceeds the maximum length of 105".to_string()));
				}
			}
		}
		Ok(())
	}
}


// NotificationItem9 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct NotificationItem9 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EndToEndId", skip_serializing_if = "Option::is_none") )]
	pub end_to_end_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UETR", skip_serializing_if = "Option::is_none") )]
	pub uetr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Acct", skip_serializing_if = "Option::is_none") )]
	pub acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctOwnr", skip_serializing_if = "Option::is_none") )]
	pub acct_ownr: Option<Party50Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctSvcr", skip_serializing_if = "Option::is_none") )]
	pub acct_svcr: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RltdAcct", skip_serializing_if = "Option::is_none") )]
	pub rltd_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveOrHistoricCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XpctdValDt", skip_serializing_if = "Option::is_none") )]
	pub xpctd_val_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dbtr", skip_serializing_if = "Option::is_none") )]
	pub dbtr: Option<Party50Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtrAgt", skip_serializing_if = "Option::is_none") )]
	pub dbtr_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrmyAgt", skip_serializing_if = "Option::is_none") )]
	pub intrmy_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Purp", skip_serializing_if = "Option::is_none") )]
	pub purp: Option<Purpose2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RltdRmtInf", skip_serializing_if = "Option::is_none") )]
	pub rltd_rmt_inf: Option<RemittanceLocation8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RmtInf", skip_serializing_if = "Option::is_none") )]
	pub rmt_inf: Option<RemittanceInformation22>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UndrlygAllcn", skip_serializing_if = "Option::is_none") )]
	pub undrlyg_allcn: Option<Vec<TransactionAllocation1>>,
}

impl NotificationItem9 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.end_to_end_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "end_to_end_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "end_to_end_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.uetr {
			let pattern = Regex::new("[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "uetr does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.acct { val.validate()? }
		if let Some(ref val) = self.acct_ownr { val.validate()? }
		if let Some(ref val) = self.acct_svcr { val.validate()? }
		if let Some(ref val) = self.rltd_acct { val.validate()? }
		self.amt.validate()?;
		if let Some(ref val) = self.dbtr { val.validate()? }
		if let Some(ref val) = self.dbtr_agt { val.validate()? }
		if let Some(ref val) = self.intrmy_agt { val.validate()? }
		if let Some(ref val) = self.purp { val.validate()? }
		if let Some(ref val) = self.rltd_rmt_inf { val.validate()? }
		if let Some(ref val) = self.rmt_inf { val.validate()? }
		if let Some(ref vec) = self.undrlyg_allcn { for item in vec { item.validate()? } }
		Ok(())
	}
}


// NotificationStatus3Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum NotificationStatus3Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "RCBD") )]
	CodeRCBD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RCVD") )]
	CodeRCVD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NRCD") )]
	CodeNRCD,
}

impl NotificationStatus3Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// Number3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Number3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Shrt", skip_serializing_if = "Option::is_none") )]
	pub shrt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Lng", skip_serializing_if = "Option::is_none") )]
	pub lng: Option<String>,
}

impl Number3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.shrt {
			let pattern = Regex::new("[0-9]{3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "shrt does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.lng {
			let pattern = Regex::new("[0-9]{5}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "lng does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// NumberAndSumOfTransactions1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct NumberAndSumOfTransactions1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfNtries", skip_serializing_if = "Option::is_none") )]
	pub nb_of_ntries: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sum", skip_serializing_if = "Option::is_none") )]
	pub sum: Option<f64>,
}

impl NumberAndSumOfTransactions1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.nb_of_ntries {
			let pattern = Regex::new("[0-9]{1,15}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "nb_of_ntries does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// NumberAndSumOfTransactions2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct NumberAndSumOfTransactions2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfNtries", skip_serializing_if = "Option::is_none") )]
	pub nb_of_ntries: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sum", skip_serializing_if = "Option::is_none") )]
	pub sum: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlNetNtryAmt", skip_serializing_if = "Option::is_none") )]
	pub ttl_net_ntry_amt: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtDbtInd", skip_serializing_if = "Option::is_none") )]
	pub cdt_dbt_ind: Option<CreditDebitCode>,
}

impl NumberAndSumOfTransactions2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.nb_of_ntries {
			let pattern = Regex::new("[0-9]{1,15}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "nb_of_ntries does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.cdt_dbt_ind { val.validate()? }
		Ok(())
	}
}


// NumberAndSumOfTransactions4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct NumberAndSumOfTransactions4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfNtries", skip_serializing_if = "Option::is_none") )]
	pub nb_of_ntries: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sum", skip_serializing_if = "Option::is_none") )]
	pub sum: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlNetNtry", skip_serializing_if = "Option::is_none") )]
	pub ttl_net_ntry: Option<AmountAndDirection35>,
}

impl NumberAndSumOfTransactions4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.nb_of_ntries {
			let pattern = Regex::new("[0-9]{1,15}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "nb_of_ntries does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.ttl_net_ntry { val.validate()? }
		Ok(())
	}
}


// NumberCount1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct NumberCount1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CurInstrNb", skip_serializing_if = "Option::is_none") )]
	pub cur_instr_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlNb", skip_serializing_if = "Option::is_none") )]
	pub ttl_nb: Option<TotalNumber1>,
}

impl NumberCount1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cur_instr_nb {
			let pattern = Regex::new("[0-9]{3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "cur_instr_nb does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.ttl_nb { val.validate()? }
		Ok(())
	}
}


// NumberOfCancellationsPerStatus1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct NumberOfCancellationsPerStatus1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtldNbOfTxs") )]
	pub dtld_nb_of_txs: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtldSts") )]
	pub dtld_sts: CancellationIndividualStatus1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtldCtrlSum", skip_serializing_if = "Option::is_none") )]
	pub dtld_ctrl_sum: Option<f64>,
}

impl NumberOfCancellationsPerStatus1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[0-9]{1,15}").unwrap();
		if !pattern.is_match(&self.dtld_nb_of_txs) {
			return Err(ValidationError::new(1005, "dtld_nb_of_txs does not match the required pattern".to_string()));
		}
		self.dtld_sts.validate()?;
		Ok(())
	}
}


// NumberOfTransactionsPerStatus1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct NumberOfTransactionsPerStatus1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtldNbOfTxs") )]
	pub dtld_nb_of_txs: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtldSts") )]
	pub dtld_sts: TransactionIndividualStatus1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtldCtrlSum", skip_serializing_if = "Option::is_none") )]
	pub dtld_ctrl_sum: Option<f64>,
}

impl NumberOfTransactionsPerStatus1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[0-9]{1,15}").unwrap();
		if !pattern.is_match(&self.dtld_nb_of_txs) {
			return Err(ValidationError::new(1005, "dtld_nb_of_txs does not match the required pattern".to_string()));
		}
		self.dtld_sts.validate()?;
		Ok(())
	}
}


// OnLineCapability1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum OnLineCapability1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "OFLN") )]
	CodeOFLN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ONLN") )]
	CodeONLN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SMON") )]
	CodeSMON,
}

impl OnLineCapability1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// OrderQuantityType2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum OrderQuantityType2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "UNIT") )]
	CodeUNIT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CASH") )]
	CodeCASH,
}

impl OrderQuantityType2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// OrganisationIdentification29 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct OrganisationIdentification29 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AnyBIC", skip_serializing_if = "Option::is_none") )]
	pub any_bic: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LEI", skip_serializing_if = "Option::is_none") )]
	pub lei: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<Vec<GenericOrganisationIdentification1>>,
}

impl OrganisationIdentification29 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.any_bic {
			let pattern = Regex::new("[A-Z0-9]{4,4}[A-Z]{2,2}[A-Z0-9]{2,2}([A-Z0-9]{3,3}){0,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "any_bic does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.lei {
			let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "lei does not match the required pattern".to_string()));
			}
		}
		if let Some(ref vec) = self.othr { for item in vec { item.validate()? } }
		Ok(())
	}
}


// OrganisationIdentification39 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct OrganisationIdentification39 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AnyBIC", skip_serializing_if = "Option::is_none") )]
	pub any_bic: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LEI", skip_serializing_if = "Option::is_none") )]
	pub lei: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<Vec<GenericOrganisationIdentification3>>,
}

impl OrganisationIdentification39 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.any_bic {
			let pattern = Regex::new("[A-Z0-9]{4,4}[A-Z]{2,2}[A-Z0-9]{2,2}([A-Z0-9]{3,3}){0,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "any_bic does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.lei {
			let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "lei does not match the required pattern".to_string()));
			}
		}
		if let Some(ref vec) = self.othr { for item in vec { item.validate()? } }
		Ok(())
	}
}


// OrganisationIdentificationSchemeName1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct OrganisationIdentificationSchemeName1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl OrganisationIdentificationSchemeName1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// OriginalAndCurrentQuantities1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct OriginalAndCurrentQuantities1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FaceAmt") )]
	pub face_amt: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AmtsdVal") )]
	pub amtsd_val: f64,
}

impl OriginalAndCurrentQuantities1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// OriginalBusinessQuery1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct OriginalBusinessQuery1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgId") )]
	pub msg_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgNmId", skip_serializing_if = "Option::is_none") )]
	pub msg_nm_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CreDtTm", skip_serializing_if = "Option::is_none") )]
	pub cre_dt_tm: Option<String>,
}

impl OriginalBusinessQuery1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.msg_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "msg_id is shorter than the minimum length of 1".to_string()));
		}
		if self.msg_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "msg_id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.msg_nm_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "msg_nm_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "msg_nm_id exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// OriginalGroupHeader21 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct OriginalGroupHeader21 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "GrpCxlId", skip_serializing_if = "Option::is_none") )]
	pub grp_cxl_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Case", skip_serializing_if = "Option::is_none") )]
	pub case: Option<Case6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlMsgId") )]
	pub orgnl_msg_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlMsgNmId") )]
	pub orgnl_msg_nm_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlCreDtTm", skip_serializing_if = "Option::is_none") )]
	pub orgnl_cre_dt_tm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfTxs", skip_serializing_if = "Option::is_none") )]
	pub nb_of_txs: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrlSum", skip_serializing_if = "Option::is_none") )]
	pub ctrl_sum: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GrpCxl", skip_serializing_if = "Option::is_none") )]
	pub grp_cxl: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CxlRsnInf", skip_serializing_if = "Option::is_none") )]
	pub cxl_rsn_inf: Option<Vec<PaymentCancellationReason6>>,
}

impl OriginalGroupHeader21 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.grp_cxl_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "grp_cxl_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "grp_cxl_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.case { val.validate()? }
		if self.orgnl_msg_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "orgnl_msg_id is shorter than the minimum length of 1".to_string()));
		}
		if self.orgnl_msg_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "orgnl_msg_id exceeds the maximum length of 35".to_string()));
		}
		if self.orgnl_msg_nm_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "orgnl_msg_nm_id is shorter than the minimum length of 1".to_string()));
		}
		if self.orgnl_msg_nm_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "orgnl_msg_nm_id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.nb_of_txs {
			let pattern = Regex::new("[0-9]{1,15}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "nb_of_txs does not match the required pattern".to_string()));
			}
		}
		if let Some(ref vec) = self.cxl_rsn_inf { for item in vec { item.validate()? } }
		Ok(())
	}
}


// OriginalGroupHeader23 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct OriginalGroupHeader23 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlGrpCxlId", skip_serializing_if = "Option::is_none") )]
	pub orgnl_grp_cxl_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RslvdCase", skip_serializing_if = "Option::is_none") )]
	pub rslvd_case: Option<Case6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlMsgId") )]
	pub orgnl_msg_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlMsgNmId") )]
	pub orgnl_msg_nm_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlCreDtTm", skip_serializing_if = "Option::is_none") )]
	pub orgnl_cre_dt_tm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlNbOfTxs", skip_serializing_if = "Option::is_none") )]
	pub orgnl_nb_of_txs: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlCtrlSum", skip_serializing_if = "Option::is_none") )]
	pub orgnl_ctrl_sum: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GrpCxlSts", skip_serializing_if = "Option::is_none") )]
	pub grp_cxl_sts: Option<GroupCancellationStatus1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CxlStsRsnInf", skip_serializing_if = "Option::is_none") )]
	pub cxl_sts_rsn_inf: Option<Vec<CancellationStatusReason5>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfTxsPerCxlSts", skip_serializing_if = "Option::is_none") )]
	pub nb_of_txs_per_cxl_sts: Option<Vec<NumberOfTransactionsPerStatus1>>,
}

impl OriginalGroupHeader23 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.orgnl_grp_cxl_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_grp_cxl_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_grp_cxl_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.rslvd_case { val.validate()? }
		if self.orgnl_msg_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "orgnl_msg_id is shorter than the minimum length of 1".to_string()));
		}
		if self.orgnl_msg_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "orgnl_msg_id exceeds the maximum length of 35".to_string()));
		}
		if self.orgnl_msg_nm_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "orgnl_msg_nm_id is shorter than the minimum length of 1".to_string()));
		}
		if self.orgnl_msg_nm_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "orgnl_msg_nm_id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.orgnl_nb_of_txs {
			let pattern = Regex::new("[0-9]{1,15}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "orgnl_nb_of_txs does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.grp_cxl_sts { val.validate()? }
		if let Some(ref vec) = self.cxl_sts_rsn_inf { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.nb_of_txs_per_cxl_sts { for item in vec { item.validate()? } }
		Ok(())
	}
}


// OriginalGroupInformation29 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct OriginalGroupInformation29 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlMsgId") )]
	pub orgnl_msg_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlMsgNmId") )]
	pub orgnl_msg_nm_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlCreDtTm", skip_serializing_if = "Option::is_none") )]
	pub orgnl_cre_dt_tm: Option<String>,
}

impl OriginalGroupInformation29 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.orgnl_msg_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "orgnl_msg_id is shorter than the minimum length of 1".to_string()));
		}
		if self.orgnl_msg_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "orgnl_msg_id exceeds the maximum length of 35".to_string()));
		}
		if self.orgnl_msg_nm_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "orgnl_msg_nm_id is shorter than the minimum length of 1".to_string()));
		}
		if self.orgnl_msg_nm_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "orgnl_msg_nm_id exceeds the maximum length of 35".to_string()));
		}
		Ok(())
	}
}


// OriginalItem8 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct OriginalItem8 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlItmId") )]
	pub orgnl_itm_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlEndToEndId", skip_serializing_if = "Option::is_none") )]
	pub orgnl_end_to_end_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UETR", skip_serializing_if = "Option::is_none") )]
	pub uetr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveOrHistoricCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XpctdValDt", skip_serializing_if = "Option::is_none") )]
	pub xpctd_val_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlItmRef", skip_serializing_if = "Option::is_none") )]
	pub orgnl_itm_ref: Option<OriginalItemReference7>,
}

impl OriginalItem8 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.orgnl_itm_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "orgnl_itm_id is shorter than the minimum length of 1".to_string()));
		}
		if self.orgnl_itm_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "orgnl_itm_id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.orgnl_end_to_end_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_end_to_end_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_end_to_end_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.uetr {
			let pattern = Regex::new("[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "uetr does not match the required pattern".to_string()));
			}
		}
		self.amt.validate()?;
		if let Some(ref val) = self.orgnl_itm_ref { val.validate()? }
		Ok(())
	}
}


// OriginalItemAndStatus8 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct OriginalItemAndStatus8 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlItmId") )]
	pub orgnl_itm_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlEndToEndId", skip_serializing_if = "Option::is_none") )]
	pub orgnl_end_to_end_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlUETR", skip_serializing_if = "Option::is_none") )]
	pub orgnl_uetr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveOrHistoricCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XpctdValDt", skip_serializing_if = "Option::is_none") )]
	pub xpctd_val_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ItmSts") )]
	pub itm_sts: NotificationStatus3Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlStsInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_sts_inf: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlItmRef", skip_serializing_if = "Option::is_none") )]
	pub orgnl_itm_ref: Option<OriginalItemReference7>,
}

impl OriginalItemAndStatus8 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.orgnl_itm_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "orgnl_itm_id is shorter than the minimum length of 1".to_string()));
		}
		if self.orgnl_itm_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "orgnl_itm_id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.orgnl_end_to_end_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_end_to_end_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_end_to_end_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.orgnl_uetr {
			let pattern = Regex::new("[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "orgnl_uetr does not match the required pattern".to_string()));
			}
		}
		self.amt.validate()?;
		self.itm_sts.validate()?;
		if let Some(ref val) = self.addtl_sts_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_sts_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 105 {
				return Err(ValidationError::new(1002, "addtl_sts_inf exceeds the maximum length of 105".to_string()));
			}
		}
		if let Some(ref val) = self.orgnl_itm_ref { val.validate()? }
		Ok(())
	}
}


// OriginalItemReference7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct OriginalItemReference7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Acct", skip_serializing_if = "Option::is_none") )]
	pub acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctOwnr", skip_serializing_if = "Option::is_none") )]
	pub acct_ownr: Option<Party50Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctSvcr", skip_serializing_if = "Option::is_none") )]
	pub acct_svcr: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RltdAcct", skip_serializing_if = "Option::is_none") )]
	pub rltd_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dbtr", skip_serializing_if = "Option::is_none") )]
	pub dbtr: Option<Party50Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtrAgt", skip_serializing_if = "Option::is_none") )]
	pub dbtr_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrmyAgt", skip_serializing_if = "Option::is_none") )]
	pub intrmy_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Purp", skip_serializing_if = "Option::is_none") )]
	pub purp: Option<Purpose2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RltdRmtInf", skip_serializing_if = "Option::is_none") )]
	pub rltd_rmt_inf: Option<RemittanceLocation8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RmtInf", skip_serializing_if = "Option::is_none") )]
	pub rmt_inf: Option<RemittanceInformation22>,
}

impl OriginalItemReference7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.acct { val.validate()? }
		if let Some(ref val) = self.acct_ownr { val.validate()? }
		if let Some(ref val) = self.acct_svcr { val.validate()? }
		if let Some(ref val) = self.rltd_acct { val.validate()? }
		if let Some(ref val) = self.dbtr { val.validate()? }
		if let Some(ref val) = self.dbtr_agt { val.validate()? }
		if let Some(ref val) = self.intrmy_agt { val.validate()? }
		if let Some(ref val) = self.purp { val.validate()? }
		if let Some(ref val) = self.rltd_rmt_inf { val.validate()? }
		if let Some(ref val) = self.rmt_inf { val.validate()? }
		Ok(())
	}
}


// OriginalMessageAndIssuer1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct OriginalMessageAndIssuer1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgId") )]
	pub msg_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgNmId", skip_serializing_if = "Option::is_none") )]
	pub msg_nm_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgtrNm", skip_serializing_if = "Option::is_none") )]
	pub orgtr_nm: Option<String>,
}

impl OriginalMessageAndIssuer1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.msg_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "msg_id is shorter than the minimum length of 1".to_string()));
		}
		if self.msg_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "msg_id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.msg_nm_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "msg_nm_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "msg_nm_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.orgtr_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgtr_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 70 {
				return Err(ValidationError::new(1002, "orgtr_nm exceeds the maximum length of 70".to_string()));
			}
		}
		Ok(())
	}
}


// OriginalNotification15 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct OriginalNotification15 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlMsgId") )]
	pub orgnl_msg_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlCreDtTm", skip_serializing_if = "Option::is_none") )]
	pub orgnl_cre_dt_tm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlNtfctnId") )]
	pub orgnl_ntfctn_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtfctnSts", skip_serializing_if = "Option::is_none") )]
	pub ntfctn_sts: Option<NotificationStatus3Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlStsInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_sts_inf: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlNtfctnRef", skip_serializing_if = "Option::is_none") )]
	pub orgnl_ntfctn_ref: Option<Vec<OriginalNotificationReference13>>,
}

impl OriginalNotification15 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.orgnl_msg_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "orgnl_msg_id is shorter than the minimum length of 1".to_string()));
		}
		if self.orgnl_msg_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "orgnl_msg_id exceeds the maximum length of 35".to_string()));
		}
		if self.orgnl_ntfctn_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "orgnl_ntfctn_id is shorter than the minimum length of 1".to_string()));
		}
		if self.orgnl_ntfctn_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "orgnl_ntfctn_id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.ntfctn_sts { val.validate()? }
		if let Some(ref val) = self.addtl_sts_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_sts_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "addtl_sts_inf exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref vec) = self.orgnl_ntfctn_ref { for item in vec { item.validate()? } }
		Ok(())
	}
}


// OriginalNotification16 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct OriginalNotification16 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlMsgId") )]
	pub orgnl_msg_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlCreDtTm", skip_serializing_if = "Option::is_none") )]
	pub orgnl_cre_dt_tm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlNtfctnId") )]
	pub orgnl_ntfctn_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtfctnCxl", skip_serializing_if = "Option::is_none") )]
	pub ntfctn_cxl: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlNtfctnRef", skip_serializing_if = "Option::is_none") )]
	pub orgnl_ntfctn_ref: Option<Vec<OriginalNotificationReference14>>,
}

impl OriginalNotification16 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.orgnl_msg_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "orgnl_msg_id is shorter than the minimum length of 1".to_string()));
		}
		if self.orgnl_msg_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "orgnl_msg_id exceeds the maximum length of 35".to_string()));
		}
		if self.orgnl_ntfctn_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "orgnl_ntfctn_id is shorter than the minimum length of 1".to_string()));
		}
		if self.orgnl_ntfctn_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "orgnl_ntfctn_id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref vec) = self.orgnl_ntfctn_ref { for item in vec { item.validate()? } }
		Ok(())
	}
}


// OriginalNotificationReference13 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct OriginalNotificationReference13 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Acct", skip_serializing_if = "Option::is_none") )]
	pub acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctOwnr", skip_serializing_if = "Option::is_none") )]
	pub acct_ownr: Option<Party50Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctSvcr", skip_serializing_if = "Option::is_none") )]
	pub acct_svcr: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RltdAcct", skip_serializing_if = "Option::is_none") )]
	pub rltd_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlAmt", skip_serializing_if = "Option::is_none") )]
	pub ttl_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XpctdValDt", skip_serializing_if = "Option::is_none") )]
	pub xpctd_val_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dbtr", skip_serializing_if = "Option::is_none") )]
	pub dbtr: Option<Party50Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtrAgt", skip_serializing_if = "Option::is_none") )]
	pub dbtr_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrmyAgt", skip_serializing_if = "Option::is_none") )]
	pub intrmy_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlItmAndSts") )]
	pub orgnl_itm_and_sts: Vec<OriginalItemAndStatus8>,
}

impl OriginalNotificationReference13 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.acct { val.validate()? }
		if let Some(ref val) = self.acct_ownr { val.validate()? }
		if let Some(ref val) = self.acct_svcr { val.validate()? }
		if let Some(ref val) = self.rltd_acct { val.validate()? }
		if let Some(ref val) = self.ttl_amt { val.validate()? }
		if let Some(ref val) = self.dbtr { val.validate()? }
		if let Some(ref val) = self.dbtr_agt { val.validate()? }
		if let Some(ref val) = self.intrmy_agt { val.validate()? }
		for item in &self.orgnl_itm_and_sts { item.validate()? }
		Ok(())
	}
}


// OriginalNotificationReference14 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct OriginalNotificationReference14 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Acct", skip_serializing_if = "Option::is_none") )]
	pub acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctOwnr", skip_serializing_if = "Option::is_none") )]
	pub acct_ownr: Option<Party50Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctSvcr", skip_serializing_if = "Option::is_none") )]
	pub acct_svcr: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RltdAcct", skip_serializing_if = "Option::is_none") )]
	pub rltd_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlAmt", skip_serializing_if = "Option::is_none") )]
	pub ttl_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XpctdValDt", skip_serializing_if = "Option::is_none") )]
	pub xpctd_val_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dbtr", skip_serializing_if = "Option::is_none") )]
	pub dbtr: Option<Party50Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtrAgt", skip_serializing_if = "Option::is_none") )]
	pub dbtr_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrmyAgt", skip_serializing_if = "Option::is_none") )]
	pub intrmy_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlItm") )]
	pub orgnl_itm: Vec<OriginalItem8>,
}

impl OriginalNotificationReference14 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.acct { val.validate()? }
		if let Some(ref val) = self.acct_ownr { val.validate()? }
		if let Some(ref val) = self.acct_svcr { val.validate()? }
		if let Some(ref val) = self.rltd_acct { val.validate()? }
		if let Some(ref val) = self.ttl_amt { val.validate()? }
		if let Some(ref val) = self.dbtr { val.validate()? }
		if let Some(ref val) = self.dbtr_agt { val.validate()? }
		if let Some(ref val) = self.intrmy_agt { val.validate()? }
		for item in &self.orgnl_itm { item.validate()? }
		Ok(())
	}
}


// OriginalPaymentInstruction48 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct OriginalPaymentInstruction48 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlPmtInfCxlId", skip_serializing_if = "Option::is_none") )]
	pub orgnl_pmt_inf_cxl_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RslvdCase", skip_serializing_if = "Option::is_none") )]
	pub rslvd_case: Option<Case6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlPmtInfId") )]
	pub orgnl_pmt_inf_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlGrpInf", skip_serializing_if = "Option::is_none") )]
	pub orgnl_grp_inf: Option<OriginalGroupInformation29>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlNbOfTxs", skip_serializing_if = "Option::is_none") )]
	pub orgnl_nb_of_txs: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlCtrlSum", skip_serializing_if = "Option::is_none") )]
	pub orgnl_ctrl_sum: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtInfCxlSts", skip_serializing_if = "Option::is_none") )]
	pub pmt_inf_cxl_sts: Option<GroupCancellationStatus1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CxlStsRsnInf", skip_serializing_if = "Option::is_none") )]
	pub cxl_sts_rsn_inf: Option<Vec<CancellationStatusReason5>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfTxsPerCxlSts", skip_serializing_if = "Option::is_none") )]
	pub nb_of_txs_per_cxl_sts: Option<Vec<NumberOfCancellationsPerStatus1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxInfAndSts", skip_serializing_if = "Option::is_none") )]
	pub tx_inf_and_sts: Option<Vec<PaymentTransaction153>>,
}

impl OriginalPaymentInstruction48 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.orgnl_pmt_inf_cxl_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_pmt_inf_cxl_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_pmt_inf_cxl_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.rslvd_case { val.validate()? }
		if self.orgnl_pmt_inf_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "orgnl_pmt_inf_id is shorter than the minimum length of 1".to_string()));
		}
		if self.orgnl_pmt_inf_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "orgnl_pmt_inf_id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.orgnl_grp_inf { val.validate()? }
		if let Some(ref val) = self.orgnl_nb_of_txs {
			let pattern = Regex::new("[0-9]{1,15}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "orgnl_nb_of_txs does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.pmt_inf_cxl_sts { val.validate()? }
		if let Some(ref vec) = self.cxl_sts_rsn_inf { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.nb_of_txs_per_cxl_sts { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.tx_inf_and_sts { for item in vec { item.validate()? } }
		Ok(())
	}
}


// OriginalPaymentInstruction49 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct OriginalPaymentInstruction49 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtCxlId", skip_serializing_if = "Option::is_none") )]
	pub pmt_cxl_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Case", skip_serializing_if = "Option::is_none") )]
	pub case: Option<Case6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlPmtInfId") )]
	pub orgnl_pmt_inf_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlGrpInf", skip_serializing_if = "Option::is_none") )]
	pub orgnl_grp_inf: Option<OriginalGroupInformation29>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfTxs", skip_serializing_if = "Option::is_none") )]
	pub nb_of_txs: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrlSum", skip_serializing_if = "Option::is_none") )]
	pub ctrl_sum: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtInfCxl", skip_serializing_if = "Option::is_none") )]
	pub pmt_inf_cxl: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CxlRsnInf", skip_serializing_if = "Option::is_none") )]
	pub cxl_rsn_inf: Option<Vec<PaymentCancellationReason6>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxInf", skip_serializing_if = "Option::is_none") )]
	pub tx_inf: Option<Vec<PaymentTransaction154>>,
}

impl OriginalPaymentInstruction49 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.pmt_cxl_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "pmt_cxl_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "pmt_cxl_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.case { val.validate()? }
		if self.orgnl_pmt_inf_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "orgnl_pmt_inf_id is shorter than the minimum length of 1".to_string()));
		}
		if self.orgnl_pmt_inf_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "orgnl_pmt_inf_id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.orgnl_grp_inf { val.validate()? }
		if let Some(ref val) = self.nb_of_txs {
			let pattern = Regex::new("[0-9]{1,15}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "nb_of_txs does not match the required pattern".to_string()));
			}
		}
		if let Some(ref vec) = self.cxl_rsn_inf { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.tx_inf { for item in vec { item.validate()? } }
		Ok(())
	}
}


// OriginalTransactionReference35 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct OriginalTransactionReference35 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrBkSttlmAmt", skip_serializing_if = "Option::is_none") )]
	pub intr_bk_sttlm_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt", skip_serializing_if = "Option::is_none") )]
	pub amt: Option<AmountType4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrBkSttlmDt", skip_serializing_if = "Option::is_none") )]
	pub intr_bk_sttlm_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReqdColltnDt", skip_serializing_if = "Option::is_none") )]
	pub reqd_colltn_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReqdExctnDt", skip_serializing_if = "Option::is_none") )]
	pub reqd_exctn_dt: Option<DateAndDateTime2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtrSchmeId", skip_serializing_if = "Option::is_none") )]
	pub cdtr_schme_id: Option<PartyIdentification135>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttlmInf", skip_serializing_if = "Option::is_none") )]
	pub sttlm_inf: Option<SettlementInstruction11>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtTpInf", skip_serializing_if = "Option::is_none") )]
	pub pmt_tp_inf: Option<PaymentTypeInformation27>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtMtd", skip_serializing_if = "Option::is_none") )]
	pub pmt_mtd: Option<PaymentMethod4Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MndtRltdInf", skip_serializing_if = "Option::is_none") )]
	pub mndt_rltd_inf: Option<MandateRelatedData2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RmtInf", skip_serializing_if = "Option::is_none") )]
	pub rmt_inf: Option<RemittanceInformation21>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UltmtDbtr", skip_serializing_if = "Option::is_none") )]
	pub ultmt_dbtr: Option<Party40Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dbtr", skip_serializing_if = "Option::is_none") )]
	pub dbtr: Option<Party40Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtrAcct", skip_serializing_if = "Option::is_none") )]
	pub dbtr_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtrAgt", skip_serializing_if = "Option::is_none") )]
	pub dbtr_agt: Option<BranchAndFinancialInstitutionIdentification6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtrAgtAcct", skip_serializing_if = "Option::is_none") )]
	pub dbtr_agt_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtrAgt", skip_serializing_if = "Option::is_none") )]
	pub cdtr_agt: Option<BranchAndFinancialInstitutionIdentification6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtrAgtAcct", skip_serializing_if = "Option::is_none") )]
	pub cdtr_agt_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cdtr", skip_serializing_if = "Option::is_none") )]
	pub cdtr: Option<Party40Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtrAcct", skip_serializing_if = "Option::is_none") )]
	pub cdtr_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UltmtCdtr", skip_serializing_if = "Option::is_none") )]
	pub ultmt_cdtr: Option<Party40Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Purp", skip_serializing_if = "Option::is_none") )]
	pub purp: Option<Purpose2Choice>,
}

impl OriginalTransactionReference35 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.intr_bk_sttlm_amt { val.validate()? }
		if let Some(ref val) = self.amt { val.validate()? }
		if let Some(ref val) = self.reqd_exctn_dt { val.validate()? }
		if let Some(ref val) = self.cdtr_schme_id { val.validate()? }
		if let Some(ref val) = self.sttlm_inf { val.validate()? }
		if let Some(ref val) = self.pmt_tp_inf { val.validate()? }
		if let Some(ref val) = self.pmt_mtd { val.validate()? }
		if let Some(ref val) = self.mndt_rltd_inf { val.validate()? }
		if let Some(ref val) = self.rmt_inf { val.validate()? }
		if let Some(ref val) = self.ultmt_dbtr { val.validate()? }
		if let Some(ref val) = self.dbtr { val.validate()? }
		if let Some(ref val) = self.dbtr_acct { val.validate()? }
		if let Some(ref val) = self.dbtr_agt { val.validate()? }
		if let Some(ref val) = self.dbtr_agt_acct { val.validate()? }
		if let Some(ref val) = self.cdtr_agt { val.validate()? }
		if let Some(ref val) = self.cdtr_agt_acct { val.validate()? }
		if let Some(ref val) = self.cdtr { val.validate()? }
		if let Some(ref val) = self.cdtr_acct { val.validate()? }
		if let Some(ref val) = self.ultmt_cdtr { val.validate()? }
		if let Some(ref val) = self.purp { val.validate()? }
		Ok(())
	}
}


// OriginalTransactionReference42 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct OriginalTransactionReference42 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrBkSttlmAmt", skip_serializing_if = "Option::is_none") )]
	pub intr_bk_sttlm_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt", skip_serializing_if = "Option::is_none") )]
	pub amt: Option<AmountType4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrBkSttlmDt", skip_serializing_if = "Option::is_none") )]
	pub intr_bk_sttlm_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReqdColltnDt", skip_serializing_if = "Option::is_none") )]
	pub reqd_colltn_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReqdExctnDt", skip_serializing_if = "Option::is_none") )]
	pub reqd_exctn_dt: Option<DateAndDateTime2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtrSchmeId", skip_serializing_if = "Option::is_none") )]
	pub cdtr_schme_id: Option<PartyIdentification272>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttlmInf", skip_serializing_if = "Option::is_none") )]
	pub sttlm_inf: Option<SettlementInstruction15>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtTpInf", skip_serializing_if = "Option::is_none") )]
	pub pmt_tp_inf: Option<PaymentTypeInformation27>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtMtd", skip_serializing_if = "Option::is_none") )]
	pub pmt_mtd: Option<PaymentMethod4Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MndtRltdInf", skip_serializing_if = "Option::is_none") )]
	pub mndt_rltd_inf: Option<MandateRelatedData3Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RmtInf", skip_serializing_if = "Option::is_none") )]
	pub rmt_inf: Option<RemittanceInformation22>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UltmtDbtr", skip_serializing_if = "Option::is_none") )]
	pub ultmt_dbtr: Option<Party50Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dbtr", skip_serializing_if = "Option::is_none") )]
	pub dbtr: Option<Party50Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtrAcct", skip_serializing_if = "Option::is_none") )]
	pub dbtr_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtrAgt", skip_serializing_if = "Option::is_none") )]
	pub dbtr_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtrAgtAcct", skip_serializing_if = "Option::is_none") )]
	pub dbtr_agt_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtrAgt", skip_serializing_if = "Option::is_none") )]
	pub cdtr_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtrAgtAcct", skip_serializing_if = "Option::is_none") )]
	pub cdtr_agt_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cdtr", skip_serializing_if = "Option::is_none") )]
	pub cdtr: Option<Party50Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtrAcct", skip_serializing_if = "Option::is_none") )]
	pub cdtr_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UltmtCdtr", skip_serializing_if = "Option::is_none") )]
	pub ultmt_cdtr: Option<Party50Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Purp", skip_serializing_if = "Option::is_none") )]
	pub purp: Option<Purpose2Choice>,
}

impl OriginalTransactionReference42 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.intr_bk_sttlm_amt { val.validate()? }
		if let Some(ref val) = self.amt { val.validate()? }
		if let Some(ref val) = self.reqd_exctn_dt { val.validate()? }
		if let Some(ref val) = self.cdtr_schme_id { val.validate()? }
		if let Some(ref val) = self.sttlm_inf { val.validate()? }
		if let Some(ref val) = self.pmt_tp_inf { val.validate()? }
		if let Some(ref val) = self.pmt_mtd { val.validate()? }
		if let Some(ref val) = self.mndt_rltd_inf { val.validate()? }
		if let Some(ref val) = self.rmt_inf { val.validate()? }
		if let Some(ref val) = self.ultmt_dbtr { val.validate()? }
		if let Some(ref val) = self.dbtr { val.validate()? }
		if let Some(ref val) = self.dbtr_acct { val.validate()? }
		if let Some(ref val) = self.dbtr_agt { val.validate()? }
		if let Some(ref val) = self.dbtr_agt_acct { val.validate()? }
		if let Some(ref val) = self.cdtr_agt { val.validate()? }
		if let Some(ref val) = self.cdtr_agt_acct { val.validate()? }
		if let Some(ref val) = self.cdtr { val.validate()? }
		if let Some(ref val) = self.cdtr_acct { val.validate()? }
		if let Some(ref val) = self.ultmt_cdtr { val.validate()? }
		if let Some(ref val) = self.purp { val.validate()? }
		Ok(())
	}
}


// OtherContact1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct OtherContact1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChanlTp") )]
	pub chanl_tp: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<String>,
}

impl OtherContact1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.chanl_tp.chars().count() < 1 {
			return Err(ValidationError::new(1001, "chanl_tp is shorter than the minimum length of 1".to_string()));
		}
		if self.chanl_tp.chars().count() > 4 {
			return Err(ValidationError::new(1002, "chanl_tp exceeds the maximum length of 4".to_string()));
		}
		if let Some(ref val) = self.id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 128 {
				return Err(ValidationError::new(1002, "id exceeds the maximum length of 128".to_string()));
			}
		}
		Ok(())
	}
}


// OtherIdentification1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct OtherIdentification1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sfx", skip_serializing_if = "Option::is_none") )]
	pub sfx: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: IdentificationSource3Choice,
}

impl OtherIdentification1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.sfx {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "sfx is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 16 {
				return Err(ValidationError::new(1002, "sfx exceeds the maximum length of 16".to_string()));
			}
		}
		self.tp.validate()?;
		Ok(())
	}
}


// OtherIdentification4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct OtherIdentification4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: IdentificationSource5Choice,
}

impl OtherIdentification4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
		}
		self.tp.validate()?;
		Ok(())
	}
}


// POIComponentType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum POIComponentType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "SOFT") )]
	CodeSOFT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EMVK") )]
	CodeEMVK,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EMVO") )]
	CodeEMVO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MRIT") )]
	CodeMRIT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CHIT") )]
	CodeCHIT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SECM") )]
	CodeSECM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PEDV") )]
	CodePEDV,
}

impl POIComponentType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// Pagination ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Pagination {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PgNb") )]
	pub pg_nb: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LastPgInd") )]
	pub last_pg_ind: bool,
}

impl Pagination {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[0-9]{1,5}").unwrap();
		if !pattern.is_match(&self.pg_nb) {
			return Err(ValidationError::new(1005, "pg_nb does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// Pagination1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Pagination1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PgNb") )]
	pub pg_nb: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LastPgInd") )]
	pub last_pg_ind: bool,
}

impl Pagination1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[0-9]{1,5}").unwrap();
		if !pattern.is_match(&self.pg_nb) {
			return Err(ValidationError::new(1005, "pg_nb does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// ParentCashAccount5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ParentCashAccount5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Lvl", skip_serializing_if = "Option::is_none") )]
	pub lvl: Option<AccountLevel1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: CashAccount40,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Svcr", skip_serializing_if = "Option::is_none") )]
	pub svcr: Option<BranchAndFinancialInstitutionIdentification8>,
}

impl ParentCashAccount5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.lvl { val.validate()? }
		self.id.validate()?;
		if let Some(ref val) = self.svcr { val.validate()? }
		Ok(())
	}
}


// PartialSettlement2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum PartialSettlement2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "PAIN") )]
	CodePAIN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PARC") )]
	CodePARC,
}

impl PartialSettlement2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// Party38Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Party38Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgId", skip_serializing_if = "Option::is_none") )]
	pub org_id: Option<OrganisationIdentification29>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrvtId", skip_serializing_if = "Option::is_none") )]
	pub prvt_id: Option<PersonIdentification13>,
}

impl Party38Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.org_id { val.validate()? }
		if let Some(ref val) = self.prvt_id { val.validate()? }
		Ok(())
	}
}


// Party40Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Party40Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pty", skip_serializing_if = "Option::is_none") )]
	pub pty: Option<PartyIdentification135>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Agt", skip_serializing_if = "Option::is_none") )]
	pub agt: Option<BranchAndFinancialInstitutionIdentification6>,
}

impl Party40Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.pty { val.validate()? }
		if let Some(ref val) = self.agt { val.validate()? }
		Ok(())
	}
}


// Party50Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Party50Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pty", skip_serializing_if = "Option::is_none") )]
	pub pty: Option<PartyIdentification272>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Agt", skip_serializing_if = "Option::is_none") )]
	pub agt: Option<BranchAndFinancialInstitutionIdentification8>,
}

impl Party50Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.pty { val.validate()? }
		if let Some(ref val) = self.agt { val.validate()? }
		Ok(())
	}
}


// Party52Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Party52Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgId", skip_serializing_if = "Option::is_none") )]
	pub org_id: Option<OrganisationIdentification39>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrvtId", skip_serializing_if = "Option::is_none") )]
	pub prvt_id: Option<PersonIdentification18>,
}

impl Party52Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.org_id { val.validate()? }
		if let Some(ref val) = self.prvt_id { val.validate()? }
		Ok(())
	}
}


// Party56Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Party56Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgId", skip_serializing_if = "Option::is_none") )]
	pub org_id: Option<OrganisationIdentification39>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FIId", skip_serializing_if = "Option::is_none") )]
	pub fi_id: Option<FinancialInstitutionIdentification19>,
}

impl Party56Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.org_id { val.validate()? }
		if let Some(ref val) = self.fi_id { val.validate()? }
		Ok(())
	}
}


// PartyAndSignature3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PartyAndSignature3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pty") )]
	pub pty: PartyIdentification135,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sgntr") )]
	pub sgntr: SkipPayload,
}

impl PartyAndSignature3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.pty.validate()?;
		self.sgntr.validate()?;
		Ok(())
	}
}


// PartyIdentification120Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PartyIdentification120Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AnyBIC", skip_serializing_if = "Option::is_none") )]
	pub any_bic: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrtryId", skip_serializing_if = "Option::is_none") )]
	pub prtry_id: Option<GenericIdentification36>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NmAndAdr", skip_serializing_if = "Option::is_none") )]
	pub nm_and_adr: Option<NameAndAddress5>,
}

impl PartyIdentification120Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.any_bic {
			let pattern = Regex::new("[A-Z0-9]{4,4}[A-Z]{2,2}[A-Z0-9]{2,2}([A-Z0-9]{3,3}){0,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "any_bic does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.prtry_id { val.validate()? }
		if let Some(ref val) = self.nm_and_adr { val.validate()? }
		Ok(())
	}
}


// PartyIdentification127Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PartyIdentification127Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AnyBIC", skip_serializing_if = "Option::is_none") )]
	pub any_bic: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrtryId", skip_serializing_if = "Option::is_none") )]
	pub prtry_id: Option<GenericIdentification36>,
}

impl PartyIdentification127Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.any_bic {
			let pattern = Regex::new("[A-Z0-9]{4,4}[A-Z]{2,2}[A-Z0-9]{2,2}([A-Z0-9]{3,3}){0,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "any_bic does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.prtry_id { val.validate()? }
		Ok(())
	}
}


// PartyIdentification135 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PartyIdentification135 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm", skip_serializing_if = "Option::is_none") )]
	pub nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstlAdr", skip_serializing_if = "Option::is_none") )]
	pub pstl_adr: Option<PostalAddress24>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<Party38Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtryOfRes", skip_serializing_if = "Option::is_none") )]
	pub ctry_of_res: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtctDtls", skip_serializing_if = "Option::is_none") )]
	pub ctct_dtls: Option<Contact4>,
}

impl PartyIdentification135 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "nm exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.pstl_adr { val.validate()? }
		if let Some(ref val) = self.id { val.validate()? }
		if let Some(ref val) = self.ctry_of_res {
			let pattern = Regex::new("[A-Z]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ctry_of_res does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.ctct_dtls { val.validate()? }
		Ok(())
	}
}


// PartyIdentification136 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PartyIdentification136 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: PartyIdentification120Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LEI", skip_serializing_if = "Option::is_none") )]
	pub lei: Option<String>,
}

impl PartyIdentification136 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.id.validate()?;
		if let Some(ref val) = self.lei {
			let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "lei does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// PartyIdentification242Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PartyIdentification242Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NmAndAdr", skip_serializing_if = "Option::is_none") )]
	pub nm_and_adr: Option<NameAndAddress8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AnyBIC", skip_serializing_if = "Option::is_none") )]
	pub any_bic: Option<PartyIdentification265>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PtyId", skip_serializing_if = "Option::is_none") )]
	pub pty_id: Option<PartyIdentification266>,
}

impl PartyIdentification242Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.nm_and_adr { val.validate()? }
		if let Some(ref val) = self.any_bic { val.validate()? }
		if let Some(ref val) = self.pty_id { val.validate()? }
		Ok(())
	}
}


// PartyIdentification265 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PartyIdentification265 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AnyBIC") )]
	pub any_bic: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AltrntvIdr", skip_serializing_if = "Option::is_none") )]
	pub altrntv_idr: Option<Vec<String>>,
}

impl PartyIdentification265 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z0-9]{4,4}[A-Z]{2,2}[A-Z0-9]{2,2}([A-Z0-9]{3,3}){0,1}").unwrap();
		if !pattern.is_match(&self.any_bic) {
			return Err(ValidationError::new(1005, "any_bic does not match the required pattern".to_string()));
		}
		if let Some(ref vec) = self.altrntv_idr {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "altrntv_idr is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 35 {
					return Err(ValidationError::new(1002, "altrntv_idr exceeds the maximum length of 35".to_string()));
				}
			}
		}
		Ok(())
	}
}


// PartyIdentification266 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PartyIdentification266 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PtyNm", skip_serializing_if = "Option::is_none") )]
	pub pty_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AnyBIC", skip_serializing_if = "Option::is_none") )]
	pub any_bic: Option<PartyIdentification265>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctNb", skip_serializing_if = "Option::is_none") )]
	pub acct_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Adr", skip_serializing_if = "Option::is_none") )]
	pub adr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrSysId", skip_serializing_if = "Option::is_none") )]
	pub clr_sys_id: Option<ClearingSystemIdentification2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LglNttyIdr", skip_serializing_if = "Option::is_none") )]
	pub lgl_ntty_idr: Option<String>,
}

impl PartyIdentification266 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.pty_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "pty_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 34 {
				return Err(ValidationError::new(1002, "pty_nm exceeds the maximum length of 34".to_string()));
			}
		}
		if let Some(ref val) = self.any_bic { val.validate()? }
		if let Some(ref val) = self.acct_nb {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "acct_nb is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 34 {
				return Err(ValidationError::new(1002, "acct_nb exceeds the maximum length of 34".to_string()));
			}
		}
		if let Some(ref val) = self.adr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "adr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 105 {
				return Err(ValidationError::new(1002, "adr exceeds the maximum length of 105".to_string()));
			}
		}
		if let Some(ref val) = self.clr_sys_id { val.validate()? }
		if let Some(ref val) = self.lgl_ntty_idr {
			let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "lgl_ntty_idr does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// PartyIdentification272 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PartyIdentification272 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm", skip_serializing_if = "Option::is_none") )]
	pub nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstlAdr", skip_serializing_if = "Option::is_none") )]
	pub pstl_adr: Option<PostalAddress27>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<Party52Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtryOfRes", skip_serializing_if = "Option::is_none") )]
	pub ctry_of_res: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtctDtls", skip_serializing_if = "Option::is_none") )]
	pub ctct_dtls: Option<Contact13>,
}

impl PartyIdentification272 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "nm exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.pstl_adr { val.validate()? }
		if let Some(ref val) = self.id { val.validate()? }
		if let Some(ref val) = self.ctry_of_res {
			let pattern = Regex::new("[A-Z]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ctry_of_res does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.ctct_dtls { val.validate()? }
		Ok(())
	}
}


// PartyIdentification273 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PartyIdentification273 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm") )]
	pub nm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LglNm", skip_serializing_if = "Option::is_none") )]
	pub lgl_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstlAdr", skip_serializing_if = "Option::is_none") )]
	pub pstl_adr: Option<PostalAddress27>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: Party56Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtryOfRes", skip_serializing_if = "Option::is_none") )]
	pub ctry_of_res: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtctDtls", skip_serializing_if = "Option::is_none") )]
	pub ctct_dtls: Option<Contact13>,
}

impl PartyIdentification273 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.nm.chars().count() < 1 {
			return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
		}
		if self.nm.chars().count() > 140 {
			return Err(ValidationError::new(1002, "nm exceeds the maximum length of 140".to_string()));
		}
		if let Some(ref val) = self.lgl_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "lgl_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "lgl_nm exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.pstl_adr { val.validate()? }
		self.id.validate()?;
		if let Some(ref val) = self.ctry_of_res {
			let pattern = Regex::new("[A-Z]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ctry_of_res does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.ctct_dtls { val.validate()? }
		Ok(())
	}
}


// PartyIdentification2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PartyIdentification2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BICOrBEI", skip_serializing_if = "Option::is_none") )]
	pub bic_or_bei: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrtryId", skip_serializing_if = "Option::is_none") )]
	pub prtry_id: Option<GenericIdentification1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NmAndAdr", skip_serializing_if = "Option::is_none") )]
	pub nm_and_adr: Option<NameAndAddress5>,
}

impl PartyIdentification2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.bic_or_bei {
			let pattern = Regex::new("[A-Z]{6,6}[A-Z2-9][A-NP-Z0-9]([A-Z0-9]{3,3}){0,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "bic_or_bei does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.prtry_id { val.validate()? }
		if let Some(ref val) = self.nm_and_adr { val.validate()? }
		Ok(())
	}
}


// PartyIdentification44 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PartyIdentification44 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AnyBIC") )]
	pub any_bic: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AltrntvIdr", skip_serializing_if = "Option::is_none") )]
	pub altrntv_idr: Option<Vec<String>>,
}

impl PartyIdentification44 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z]{6,6}[A-Z2-9][A-NP-Z0-9]([A-Z0-9]{3,3}){0,1}").unwrap();
		if !pattern.is_match(&self.any_bic) {
			return Err(ValidationError::new(1005, "any_bic does not match the required pattern".to_string()));
		}
		if let Some(ref vec) = self.altrntv_idr {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "altrntv_idr is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 35 {
					return Err(ValidationError::new(1002, "altrntv_idr exceeds the maximum length of 35".to_string()));
				}
			}
		}
		Ok(())
	}
}


// PartyIdentification59 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PartyIdentification59 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PtyNm", skip_serializing_if = "Option::is_none") )]
	pub pty_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AnyBIC", skip_serializing_if = "Option::is_none") )]
	pub any_bic: Option<PartyIdentification44>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctNb", skip_serializing_if = "Option::is_none") )]
	pub acct_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Adr", skip_serializing_if = "Option::is_none") )]
	pub adr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrSysId", skip_serializing_if = "Option::is_none") )]
	pub clr_sys_id: Option<ClearingSystemIdentification2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LglNttyIdr", skip_serializing_if = "Option::is_none") )]
	pub lgl_ntty_idr: Option<String>,
}

impl PartyIdentification59 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.pty_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "pty_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 34 {
				return Err(ValidationError::new(1002, "pty_nm exceeds the maximum length of 34".to_string()));
			}
		}
		if let Some(ref val) = self.any_bic { val.validate()? }
		if let Some(ref val) = self.acct_nb {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "acct_nb is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 34 {
				return Err(ValidationError::new(1002, "acct_nb exceeds the maximum length of 34".to_string()));
			}
		}
		if let Some(ref val) = self.adr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "adr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 105 {
				return Err(ValidationError::new(1002, "adr exceeds the maximum length of 105".to_string()));
			}
		}
		if let Some(ref val) = self.clr_sys_id { val.validate()? }
		if let Some(ref val) = self.lgl_ntty_idr {
			let pattern = Regex::new("[A-Z0-9]{18,18}[0-9]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "lgl_ntty_idr does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// PartyIdentification73Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PartyIdentification73Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NmAndAdr", skip_serializing_if = "Option::is_none") )]
	pub nm_and_adr: Option<NameAndAddress8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AnyBIC", skip_serializing_if = "Option::is_none") )]
	pub any_bic: Option<PartyIdentification44>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PtyId", skip_serializing_if = "Option::is_none") )]
	pub pty_id: Option<PartyIdentification59>,
}

impl PartyIdentification73Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.nm_and_adr { val.validate()? }
		if let Some(ref val) = self.any_bic { val.validate()? }
		if let Some(ref val) = self.pty_id { val.validate()? }
		Ok(())
	}
}


// PartyType3Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum PartyType3Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "OPOI") )]
	CodeOPOI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MERC") )]
	CodeMERC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ACCP") )]
	CodeACCP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ITAG") )]
	CodeITAG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ACQR") )]
	CodeACQR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CISS") )]
	CodeCISS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DLIS") )]
	CodeDLIS,
}

impl PartyType3Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// PartyType4Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum PartyType4Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "MERC") )]
	CodeMERC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ACCP") )]
	CodeACCP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ITAG") )]
	CodeITAG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ACQR") )]
	CodeACQR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CISS") )]
	CodeCISS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TAXH") )]
	CodeTAXH,
}

impl PartyType4Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// PayInCallItem ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PayInCallItem {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveOrHistoricCurrencyAndAmount,
}

impl PayInCallItem {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.amt.validate()?;
		Ok(())
	}
}


// PayInFactors1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PayInFactors1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AggtShrtPosLmt") )]
	pub aggt_shrt_pos_lmt: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CcyFctrs") )]
	pub ccy_fctrs: Vec<CurrencyFactors1>,
}

impl PayInFactors1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.aggt_shrt_pos_lmt.validate()?;
		for item in &self.ccy_fctrs { item.validate()? }
		Ok(())
	}
}


// PayInScheduleItems1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PayInScheduleItems1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ddln") )]
	pub ddln: String,
}

impl PayInScheduleItems1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.amt.validate()?;
		Ok(())
	}
}


// PaymentCancellationReason6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PaymentCancellationReason6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Orgtr", skip_serializing_if = "Option::is_none") )]
	pub orgtr: Option<PartyIdentification272>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn", skip_serializing_if = "Option::is_none") )]
	pub rsn: Option<CancellationReason33Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_inf: Option<Vec<String>>,
}

impl PaymentCancellationReason6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.orgtr { val.validate()? }
		if let Some(ref val) = self.rsn { val.validate()? }
		if let Some(ref vec) = self.addtl_inf {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "addtl_inf is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 105 {
					return Err(ValidationError::new(1002, "addtl_inf exceeds the maximum length of 105".to_string()));
				}
			}
		}
		Ok(())
	}
}


// PaymentCard4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PaymentCard4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PlainCardData", skip_serializing_if = "Option::is_none") )]
	pub plain_card_data: Option<PlainCardData1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CardCtryCd", skip_serializing_if = "Option::is_none") )]
	pub card_ctry_cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CardBrnd", skip_serializing_if = "Option::is_none") )]
	pub card_brnd: Option<GenericIdentification1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlCardData", skip_serializing_if = "Option::is_none") )]
	pub addtl_card_data: Option<String>,
}

impl PaymentCard4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.plain_card_data { val.validate()? }
		if let Some(ref val) = self.card_ctry_cd {
			let pattern = Regex::new("[0-9]{3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "card_ctry_cd does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.card_brnd { val.validate()? }
		if let Some(ref val) = self.addtl_card_data {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_card_data is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 70 {
				return Err(ValidationError::new(1002, "addtl_card_data exceeds the maximum length of 70".to_string()));
			}
		}
		Ok(())
	}
}


// PaymentCommon6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PaymentCommon6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtFr", skip_serializing_if = "Option::is_none") )]
	pub pmt_fr: Option<System3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtTo", skip_serializing_if = "Option::is_none") )]
	pub pmt_to: Option<System3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CmonSts", skip_serializing_if = "Option::is_none") )]
	pub cmon_sts: Option<Vec<PaymentStatus6>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReqdExctnDt", skip_serializing_if = "Option::is_none") )]
	pub reqd_exctn_dt: Option<DateAndDateTime2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtryDt", skip_serializing_if = "Option::is_none") )]
	pub ntry_dt: Option<DateAndDateTime2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtDbtInd", skip_serializing_if = "Option::is_none") )]
	pub cdt_dbt_ind: Option<CreditDebitCode>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtMtd", skip_serializing_if = "Option::is_none") )]
	pub pmt_mtd: Option<PaymentOrigin1Choice>,
}

impl PaymentCommon6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.pmt_fr { val.validate()? }
		if let Some(ref val) = self.pmt_to { val.validate()? }
		if let Some(ref vec) = self.cmon_sts { for item in vec { item.validate()? } }
		if let Some(ref val) = self.reqd_exctn_dt { val.validate()? }
		if let Some(ref val) = self.ntry_dt { val.validate()? }
		if let Some(ref val) = self.cdt_dbt_ind { val.validate()? }
		if let Some(ref val) = self.pmt_mtd { val.validate()? }
		Ok(())
	}
}


// PaymentComplementaryInformation11 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PaymentComplementaryInformation11 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstrId", skip_serializing_if = "Option::is_none") )]
	pub instr_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EndToEndId", skip_serializing_if = "Option::is_none") )]
	pub end_to_end_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxId", skip_serializing_if = "Option::is_none") )]
	pub tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtTpInf", skip_serializing_if = "Option::is_none") )]
	pub pmt_tp_inf: Option<PaymentTypeInformation27>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReqdExctnDt", skip_serializing_if = "Option::is_none") )]
	pub reqd_exctn_dt: Option<DateAndDateTime2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReqdColltnDt", skip_serializing_if = "Option::is_none") )]
	pub reqd_colltn_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrBkSttlmDt", skip_serializing_if = "Option::is_none") )]
	pub intr_bk_sttlm_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt", skip_serializing_if = "Option::is_none") )]
	pub amt: Option<AmountType4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrBkSttlmAmt", skip_serializing_if = "Option::is_none") )]
	pub intr_bk_sttlm_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgBr", skip_serializing_if = "Option::is_none") )]
	pub chrg_br: Option<ChargeBearerType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UltmtDbtr", skip_serializing_if = "Option::is_none") )]
	pub ultmt_dbtr: Option<PartyIdentification272>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dbtr", skip_serializing_if = "Option::is_none") )]
	pub dbtr: Option<PartyIdentification272>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtrAcct", skip_serializing_if = "Option::is_none") )]
	pub dbtr_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtrAgt", skip_serializing_if = "Option::is_none") )]
	pub dbtr_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtrAgtAcct", skip_serializing_if = "Option::is_none") )]
	pub dbtr_agt_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttlmInf", skip_serializing_if = "Option::is_none") )]
	pub sttlm_inf: Option<SettlementInstruction15>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrmyAgt1", skip_serializing_if = "Option::is_none") )]
	pub intrmy_agt1: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrmyAgt1Acct", skip_serializing_if = "Option::is_none") )]
	pub intrmy_agt1_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrmyAgt2", skip_serializing_if = "Option::is_none") )]
	pub intrmy_agt2: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrmyAgt2Acct", skip_serializing_if = "Option::is_none") )]
	pub intrmy_agt2_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrmyAgt3", skip_serializing_if = "Option::is_none") )]
	pub intrmy_agt3: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrmyAgt3Acct", skip_serializing_if = "Option::is_none") )]
	pub intrmy_agt3_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtrAgt", skip_serializing_if = "Option::is_none") )]
	pub cdtr_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtrAgtAcct", skip_serializing_if = "Option::is_none") )]
	pub cdtr_agt_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cdtr", skip_serializing_if = "Option::is_none") )]
	pub cdtr: Option<PartyIdentification272>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtrAcct", skip_serializing_if = "Option::is_none") )]
	pub cdtr_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UltmtCdtr", skip_serializing_if = "Option::is_none") )]
	pub ultmt_cdtr: Option<PartyIdentification272>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Purp", skip_serializing_if = "Option::is_none") )]
	pub purp: Option<Purpose2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstrForDbtrAgt", skip_serializing_if = "Option::is_none") )]
	pub instr_for_dbtr_agt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrvsInstgAgt1", skip_serializing_if = "Option::is_none") )]
	pub prvs_instg_agt1: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrvsInstgAgt1Acct", skip_serializing_if = "Option::is_none") )]
	pub prvs_instg_agt1_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrvsInstgAgt2", skip_serializing_if = "Option::is_none") )]
	pub prvs_instg_agt2: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrvsInstgAgt2Acct", skip_serializing_if = "Option::is_none") )]
	pub prvs_instg_agt2_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrvsInstgAgt3", skip_serializing_if = "Option::is_none") )]
	pub prvs_instg_agt3: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrvsInstgAgt3Acct", skip_serializing_if = "Option::is_none") )]
	pub prvs_instg_agt3_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstrForNxtAgt", skip_serializing_if = "Option::is_none") )]
	pub instr_for_nxt_agt: Option<Vec<InstructionForNextAgent1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstrForCdtrAgt", skip_serializing_if = "Option::is_none") )]
	pub instr_for_cdtr_agt: Option<Vec<InstructionForCreditorAgent3>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RltdRmtInf", skip_serializing_if = "Option::is_none") )]
	pub rltd_rmt_inf: Option<Vec<RemittanceLocation8>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RmtInf", skip_serializing_if = "Option::is_none") )]
	pub rmt_inf: Option<RemittanceInformation22>,
}

impl PaymentComplementaryInformation11 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.instr_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "instr_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "instr_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.end_to_end_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "end_to_end_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "end_to_end_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.pmt_tp_inf { val.validate()? }
		if let Some(ref val) = self.reqd_exctn_dt { val.validate()? }
		if let Some(ref val) = self.amt { val.validate()? }
		if let Some(ref val) = self.intr_bk_sttlm_amt { val.validate()? }
		if let Some(ref val) = self.chrg_br { val.validate()? }
		if let Some(ref val) = self.ultmt_dbtr { val.validate()? }
		if let Some(ref val) = self.dbtr { val.validate()? }
		if let Some(ref val) = self.dbtr_acct { val.validate()? }
		if let Some(ref val) = self.dbtr_agt { val.validate()? }
		if let Some(ref val) = self.dbtr_agt_acct { val.validate()? }
		if let Some(ref val) = self.sttlm_inf { val.validate()? }
		if let Some(ref val) = self.intrmy_agt1 { val.validate()? }
		if let Some(ref val) = self.intrmy_agt1_acct { val.validate()? }
		if let Some(ref val) = self.intrmy_agt2 { val.validate()? }
		if let Some(ref val) = self.intrmy_agt2_acct { val.validate()? }
		if let Some(ref val) = self.intrmy_agt3 { val.validate()? }
		if let Some(ref val) = self.intrmy_agt3_acct { val.validate()? }
		if let Some(ref val) = self.cdtr_agt { val.validate()? }
		if let Some(ref val) = self.cdtr_agt_acct { val.validate()? }
		if let Some(ref val) = self.cdtr { val.validate()? }
		if let Some(ref val) = self.cdtr_acct { val.validate()? }
		if let Some(ref val) = self.ultmt_cdtr { val.validate()? }
		if let Some(ref val) = self.purp { val.validate()? }
		if let Some(ref val) = self.instr_for_dbtr_agt {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "instr_for_dbtr_agt is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "instr_for_dbtr_agt exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.prvs_instg_agt1 { val.validate()? }
		if let Some(ref val) = self.prvs_instg_agt1_acct { val.validate()? }
		if let Some(ref val) = self.prvs_instg_agt2 { val.validate()? }
		if let Some(ref val) = self.prvs_instg_agt2_acct { val.validate()? }
		if let Some(ref val) = self.prvs_instg_agt3 { val.validate()? }
		if let Some(ref val) = self.prvs_instg_agt3_acct { val.validate()? }
		if let Some(ref vec) = self.instr_for_nxt_agt { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.instr_for_cdtr_agt { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.rltd_rmt_inf { for item in vec { item.validate()? } }
		if let Some(ref val) = self.rmt_inf { val.validate()? }
		Ok(())
	}
}


// PaymentContext3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PaymentContext3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CardPres", skip_serializing_if = "Option::is_none") )]
	pub card_pres: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CrdhldrPres", skip_serializing_if = "Option::is_none") )]
	pub crdhldr_pres: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OnLineCntxt", skip_serializing_if = "Option::is_none") )]
	pub on_line_cntxt: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AttndncCntxt", skip_serializing_if = "Option::is_none") )]
	pub attndnc_cntxt: Option<AttendanceContext1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxEnvt", skip_serializing_if = "Option::is_none") )]
	pub tx_envt: Option<TransactionEnvironment1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxChanl", skip_serializing_if = "Option::is_none") )]
	pub tx_chanl: Option<TransactionChannel1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AttndntMsgCpbl", skip_serializing_if = "Option::is_none") )]
	pub attndnt_msg_cpbl: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AttndntLang", skip_serializing_if = "Option::is_none") )]
	pub attndnt_lang: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CardDataNtryMd") )]
	pub card_data_ntry_md: CardDataReading1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FllbckInd", skip_serializing_if = "Option::is_none") )]
	pub fllbck_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AuthntcnMtd", skip_serializing_if = "Option::is_none") )]
	pub authntcn_mtd: Option<CardholderAuthentication2>,
}

impl PaymentContext3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.attndnc_cntxt { val.validate()? }
		if let Some(ref val) = self.tx_envt { val.validate()? }
		if let Some(ref val) = self.tx_chanl { val.validate()? }
		if let Some(ref val) = self.attndnt_lang {
			let pattern = Regex::new("[a-z]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "attndnt_lang does not match the required pattern".to_string()));
			}
		}
		self.card_data_ntry_md.validate()?;
		if let Some(ref val) = self.authntcn_mtd { val.validate()? }
		Ok(())
	}
}


// PaymentIdentification8 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PaymentIdentification8 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstrId", skip_serializing_if = "Option::is_none") )]
	pub instr_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EndToEndId") )]
	pub end_to_end_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxId", skip_serializing_if = "Option::is_none") )]
	pub tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UETR", skip_serializing_if = "Option::is_none") )]
	pub uetr: Option<String>,
}

impl PaymentIdentification8 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.instr_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "instr_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "instr_id exceeds the maximum length of 35".to_string()));
			}
		}
		if self.end_to_end_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "end_to_end_id is shorter than the minimum length of 1".to_string()));
		}
		if self.end_to_end_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "end_to_end_id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.uetr {
			let pattern = Regex::new("[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "uetr does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// PaymentIdentification8Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PaymentIdentification8Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxId", skip_serializing_if = "Option::is_none") )]
	pub tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UETR", skip_serializing_if = "Option::is_none") )]
	pub uetr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "QId", skip_serializing_if = "Option::is_none") )]
	pub q_id: Option<QueueTransactionIdentification1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LngBizId", skip_serializing_if = "Option::is_none") )]
	pub lng_biz_id: Option<LongPaymentIdentification4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ShrtBizId", skip_serializing_if = "Option::is_none") )]
	pub shrt_biz_id: Option<ShortPaymentIdentification4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrtryId", skip_serializing_if = "Option::is_none") )]
	pub prtry_id: Option<String>,
}

impl PaymentIdentification8Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.uetr {
			let pattern = Regex::new("[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "uetr does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.q_id { val.validate()? }
		if let Some(ref val) = self.lng_biz_id { val.validate()? }
		if let Some(ref val) = self.shrt_biz_id { val.validate()? }
		if let Some(ref val) = self.prtry_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 70 {
				return Err(ValidationError::new(1002, "prtry_id exceeds the maximum length of 70".to_string()));
			}
		}
		Ok(())
	}
}


// PaymentInstruction13 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PaymentInstruction13 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReqdExctnDtTm", skip_serializing_if = "Option::is_none") )]
	pub reqd_exctn_dt_tm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtTp", skip_serializing_if = "Option::is_none") )]
	pub pmt_tp: Option<PaymentType4Choice>,
}

impl PaymentInstruction13 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.pmt_tp { val.validate()? }
		Ok(())
	}
}


// PaymentInstruction33 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PaymentInstruction33 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Instr", skip_serializing_if = "Option::is_none") )]
	pub instr: Option<Instruction1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<PaymentType4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prty", skip_serializing_if = "Option::is_none") )]
	pub prty: Option<Priority1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrcgVldtyTm", skip_serializing_if = "Option::is_none") )]
	pub prcg_vldty_tm: Option<DateTimePeriod1Choice>,
}

impl PaymentInstruction33 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.instr { val.validate()? }
		if let Some(ref val) = self.tp { val.validate()? }
		if let Some(ref val) = self.prty { val.validate()? }
		if let Some(ref val) = self.prcg_vldty_tm { val.validate()? }
		Ok(())
	}
}


// PaymentInstruction47 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PaymentInstruction47 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgId", skip_serializing_if = "Option::is_none") )]
	pub msg_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReqdExctnDt", skip_serializing_if = "Option::is_none") )]
	pub reqd_exctn_dt: Option<DateAndDateTime2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sts", skip_serializing_if = "Option::is_none") )]
	pub sts: Option<Vec<PaymentStatus6>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstdAmt", skip_serializing_if = "Option::is_none") )]
	pub instd_amt: Option<Amount3Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrBkSttlmAmt", skip_serializing_if = "Option::is_none") )]
	pub intr_bk_sttlm_amt: Option<Amount2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Purp", skip_serializing_if = "Option::is_none") )]
	pub purp: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtMtd", skip_serializing_if = "Option::is_none") )]
	pub pmt_mtd: Option<PaymentOrigin1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prty", skip_serializing_if = "Option::is_none") )]
	pub prty: Option<Priority1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrcgVldtyTm", skip_serializing_if = "Option::is_none") )]
	pub prcg_vldty_tm: Option<DateTimePeriod1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstrCpy", skip_serializing_if = "Option::is_none") )]
	pub instr_cpy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<PaymentType4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GnrtdOrdr", skip_serializing_if = "Option::is_none") )]
	pub gnrtd_ordr: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxId", skip_serializing_if = "Option::is_none") )]
	pub tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrBkSttlmDt", skip_serializing_if = "Option::is_none") )]
	pub intr_bk_sttlm_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EndToEndId", skip_serializing_if = "Option::is_none") )]
	pub end_to_end_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pties", skip_serializing_if = "Option::is_none") )]
	pub pties: Option<PaymentTransactionParty4>,
}

impl PaymentInstruction47 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.msg_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "msg_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "msg_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.reqd_exctn_dt { val.validate()? }
		if let Some(ref vec) = self.sts { for item in vec { item.validate()? } }
		if let Some(ref val) = self.instd_amt { val.validate()? }
		if let Some(ref val) = self.intr_bk_sttlm_amt { val.validate()? }
		if let Some(ref val) = self.purp {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "purp is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 10 {
				return Err(ValidationError::new(1002, "purp exceeds the maximum length of 10".to_string()));
			}
		}
		if let Some(ref val) = self.pmt_mtd { val.validate()? }
		if let Some(ref val) = self.prty { val.validate()? }
		if let Some(ref val) = self.prcg_vldty_tm { val.validate()? }
		if let Some(ref val) = self.instr_cpy {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "instr_cpy is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 20000 {
				return Err(ValidationError::new(1002, "instr_cpy exceeds the maximum length of 20000".to_string()));
			}
		}
		if let Some(ref val) = self.tp { val.validate()? }
		if let Some(ref val) = self.tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.end_to_end_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "end_to_end_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "end_to_end_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.pties { val.validate()? }
		Ok(())
	}
}


// PaymentInstrument1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum PaymentInstrument1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "BDT") )]
	CodeBDT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BCT") )]
	CodeBCT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CDT") )]
	CodeCDT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CCT") )]
	CodeCCT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CHK") )]
	CodeCHK,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BKT") )]
	CodeBKT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DCP") )]
	CodeDCP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CCP") )]
	CodeCCP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RTI") )]
	CodeRTI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CAN") )]
	CodeCAN,
}

impl PaymentInstrument1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// PaymentMethod4Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum PaymentMethod4Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "CHK") )]
	CodeCHK,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TRF") )]
	CodeTRF,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DD") )]
	CodeDD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TRA") )]
	CodeTRA,
}

impl PaymentMethod4Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// PaymentOrigin1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PaymentOrigin1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FINMT", skip_serializing_if = "Option::is_none") )]
	pub finmt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XMLMsgNm", skip_serializing_if = "Option::is_none") )]
	pub xml_msg_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Instrm", skip_serializing_if = "Option::is_none") )]
	pub instrm: Option<PaymentInstrument1Code>,
}

impl PaymentOrigin1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.finmt {
			let pattern = Regex::new("[0-9]{1,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "finmt does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.xml_msg_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "xml_msg_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "xml_msg_nm exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.instrm { val.validate()? }
		Ok(())
	}
}


// PaymentReceipt1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum PaymentReceipt1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "PAYM") )]
	CodePAYM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RECE") )]
	CodeRECE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NONE") )]
	CodeNONE,
}

impl PaymentReceipt1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// PaymentReturnCriteria4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PaymentReturnCriteria4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgIdInd", skip_serializing_if = "Option::is_none") )]
	pub msg_id_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReqdExctnDtInd", skip_serializing_if = "Option::is_none") )]
	pub reqd_exctn_dt_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstrInd", skip_serializing_if = "Option::is_none") )]
	pub instr_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstrStsRtrCrit", skip_serializing_if = "Option::is_none") )]
	pub instr_sts_rtr_crit: Option<InstructionStatusReturnCriteria1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstdAmtInd", skip_serializing_if = "Option::is_none") )]
	pub instd_amt_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtDbtInd", skip_serializing_if = "Option::is_none") )]
	pub cdt_dbt_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrBkSttlmAmtInd", skip_serializing_if = "Option::is_none") )]
	pub intr_bk_sttlm_amt_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrtyInd", skip_serializing_if = "Option::is_none") )]
	pub prty_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrcgVldtyTmInd", skip_serializing_if = "Option::is_none") )]
	pub prcg_vldty_tm_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PurpInd", skip_serializing_if = "Option::is_none") )]
	pub purp_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstrCpyInd", skip_serializing_if = "Option::is_none") )]
	pub instr_cpy_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtMTInd", skip_serializing_if = "Option::is_none") )]
	pub pmt_mt_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtTpInd", skip_serializing_if = "Option::is_none") )]
	pub pmt_tp_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxIdInd", skip_serializing_if = "Option::is_none") )]
	pub tx_id_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrBkSttlmDtInd", skip_serializing_if = "Option::is_none") )]
	pub intr_bk_sttlm_dt_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EndToEndIdInd", skip_serializing_if = "Option::is_none") )]
	pub end_to_end_id_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtMtdInd", skip_serializing_if = "Option::is_none") )]
	pub pmt_mtd_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtrInd", skip_serializing_if = "Option::is_none") )]
	pub dbtr_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtrAgtInd", skip_serializing_if = "Option::is_none") )]
	pub dbtr_agt_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstgRmbrsmntAgtInd", skip_serializing_if = "Option::is_none") )]
	pub instg_rmbrsmnt_agt_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstdRmbrsmntAgtInd", skip_serializing_if = "Option::is_none") )]
	pub instd_rmbrsmnt_agt_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrmyInd", skip_serializing_if = "Option::is_none") )]
	pub intrmy_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtrAgtInd", skip_serializing_if = "Option::is_none") )]
	pub cdtr_agt_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtrInd", skip_serializing_if = "Option::is_none") )]
	pub cdtr_ind: Option<bool>,
}

impl PaymentReturnCriteria4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.instr_sts_rtr_crit { val.validate()? }
		Ok(())
	}
}


// PaymentReturnReason8 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PaymentReturnReason8 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlBkTxCd", skip_serializing_if = "Option::is_none") )]
	pub orgnl_bk_tx_cd: Option<BankTransactionCodeStructure4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Orgtr", skip_serializing_if = "Option::is_none") )]
	pub orgtr: Option<PartyIdentification272>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn", skip_serializing_if = "Option::is_none") )]
	pub rsn: Option<ReturnReason5Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_inf: Option<Vec<String>>,
}

impl PaymentReturnReason8 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.orgnl_bk_tx_cd { val.validate()? }
		if let Some(ref val) = self.orgtr { val.validate()? }
		if let Some(ref val) = self.rsn { val.validate()? }
		if let Some(ref vec) = self.addtl_inf {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "addtl_inf is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 105 {
					return Err(ValidationError::new(1002, "addtl_inf exceeds the maximum length of 105".to_string()));
				}
			}
		}
		Ok(())
	}
}


// PaymentRole1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PaymentRole1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl PaymentRole1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// PaymentRole1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum PaymentRole1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "LQMG") )]
	CodeLQMG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LMMG") )]
	CodeLMMG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PYMG") )]
	CodePYMG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "REDR") )]
	CodeREDR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BKMG") )]
	CodeBKMG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "STMG") )]
	CodeSTMG,
}

impl PaymentRole1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// PaymentSearch10 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PaymentSearch10 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgId", skip_serializing_if = "Option::is_none") )]
	pub msg_id: Option<Vec<String>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReqdExctnDt", skip_serializing_if = "Option::is_none") )]
	pub reqd_exctn_dt: Option<Vec<DateAndDateTimeSearch3Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtId", skip_serializing_if = "Option::is_none") )]
	pub pmt_id: Option<Vec<PaymentIdentification8Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sts", skip_serializing_if = "Option::is_none") )]
	pub sts: Option<Vec<InstructionStatusSearch5>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstdAmt", skip_serializing_if = "Option::is_none") )]
	pub instd_amt: Option<Vec<ActiveOrHistoricAmountRange2Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstdAmtCcy", skip_serializing_if = "Option::is_none") )]
	pub instd_amt_ccy: Option<Vec<String>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtDbtInd", skip_serializing_if = "Option::is_none") )]
	pub cdt_dbt_ind: Option<CreditDebitCode>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrBkSttlmAmt", skip_serializing_if = "Option::is_none") )]
	pub intr_bk_sttlm_amt: Option<Vec<ActiveAmountRange3Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrBkSttlmAmtCcy", skip_serializing_if = "Option::is_none") )]
	pub intr_bk_sttlm_amt_ccy: Option<Vec<String>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtMtd", skip_serializing_if = "Option::is_none") )]
	pub pmt_mtd: Option<Vec<PaymentOrigin1Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtTp", skip_serializing_if = "Option::is_none") )]
	pub pmt_tp: Option<Vec<PaymentType4Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prty", skip_serializing_if = "Option::is_none") )]
	pub prty: Option<Vec<Priority1Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrcgVldtyTm", skip_serializing_if = "Option::is_none") )]
	pub prcg_vldty_tm: Option<Vec<DateTimePeriod1Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Instr", skip_serializing_if = "Option::is_none") )]
	pub instr: Option<Vec<Instruction1Code>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxId", skip_serializing_if = "Option::is_none") )]
	pub tx_id: Option<Vec<String>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UETR", skip_serializing_if = "Option::is_none") )]
	pub uetr: Option<Vec<String>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrBkSttlmDt", skip_serializing_if = "Option::is_none") )]
	pub intr_bk_sttlm_dt: Option<Vec<String>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EndToEndId", skip_serializing_if = "Option::is_none") )]
	pub end_to_end_id: Option<Vec<String>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pties", skip_serializing_if = "Option::is_none") )]
	pub pties: Option<PaymentTransactionParty4>,
}

impl PaymentSearch10 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.msg_id {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "msg_id is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 35 {
					return Err(ValidationError::new(1002, "msg_id exceeds the maximum length of 35".to_string()));
				}
			}
		}
		if let Some(ref vec) = self.reqd_exctn_dt { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.pmt_id { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.sts { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.instd_amt { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.instd_amt_ccy {
			for item in vec {
				let pattern = Regex::new("[A-Z]{3,3}").unwrap();
				if !pattern.is_match(&item) {
					return Err(ValidationError::new(1005, "instd_amt_ccy does not match the required pattern".to_string()));
				}
			}
		}
		if let Some(ref val) = self.cdt_dbt_ind { val.validate()? }
		if let Some(ref vec) = self.intr_bk_sttlm_amt { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.intr_bk_sttlm_amt_ccy {
			for item in vec {
				let pattern = Regex::new("[A-Z]{3,3}").unwrap();
				if !pattern.is_match(&item) {
					return Err(ValidationError::new(1005, "intr_bk_sttlm_amt_ccy does not match the required pattern".to_string()));
				}
			}
		}
		if let Some(ref vec) = self.pmt_mtd { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.pmt_tp { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.prty { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.prcg_vldty_tm { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.instr { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.tx_id {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "tx_id is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 35 {
					return Err(ValidationError::new(1002, "tx_id exceeds the maximum length of 35".to_string()));
				}
			}
		}
		if let Some(ref vec) = self.uetr {
			for item in vec {
				let pattern = Regex::new("[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}").unwrap();
				if !pattern.is_match(&item) {
					return Err(ValidationError::new(1005, "uetr does not match the required pattern".to_string()));
				}
			}
		}
		if let Some(ref vec) = self.end_to_end_id {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "end_to_end_id is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 35 {
					return Err(ValidationError::new(1002, "end_to_end_id exceeds the maximum length of 35".to_string()));
				}
			}
		}
		if let Some(ref val) = self.pties { val.validate()? }
		Ok(())
	}
}


// PaymentStatus6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PaymentStatus6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<PaymentStatusCode6Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtTm", skip_serializing_if = "Option::is_none") )]
	pub dt_tm: Option<DateAndDateTime2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn", skip_serializing_if = "Option::is_none") )]
	pub rsn: Option<Vec<PaymentStatusReason1Choice>>,
}

impl PaymentStatus6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.dt_tm { val.validate()? }
		if let Some(ref vec) = self.rsn { for item in vec { item.validate()? } }
		Ok(())
	}
}


// PaymentStatusCode6Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PaymentStatusCode6Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pdg", skip_serializing_if = "Option::is_none") )]
	pub pdg: Option<PendingStatus4Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Fnl", skip_serializing_if = "Option::is_none") )]
	pub fnl: Option<FinalStatus1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RTGS", skip_serializing_if = "Option::is_none") )]
	pub rtgs: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sttlm", skip_serializing_if = "Option::is_none") )]
	pub sttlm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl PaymentStatusCode6Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.pdg { val.validate()? }
		if let Some(ref val) = self.fnl { val.validate()? }
		if let Some(ref val) = self.rtgs {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "rtgs is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "rtgs exceeds the maximum length of 4".to_string()));
			}
			let pattern = Regex::new("[a-zA-Z0-9]{1,4}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "rtgs does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.sttlm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "sttlm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "sttlm exceeds the maximum length of 4".to_string()));
			}
			let pattern = Regex::new("[a-zA-Z0-9]{1,4}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "sttlm does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// PaymentStatusCodeSearch2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PaymentStatusCodeSearch2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PdgSts", skip_serializing_if = "Option::is_none") )]
	pub pdg_sts: Option<PendingStatus4Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FnlSts", skip_serializing_if = "Option::is_none") )]
	pub fnl_sts: Option<FinalStatusCode>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PdgAndFnlSts", skip_serializing_if = "Option::is_none") )]
	pub pdg_and_fnl_sts: Option<CashPaymentStatus2Code>,
}

impl PaymentStatusCodeSearch2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.pdg_sts { val.validate()? }
		if let Some(ref val) = self.fnl_sts { val.validate()? }
		if let Some(ref val) = self.pdg_and_fnl_sts { val.validate()? }
		Ok(())
	}
}


// PaymentStatusReason1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PaymentStatusReason1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Umtchd", skip_serializing_if = "Option::is_none") )]
	pub umtchd: Option<UnmatchedStatusReason1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Canc", skip_serializing_if = "Option::is_none") )]
	pub canc: Option<CancelledStatusReason1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sspd", skip_serializing_if = "Option::is_none") )]
	pub sspd: Option<SuspendedStatusReason1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PdgFlngSttlm", skip_serializing_if = "Option::is_none") )]
	pub pdg_flng_sttlm: Option<PendingFailingSettlement1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PdgSttlm", skip_serializing_if = "Option::is_none") )]
	pub pdg_sttlm: Option<PendingSettlement2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrtryRjctn", skip_serializing_if = "Option::is_none") )]
	pub prtry_rjctn: Option<ProprietaryStatusJustification2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl PaymentStatusReason1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.umtchd { val.validate()? }
		if let Some(ref val) = self.canc { val.validate()? }
		if let Some(ref val) = self.sspd { val.validate()? }
		if let Some(ref val) = self.pdg_flng_sttlm { val.validate()? }
		if let Some(ref val) = self.pdg_sttlm { val.validate()? }
		if let Some(ref val) = self.prtry_rjctn { val.validate()? }
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// PaymentTransaction152 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PaymentTransaction152 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CxlStsId", skip_serializing_if = "Option::is_none") )]
	pub cxl_sts_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RslvdCase", skip_serializing_if = "Option::is_none") )]
	pub rslvd_case: Option<Case6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlGrpInf", skip_serializing_if = "Option::is_none") )]
	pub orgnl_grp_inf: Option<OriginalGroupInformation29>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlInstrId", skip_serializing_if = "Option::is_none") )]
	pub orgnl_instr_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlEndToEndId", skip_serializing_if = "Option::is_none") )]
	pub orgnl_end_to_end_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlTxId", skip_serializing_if = "Option::is_none") )]
	pub orgnl_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlClrSysRef", skip_serializing_if = "Option::is_none") )]
	pub orgnl_clr_sys_ref: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlUETR", skip_serializing_if = "Option::is_none") )]
	pub orgnl_uetr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxCxlSts", skip_serializing_if = "Option::is_none") )]
	pub tx_cxl_sts: Option<CancellationIndividualStatus1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CxlStsRsnInf", skip_serializing_if = "Option::is_none") )]
	pub cxl_sts_rsn_inf: Option<Vec<CancellationStatusReason5>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RsltnRltdInf", skip_serializing_if = "Option::is_none") )]
	pub rsltn_rltd_inf: Option<ResolutionData5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlIntrBkSttlmAmt", skip_serializing_if = "Option::is_none") )]
	pub orgnl_intr_bk_sttlm_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlIntrBkSttlmDt", skip_serializing_if = "Option::is_none") )]
	pub orgnl_intr_bk_sttlm_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Assgnr", skip_serializing_if = "Option::is_none") )]
	pub assgnr: Option<Party50Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Assgne", skip_serializing_if = "Option::is_none") )]
	pub assgne: Option<Party50Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlTxRef", skip_serializing_if = "Option::is_none") )]
	pub orgnl_tx_ref: Option<OriginalTransactionReference42>,
}

impl PaymentTransaction152 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cxl_sts_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cxl_sts_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "cxl_sts_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.rslvd_case { val.validate()? }
		if let Some(ref val) = self.orgnl_grp_inf { val.validate()? }
		if let Some(ref val) = self.orgnl_instr_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_instr_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_instr_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.orgnl_end_to_end_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_end_to_end_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_end_to_end_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.orgnl_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.orgnl_clr_sys_ref {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_clr_sys_ref is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_clr_sys_ref exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.orgnl_uetr {
			let pattern = Regex::new("[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "orgnl_uetr does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.tx_cxl_sts { val.validate()? }
		if let Some(ref vec) = self.cxl_sts_rsn_inf { for item in vec { item.validate()? } }
		if let Some(ref val) = self.rsltn_rltd_inf { val.validate()? }
		if let Some(ref val) = self.orgnl_intr_bk_sttlm_amt { val.validate()? }
		if let Some(ref val) = self.assgnr { val.validate()? }
		if let Some(ref val) = self.assgne { val.validate()? }
		if let Some(ref val) = self.orgnl_tx_ref { val.validate()? }
		Ok(())
	}
}


// PaymentTransaction153 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PaymentTransaction153 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CxlStsId", skip_serializing_if = "Option::is_none") )]
	pub cxl_sts_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RslvdCase", skip_serializing_if = "Option::is_none") )]
	pub rslvd_case: Option<Case6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlInstrId", skip_serializing_if = "Option::is_none") )]
	pub orgnl_instr_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlEndToEndId", skip_serializing_if = "Option::is_none") )]
	pub orgnl_end_to_end_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UETR", skip_serializing_if = "Option::is_none") )]
	pub uetr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxCxlSts", skip_serializing_if = "Option::is_none") )]
	pub tx_cxl_sts: Option<CancellationIndividualStatus1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CxlStsRsnInf", skip_serializing_if = "Option::is_none") )]
	pub cxl_sts_rsn_inf: Option<Vec<CancellationStatusReason5>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlInstdAmt", skip_serializing_if = "Option::is_none") )]
	pub orgnl_instd_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlReqdExctnDt", skip_serializing_if = "Option::is_none") )]
	pub orgnl_reqd_exctn_dt: Option<DateAndDateTime2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlReqdColltnDt", skip_serializing_if = "Option::is_none") )]
	pub orgnl_reqd_colltn_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlTxRef", skip_serializing_if = "Option::is_none") )]
	pub orgnl_tx_ref: Option<OriginalTransactionReference42>,
}

impl PaymentTransaction153 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cxl_sts_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cxl_sts_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "cxl_sts_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.rslvd_case { val.validate()? }
		if let Some(ref val) = self.orgnl_instr_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_instr_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_instr_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.orgnl_end_to_end_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_end_to_end_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_end_to_end_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.uetr {
			let pattern = Regex::new("[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "uetr does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.tx_cxl_sts { val.validate()? }
		if let Some(ref vec) = self.cxl_sts_rsn_inf { for item in vec { item.validate()? } }
		if let Some(ref val) = self.orgnl_instd_amt { val.validate()? }
		if let Some(ref val) = self.orgnl_reqd_exctn_dt { val.validate()? }
		if let Some(ref val) = self.orgnl_tx_ref { val.validate()? }
		Ok(())
	}
}


// PaymentTransaction154 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PaymentTransaction154 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CxlId", skip_serializing_if = "Option::is_none") )]
	pub cxl_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Case", skip_serializing_if = "Option::is_none") )]
	pub case: Option<Case6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlInstrId", skip_serializing_if = "Option::is_none") )]
	pub orgnl_instr_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlEndToEndId", skip_serializing_if = "Option::is_none") )]
	pub orgnl_end_to_end_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlUETR", skip_serializing_if = "Option::is_none") )]
	pub orgnl_uetr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlInstdAmt", skip_serializing_if = "Option::is_none") )]
	pub orgnl_instd_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlReqdExctnDt", skip_serializing_if = "Option::is_none") )]
	pub orgnl_reqd_exctn_dt: Option<DateAndDateTime2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlReqdColltnDt", skip_serializing_if = "Option::is_none") )]
	pub orgnl_reqd_colltn_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CxlRsnInf", skip_serializing_if = "Option::is_none") )]
	pub cxl_rsn_inf: Option<Vec<PaymentCancellationReason6>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlTxRef", skip_serializing_if = "Option::is_none") )]
	pub orgnl_tx_ref: Option<OriginalTransactionReference42>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl PaymentTransaction154 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cxl_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cxl_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "cxl_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.case { val.validate()? }
		if let Some(ref val) = self.orgnl_instr_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_instr_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_instr_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.orgnl_end_to_end_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_end_to_end_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_end_to_end_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.orgnl_uetr {
			let pattern = Regex::new("[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "orgnl_uetr does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.orgnl_instd_amt { val.validate()? }
		if let Some(ref val) = self.orgnl_reqd_exctn_dt { val.validate()? }
		if let Some(ref vec) = self.cxl_rsn_inf { for item in vec { item.validate()? } }
		if let Some(ref val) = self.orgnl_tx_ref { val.validate()? }
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// PaymentTransaction155 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PaymentTransaction155 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CxlId", skip_serializing_if = "Option::is_none") )]
	pub cxl_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Case", skip_serializing_if = "Option::is_none") )]
	pub case: Option<Case6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlGrpInf", skip_serializing_if = "Option::is_none") )]
	pub orgnl_grp_inf: Option<OriginalGroupInformation29>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlInstrId", skip_serializing_if = "Option::is_none") )]
	pub orgnl_instr_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlEndToEndId", skip_serializing_if = "Option::is_none") )]
	pub orgnl_end_to_end_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlTxId", skip_serializing_if = "Option::is_none") )]
	pub orgnl_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlUETR", skip_serializing_if = "Option::is_none") )]
	pub orgnl_uetr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlClrSysRef", skip_serializing_if = "Option::is_none") )]
	pub orgnl_clr_sys_ref: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlIntrBkSttlmAmt", skip_serializing_if = "Option::is_none") )]
	pub orgnl_intr_bk_sttlm_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlIntrBkSttlmDt", skip_serializing_if = "Option::is_none") )]
	pub orgnl_intr_bk_sttlm_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Assgnr", skip_serializing_if = "Option::is_none") )]
	pub assgnr: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Assgne", skip_serializing_if = "Option::is_none") )]
	pub assgne: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CxlRsnInf", skip_serializing_if = "Option::is_none") )]
	pub cxl_rsn_inf: Option<Vec<PaymentCancellationReason6>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlTxRef", skip_serializing_if = "Option::is_none") )]
	pub orgnl_tx_ref: Option<OriginalTransactionReference42>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SplmtryData", skip_serializing_if = "Option::is_none") )]
	pub splmtry_data: Option<Vec<SupplementaryData1>>,
}

impl PaymentTransaction155 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cxl_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cxl_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "cxl_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.case { val.validate()? }
		if let Some(ref val) = self.orgnl_grp_inf { val.validate()? }
		if let Some(ref val) = self.orgnl_instr_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_instr_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_instr_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.orgnl_end_to_end_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_end_to_end_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_end_to_end_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.orgnl_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.orgnl_uetr {
			let pattern = Regex::new("[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "orgnl_uetr does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.orgnl_clr_sys_ref {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_clr_sys_ref is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_clr_sys_ref exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.orgnl_intr_bk_sttlm_amt { val.validate()? }
		if let Some(ref val) = self.assgnr { val.validate()? }
		if let Some(ref val) = self.assgne { val.validate()? }
		if let Some(ref vec) = self.cxl_rsn_inf { for item in vec { item.validate()? } }
		if let Some(ref val) = self.orgnl_tx_ref { val.validate()? }
		if let Some(ref vec) = self.splmtry_data { for item in vec { item.validate()? } }
		Ok(())
	}
}


// PaymentTransaction157 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PaymentTransaction157 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ModStsId", skip_serializing_if = "Option::is_none") )]
	pub mod_sts_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RslvdCase", skip_serializing_if = "Option::is_none") )]
	pub rslvd_case: Option<Case6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlGrpInf") )]
	pub orgnl_grp_inf: OriginalGroupInformation29,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlPmtInfId", skip_serializing_if = "Option::is_none") )]
	pub orgnl_pmt_inf_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlInstrId", skip_serializing_if = "Option::is_none") )]
	pub orgnl_instr_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlEndToEndId", skip_serializing_if = "Option::is_none") )]
	pub orgnl_end_to_end_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlTxId", skip_serializing_if = "Option::is_none") )]
	pub orgnl_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlClrSysRef", skip_serializing_if = "Option::is_none") )]
	pub orgnl_clr_sys_ref: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlUETR", skip_serializing_if = "Option::is_none") )]
	pub orgnl_uetr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ModStsRsnInf", skip_serializing_if = "Option::is_none") )]
	pub mod_sts_rsn_inf: Option<Vec<ModificationStatusReason3>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RsltnRltdInf", skip_serializing_if = "Option::is_none") )]
	pub rsltn_rltd_inf: Option<ResolutionData5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlIntrBkSttlmAmt", skip_serializing_if = "Option::is_none") )]
	pub orgnl_intr_bk_sttlm_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlIntrBkSttlmDt", skip_serializing_if = "Option::is_none") )]
	pub orgnl_intr_bk_sttlm_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Assgnr", skip_serializing_if = "Option::is_none") )]
	pub assgnr: Option<Party50Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Assgne", skip_serializing_if = "Option::is_none") )]
	pub assgne: Option<Party50Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlTxRef", skip_serializing_if = "Option::is_none") )]
	pub orgnl_tx_ref: Option<OriginalTransactionReference42>,
}

impl PaymentTransaction157 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.mod_sts_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "mod_sts_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "mod_sts_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.rslvd_case { val.validate()? }
		self.orgnl_grp_inf.validate()?;
		if let Some(ref val) = self.orgnl_pmt_inf_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_pmt_inf_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_pmt_inf_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.orgnl_instr_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_instr_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_instr_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.orgnl_end_to_end_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_end_to_end_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_end_to_end_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.orgnl_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.orgnl_clr_sys_ref {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_clr_sys_ref is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_clr_sys_ref exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.orgnl_uetr {
			let pattern = Regex::new("[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "orgnl_uetr does not match the required pattern".to_string()));
			}
		}
		if let Some(ref vec) = self.mod_sts_rsn_inf { for item in vec { item.validate()? } }
		if let Some(ref val) = self.rsltn_rltd_inf { val.validate()? }
		if let Some(ref val) = self.orgnl_intr_bk_sttlm_amt { val.validate()? }
		if let Some(ref val) = self.assgnr { val.validate()? }
		if let Some(ref val) = self.assgne { val.validate()? }
		if let Some(ref val) = self.orgnl_tx_ref { val.validate()? }
		Ok(())
	}
}


// PaymentTransactionParty4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PaymentTransactionParty4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstgAgt", skip_serializing_if = "Option::is_none") )]
	pub instg_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstdAgt", skip_serializing_if = "Option::is_none") )]
	pub instd_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UltmtDbtr", skip_serializing_if = "Option::is_none") )]
	pub ultmt_dbtr: Option<Party50Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dbtr", skip_serializing_if = "Option::is_none") )]
	pub dbtr: Option<Party50Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtrAgt", skip_serializing_if = "Option::is_none") )]
	pub dbtr_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstgRmbrsmntAgt", skip_serializing_if = "Option::is_none") )]
	pub instg_rmbrsmnt_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstdRmbrsmntAgt", skip_serializing_if = "Option::is_none") )]
	pub instd_rmbrsmnt_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrmyAgt1", skip_serializing_if = "Option::is_none") )]
	pub intrmy_agt1: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrmyAgt2", skip_serializing_if = "Option::is_none") )]
	pub intrmy_agt2: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrmyAgt3", skip_serializing_if = "Option::is_none") )]
	pub intrmy_agt3: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtrAgt", skip_serializing_if = "Option::is_none") )]
	pub cdtr_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cdtr", skip_serializing_if = "Option::is_none") )]
	pub cdtr: Option<Party50Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UltmtCdtr", skip_serializing_if = "Option::is_none") )]
	pub ultmt_cdtr: Option<Party50Choice>,
}

impl PaymentTransactionParty4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.instg_agt { val.validate()? }
		if let Some(ref val) = self.instd_agt { val.validate()? }
		if let Some(ref val) = self.ultmt_dbtr { val.validate()? }
		if let Some(ref val) = self.dbtr { val.validate()? }
		if let Some(ref val) = self.dbtr_agt { val.validate()? }
		if let Some(ref val) = self.instg_rmbrsmnt_agt { val.validate()? }
		if let Some(ref val) = self.instd_rmbrsmnt_agt { val.validate()? }
		if let Some(ref val) = self.intrmy_agt1 { val.validate()? }
		if let Some(ref val) = self.intrmy_agt2 { val.validate()? }
		if let Some(ref val) = self.intrmy_agt3 { val.validate()? }
		if let Some(ref val) = self.cdtr_agt { val.validate()? }
		if let Some(ref val) = self.cdtr { val.validate()? }
		if let Some(ref val) = self.ultmt_cdtr { val.validate()? }
		Ok(())
	}
}


// PaymentTransactionStatus1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PaymentTransactionStatus1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sts") )]
	pub sts: TransactionStatus1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StsRsnInf", skip_serializing_if = "Option::is_none") )]
	pub sts_rsn_inf: Option<Vec<StatusReasonInformation12>>,
}

impl PaymentTransactionStatus1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.sts.validate()?;
		if let Some(ref vec) = self.sts_rsn_inf { for item in vec { item.validate()? } }
		Ok(())
	}
}


// PaymentType3Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum PaymentType3Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "CBS") )]
	CodeCBS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BCK") )]
	CodeBCK,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BAL") )]
	CodeBAL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CLS") )]
	CodeCLS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CTR") )]
	CodeCTR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CBH") )]
	CodeCBH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CBP") )]
	CodeCBP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DPG") )]
	CodeDPG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DPN") )]
	CodeDPN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EXP") )]
	CodeEXP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TCH") )]
	CodeTCH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LMT") )]
	CodeLMT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LIQ") )]
	CodeLIQ,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DPP") )]
	CodeDPP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DPH") )]
	CodeDPH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DPS") )]
	CodeDPS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "STF") )]
	CodeSTF,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TRP") )]
	CodeTRP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TCS") )]
	CodeTCS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LOA") )]
	CodeLOA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LOR") )]
	CodeLOR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TCP") )]
	CodeTCP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OND") )]
	CodeOND,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MGL") )]
	CodeMGL,
}

impl PaymentType3Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// PaymentType4Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PaymentType4Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<PaymentType3Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl PaymentType4Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// PaymentTypeInformation27 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PaymentTypeInformation27 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstrPrty", skip_serializing_if = "Option::is_none") )]
	pub instr_prty: Option<Priority2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrChanl", skip_serializing_if = "Option::is_none") )]
	pub clr_chanl: Option<ClearingChannel2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SvcLvl", skip_serializing_if = "Option::is_none") )]
	pub svc_lvl: Option<Vec<ServiceLevel8Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LclInstrm", skip_serializing_if = "Option::is_none") )]
	pub lcl_instrm: Option<LocalInstrument2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SeqTp", skip_serializing_if = "Option::is_none") )]
	pub seq_tp: Option<SequenceType3Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtgyPurp", skip_serializing_if = "Option::is_none") )]
	pub ctgy_purp: Option<CategoryPurpose1Choice>,
}

impl PaymentTypeInformation27 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.instr_prty { val.validate()? }
		if let Some(ref val) = self.clr_chanl { val.validate()? }
		if let Some(ref vec) = self.svc_lvl { for item in vec { item.validate()? } }
		if let Some(ref val) = self.lcl_instrm { val.validate()? }
		if let Some(ref val) = self.seq_tp { val.validate()? }
		if let Some(ref val) = self.ctgy_purp { val.validate()? }
		Ok(())
	}
}


// PendingFailingSettlement1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum PendingFailingSettlement1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "AWMO") )]
	CodeAWMO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AWSH") )]
	CodeAWSH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LAAW") )]
	CodeLAAW,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DOCY") )]
	CodeDOCY,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CLAT") )]
	CodeCLAT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CERT") )]
	CodeCERT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MINO") )]
	CodeMINO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PHSE") )]
	CodePHSE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SBLO") )]
	CodeSBLO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DKNY") )]
	CodeDKNY,
	#[cfg_attr( feature = "derive_serde", serde(rename = "STCD") )]
	CodeSTCD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BENO") )]
	CodeBENO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LACK") )]
	CodeLACK,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LATE") )]
	CodeLATE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CANR") )]
	CodeCANR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MLAT") )]
	CodeMLAT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OBJT") )]
	CodeOBJT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DOCC") )]
	CodeDOCC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BLOC") )]
	CodeBLOC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CHAS") )]
	CodeCHAS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NEWI") )]
	CodeNEWI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CLAC") )]
	CodeCLAC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PART") )]
	CodePART,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CMON") )]
	CodeCMON,
	#[cfg_attr( feature = "derive_serde", serde(rename = "COLL") )]
	CodeCOLL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DEPO") )]
	CodeDEPO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FLIM") )]
	CodeFLIM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NOFX") )]
	CodeNOFX,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INCA") )]
	CodeINCA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LINK") )]
	CodeLINK,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BYIY") )]
	CodeBYIY,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CAIS") )]
	CodeCAIS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LALO") )]
	CodeLALO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MONY") )]
	CodeMONY,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NCON") )]
	CodeNCON,
	#[cfg_attr( feature = "derive_serde", serde(rename = "YCOL") )]
	CodeYCOL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "REFS") )]
	CodeREFS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SDUT") )]
	CodeSDUT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CYCL") )]
	CodeCYCL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BATC") )]
	CodeBATC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GUAD") )]
	CodeGUAD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PREA") )]
	CodePREA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GLOB") )]
	CodeGLOB,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CPEC") )]
	CodeCPEC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MUNO") )]
	CodeMUNO,
}

impl PendingFailingSettlement1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// PendingReason10Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum PendingReason10Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "AWMO") )]
	CodeAWMO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ADEA") )]
	CodeADEA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CAIS") )]
	CodeCAIS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "REFU") )]
	CodeREFU,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AWSH") )]
	CodeAWSH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PHSE") )]
	CodePHSE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TAMM") )]
	CodeTAMM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DOCY") )]
	CodeDOCY,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DOCC") )]
	CodeDOCC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BLOC") )]
	CodeBLOC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CHAS") )]
	CodeCHAS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NEWI") )]
	CodeNEWI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CLAC") )]
	CodeCLAC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MUNO") )]
	CodeMUNO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GLOB") )]
	CodeGLOB,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PREA") )]
	CodePREA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PART") )]
	CodePART,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NMAS") )]
	CodeNMAS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NOFX") )]
	CodeNOFX,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CMON") )]
	CodeCMON,
	#[cfg_attr( feature = "derive_serde", serde(rename = "YCOL") )]
	CodeYCOL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "COLL") )]
	CodeCOLL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DEPO") )]
	CodeDEPO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FLIM") )]
	CodeFLIM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INCA") )]
	CodeINCA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LINK") )]
	CodeLINK,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FUTU") )]
	CodeFUTU,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LACK") )]
	CodeLACK,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LALO") )]
	CodeLALO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MONY") )]
	CodeMONY,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NCON") )]
	CodeNCON,
	#[cfg_attr( feature = "derive_serde", serde(rename = "REFS") )]
	CodeREFS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SDUT") )]
	CodeSDUT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BATC") )]
	CodeBATC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CYCL") )]
	CodeCYCL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SBLO") )]
	CodeSBLO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CPEC") )]
	CodeCPEC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MINO") )]
	CodeMINO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IAAD") )]
	CodeIAAD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PHCK") )]
	CodePHCK,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BENO") )]
	CodeBENO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BOTH") )]
	CodeBOTH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CLHT") )]
	CodeCLHT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DENO") )]
	CodeDENO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DISA") )]
	CodeDISA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DKNY") )]
	CodeDKNY,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FROZ") )]
	CodeFROZ,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LAAW") )]
	CodeLAAW,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LATE") )]
	CodeLATE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LIQU") )]
	CodeLIQU,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PRCY") )]
	CodePRCY,
	#[cfg_attr( feature = "derive_serde", serde(rename = "REGT") )]
	CodeREGT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SETS") )]
	CodeSETS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CERT") )]
	CodeCERT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PRSY") )]
	CodePRSY,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INBC") )]
	CodeINBC,
}

impl PendingReason10Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// PendingReason14 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PendingReason14 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd") )]
	pub cd: PendingReason26Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlRsnInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_rsn_inf: Option<String>,
}

impl PendingReason14 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.cd.validate()?;
		if let Some(ref val) = self.addtl_rsn_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_rsn_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 210 {
				return Err(ValidationError::new(1002, "addtl_rsn_inf exceeds the maximum length of 210".to_string()));
			}
		}
		Ok(())
	}
}


// PendingReason16 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PendingReason16 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd") )]
	pub cd: PendingReason28Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlRsnInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_rsn_inf: Option<String>,
}

impl PendingReason16 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.cd.validate()?;
		if let Some(ref val) = self.addtl_rsn_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_rsn_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 210 {
				return Err(ValidationError::new(1002, "addtl_rsn_inf exceeds the maximum length of 210".to_string()));
			}
		}
		Ok(())
	}
}


// PendingReason17 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PendingReason17 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd") )]
	pub cd: PendingReason30Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlRsnInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_rsn_inf: Option<String>,
}

impl PendingReason17 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.cd.validate()?;
		if let Some(ref val) = self.addtl_rsn_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_rsn_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 210 {
				return Err(ValidationError::new(1002, "addtl_rsn_inf exceeds the maximum length of 210".to_string()));
			}
		}
		Ok(())
	}
}


// PendingReason26Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PendingReason26Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<PendingReason10Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification30>,
}

impl PendingReason26Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// PendingReason28Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PendingReason28Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<PendingReason6Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification30>,
}

impl PendingReason28Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// PendingReason30Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PendingReason30Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<PendingReason9Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification30>,
}

impl PendingReason30Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// PendingReason6Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum PendingReason6Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ADEA") )]
	CodeADEA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CONF") )]
	CodeCONF,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CDRG") )]
	CodeCDRG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CDCY") )]
	CodeCDCY,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CDRE") )]
	CodeCDRE,
}

impl PendingReason6Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// PendingReason9Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum PendingReason9Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ADEA") )]
	CodeADEA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CONF") )]
	CodeCONF,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CDRG") )]
	CodeCDRG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CDCY") )]
	CodeCDCY,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CDRE") )]
	CodeCDRE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CDAC") )]
	CodeCDAC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INBC") )]
	CodeINBC,
}

impl PendingReason9Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// PendingSettlement2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum PendingSettlement2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "AWMO") )]
	CodeAWMO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CAIS") )]
	CodeCAIS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "REFU") )]
	CodeREFU,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AWSH") )]
	CodeAWSH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PHSE") )]
	CodePHSE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TAMM") )]
	CodeTAMM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DOCY") )]
	CodeDOCY,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DOCC") )]
	CodeDOCC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BLOC") )]
	CodeBLOC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CHAS") )]
	CodeCHAS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NEWI") )]
	CodeNEWI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CLAC") )]
	CodeCLAC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MUNO") )]
	CodeMUNO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GLOB") )]
	CodeGLOB,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PREA") )]
	CodePREA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GUAD") )]
	CodeGUAD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PART") )]
	CodePART,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NMAS") )]
	CodeNMAS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CMON") )]
	CodeCMON,
	#[cfg_attr( feature = "derive_serde", serde(rename = "YCOL") )]
	CodeYCOL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "COLL") )]
	CodeCOLL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DEPO") )]
	CodeDEPO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FLIM") )]
	CodeFLIM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NOFX") )]
	CodeNOFX,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INCA") )]
	CodeINCA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LINK") )]
	CodeLINK,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FUTU") )]
	CodeFUTU,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LACK") )]
	CodeLACK,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LALO") )]
	CodeLALO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MONY") )]
	CodeMONY,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NCON") )]
	CodeNCON,
	#[cfg_attr( feature = "derive_serde", serde(rename = "REFS") )]
	CodeREFS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SDUT") )]
	CodeSDUT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BATC") )]
	CodeBATC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CYCL") )]
	CodeCYCL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SBLO") )]
	CodeSBLO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CPEC") )]
	CodeCPEC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MINO") )]
	CodeMINO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PCAP") )]
	CodePCAP,
}

impl PendingSettlement2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// PendingStatus36Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PendingStatus36Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NoSpcfdRsn", skip_serializing_if = "Option::is_none") )]
	pub no_spcfd_rsn: Option<NoReasonCode>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn", skip_serializing_if = "Option::is_none") )]
	pub rsn: Option<Vec<PendingReason14>>,
}

impl PendingStatus36Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.no_spcfd_rsn { val.validate()? }
		if let Some(ref vec) = self.rsn { for item in vec { item.validate()? } }
		Ok(())
	}
}


// PendingStatus38Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PendingStatus38Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NoSpcfdRsn", skip_serializing_if = "Option::is_none") )]
	pub no_spcfd_rsn: Option<NoReasonCode>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn", skip_serializing_if = "Option::is_none") )]
	pub rsn: Option<Vec<PendingReason16>>,
}

impl PendingStatus38Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.no_spcfd_rsn { val.validate()? }
		if let Some(ref vec) = self.rsn { for item in vec { item.validate()? } }
		Ok(())
	}
}


// PendingStatus39Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PendingStatus39Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NoSpcfdRsn", skip_serializing_if = "Option::is_none") )]
	pub no_spcfd_rsn: Option<NoReasonCode>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn", skip_serializing_if = "Option::is_none") )]
	pub rsn: Option<Vec<PendingReason17>>,
}

impl PendingStatus39Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.no_spcfd_rsn { val.validate()? }
		if let Some(ref vec) = self.rsn { for item in vec { item.validate()? } }
		Ok(())
	}
}


// PendingStatus4Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum PendingStatus4Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ACPD") )]
	CodeACPD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VALD") )]
	CodeVALD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MATD") )]
	CodeMATD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AUTD") )]
	CodeAUTD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INVD") )]
	CodeINVD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UMAC") )]
	CodeUMAC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "STLE") )]
	CodeSTLE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "STLM") )]
	CodeSTLM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SSPD") )]
	CodeSSPD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PCAN") )]
	CodePCAN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PSTL") )]
	CodePSTL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PFST") )]
	CodePFST,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SMLR") )]
	CodeSMLR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RMLR") )]
	CodeRMLR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SRBL") )]
	CodeSRBL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AVLB") )]
	CodeAVLB,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SRML") )]
	CodeSRML,
}

impl PendingStatus4Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// PendingStatusAndReason2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PendingStatusAndReason2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrcgSts", skip_serializing_if = "Option::is_none") )]
	pub prcg_sts: Option<Vec<ProcessingStatus66Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttlmSts", skip_serializing_if = "Option::is_none") )]
	pub sttlm_sts: Option<Vec<SettlementStatus16Choice>>,
}

impl PendingStatusAndReason2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.prcg_sts { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.sttlm_sts { for item in vec { item.validate()? } }
		Ok(())
	}
}


// PercentageRange1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PercentageRange1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Fr", skip_serializing_if = "Option::is_none") )]
	pub fr: Option<PercentageRangeBoundary1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "To", skip_serializing_if = "Option::is_none") )]
	pub to: Option<PercentageRangeBoundary1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrTo", skip_serializing_if = "Option::is_none") )]
	pub fr_to: Option<FromToPercentageRange1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EQ", skip_serializing_if = "Option::is_none") )]
	pub eq: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NEQ", skip_serializing_if = "Option::is_none") )]
	pub neq: Option<f64>,
}

impl PercentageRange1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.fr { val.validate()? }
		if let Some(ref val) = self.to { val.validate()? }
		if let Some(ref val) = self.fr_to { val.validate()? }
		Ok(())
	}
}


// PercentageRangeBoundary1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PercentageRangeBoundary1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BdryRate") )]
	pub bdry_rate: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Incl") )]
	pub incl: bool,
}

impl PercentageRangeBoundary1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// Period2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Period2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrDt") )]
	pub fr_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ToDt") )]
	pub to_dt: String,
}

impl Period2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// Period7Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Period7Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrDtTmToDtTm", skip_serializing_if = "Option::is_none") )]
	pub fr_dt_tm_to_dt_tm: Option<DateTimePeriod1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrDtToDt", skip_serializing_if = "Option::is_none") )]
	pub fr_dt_to_dt: Option<Period2>,
}

impl Period7Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.fr_dt_tm_to_dt_tm { val.validate()? }
		if let Some(ref val) = self.fr_dt_to_dt { val.validate()? }
		Ok(())
	}
}


// PersonIdentification13 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PersonIdentification13 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtAndPlcOfBirth", skip_serializing_if = "Option::is_none") )]
	pub dt_and_plc_of_birth: Option<DateAndPlaceOfBirth1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<Vec<GenericPersonIdentification1>>,
}

impl PersonIdentification13 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.dt_and_plc_of_birth { val.validate()? }
		if let Some(ref vec) = self.othr { for item in vec { item.validate()? } }
		Ok(())
	}
}


// PersonIdentification18 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PersonIdentification18 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtAndPlcOfBirth", skip_serializing_if = "Option::is_none") )]
	pub dt_and_plc_of_birth: Option<DateAndPlaceOfBirth1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<Vec<GenericPersonIdentification2>>,
}

impl PersonIdentification18 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.dt_and_plc_of_birth { val.validate()? }
		if let Some(ref vec) = self.othr { for item in vec { item.validate()? } }
		Ok(())
	}
}


// PersonIdentificationSchemeName1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PersonIdentificationSchemeName1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl PersonIdentificationSchemeName1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// PlainCardData1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PlainCardData1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PAN") )]
	pub pan: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CardSeqNb", skip_serializing_if = "Option::is_none") )]
	pub card_seq_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FctvDt", skip_serializing_if = "Option::is_none") )]
	pub fctv_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XpryDt") )]
	pub xpry_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SvcCd", skip_serializing_if = "Option::is_none") )]
	pub svc_cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TrckData", skip_serializing_if = "Option::is_none") )]
	pub trck_data: Option<Vec<TrackData1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CardSctyCd", skip_serializing_if = "Option::is_none") )]
	pub card_scty_cd: Option<CardSecurityInformation1>,
}

impl PlainCardData1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[0-9]{8,28}").unwrap();
		if !pattern.is_match(&self.pan) {
			return Err(ValidationError::new(1005, "pan does not match the required pattern".to_string()));
		}
		if let Some(ref val) = self.card_seq_nb {
			let pattern = Regex::new("[0-9]{2,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "card_seq_nb does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.svc_cd {
			let pattern = Regex::new("[0-9]{3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "svc_cd does not match the required pattern".to_string()));
			}
		}
		if let Some(ref vec) = self.trck_data { for item in vec { item.validate()? } }
		if let Some(ref val) = self.card_scty_cd { val.validate()? }
		Ok(())
	}
}


// PointOfInteraction1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PointOfInteraction1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: GenericIdentification32,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SysNm", skip_serializing_if = "Option::is_none") )]
	pub sys_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GrpId", skip_serializing_if = "Option::is_none") )]
	pub grp_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cpblties", skip_serializing_if = "Option::is_none") )]
	pub cpblties: Option<PointOfInteractionCapabilities1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cmpnt", skip_serializing_if = "Option::is_none") )]
	pub cmpnt: Option<Vec<PointOfInteractionComponent1>>,
}

impl PointOfInteraction1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.id.validate()?;
		if let Some(ref val) = self.sys_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "sys_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 70 {
				return Err(ValidationError::new(1002, "sys_nm exceeds the maximum length of 70".to_string()));
			}
		}
		if let Some(ref val) = self.grp_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "grp_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "grp_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.cpblties { val.validate()? }
		if let Some(ref vec) = self.cmpnt { for item in vec { item.validate()? } }
		Ok(())
	}
}


// PointOfInteractionCapabilities1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PointOfInteractionCapabilities1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CardRdngCpblties", skip_serializing_if = "Option::is_none") )]
	pub card_rdng_cpblties: Option<Vec<CardDataReading1Code>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CrdhldrVrfctnCpblties", skip_serializing_if = "Option::is_none") )]
	pub crdhldr_vrfctn_cpblties: Option<Vec<CardholderVerificationCapability1Code>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OnLineCpblties", skip_serializing_if = "Option::is_none") )]
	pub on_line_cpblties: Option<OnLineCapability1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DispCpblties", skip_serializing_if = "Option::is_none") )]
	pub disp_cpblties: Option<Vec<DisplayCapabilities1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrtLineWidth", skip_serializing_if = "Option::is_none") )]
	pub prt_line_width: Option<String>,
}

impl PointOfInteractionCapabilities1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.card_rdng_cpblties { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.crdhldr_vrfctn_cpblties { for item in vec { item.validate()? } }
		if let Some(ref val) = self.on_line_cpblties { val.validate()? }
		if let Some(ref vec) = self.disp_cpblties { for item in vec { item.validate()? } }
		if let Some(ref val) = self.prt_line_width {
			let pattern = Regex::new("[0-9]{1,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "prt_line_width does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// PointOfInteractionComponent1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PointOfInteractionComponent1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "POICmpntTp") )]
	pub poi_cmpnt_tp: POIComponentType1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ManfctrId", skip_serializing_if = "Option::is_none") )]
	pub manfctr_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Mdl", skip_serializing_if = "Option::is_none") )]
	pub mdl: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VrsnNb", skip_serializing_if = "Option::is_none") )]
	pub vrsn_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SrlNb", skip_serializing_if = "Option::is_none") )]
	pub srl_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ApprvlNb", skip_serializing_if = "Option::is_none") )]
	pub apprvl_nb: Option<Vec<String>>,
}

impl PointOfInteractionComponent1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.poi_cmpnt_tp.validate()?;
		if let Some(ref val) = self.manfctr_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "manfctr_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "manfctr_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.mdl {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "mdl is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "mdl exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.vrsn_nb {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "vrsn_nb is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 16 {
				return Err(ValidationError::new(1002, "vrsn_nb exceeds the maximum length of 16".to_string()));
			}
		}
		if let Some(ref val) = self.srl_nb {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "srl_nb is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "srl_nb exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref vec) = self.apprvl_nb {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "apprvl_nb is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 70 {
					return Err(ValidationError::new(1002, "apprvl_nb exceeds the maximum length of 70".to_string()));
				}
			}
		}
		Ok(())
	}
}


// PostalAddress1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PostalAddress1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AdrTp", skip_serializing_if = "Option::is_none") )]
	pub adr_tp: Option<AddressType2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AdrLine", skip_serializing_if = "Option::is_none") )]
	pub adr_line: Option<Vec<String>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StrtNm", skip_serializing_if = "Option::is_none") )]
	pub strt_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BldgNb", skip_serializing_if = "Option::is_none") )]
	pub bldg_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstCd", skip_serializing_if = "Option::is_none") )]
	pub pst_cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TwnNm", skip_serializing_if = "Option::is_none") )]
	pub twn_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrySubDvsn", skip_serializing_if = "Option::is_none") )]
	pub ctry_sub_dvsn: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ctry") )]
	pub ctry: String,
}

impl PostalAddress1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.adr_tp { val.validate()? }
		if let Some(ref vec) = self.adr_line {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "adr_line is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 70 {
					return Err(ValidationError::new(1002, "adr_line exceeds the maximum length of 70".to_string()));
				}
			}
		}
		if let Some(ref val) = self.strt_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "strt_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 70 {
				return Err(ValidationError::new(1002, "strt_nm exceeds the maximum length of 70".to_string()));
			}
		}
		if let Some(ref val) = self.bldg_nb {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "bldg_nb is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 16 {
				return Err(ValidationError::new(1002, "bldg_nb exceeds the maximum length of 16".to_string()));
			}
		}
		if let Some(ref val) = self.pst_cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "pst_cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 16 {
				return Err(ValidationError::new(1002, "pst_cd exceeds the maximum length of 16".to_string()));
			}
		}
		if let Some(ref val) = self.twn_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "twn_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "twn_nm exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.ctry_sub_dvsn {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "ctry_sub_dvsn is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "ctry_sub_dvsn exceeds the maximum length of 35".to_string()));
			}
		}
		let pattern = Regex::new("[A-Z]{2,2}").unwrap();
		if !pattern.is_match(&self.ctry) {
			return Err(ValidationError::new(1005, "ctry does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// PostalAddress24 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PostalAddress24 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AdrTp", skip_serializing_if = "Option::is_none") )]
	pub adr_tp: Option<AddressType3Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dept", skip_serializing_if = "Option::is_none") )]
	pub dept: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubDept", skip_serializing_if = "Option::is_none") )]
	pub sub_dept: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StrtNm", skip_serializing_if = "Option::is_none") )]
	pub strt_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BldgNb", skip_serializing_if = "Option::is_none") )]
	pub bldg_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BldgNm", skip_serializing_if = "Option::is_none") )]
	pub bldg_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Flr", skip_serializing_if = "Option::is_none") )]
	pub flr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstBx", skip_serializing_if = "Option::is_none") )]
	pub pst_bx: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Room", skip_serializing_if = "Option::is_none") )]
	pub room: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstCd", skip_serializing_if = "Option::is_none") )]
	pub pst_cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TwnNm", skip_serializing_if = "Option::is_none") )]
	pub twn_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TwnLctnNm", skip_serializing_if = "Option::is_none") )]
	pub twn_lctn_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DstrctNm", skip_serializing_if = "Option::is_none") )]
	pub dstrct_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrySubDvsn", skip_serializing_if = "Option::is_none") )]
	pub ctry_sub_dvsn: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ctry", skip_serializing_if = "Option::is_none") )]
	pub ctry: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AdrLine", skip_serializing_if = "Option::is_none") )]
	pub adr_line: Option<Vec<String>>,
}

impl PostalAddress24 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.adr_tp { val.validate()? }
		if let Some(ref val) = self.dept {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "dept is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 70 {
				return Err(ValidationError::new(1002, "dept exceeds the maximum length of 70".to_string()));
			}
		}
		if let Some(ref val) = self.sub_dept {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "sub_dept is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 70 {
				return Err(ValidationError::new(1002, "sub_dept exceeds the maximum length of 70".to_string()));
			}
		}
		if let Some(ref val) = self.strt_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "strt_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 70 {
				return Err(ValidationError::new(1002, "strt_nm exceeds the maximum length of 70".to_string()));
			}
		}
		if let Some(ref val) = self.bldg_nb {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "bldg_nb is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 16 {
				return Err(ValidationError::new(1002, "bldg_nb exceeds the maximum length of 16".to_string()));
			}
		}
		if let Some(ref val) = self.bldg_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "bldg_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "bldg_nm exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.flr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "flr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 70 {
				return Err(ValidationError::new(1002, "flr exceeds the maximum length of 70".to_string()));
			}
		}
		if let Some(ref val) = self.pst_bx {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "pst_bx is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 16 {
				return Err(ValidationError::new(1002, "pst_bx exceeds the maximum length of 16".to_string()));
			}
		}
		if let Some(ref val) = self.room {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "room is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 70 {
				return Err(ValidationError::new(1002, "room exceeds the maximum length of 70".to_string()));
			}
		}
		if let Some(ref val) = self.pst_cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "pst_cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 16 {
				return Err(ValidationError::new(1002, "pst_cd exceeds the maximum length of 16".to_string()));
			}
		}
		if let Some(ref val) = self.twn_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "twn_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "twn_nm exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.twn_lctn_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "twn_lctn_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "twn_lctn_nm exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.dstrct_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "dstrct_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "dstrct_nm exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.ctry_sub_dvsn {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "ctry_sub_dvsn is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "ctry_sub_dvsn exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.ctry {
			let pattern = Regex::new("[A-Z]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ctry does not match the required pattern".to_string()));
			}
		}
		if let Some(ref vec) = self.adr_line {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "adr_line is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 70 {
					return Err(ValidationError::new(1002, "adr_line exceeds the maximum length of 70".to_string()));
				}
			}
		}
		Ok(())
	}
}


// PostalAddress27 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PostalAddress27 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AdrTp", skip_serializing_if = "Option::is_none") )]
	pub adr_tp: Option<AddressType3Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CareOf", skip_serializing_if = "Option::is_none") )]
	pub care_of: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dept", skip_serializing_if = "Option::is_none") )]
	pub dept: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SubDept", skip_serializing_if = "Option::is_none") )]
	pub sub_dept: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StrtNm", skip_serializing_if = "Option::is_none") )]
	pub strt_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BldgNb", skip_serializing_if = "Option::is_none") )]
	pub bldg_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BldgNm", skip_serializing_if = "Option::is_none") )]
	pub bldg_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Flr", skip_serializing_if = "Option::is_none") )]
	pub flr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnitNb", skip_serializing_if = "Option::is_none") )]
	pub unit_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstBx", skip_serializing_if = "Option::is_none") )]
	pub pst_bx: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Room", skip_serializing_if = "Option::is_none") )]
	pub room: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstCd", skip_serializing_if = "Option::is_none") )]
	pub pst_cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TwnNm", skip_serializing_if = "Option::is_none") )]
	pub twn_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TwnLctnNm", skip_serializing_if = "Option::is_none") )]
	pub twn_lctn_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DstrctNm", skip_serializing_if = "Option::is_none") )]
	pub dstrct_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrySubDvsn", skip_serializing_if = "Option::is_none") )]
	pub ctry_sub_dvsn: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ctry", skip_serializing_if = "Option::is_none") )]
	pub ctry: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AdrLine", skip_serializing_if = "Option::is_none") )]
	pub adr_line: Option<Vec<String>>,
}

impl PostalAddress27 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.adr_tp { val.validate()? }
		if let Some(ref val) = self.care_of {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "care_of is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "care_of exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.dept {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "dept is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 70 {
				return Err(ValidationError::new(1002, "dept exceeds the maximum length of 70".to_string()));
			}
		}
		if let Some(ref val) = self.sub_dept {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "sub_dept is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 70 {
				return Err(ValidationError::new(1002, "sub_dept exceeds the maximum length of 70".to_string()));
			}
		}
		if let Some(ref val) = self.strt_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "strt_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "strt_nm exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.bldg_nb {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "bldg_nb is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 16 {
				return Err(ValidationError::new(1002, "bldg_nb exceeds the maximum length of 16".to_string()));
			}
		}
		if let Some(ref val) = self.bldg_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "bldg_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "bldg_nm exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.flr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "flr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 70 {
				return Err(ValidationError::new(1002, "flr exceeds the maximum length of 70".to_string()));
			}
		}
		if let Some(ref val) = self.unit_nb {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "unit_nb is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 16 {
				return Err(ValidationError::new(1002, "unit_nb exceeds the maximum length of 16".to_string()));
			}
		}
		if let Some(ref val) = self.pst_bx {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "pst_bx is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 16 {
				return Err(ValidationError::new(1002, "pst_bx exceeds the maximum length of 16".to_string()));
			}
		}
		if let Some(ref val) = self.room {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "room is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 70 {
				return Err(ValidationError::new(1002, "room exceeds the maximum length of 70".to_string()));
			}
		}
		if let Some(ref val) = self.pst_cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "pst_cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 16 {
				return Err(ValidationError::new(1002, "pst_cd exceeds the maximum length of 16".to_string()));
			}
		}
		if let Some(ref val) = self.twn_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "twn_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "twn_nm exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.twn_lctn_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "twn_lctn_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "twn_lctn_nm exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.dstrct_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "dstrct_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "dstrct_nm exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.ctry_sub_dvsn {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "ctry_sub_dvsn is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "ctry_sub_dvsn exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.ctry {
			let pattern = Regex::new("[A-Z]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ctry does not match the required pattern".to_string()));
			}
		}
		if let Some(ref vec) = self.adr_line {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "adr_line is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 70 {
					return Err(ValidationError::new(1002, "adr_line exceeds the maximum length of 70".to_string()));
				}
			}
		}
		Ok(())
	}
}


// PreferredContactMethod1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum PreferredContactMethod1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "LETT") )]
	CodeLETT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MAIL") )]
	CodeMAIL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PHON") )]
	CodePHON,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FAXX") )]
	CodeFAXX,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CELL") )]
	CodeCELL,
}

impl PreferredContactMethod1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// PreferredContactMethod2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum PreferredContactMethod2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "MAIL") )]
	CodeMAIL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FAXX") )]
	CodeFAXX,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LETT") )]
	CodeLETT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CELL") )]
	CodeCELL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ONLI") )]
	CodeONLI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PHON") )]
	CodePHON,
}

impl PreferredContactMethod2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// Price7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Price7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: YieldedOrValueType1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val") )]
	pub val: PriceRateOrAmount3Choice,
}

impl Price7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.tp.validate()?;
		self.val.validate()?;
		Ok(())
	}
}


// PriceRateOrAmount3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PriceRateOrAmount3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rate", skip_serializing_if = "Option::is_none") )]
	pub rate: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt", skip_serializing_if = "Option::is_none") )]
	pub amt: Option<ActiveOrHistoricCurrencyAnd13DecimalAmount>,
}

impl PriceRateOrAmount3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.amt { val.validate()? }
		Ok(())
	}
}


// PriceValue1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PriceValue1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveCurrencyAnd13DecimalAmount,
}

impl PriceValue1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.amt.validate()?;
		Ok(())
	}
}


// PriceValueType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum PriceValueType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "DISC") )]
	CodeDISC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PREM") )]
	CodePREM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PARV") )]
	CodePARV,
}

impl PriceValueType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// Priority1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Priority1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<Priority5Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl Priority1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// Priority1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum Priority1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "HIGH") )]
	CodeHIGH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NORM") )]
	CodeNORM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LOWW") )]
	CodeLOWW,
}

impl Priority1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// Priority2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum Priority2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "HIGH") )]
	CodeHIGH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NORM") )]
	CodeNORM,
}

impl Priority2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// Priority5Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum Priority5Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "HIGH") )]
	CodeHIGH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LOWW") )]
	CodeLOWW,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NORM") )]
	CodeNORM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "URGT") )]
	CodeURGT,
}

impl Priority5Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// PriorityNumeric4Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct PriorityNumeric4Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nmrc", skip_serializing_if = "Option::is_none") )]
	pub nmrc: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification30>,
}

impl PriorityNumeric4Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.nmrc {
			let pattern = Regex::new("[0-9]{4}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "nmrc does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// ProcessingPosition3Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum ProcessingPosition3Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "AFTE") )]
	CodeAFTE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "WITH") )]
	CodeWITH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BEFO") )]
	CodeBEFO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INFO") )]
	CodeINFO,
}

impl ProcessingPosition3Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ProcessingPosition7Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ProcessingPosition7Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<ProcessingPosition3Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification30>,
}

impl ProcessingPosition7Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// ProcessingStatus66Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ProcessingStatus66Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AckdAccptd", skip_serializing_if = "Option::is_none") )]
	pub ackd_accptd: Option<AcknowledgedAcceptedStatus21Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rpr", skip_serializing_if = "Option::is_none") )]
	pub rpr: Option<RejectionOrRepairStatus38Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Canc", skip_serializing_if = "Option::is_none") )]
	pub canc: Option<CancellationStatus14Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<ProprietaryStatusAndReason6>,
}

impl ProcessingStatus66Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ackd_accptd { val.validate()? }
		if let Some(ref val) = self.rpr { val.validate()? }
		if let Some(ref val) = self.canc { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// ProcessingStatus67Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ProcessingStatus67Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rjctd", skip_serializing_if = "Option::is_none") )]
	pub rjctd: Option<RejectionOrRepairStatus38Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rpr", skip_serializing_if = "Option::is_none") )]
	pub rpr: Option<RejectionOrRepairStatus38Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Canc", skip_serializing_if = "Option::is_none") )]
	pub canc: Option<CancellationStatus14Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AckdAccptd", skip_serializing_if = "Option::is_none") )]
	pub ackd_accptd: Option<AcknowledgedAcceptedStatus21Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<ProprietaryStatusAndReason6>,
}

impl ProcessingStatus67Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.rjctd { val.validate()? }
		if let Some(ref val) = self.rpr { val.validate()? }
		if let Some(ref val) = self.canc { val.validate()? }
		if let Some(ref val) = self.ackd_accptd { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// ProcessingStatus68Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ProcessingStatus68Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<TransactionProcessingStatus3Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification30>,
}

impl ProcessingStatus68Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// ProcessingStatus69Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ProcessingStatus69Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PdgCxl", skip_serializing_if = "Option::is_none") )]
	pub pdg_cxl: Option<PendingStatus39Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rjctd", skip_serializing_if = "Option::is_none") )]
	pub rjctd: Option<RejectionOrRepairStatus39Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rpr", skip_serializing_if = "Option::is_none") )]
	pub rpr: Option<RejectionOrRepairStatus39Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AckdAccptd", skip_serializing_if = "Option::is_none") )]
	pub ackd_accptd: Option<AcknowledgedAcceptedStatus24Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<ProprietaryStatusAndReason6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dnd", skip_serializing_if = "Option::is_none") )]
	pub dnd: Option<DeniedStatus16Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Canc", skip_serializing_if = "Option::is_none") )]
	pub canc: Option<CancellationStatus15Choice>,
}

impl ProcessingStatus69Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.pdg_cxl { val.validate()? }
		if let Some(ref val) = self.rjctd { val.validate()? }
		if let Some(ref val) = self.rpr { val.validate()? }
		if let Some(ref val) = self.ackd_accptd { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		if let Some(ref val) = self.dnd { val.validate()? }
		if let Some(ref val) = self.canc { val.validate()? }
		Ok(())
	}
}


// ProcessingStatus71Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ProcessingStatus71Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AckdAccptd", skip_serializing_if = "Option::is_none") )]
	pub ackd_accptd: Option<AcknowledgedAcceptedStatus21Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pdg", skip_serializing_if = "Option::is_none") )]
	pub pdg: Option<PendingStatus38Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rjctd", skip_serializing_if = "Option::is_none") )]
	pub rjctd: Option<RejectionOrRepairStatus40Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rpr", skip_serializing_if = "Option::is_none") )]
	pub rpr: Option<RejectionOrRepairStatus39Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dnd", skip_serializing_if = "Option::is_none") )]
	pub dnd: Option<DeniedStatus16Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cmpltd", skip_serializing_if = "Option::is_none") )]
	pub cmpltd: Option<ProprietaryReason4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<ProprietaryStatusAndReason6>,
}

impl ProcessingStatus71Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ackd_accptd { val.validate()? }
		if let Some(ref val) = self.pdg { val.validate()? }
		if let Some(ref val) = self.rjctd { val.validate()? }
		if let Some(ref val) = self.rpr { val.validate()? }
		if let Some(ref val) = self.dnd { val.validate()? }
		if let Some(ref val) = self.cmpltd { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// ProcessingType1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ProcessingType1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<ProcessingType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl ProcessingType1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// ProcessingType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum ProcessingType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "RJCT") )]
	CodeRJCT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CVHD") )]
	CodeCVHD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RSVT") )]
	CodeRSVT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BLCK") )]
	CodeBLCK,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EARM") )]
	CodeEARM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EFAC") )]
	CodeEFAC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DLVR") )]
	CodeDLVR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "COLD") )]
	CodeCOLD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CSDB") )]
	CodeCSDB,
}

impl ProcessingType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// Product2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Product2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PdctCd") )]
	pub pdct_cd: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnitOfMeasr", skip_serializing_if = "Option::is_none") )]
	pub unit_of_measr: Option<UnitOfMeasure1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PdctQty", skip_serializing_if = "Option::is_none") )]
	pub pdct_qty: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UnitPric", skip_serializing_if = "Option::is_none") )]
	pub unit_pric: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PdctAmt", skip_serializing_if = "Option::is_none") )]
	pub pdct_amt: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TaxTp", skip_serializing_if = "Option::is_none") )]
	pub tax_tp: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlPdctInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_pdct_inf: Option<String>,
}

impl Product2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.pdct_cd.chars().count() < 1 {
			return Err(ValidationError::new(1001, "pdct_cd is shorter than the minimum length of 1".to_string()));
		}
		if self.pdct_cd.chars().count() > 70 {
			return Err(ValidationError::new(1002, "pdct_cd exceeds the maximum length of 70".to_string()));
		}
		if let Some(ref val) = self.unit_of_measr { val.validate()? }
		if let Some(ref val) = self.tax_tp {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tax_tp is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "tax_tp exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.addtl_pdct_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_pdct_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "addtl_pdct_inf exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// ProprietaryAgent5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ProprietaryAgent5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Agt") )]
	pub agt: BranchAndFinancialInstitutionIdentification8,
}

impl ProprietaryAgent5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.tp.chars().count() < 1 {
			return Err(ValidationError::new(1001, "tp is shorter than the minimum length of 1".to_string()));
		}
		if self.tp.chars().count() > 35 {
			return Err(ValidationError::new(1002, "tp exceeds the maximum length of 35".to_string()));
		}
		self.agt.validate()?;
		Ok(())
	}
}


// ProprietaryBankTransactionCodeStructure1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ProprietaryBankTransactionCodeStructure1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd") )]
	pub cd: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr", skip_serializing_if = "Option::is_none") )]
	pub issr: Option<String>,
}

impl ProprietaryBankTransactionCodeStructure1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.cd.chars().count() < 1 {
			return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
		}
		if self.cd.chars().count() > 35 {
			return Err(ValidationError::new(1002, "cd exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.issr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "issr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "issr exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// ProprietaryData6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ProprietaryData6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Any") )]
	pub any: SkipPayload,
}

impl ProprietaryData6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.any.validate()?;
		Ok(())
	}
}


// ProprietaryData7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ProprietaryData7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Data") )]
	pub data: ProprietaryData6,
}

impl ProprietaryData7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.tp.chars().count() < 1 {
			return Err(ValidationError::new(1001, "tp is shorter than the minimum length of 1".to_string()));
		}
		if self.tp.chars().count() > 35 {
			return Err(ValidationError::new(1002, "tp exceeds the maximum length of 35".to_string()));
		}
		self.data.validate()?;
		Ok(())
	}
}


// ProprietaryDate3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ProprietaryDate3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dt") )]
	pub dt: DateAndDateTime2Choice,
}

impl ProprietaryDate3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.tp.chars().count() < 1 {
			return Err(ValidationError::new(1001, "tp is shorter than the minimum length of 1".to_string()));
		}
		if self.tp.chars().count() > 35 {
			return Err(ValidationError::new(1002, "tp exceeds the maximum length of 35".to_string()));
		}
		self.dt.validate()?;
		Ok(())
	}
}


// ProprietaryParty6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ProprietaryParty6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pty") )]
	pub pty: Party50Choice,
}

impl ProprietaryParty6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.tp.chars().count() < 1 {
			return Err(ValidationError::new(1001, "tp is shorter than the minimum length of 1".to_string()));
		}
		if self.tp.chars().count() > 35 {
			return Err(ValidationError::new(1002, "tp exceeds the maximum length of 35".to_string()));
		}
		self.pty.validate()?;
		Ok(())
	}
}


// ProprietaryPrice2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ProprietaryPrice2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pric") )]
	pub pric: ActiveOrHistoricCurrencyAndAmount,
}

impl ProprietaryPrice2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.tp.chars().count() < 1 {
			return Err(ValidationError::new(1001, "tp is shorter than the minimum length of 1".to_string()));
		}
		if self.tp.chars().count() > 35 {
			return Err(ValidationError::new(1002, "tp exceeds the maximum length of 35".to_string()));
		}
		self.pric.validate()?;
		Ok(())
	}
}


// ProprietaryQuantity1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ProprietaryQuantity1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Qty") )]
	pub qty: String,
}

impl ProprietaryQuantity1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.tp.chars().count() < 1 {
			return Err(ValidationError::new(1001, "tp is shorter than the minimum length of 1".to_string()));
		}
		if self.tp.chars().count() > 35 {
			return Err(ValidationError::new(1002, "tp exceeds the maximum length of 35".to_string()));
		}
		if self.qty.chars().count() < 1 {
			return Err(ValidationError::new(1001, "qty is shorter than the minimum length of 1".to_string()));
		}
		if self.qty.chars().count() > 35 {
			return Err(ValidationError::new(1002, "qty exceeds the maximum length of 35".to_string()));
		}
		Ok(())
	}
}


// ProprietaryReason4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ProprietaryReason4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn", skip_serializing_if = "Option::is_none") )]
	pub rsn: Option<GenericIdentification30>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlRsnInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_rsn_inf: Option<String>,
}

impl ProprietaryReason4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.rsn { val.validate()? }
		if let Some(ref val) = self.addtl_rsn_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_rsn_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 210 {
				return Err(ValidationError::new(1002, "addtl_rsn_inf exceeds the maximum length of 210".to_string()));
			}
		}
		Ok(())
	}
}


// ProprietaryReference1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ProprietaryReference1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ref") )]
	pub ref_attr: String,
}

impl ProprietaryReference1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.tp.chars().count() < 1 {
			return Err(ValidationError::new(1001, "tp is shorter than the minimum length of 1".to_string()));
		}
		if self.tp.chars().count() > 35 {
			return Err(ValidationError::new(1002, "tp exceeds the maximum length of 35".to_string()));
		}
		if self.ref_attr.chars().count() < 1 {
			return Err(ValidationError::new(1001, "ref_attr is shorter than the minimum length of 1".to_string()));
		}
		if self.ref_attr.chars().count() > 35 {
			return Err(ValidationError::new(1002, "ref_attr exceeds the maximum length of 35".to_string()));
		}
		Ok(())
	}
}


// ProprietaryStatusAndReason6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ProprietaryStatusAndReason6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrtrySts") )]
	pub prtry_sts: GenericIdentification30,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrtryRsn", skip_serializing_if = "Option::is_none") )]
	pub prtry_rsn: Option<Vec<ProprietaryReason4>>,
}

impl ProprietaryStatusAndReason6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.prtry_sts.validate()?;
		if let Some(ref vec) = self.prtry_rsn { for item in vec { item.validate()? } }
		Ok(())
	}
}


// ProprietaryStatusJustification2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ProprietaryStatusJustification2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrtryStsRsn") )]
	pub prtry_sts_rsn: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn") )]
	pub rsn: String,
}

impl ProprietaryStatusJustification2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.prtry_sts_rsn.chars().count() < 1 {
			return Err(ValidationError::new(1001, "prtry_sts_rsn is shorter than the minimum length of 1".to_string()));
		}
		if self.prtry_sts_rsn.chars().count() > 4 {
			return Err(ValidationError::new(1002, "prtry_sts_rsn exceeds the maximum length of 4".to_string()));
		}
		let pattern = Regex::new("[a-zA-Z0-9]{1,4}").unwrap();
		if !pattern.is_match(&self.prtry_sts_rsn) {
			return Err(ValidationError::new(1005, "prtry_sts_rsn does not match the required pattern".to_string()));
		}
		if self.rsn.chars().count() < 1 {
			return Err(ValidationError::new(1001, "rsn is shorter than the minimum length of 1".to_string()));
		}
		if self.rsn.chars().count() > 256 {
			return Err(ValidationError::new(1002, "rsn exceeds the maximum length of 256".to_string()));
		}
		Ok(())
	}
}


// ProxyAccountIdentification1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ProxyAccountIdentification1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<ProxyAccountType1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
}

impl ProxyAccountIdentification1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tp { val.validate()? }
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 2048 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 2048".to_string()));
		}
		Ok(())
	}
}


// ProxyAccountType1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ProxyAccountType1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl ProxyAccountType1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// Purpose2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Purpose2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl Purpose2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// QuantityType1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct QuantityType1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<OrderQuantityType2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification47>,
}

impl QuantityType1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// QueryType2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum QueryType2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ALLL") )]
	CodeALLL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CHNG") )]
	CodeCHNG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MODF") )]
	CodeMODF,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DELD") )]
	CodeDELD,
}

impl QueryType2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// QueryType3Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum QueryType3Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ALLL") )]
	CodeALLL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CHNG") )]
	CodeCHNG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MODF") )]
	CodeMODF,
}

impl QueryType3Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// QueueTransactionIdentification1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct QueueTransactionIdentification1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "QId") )]
	pub q_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PosInQ") )]
	pub pos_in_q: String,
}

impl QueueTransactionIdentification1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.q_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "q_id is shorter than the minimum length of 1".to_string()));
		}
		if self.q_id.chars().count() > 16 {
			return Err(ValidationError::new(1002, "q_id exceeds the maximum length of 16".to_string()));
		}
		if self.pos_in_q.chars().count() < 1 {
			return Err(ValidationError::new(1001, "pos_in_q is shorter than the minimum length of 1".to_string()));
		}
		if self.pos_in_q.chars().count() > 16 {
			return Err(ValidationError::new(1002, "pos_in_q exceeds the maximum length of 16".to_string()));
		}
		Ok(())
	}
}


// Rate4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Rate4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: RateType4Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VldtyRg", skip_serializing_if = "Option::is_none") )]
	pub vldty_rg: Option<ActiveOrHistoricCurrencyAndAmountRange2>,
}

impl Rate4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.tp.validate()?;
		if let Some(ref val) = self.vldty_rg { val.validate()? }
		Ok(())
	}
}


// RateType4Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct RateType4Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pctg", skip_serializing_if = "Option::is_none") )]
	pub pctg: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<String>,
}

impl RateType4Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.othr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "othr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "othr exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// Receipt6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Receipt6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlMsgId") )]
	pub orgnl_msg_id: OriginalMessageAndIssuer1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlPmtId", skip_serializing_if = "Option::is_none") )]
	pub orgnl_pmt_id: Option<PaymentIdentification8Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReqHdlg", skip_serializing_if = "Option::is_none") )]
	pub req_hdlg: Option<Vec<RequestHandling3>>,
}

impl Receipt6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.orgnl_msg_id.validate()?;
		if let Some(ref val) = self.orgnl_pmt_id { val.validate()? }
		if let Some(ref vec) = self.req_hdlg { for item in vec { item.validate()? } }
		Ok(())
	}
}


// References14 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct References14 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctOwnrTxId", skip_serializing_if = "Option::is_none") )]
	pub acct_ownr_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctSvcrTxId", skip_serializing_if = "Option::is_none") )]
	pub acct_svcr_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MktInfrstrctrTxId", skip_serializing_if = "Option::is_none") )]
	pub mkt_infrstrctr_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrcrTxId", skip_serializing_if = "Option::is_none") )]
	pub prcr_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PoolId", skip_serializing_if = "Option::is_none") )]
	pub pool_id: Option<String>,
}

impl References14 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.acct_ownr_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "acct_ownr_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "acct_ownr_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.acct_svcr_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "acct_svcr_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "acct_svcr_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.mkt_infrstrctr_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "mkt_infrstrctr_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "mkt_infrstrctr_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.prcr_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prcr_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prcr_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.pool_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "pool_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "pool_id exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// References34Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct References34Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SctiesSttlmTxId", skip_serializing_if = "Option::is_none") )]
	pub scties_sttlm_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntraPosMvmntId", skip_serializing_if = "Option::is_none") )]
	pub intra_pos_mvmnt_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntraBalMvmntId", skip_serializing_if = "Option::is_none") )]
	pub intra_bal_mvmnt_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctSvcrTxId", skip_serializing_if = "Option::is_none") )]
	pub acct_svcr_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MktInfrstrctrTxId", skip_serializing_if = "Option::is_none") )]
	pub mkt_infrstrctr_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PoolId", skip_serializing_if = "Option::is_none") )]
	pub pool_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrTxId", skip_serializing_if = "Option::is_none") )]
	pub othr_tx_id: Option<String>,
}

impl References34Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.scties_sttlm_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "scties_sttlm_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "scties_sttlm_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.intra_pos_mvmnt_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "intra_pos_mvmnt_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "intra_pos_mvmnt_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.intra_bal_mvmnt_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "intra_bal_mvmnt_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "intra_bal_mvmnt_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.acct_svcr_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "acct_svcr_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "acct_svcr_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.mkt_infrstrctr_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "mkt_infrstrctr_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "mkt_infrstrctr_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.pool_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "pool_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "pool_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.othr_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "othr_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "othr_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// References36Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct References36Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctOwnrTxId", skip_serializing_if = "Option::is_none") )]
	pub acct_ownr_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctSvcrTxId", skip_serializing_if = "Option::is_none") )]
	pub acct_svcr_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MktInfrstrctrTxId", skip_serializing_if = "Option::is_none") )]
	pub mkt_infrstrctr_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrcrTxId", skip_serializing_if = "Option::is_none") )]
	pub prcr_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PoolId", skip_serializing_if = "Option::is_none") )]
	pub pool_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CorpActnEvtId", skip_serializing_if = "Option::is_none") )]
	pub corp_actn_evt_id: Option<String>,
}

impl References36Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.acct_ownr_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "acct_ownr_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "acct_ownr_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.acct_svcr_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "acct_svcr_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "acct_svcr_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.mkt_infrstrctr_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "mkt_infrstrctr_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "mkt_infrstrctr_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.prcr_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prcr_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prcr_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.pool_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "pool_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "pool_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.corp_actn_evt_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "corp_actn_evt_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "corp_actn_evt_id exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// References74Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct References74Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SctiesSttlmTxId", skip_serializing_if = "Option::is_none") )]
	pub scties_sttlm_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntraPosMvmntId", skip_serializing_if = "Option::is_none") )]
	pub intra_pos_mvmnt_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntraBalMvmntId", skip_serializing_if = "Option::is_none") )]
	pub intra_bal_mvmnt_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctSvcrTxId", skip_serializing_if = "Option::is_none") )]
	pub acct_svcr_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MktInfrstrctrTxId", skip_serializing_if = "Option::is_none") )]
	pub mkt_infrstrctr_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrPtyMktInfrstrctrTxId", skip_serializing_if = "Option::is_none") )]
	pub ctr_pty_mkt_infrstrctr_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PoolId", skip_serializing_if = "Option::is_none") )]
	pub pool_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CmonId", skip_serializing_if = "Option::is_none") )]
	pub cmon_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradId", skip_serializing_if = "Option::is_none") )]
	pub trad_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrTxId", skip_serializing_if = "Option::is_none") )]
	pub othr_tx_id: Option<String>,
}

impl References74Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.scties_sttlm_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "scties_sttlm_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "scties_sttlm_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.intra_pos_mvmnt_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "intra_pos_mvmnt_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "intra_pos_mvmnt_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.intra_bal_mvmnt_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "intra_bal_mvmnt_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "intra_bal_mvmnt_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.acct_svcr_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "acct_svcr_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "acct_svcr_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.mkt_infrstrctr_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "mkt_infrstrctr_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "mkt_infrstrctr_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.ctr_pty_mkt_infrstrctr_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "ctr_pty_mkt_infrstrctr_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "ctr_pty_mkt_infrstrctr_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.pool_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "pool_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "pool_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.cmon_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cmon_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "cmon_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.trad_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "trad_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 52 {
				return Err(ValidationError::new(1002, "trad_id exceeds the maximum length of 52".to_string()));
			}
		}
		if let Some(ref val) = self.othr_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "othr_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "othr_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// ReferredDocumentInformation7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ReferredDocumentInformation7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<ReferredDocumentType4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nb", skip_serializing_if = "Option::is_none") )]
	pub nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RltdDt", skip_serializing_if = "Option::is_none") )]
	pub rltd_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LineDtls", skip_serializing_if = "Option::is_none") )]
	pub line_dtls: Option<Vec<DocumentLineInformation1>>,
}

impl ReferredDocumentInformation7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tp { val.validate()? }
		if let Some(ref val) = self.nb {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nb is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "nb exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref vec) = self.line_dtls { for item in vec { item.validate()? } }
		Ok(())
	}
}


// ReferredDocumentInformation8 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ReferredDocumentInformation8 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<DocumentType1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nb", skip_serializing_if = "Option::is_none") )]
	pub nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RltdDt", skip_serializing_if = "Option::is_none") )]
	pub rltd_dt: Option<DateAndType1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LineDtls", skip_serializing_if = "Option::is_none") )]
	pub line_dtls: Option<Vec<DocumentLineInformation2>>,
}

impl ReferredDocumentInformation8 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tp { val.validate()? }
		if let Some(ref val) = self.nb {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nb is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "nb exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.rltd_dt { val.validate()? }
		if let Some(ref vec) = self.line_dtls { for item in vec { item.validate()? } }
		Ok(())
	}
}


// ReferredDocumentType3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ReferredDocumentType3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<DocumentType6Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl ReferredDocumentType3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// ReferredDocumentType4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ReferredDocumentType4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdOrPrtry") )]
	pub cd_or_prtry: ReferredDocumentType3Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Issr", skip_serializing_if = "Option::is_none") )]
	pub issr: Option<String>,
}

impl ReferredDocumentType4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.cd_or_prtry.validate()?;
		if let Some(ref val) = self.issr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "issr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "issr exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// RejectionAndRepairReason32Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct RejectionAndRepairReason32Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<RejectionReason33Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification30>,
}

impl RejectionAndRepairReason32Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// RejectionAndRepairReason33Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct RejectionAndRepairReason33Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<RejectionReason34Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification30>,
}

impl RejectionAndRepairReason33Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// RejectionAndRepairReason34Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct RejectionAndRepairReason34Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<RejectionReason35Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification30>,
}

impl RejectionAndRepairReason34Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// RejectionOrRepairReason32 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct RejectionOrRepairReason32 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<Vec<RejectionAndRepairReason32Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlRsnInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_rsn_inf: Option<String>,
}

impl RejectionOrRepairReason32 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.cd { for item in vec { item.validate()? } }
		if let Some(ref val) = self.addtl_rsn_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_rsn_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 210 {
				return Err(ValidationError::new(1002, "addtl_rsn_inf exceeds the maximum length of 210".to_string()));
			}
		}
		Ok(())
	}
}


// RejectionOrRepairReason33 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct RejectionOrRepairReason33 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd") )]
	pub cd: RejectionAndRepairReason33Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlRsnInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_rsn_inf: Option<String>,
}

impl RejectionOrRepairReason33 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.cd.validate()?;
		if let Some(ref val) = self.addtl_rsn_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_rsn_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 210 {
				return Err(ValidationError::new(1002, "addtl_rsn_inf exceeds the maximum length of 210".to_string()));
			}
		}
		Ok(())
	}
}


// RejectionOrRepairReason34 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct RejectionOrRepairReason34 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd") )]
	pub cd: RejectionAndRepairReason34Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlRsnInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_rsn_inf: Option<String>,
}

impl RejectionOrRepairReason34 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.cd.validate()?;
		if let Some(ref val) = self.addtl_rsn_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_rsn_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 210 {
				return Err(ValidationError::new(1002, "addtl_rsn_inf exceeds the maximum length of 210".to_string()));
			}
		}
		Ok(())
	}
}


// RejectionOrRepairStatus38Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct RejectionOrRepairStatus38Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NoSpcfdRsn", skip_serializing_if = "Option::is_none") )]
	pub no_spcfd_rsn: Option<NoReasonCode>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn", skip_serializing_if = "Option::is_none") )]
	pub rsn: Option<Vec<RejectionOrRepairReason32>>,
}

impl RejectionOrRepairStatus38Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.no_spcfd_rsn { val.validate()? }
		if let Some(ref vec) = self.rsn { for item in vec { item.validate()? } }
		Ok(())
	}
}


// RejectionOrRepairStatus39Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct RejectionOrRepairStatus39Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NoSpcfdRsn", skip_serializing_if = "Option::is_none") )]
	pub no_spcfd_rsn: Option<NoReasonCode>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn", skip_serializing_if = "Option::is_none") )]
	pub rsn: Option<Vec<RejectionOrRepairReason33>>,
}

impl RejectionOrRepairStatus39Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.no_spcfd_rsn { val.validate()? }
		if let Some(ref vec) = self.rsn { for item in vec { item.validate()? } }
		Ok(())
	}
}


// RejectionOrRepairStatus40Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct RejectionOrRepairStatus40Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NoSpcfdRsn", skip_serializing_if = "Option::is_none") )]
	pub no_spcfd_rsn: Option<NoReasonCode>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn", skip_serializing_if = "Option::is_none") )]
	pub rsn: Option<Vec<RejectionOrRepairReason34>>,
}

impl RejectionOrRepairStatus40Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.no_spcfd_rsn { val.validate()? }
		if let Some(ref vec) = self.rsn { for item in vec { item.validate()? } }
		Ok(())
	}
}


// RejectionReason33Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum RejectionReason33Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "CASH") )]
	CodeCASH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ADEA") )]
	CodeADEA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DMON") )]
	CodeDMON,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NCRR") )]
	CodeNCRR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LATE") )]
	CodeLATE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INVL") )]
	CodeINVL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INVB") )]
	CodeINVB,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INVN") )]
	CodeINVN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VALR") )]
	CodeVALR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MONY") )]
	CodeMONY,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CAEV") )]
	CodeCAEV,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DDAT") )]
	CodeDDAT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "REFE") )]
	CodeREFE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DQUA") )]
	CodeDQUA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DSEC") )]
	CodeDSEC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MINO") )]
	CodeMINO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MUNO") )]
	CodeMUNO,
}

impl RejectionReason33Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// RejectionReason34Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum RejectionReason34Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ADEA") )]
	CodeADEA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LATE") )]
	CodeLATE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CASH") )]
	CodeCASH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NRGM") )]
	CodeNRGM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NRGN") )]
	CodeNRGN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "REFE") )]
	CodeREFE,
}

impl RejectionReason34Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// RejectionReason35Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum RejectionReason35Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "CASH") )]
	CodeCASH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ADEA") )]
	CodeADEA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "REFE") )]
	CodeREFE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LATE") )]
	CodeLATE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DDAT") )]
	CodeDDAT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NRGN") )]
	CodeNRGN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHR") )]
	CodeOTHR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INVM") )]
	CodeINVM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INVL") )]
	CodeINVL,
}

impl RejectionReason35Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// RelatedInvestigationData1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct RelatedInvestigationData1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "InvstgtnId", skip_serializing_if = "Option::is_none") )]
	pub invstgtn_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Lctn", skip_serializing_if = "Option::is_none") )]
	pub lctn: Option<Vec<InvestigationLocationData1>>,
}

impl RelatedInvestigationData1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.invstgtn_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "invstgtn_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "invstgtn_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref vec) = self.lctn { for item in vec { item.validate()? } }
		Ok(())
	}
}


// Remittance1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Remittance1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ustrd", skip_serializing_if = "Option::is_none") )]
	pub ustrd: Option<Vec<String>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Strd", skip_serializing_if = "Option::is_none") )]
	pub strd: Option<Vec<StructuredRemittanceInformation16>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rltd", skip_serializing_if = "Option::is_none") )]
	pub rltd: Option<Vec<RemittanceLocation7>>,
}

impl Remittance1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.ustrd {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "ustrd is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 140 {
					return Err(ValidationError::new(1002, "ustrd exceeds the maximum length of 140".to_string()));
				}
			}
		}
		if let Some(ref vec) = self.strd { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.rltd { for item in vec { item.validate()? } }
		Ok(())
	}
}


// RemittanceAmount2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct RemittanceAmount2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DuePyblAmt", skip_serializing_if = "Option::is_none") )]
	pub due_pybl_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DscntApldAmt", skip_serializing_if = "Option::is_none") )]
	pub dscnt_apld_amt: Option<Vec<DiscountAmountAndType1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtNoteAmt", skip_serializing_if = "Option::is_none") )]
	pub cdt_note_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TaxAmt", skip_serializing_if = "Option::is_none") )]
	pub tax_amt: Option<Vec<TaxAmountAndType1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AdjstmntAmtAndRsn", skip_serializing_if = "Option::is_none") )]
	pub adjstmnt_amt_and_rsn: Option<Vec<DocumentAdjustment1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RmtdAmt", skip_serializing_if = "Option::is_none") )]
	pub rmtd_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
}

impl RemittanceAmount2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.due_pybl_amt { val.validate()? }
		if let Some(ref vec) = self.dscnt_apld_amt { for item in vec { item.validate()? } }
		if let Some(ref val) = self.cdt_note_amt { val.validate()? }
		if let Some(ref vec) = self.tax_amt { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.adjstmnt_amt_and_rsn { for item in vec { item.validate()? } }
		if let Some(ref val) = self.rmtd_amt { val.validate()? }
		Ok(())
	}
}


// RemittanceAmount3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct RemittanceAmount3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DuePyblAmt", skip_serializing_if = "Option::is_none") )]
	pub due_pybl_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DscntApldAmt", skip_serializing_if = "Option::is_none") )]
	pub dscnt_apld_amt: Option<Vec<DiscountAmountAndType1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtNoteAmt", skip_serializing_if = "Option::is_none") )]
	pub cdt_note_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TaxAmt", skip_serializing_if = "Option::is_none") )]
	pub tax_amt: Option<Vec<TaxAmountAndType1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AdjstmntAmtAndRsn", skip_serializing_if = "Option::is_none") )]
	pub adjstmnt_amt_and_rsn: Option<Vec<DocumentAdjustment1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RmtdAmt", skip_serializing_if = "Option::is_none") )]
	pub rmtd_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
}

impl RemittanceAmount3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.due_pybl_amt { val.validate()? }
		if let Some(ref vec) = self.dscnt_apld_amt { for item in vec { item.validate()? } }
		if let Some(ref val) = self.cdt_note_amt { val.validate()? }
		if let Some(ref vec) = self.tax_amt { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.adjstmnt_amt_and_rsn { for item in vec { item.validate()? } }
		if let Some(ref val) = self.rmtd_amt { val.validate()? }
		Ok(())
	}
}


// RemittanceAmount4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct RemittanceAmount4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RmtAmtAndTp", skip_serializing_if = "Option::is_none") )]
	pub rmt_amt_and_tp: Option<Vec<DocumentAmount1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AdjstmntAmtAndRsn", skip_serializing_if = "Option::is_none") )]
	pub adjstmnt_amt_and_rsn: Option<Vec<DocumentAdjustment1>>,
}

impl RemittanceAmount4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.rmt_amt_and_tp { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.adjstmnt_amt_and_rsn { for item in vec { item.validate()? } }
		Ok(())
	}
}


// RemittanceInformation21 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct RemittanceInformation21 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ustrd", skip_serializing_if = "Option::is_none") )]
	pub ustrd: Option<Vec<String>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Strd", skip_serializing_if = "Option::is_none") )]
	pub strd: Option<Vec<StructuredRemittanceInformation17>>,
}

impl RemittanceInformation21 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.ustrd {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "ustrd is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 140 {
					return Err(ValidationError::new(1002, "ustrd exceeds the maximum length of 140".to_string()));
				}
			}
		}
		if let Some(ref vec) = self.strd { for item in vec { item.validate()? } }
		Ok(())
	}
}


// RemittanceInformation22 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct RemittanceInformation22 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ustrd", skip_serializing_if = "Option::is_none") )]
	pub ustrd: Option<Vec<String>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Strd", skip_serializing_if = "Option::is_none") )]
	pub strd: Option<Vec<StructuredRemittanceInformation18>>,
}

impl RemittanceInformation22 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.ustrd {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "ustrd is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 140 {
					return Err(ValidationError::new(1002, "ustrd exceeds the maximum length of 140".to_string()));
				}
			}
		}
		if let Some(ref vec) = self.strd { for item in vec { item.validate()? } }
		Ok(())
	}
}


// RemittanceLocation7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct RemittanceLocation7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RmtId", skip_serializing_if = "Option::is_none") )]
	pub rmt_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RmtLctnDtls", skip_serializing_if = "Option::is_none") )]
	pub rmt_lctn_dtls: Option<Vec<RemittanceLocationData1>>,
}

impl RemittanceLocation7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.rmt_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "rmt_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "rmt_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref vec) = self.rmt_lctn_dtls { for item in vec { item.validate()? } }
		Ok(())
	}
}


// RemittanceLocation8 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct RemittanceLocation8 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RmtId", skip_serializing_if = "Option::is_none") )]
	pub rmt_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RmtLctnDtls", skip_serializing_if = "Option::is_none") )]
	pub rmt_lctn_dtls: Option<Vec<RemittanceLocationData2>>,
}

impl RemittanceLocation8 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.rmt_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "rmt_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "rmt_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref vec) = self.rmt_lctn_dtls { for item in vec { item.validate()? } }
		Ok(())
	}
}


// RemittanceLocationData1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct RemittanceLocationData1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Mtd") )]
	pub mtd: RemittanceLocationMethod2Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ElctrncAdr", skip_serializing_if = "Option::is_none") )]
	pub elctrnc_adr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstlAdr", skip_serializing_if = "Option::is_none") )]
	pub pstl_adr: Option<NameAndAddress16>,
}

impl RemittanceLocationData1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.mtd.validate()?;
		if let Some(ref val) = self.elctrnc_adr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "elctrnc_adr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 2048 {
				return Err(ValidationError::new(1002, "elctrnc_adr exceeds the maximum length of 2048".to_string()));
			}
		}
		if let Some(ref val) = self.pstl_adr { val.validate()? }
		Ok(())
	}
}


// RemittanceLocationData2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct RemittanceLocationData2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Mtd") )]
	pub mtd: RemittanceLocationMethod2Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ElctrncAdr", skip_serializing_if = "Option::is_none") )]
	pub elctrnc_adr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstlAdr", skip_serializing_if = "Option::is_none") )]
	pub pstl_adr: Option<NameAndAddress18>,
}

impl RemittanceLocationData2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.mtd.validate()?;
		if let Some(ref val) = self.elctrnc_adr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "elctrnc_adr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 2048 {
				return Err(ValidationError::new(1002, "elctrnc_adr exceeds the maximum length of 2048".to_string()));
			}
		}
		if let Some(ref val) = self.pstl_adr { val.validate()? }
		Ok(())
	}
}


// RemittanceLocationMethod2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum RemittanceLocationMethod2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "FAXI") )]
	CodeFAXI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EDIC") )]
	CodeEDIC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "URID") )]
	CodeURID,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EMAL") )]
	CodeEMAL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "POST") )]
	CodePOST,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SMSM") )]
	CodeSMSM,
}

impl RemittanceLocationMethod2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ReportData4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ReportData4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgId") )]
	pub msg_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ValDt") )]
	pub val_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtAndTmStmp") )]
	pub dt_and_tm_stmp: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: Entry2Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SchdlTp") )]
	pub schdl_tp: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttlmSsnIdr", skip_serializing_if = "Option::is_none") )]
	pub sttlm_ssn_idr: Option<String>,
}

impl ReportData4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.msg_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "msg_id is shorter than the minimum length of 1".to_string()));
		}
		if self.msg_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "msg_id exceeds the maximum length of 35".to_string()));
		}
		self.tp.validate()?;
		let pattern = Regex::new("[a-zA-Z0-9]{4}").unwrap();
		if !pattern.is_match(&self.schdl_tp) {
			return Err(ValidationError::new(1005, "schdl_tp does not match the required pattern".to_string()));
		}
		if let Some(ref val) = self.sttlm_ssn_idr {
			let pattern = Regex::new("[a-zA-Z0-9]{4}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "sttlm_ssn_idr does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// ReportData5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ReportData5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgId") )]
	pub msg_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ValDt") )]
	pub val_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtAndTmStmp") )]
	pub dt_and_tm_stmp: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: CallIn1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PayInCallAmt", skip_serializing_if = "Option::is_none") )]
	pub pay_in_call_amt: Option<Vec<PayInCallItem>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttlmSsnIdr", skip_serializing_if = "Option::is_none") )]
	pub sttlm_ssn_idr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctVal", skip_serializing_if = "Option::is_none") )]
	pub acct_val: Option<Value>,
}

impl ReportData5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.msg_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "msg_id is shorter than the minimum length of 1".to_string()));
		}
		if self.msg_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "msg_id exceeds the maximum length of 35".to_string()));
		}
		self.tp.validate()?;
		if let Some(ref vec) = self.pay_in_call_amt { for item in vec { item.validate()? } }
		if let Some(ref val) = self.sttlm_ssn_idr {
			let pattern = Regex::new("[a-zA-Z0-9]{4}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "sttlm_ssn_idr does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.acct_val { val.validate()? }
		Ok(())
	}
}


// ReportEntry14 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ReportEntry14 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtryRef", skip_serializing_if = "Option::is_none") )]
	pub ntry_ref: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveOrHistoricCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtDbtInd") )]
	pub cdt_dbt_ind: CreditDebitCode,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RvslInd", skip_serializing_if = "Option::is_none") )]
	pub rvsl_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sts") )]
	pub sts: EntryStatus1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BookgDt", skip_serializing_if = "Option::is_none") )]
	pub bookg_dt: Option<DateAndDateTime2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ValDt", skip_serializing_if = "Option::is_none") )]
	pub val_dt: Option<DateAndDateTime2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctSvcrRef", skip_serializing_if = "Option::is_none") )]
	pub acct_svcr_ref: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Avlbty", skip_serializing_if = "Option::is_none") )]
	pub avlbty: Option<Vec<CashAvailability1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BkTxCd") )]
	pub bk_tx_cd: BankTransactionCodeStructure4,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ComssnWvrInd", skip_serializing_if = "Option::is_none") )]
	pub comssn_wvr_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlInfInd", skip_serializing_if = "Option::is_none") )]
	pub addtl_inf_ind: Option<MessageIdentification2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AmtDtls", skip_serializing_if = "Option::is_none") )]
	pub amt_dtls: Option<AmountAndCurrencyExchange4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Chrgs", skip_serializing_if = "Option::is_none") )]
	pub chrgs: Option<Charges15>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TechInptChanl", skip_serializing_if = "Option::is_none") )]
	pub tech_inpt_chanl: Option<TechnicalInputChannel1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Intrst", skip_serializing_if = "Option::is_none") )]
	pub intrst: Option<TransactionInterest4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CardTx", skip_serializing_if = "Option::is_none") )]
	pub card_tx: Option<CardEntry5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NtryDtls", skip_serializing_if = "Option::is_none") )]
	pub ntry_dtls: Option<Vec<EntryDetails13>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlNtryInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_ntry_inf: Option<String>,
}

impl ReportEntry14 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ntry_ref {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "ntry_ref is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "ntry_ref exceeds the maximum length of 35".to_string()));
			}
		}
		self.amt.validate()?;
		self.cdt_dbt_ind.validate()?;
		self.sts.validate()?;
		if let Some(ref val) = self.bookg_dt { val.validate()? }
		if let Some(ref val) = self.val_dt { val.validate()? }
		if let Some(ref val) = self.acct_svcr_ref {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "acct_svcr_ref is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "acct_svcr_ref exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref vec) = self.avlbty { for item in vec { item.validate()? } }
		self.bk_tx_cd.validate()?;
		if let Some(ref val) = self.addtl_inf_ind { val.validate()? }
		if let Some(ref val) = self.amt_dtls { val.validate()? }
		if let Some(ref val) = self.chrgs { val.validate()? }
		if let Some(ref val) = self.tech_inpt_chanl { val.validate()? }
		if let Some(ref val) = self.intrst { val.validate()? }
		if let Some(ref val) = self.card_tx { val.validate()? }
		if let Some(ref vec) = self.ntry_dtls { for item in vec { item.validate()? } }
		if let Some(ref val) = self.addtl_ntry_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_ntry_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 500 {
				return Err(ValidationError::new(1002, "addtl_ntry_inf exceeds the maximum length of 500".to_string()));
			}
		}
		Ok(())
	}
}


// ReportHeader6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ReportHeader6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptId") )]
	pub rpt_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgPgntn", skip_serializing_if = "Option::is_none") )]
	pub msg_pgntn: Option<Pagination1>,
}

impl ReportHeader6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.rpt_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "rpt_id is shorter than the minimum length of 1".to_string()));
		}
		if self.rpt_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "rpt_id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.msg_pgntn { val.validate()? }
		Ok(())
	}
}


// ReportHeader7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ReportHeader7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Fr") )]
	pub fr: Party50Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "To") )]
	pub to: Party50Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CreDtTm") )]
	pub cre_dt_tm: String,
}

impl ReportHeader7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
		}
		self.fr.validate()?;
		self.to.validate()?;
		Ok(())
	}
}


// ReportIndicator1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum ReportIndicator1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "STND") )]
	CodeSTND,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PRPR") )]
	CodePRPR,
}

impl ReportIndicator1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ReportingPeriod5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ReportingPeriod5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrToDt") )]
	pub fr_to_dt: DatePeriod3,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrToTm", skip_serializing_if = "Option::is_none") )]
	pub fr_to_tm: Option<TimePeriodDetails1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: QueryType3Code,
}

impl ReportingPeriod5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.fr_to_dt.validate()?;
		if let Some(ref val) = self.fr_to_tm { val.validate()? }
		self.tp.validate()?;
		Ok(())
	}
}


// ReportingRequest7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ReportingRequest7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReqdMsgNmId") )]
	pub reqd_msg_nm_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Acct", skip_serializing_if = "Option::is_none") )]
	pub acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctOwnr") )]
	pub acct_ownr: Party50Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctSvcr", skip_serializing_if = "Option::is_none") )]
	pub acct_svcr: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgPrd", skip_serializing_if = "Option::is_none") )]
	pub rptg_prd: Option<ReportingPeriod5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RptgSeq", skip_serializing_if = "Option::is_none") )]
	pub rptg_seq: Option<SequenceRange1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReqdTxTp", skip_serializing_if = "Option::is_none") )]
	pub reqd_tx_tp: Option<TransactionType2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReqdBalTp", skip_serializing_if = "Option::is_none") )]
	pub reqd_bal_tp: Option<Vec<BalanceType13>>,
}

impl ReportingRequest7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
			}
		}
		if self.reqd_msg_nm_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "reqd_msg_nm_id is shorter than the minimum length of 1".to_string()));
		}
		if self.reqd_msg_nm_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "reqd_msg_nm_id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.acct { val.validate()? }
		self.acct_ownr.validate()?;
		if let Some(ref val) = self.acct_svcr { val.validate()? }
		if let Some(ref val) = self.rptg_prd { val.validate()? }
		if let Some(ref val) = self.rptg_seq { val.validate()? }
		if let Some(ref val) = self.reqd_tx_tp { val.validate()? }
		if let Some(ref vec) = self.reqd_bal_tp { for item in vec { item.validate()? } }
		Ok(())
	}
}


// ReportingSource1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ReportingSource1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl ReportingSource1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// RequestDetails22 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct RequestDetails22 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ref") )]
	pub ref_attr: References14,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Lkg", skip_serializing_if = "Option::is_none") )]
	pub lkg: Option<LinkageType3Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prty", skip_serializing_if = "Option::is_none") )]
	pub prty: Option<PriorityNumeric4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrPrcg", skip_serializing_if = "Option::is_none") )]
	pub othr_prcg: Option<Vec<GenericIdentification30>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrtlSttlmInd", skip_serializing_if = "Option::is_none") )]
	pub prtl_sttlm_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrChanl", skip_serializing_if = "Option::is_none") )]
	pub clr_chanl: Option<ClearingChannel2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Lnkgs", skip_serializing_if = "Option::is_none") )]
	pub lnkgs: Option<Vec<Linkages57>>,
}

impl RequestDetails22 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.ref_attr.validate()?;
		if let Some(ref val) = self.lkg { val.validate()? }
		if let Some(ref val) = self.prty { val.validate()? }
		if let Some(ref vec) = self.othr_prcg { for item in vec { item.validate()? } }
		if let Some(ref val) = self.clr_chanl { val.validate()? }
		if let Some(ref vec) = self.lnkgs { for item in vec { item.validate()? } }
		Ok(())
	}
}


// RequestHandling3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct RequestHandling3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sts") )]
	pub sts: RequestStatus1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StsRsn", skip_serializing_if = "Option::is_none") )]
	pub sts_rsn: Option<StatusReasonInformation14>,
}

impl RequestHandling3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.sts.validate()?;
		if let Some(ref val) = self.sts_rsn { val.validate()? }
		Ok(())
	}
}


// RequestStatus1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct RequestStatus1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl RequestStatus1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// RequestType3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct RequestType3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<StandingOrderQueryType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification1>,
}

impl RequestType3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// RequestType4Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct RequestType4Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtCtrl", skip_serializing_if = "Option::is_none") )]
	pub pmt_ctrl: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Enqry", skip_serializing_if = "Option::is_none") )]
	pub enqry: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification1>,
}

impl RequestType4Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.pmt_ctrl {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "pmt_ctrl is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "pmt_ctrl exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.enqry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "enqry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "enqry exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// RequestedModification11 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct RequestedModification11 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstrId", skip_serializing_if = "Option::is_none") )]
	pub instr_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EndToEndId", skip_serializing_if = "Option::is_none") )]
	pub end_to_end_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxId", skip_serializing_if = "Option::is_none") )]
	pub tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtTpInf", skip_serializing_if = "Option::is_none") )]
	pub pmt_tp_inf: Option<PaymentTypeInformation27>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReqdExctnDt", skip_serializing_if = "Option::is_none") )]
	pub reqd_exctn_dt: Option<DateAndDateTime2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReqdColltnDt", skip_serializing_if = "Option::is_none") )]
	pub reqd_colltn_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrBkSttlmDt", skip_serializing_if = "Option::is_none") )]
	pub intr_bk_sttlm_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttlmTmIndctn", skip_serializing_if = "Option::is_none") )]
	pub sttlm_tm_indctn: Option<SettlementDateTimeIndication1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt", skip_serializing_if = "Option::is_none") )]
	pub amt: Option<AmountType4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrBkSttlmAmt", skip_serializing_if = "Option::is_none") )]
	pub intr_bk_sttlm_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgBr", skip_serializing_if = "Option::is_none") )]
	pub chrg_br: Option<ChargeBearerType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UltmtDbtr", skip_serializing_if = "Option::is_none") )]
	pub ultmt_dbtr: Option<PartyIdentification272>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dbtr", skip_serializing_if = "Option::is_none") )]
	pub dbtr: Option<PartyIdentification272>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtrAcct", skip_serializing_if = "Option::is_none") )]
	pub dbtr_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtrAgtAcct", skip_serializing_if = "Option::is_none") )]
	pub dbtr_agt_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttlmInf", skip_serializing_if = "Option::is_none") )]
	pub sttlm_inf: Option<SettlementInstruction16>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtrAgtAcct", skip_serializing_if = "Option::is_none") )]
	pub cdtr_agt_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cdtr", skip_serializing_if = "Option::is_none") )]
	pub cdtr: Option<PartyIdentification272>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtrAcct", skip_serializing_if = "Option::is_none") )]
	pub cdtr_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UltmtCdtr", skip_serializing_if = "Option::is_none") )]
	pub ultmt_cdtr: Option<PartyIdentification272>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Purp", skip_serializing_if = "Option::is_none") )]
	pub purp: Option<Purpose2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstrForDbtrAgt", skip_serializing_if = "Option::is_none") )]
	pub instr_for_dbtr_agt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstrForNxtAgt", skip_serializing_if = "Option::is_none") )]
	pub instr_for_nxt_agt: Option<Vec<InstructionForNextAgent1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstrForCdtrAgt", skip_serializing_if = "Option::is_none") )]
	pub instr_for_cdtr_agt: Option<Vec<InstructionForCreditorAgent3>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RltdRmtInf", skip_serializing_if = "Option::is_none") )]
	pub rltd_rmt_inf: Option<Vec<RemittanceLocation8>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RmtInf", skip_serializing_if = "Option::is_none") )]
	pub rmt_inf: Option<RemittanceInformation22>,
}

impl RequestedModification11 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.instr_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "instr_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "instr_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.end_to_end_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "end_to_end_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "end_to_end_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.pmt_tp_inf { val.validate()? }
		if let Some(ref val) = self.reqd_exctn_dt { val.validate()? }
		if let Some(ref val) = self.sttlm_tm_indctn { val.validate()? }
		if let Some(ref val) = self.amt { val.validate()? }
		if let Some(ref val) = self.intr_bk_sttlm_amt { val.validate()? }
		if let Some(ref val) = self.chrg_br { val.validate()? }
		if let Some(ref val) = self.ultmt_dbtr { val.validate()? }
		if let Some(ref val) = self.dbtr { val.validate()? }
		if let Some(ref val) = self.dbtr_acct { val.validate()? }
		if let Some(ref val) = self.dbtr_agt_acct { val.validate()? }
		if let Some(ref val) = self.sttlm_inf { val.validate()? }
		if let Some(ref val) = self.cdtr_agt_acct { val.validate()? }
		if let Some(ref val) = self.cdtr { val.validate()? }
		if let Some(ref val) = self.cdtr_acct { val.validate()? }
		if let Some(ref val) = self.ultmt_cdtr { val.validate()? }
		if let Some(ref val) = self.purp { val.validate()? }
		if let Some(ref val) = self.instr_for_dbtr_agt {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "instr_for_dbtr_agt is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "instr_for_dbtr_agt exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref vec) = self.instr_for_nxt_agt { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.instr_for_cdtr_agt { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.rltd_rmt_inf { for item in vec { item.validate()? } }
		if let Some(ref val) = self.rmt_inf { val.validate()? }
		Ok(())
	}
}


// Reservation3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Reservation3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: Amount2Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sts", skip_serializing_if = "Option::is_none") )]
	pub sts: Option<ReservationStatus1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StartDtTm", skip_serializing_if = "Option::is_none") )]
	pub start_dt_tm: Option<DateAndDateTime2Choice>,
}

impl Reservation3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.amt.validate()?;
		if let Some(ref val) = self.sts { val.validate()? }
		if let Some(ref val) = self.start_dt_tm { val.validate()? }
		Ok(())
	}
}


// Reservation4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Reservation4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "StartDtTm", skip_serializing_if = "Option::is_none") )]
	pub start_dt_tm: Option<DateAndDateTime2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: Amount2Choice,
}

impl Reservation4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.start_dt_tm { val.validate()? }
		self.amt.validate()?;
		Ok(())
	}
}


// ReservationCriteria6Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ReservationCriteria6Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "QryNm", skip_serializing_if = "Option::is_none") )]
	pub qry_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NewCrit", skip_serializing_if = "Option::is_none") )]
	pub new_crit: Option<ReservationCriteria7>,
}

impl ReservationCriteria6Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.qry_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "qry_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "qry_nm exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.new_crit { val.validate()? }
		Ok(())
	}
}


// ReservationCriteria7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ReservationCriteria7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NewQryNm", skip_serializing_if = "Option::is_none") )]
	pub new_qry_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SchCrit", skip_serializing_if = "Option::is_none") )]
	pub sch_crit: Option<Vec<ReservationSearchCriteria6>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RtrCrit", skip_serializing_if = "Option::is_none") )]
	pub rtr_crit: Option<ReservationReturnCriteria1>,
}

impl ReservationCriteria7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.new_qry_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "new_qry_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "new_qry_nm exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref vec) = self.sch_crit { for item in vec { item.validate()? } }
		if let Some(ref val) = self.rtr_crit { val.validate()? }
		Ok(())
	}
}


// ReservationIdentification4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ReservationIdentification4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RsvatnId", skip_serializing_if = "Option::is_none") )]
	pub rsvatn_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SysId", skip_serializing_if = "Option::is_none") )]
	pub sys_id: Option<SystemIdentification2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: ReservationType2Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctOwnr", skip_serializing_if = "Option::is_none") )]
	pub acct_ownr: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctId", skip_serializing_if = "Option::is_none") )]
	pub acct_id: Option<AccountIdentification4Choice>,
}

impl ReservationIdentification4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.rsvatn_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "rsvatn_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "rsvatn_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.sys_id { val.validate()? }
		self.tp.validate()?;
		if let Some(ref val) = self.acct_ownr { val.validate()? }
		if let Some(ref val) = self.acct_id { val.validate()? }
		Ok(())
	}
}


// ReservationOrError11Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ReservationOrError11Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BizRpt", skip_serializing_if = "Option::is_none") )]
	pub biz_rpt: Option<CurrentAndDefaultReservation6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OprlErr", skip_serializing_if = "Option::is_none") )]
	pub oprl_err: Option<Vec<ErrorHandling5>>,
}

impl ReservationOrError11Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.biz_rpt { val.validate()? }
		if let Some(ref vec) = self.oprl_err { for item in vec { item.validate()? } }
		Ok(())
	}
}


// ReservationOrError9Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ReservationOrError9Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsvatn", skip_serializing_if = "Option::is_none") )]
	pub rsvatn: Option<Reservation3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BizErr", skip_serializing_if = "Option::is_none") )]
	pub biz_err: Option<Vec<ErrorHandling5>>,
}

impl ReservationOrError9Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.rsvatn { val.validate()? }
		if let Some(ref vec) = self.biz_err { for item in vec { item.validate()? } }
		Ok(())
	}
}


// ReservationQuery6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ReservationQuery6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "QryTp", skip_serializing_if = "Option::is_none") )]
	pub qry_tp: Option<QueryType2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RsvatnCrit", skip_serializing_if = "Option::is_none") )]
	pub rsvatn_crit: Option<ReservationCriteria6Choice>,
}

impl ReservationQuery6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.qry_tp { val.validate()? }
		if let Some(ref val) = self.rsvatn_crit { val.validate()? }
		Ok(())
	}
}


// ReservationReport8 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ReservationReport8 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RsvatnId") )]
	pub rsvatn_id: ReservationIdentification4,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RsvatnOrErr") )]
	pub rsvatn_or_err: ReservationOrError9Choice,
}

impl ReservationReport8 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.rsvatn_id.validate()?;
		self.rsvatn_or_err.validate()?;
		Ok(())
	}
}


// ReservationReturnCriteria1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ReservationReturnCriteria1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "StartDtTmInd", skip_serializing_if = "Option::is_none") )]
	pub start_dt_tm_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StsInd", skip_serializing_if = "Option::is_none") )]
	pub sts_ind: Option<bool>,
}

impl ReservationReturnCriteria1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ReservationSearchCriteria6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ReservationSearchCriteria6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtTm", skip_serializing_if = "Option::is_none") )]
	pub dt_tm: Option<DateTimeSearch2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SysId", skip_serializing_if = "Option::is_none") )]
	pub sys_id: Option<SystemIdentification2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DfltRsvatnTp", skip_serializing_if = "Option::is_none") )]
	pub dflt_rsvatn_tp: Option<Vec<ReservationType2Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CurRsvatnTp", skip_serializing_if = "Option::is_none") )]
	pub cur_rsvatn_tp: Option<Vec<ReservationType2Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctOwnr", skip_serializing_if = "Option::is_none") )]
	pub acct_ownr: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctId", skip_serializing_if = "Option::is_none") )]
	pub acct_id: Option<AccountIdentification4Choice>,
}

impl ReservationSearchCriteria6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.dt_tm { val.validate()? }
		if let Some(ref val) = self.sys_id { val.validate()? }
		if let Some(ref vec) = self.dflt_rsvatn_tp { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.cur_rsvatn_tp { for item in vec { item.validate()? } }
		if let Some(ref val) = self.acct_ownr { val.validate()? }
		if let Some(ref val) = self.acct_id { val.validate()? }
		Ok(())
	}
}


// ReservationStatus1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ReservationStatus1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<ReservationStatus1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl ReservationStatus1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// ReservationStatus1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum ReservationStatus1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ENAB") )]
	CodeENAB,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DISA") )]
	CodeDISA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DELD") )]
	CodeDELD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "REQD") )]
	CodeREQD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BLKD") )]
	CodeBLKD,
}

impl ReservationStatus1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ReservationType2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ReservationType2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl ReservationType2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// ResidenceLocation1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ResidenceLocation1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ctry", skip_serializing_if = "Option::is_none") )]
	pub ctry: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Area", skip_serializing_if = "Option::is_none") )]
	pub area: Option<String>,
}

impl ResidenceLocation1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ctry {
			let pattern = Regex::new("[A-Z]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ctry does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.area {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "area is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "area exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// ResolutionData5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ResolutionData5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "EndToEndId", skip_serializing_if = "Option::is_none") )]
	pub end_to_end_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxId", skip_serializing_if = "Option::is_none") )]
	pub tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UETR", skip_serializing_if = "Option::is_none") )]
	pub uetr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrBkSttlmAmt", skip_serializing_if = "Option::is_none") )]
	pub intr_bk_sttlm_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrBkSttlmDt", skip_serializing_if = "Option::is_none") )]
	pub intr_bk_sttlm_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrChanl", skip_serializing_if = "Option::is_none") )]
	pub clr_chanl: Option<ClearingChannel2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Compstn", skip_serializing_if = "Option::is_none") )]
	pub compstn: Option<Compensation5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChrgsInf", skip_serializing_if = "Option::is_none") )]
	pub chrgs_inf: Option<Vec<Charges14>>,
}

impl ResolutionData5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.end_to_end_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "end_to_end_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "end_to_end_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.uetr {
			let pattern = Regex::new("[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "uetr does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.intr_bk_sttlm_amt { val.validate()? }
		if let Some(ref val) = self.clr_chanl { val.validate()? }
		if let Some(ref val) = self.compstn { val.validate()? }
		if let Some(ref vec) = self.chrgs_inf { for item in vec { item.validate()? } }
		Ok(())
	}
}


// ReturnReason5Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ReturnReason5Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl ReturnReason5Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// SecuritiesAccount19 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct SecuritiesAccount19 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<GenericIdentification30>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm", skip_serializing_if = "Option::is_none") )]
	pub nm: Option<String>,
}

impl SecuritiesAccount19 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.tp { val.validate()? }
		if let Some(ref val) = self.nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 70 {
				return Err(ValidationError::new(1002, "nm exceeds the maximum length of 70".to_string()));
			}
		}
		Ok(())
	}
}


// SecuritiesSettlementStatus1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum SecuritiesSettlementStatus1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "PEND") )]
	CodePEND,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PENF") )]
	CodePENF,
}

impl SecuritiesSettlementStatus1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// SecuritiesTransactionReferences1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct SecuritiesTransactionReferences1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctOwnrTxId", skip_serializing_if = "Option::is_none") )]
	pub acct_ownr_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctSvcrTxId", skip_serializing_if = "Option::is_none") )]
	pub acct_svcr_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MktInfrstrctrTxId", skip_serializing_if = "Option::is_none") )]
	pub mkt_infrstrctr_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrcgId", skip_serializing_if = "Option::is_none") )]
	pub prcg_id: Option<String>,
}

impl SecuritiesTransactionReferences1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.acct_ownr_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "acct_ownr_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "acct_ownr_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.acct_svcr_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "acct_svcr_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "acct_svcr_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.mkt_infrstrctr_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "mkt_infrstrctr_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "mkt_infrstrctr_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.prcg_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prcg_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prcg_id exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// SecurityIdentification19 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct SecurityIdentification19 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ISIN", skip_serializing_if = "Option::is_none") )]
	pub isin: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrId", skip_serializing_if = "Option::is_none") )]
	pub othr_id: Option<Vec<OtherIdentification1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Desc", skip_serializing_if = "Option::is_none") )]
	pub desc: Option<String>,
}

impl SecurityIdentification19 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.isin {
			let pattern = Regex::new("[A-Z]{2,2}[A-Z0-9]{9,9}[0-9]{1,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "isin does not match the required pattern".to_string()));
			}
		}
		if let Some(ref vec) = self.othr_id { for item in vec { item.validate()? } }
		if let Some(ref val) = self.desc {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "desc is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "desc exceeds the maximum length of 140".to_string()));
			}
		}
		Ok(())
	}
}


// SecurityIdentification3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct SecurityIdentification3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "ISIN", skip_serializing_if = "Option::is_none") )]
	pub isin: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SEDOL", skip_serializing_if = "Option::is_none") )]
	pub sedol: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CUSIP", skip_serializing_if = "Option::is_none") )]
	pub cusip: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RIC", skip_serializing_if = "Option::is_none") )]
	pub ric: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TckrSymb", skip_serializing_if = "Option::is_none") )]
	pub tckr_symb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Blmbrg", skip_serializing_if = "Option::is_none") )]
	pub blmbrg: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CTA", skip_serializing_if = "Option::is_none") )]
	pub cta: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "QUICK", skip_serializing_if = "Option::is_none") )]
	pub quick: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Wrtppr", skip_serializing_if = "Option::is_none") )]
	pub wrtppr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dtch", skip_serializing_if = "Option::is_none") )]
	pub dtch: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Vlrn", skip_serializing_if = "Option::is_none") )]
	pub vlrn: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SCVM", skip_serializing_if = "Option::is_none") )]
	pub scvm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Belgn", skip_serializing_if = "Option::is_none") )]
	pub belgn: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cmon", skip_serializing_if = "Option::is_none") )]
	pub cmon: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OthrPrtryId", skip_serializing_if = "Option::is_none") )]
	pub othr_prtry_id: Option<AlternateSecurityIdentification1>,
}

impl SecurityIdentification3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.isin {
			let pattern = Regex::new("[A-Z0-9]{12,12}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "isin does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.ric {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "ric is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "ric exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.tckr_symb {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tckr_symb is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "tckr_symb exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.blmbrg {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "blmbrg is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "blmbrg exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.cta {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cta is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "cta exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.cmon {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cmon is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 12 {
				return Err(ValidationError::new(1002, "cmon exceeds the maximum length of 12".to_string()));
			}
		}
		if let Some(ref val) = self.othr_prtry_id { val.validate()? }
		Ok(())
	}
}


// SequenceRange1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct SequenceRange1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrSeq") )]
	pub fr_seq: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ToSeq") )]
	pub to_seq: String,
}

impl SequenceRange1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.fr_seq.chars().count() < 1 {
			return Err(ValidationError::new(1001, "fr_seq is shorter than the minimum length of 1".to_string()));
		}
		if self.fr_seq.chars().count() > 35 {
			return Err(ValidationError::new(1002, "fr_seq exceeds the maximum length of 35".to_string()));
		}
		if self.to_seq.chars().count() < 1 {
			return Err(ValidationError::new(1001, "to_seq is shorter than the minimum length of 1".to_string()));
		}
		if self.to_seq.chars().count() > 35 {
			return Err(ValidationError::new(1002, "to_seq exceeds the maximum length of 35".to_string()));
		}
		Ok(())
	}
}


// SequenceRange1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct SequenceRange1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrSeq", skip_serializing_if = "Option::is_none") )]
	pub fr_seq: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ToSeq", skip_serializing_if = "Option::is_none") )]
	pub to_seq: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrToSeq", skip_serializing_if = "Option::is_none") )]
	pub fr_to_seq: Option<Vec<SequenceRange1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EQSeq", skip_serializing_if = "Option::is_none") )]
	pub eq_seq: Option<Vec<String>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NEQSeq", skip_serializing_if = "Option::is_none") )]
	pub neq_seq: Option<Vec<String>>,
}

impl SequenceRange1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.fr_seq {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "fr_seq is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "fr_seq exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.to_seq {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "to_seq is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "to_seq exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref vec) = self.fr_to_seq { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.eq_seq {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "eq_seq is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 35 {
					return Err(ValidationError::new(1002, "eq_seq exceeds the maximum length of 35".to_string()));
				}
			}
		}
		if let Some(ref vec) = self.neq_seq {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "neq_seq is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 35 {
					return Err(ValidationError::new(1002, "neq_seq exceeds the maximum length of 35".to_string()));
				}
			}
		}
		Ok(())
	}
}


// SequenceType3Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum SequenceType3Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "FRST") )]
	CodeFRST,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RCUR") )]
	CodeRCUR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FNAL") )]
	CodeFNAL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OOFF") )]
	CodeOOFF,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RPRE") )]
	CodeRPRE,
}

impl SequenceType3Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ServiceAdjustmentType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum ServiceAdjustmentType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "COMP") )]
	CodeCOMP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NCMP") )]
	CodeNCMP,
}

impl ServiceAdjustmentType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ServiceLevel8Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ServiceLevel8Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl ServiceLevel8Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// ServicePaymentMethod1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum ServicePaymentMethod1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "BCMP") )]
	CodeBCMP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FLAT") )]
	CodeFLAT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PVCH") )]
	CodePVCH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INVS") )]
	CodeINVS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "WVED") )]
	CodeWVED,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FREE") )]
	CodeFREE,
}

impl ServicePaymentMethod1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// ServiceTaxDesignation1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ServiceTaxDesignation1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd") )]
	pub cd: ServiceTaxDesignation1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rgn", skip_serializing_if = "Option::is_none") )]
	pub rgn: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TaxRsn", skip_serializing_if = "Option::is_none") )]
	pub tax_rsn: Option<Vec<TaxReason1>>,
}

impl ServiceTaxDesignation1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.cd.validate()?;
		if let Some(ref val) = self.rgn {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "rgn is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "rgn exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref vec) = self.tax_rsn { for item in vec { item.validate()? } }
		Ok(())
	}
}


// ServiceTaxDesignation1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum ServiceTaxDesignation1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "XMPT") )]
	CodeXMPT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ZERO") )]
	CodeZERO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TAXE") )]
	CodeTAXE,
}

impl ServiceTaxDesignation1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// SettlementDateTimeIndication1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct SettlementDateTimeIndication1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtDtTm", skip_serializing_if = "Option::is_none") )]
	pub dbt_dt_tm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtDtTm", skip_serializing_if = "Option::is_none") )]
	pub cdt_dt_tm: Option<String>,
}

impl SettlementDateTimeIndication1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// SettlementInstruction11 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct SettlementInstruction11 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttlmMtd") )]
	pub sttlm_mtd: SettlementMethod1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttlmAcct", skip_serializing_if = "Option::is_none") )]
	pub sttlm_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrSys", skip_serializing_if = "Option::is_none") )]
	pub clr_sys: Option<ClearingSystemIdentification3Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstgRmbrsmntAgt", skip_serializing_if = "Option::is_none") )]
	pub instg_rmbrsmnt_agt: Option<BranchAndFinancialInstitutionIdentification6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstgRmbrsmntAgtAcct", skip_serializing_if = "Option::is_none") )]
	pub instg_rmbrsmnt_agt_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstdRmbrsmntAgt", skip_serializing_if = "Option::is_none") )]
	pub instd_rmbrsmnt_agt: Option<BranchAndFinancialInstitutionIdentification6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstdRmbrsmntAgtAcct", skip_serializing_if = "Option::is_none") )]
	pub instd_rmbrsmnt_agt_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ThrdRmbrsmntAgt", skip_serializing_if = "Option::is_none") )]
	pub thrd_rmbrsmnt_agt: Option<BranchAndFinancialInstitutionIdentification6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ThrdRmbrsmntAgtAcct", skip_serializing_if = "Option::is_none") )]
	pub thrd_rmbrsmnt_agt_acct: Option<CashAccount40>,
}

impl SettlementInstruction11 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.sttlm_mtd.validate()?;
		if let Some(ref val) = self.sttlm_acct { val.validate()? }
		if let Some(ref val) = self.clr_sys { val.validate()? }
		if let Some(ref val) = self.instg_rmbrsmnt_agt { val.validate()? }
		if let Some(ref val) = self.instg_rmbrsmnt_agt_acct { val.validate()? }
		if let Some(ref val) = self.instd_rmbrsmnt_agt { val.validate()? }
		if let Some(ref val) = self.instd_rmbrsmnt_agt_acct { val.validate()? }
		if let Some(ref val) = self.thrd_rmbrsmnt_agt { val.validate()? }
		if let Some(ref val) = self.thrd_rmbrsmnt_agt_acct { val.validate()? }
		Ok(())
	}
}


// SettlementInstruction15 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct SettlementInstruction15 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttlmMtd") )]
	pub sttlm_mtd: SettlementMethod1Code,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttlmAcct", skip_serializing_if = "Option::is_none") )]
	pub sttlm_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrSys", skip_serializing_if = "Option::is_none") )]
	pub clr_sys: Option<ClearingSystemIdentification3Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstgRmbrsmntAgt", skip_serializing_if = "Option::is_none") )]
	pub instg_rmbrsmnt_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstgRmbrsmntAgtAcct", skip_serializing_if = "Option::is_none") )]
	pub instg_rmbrsmnt_agt_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstdRmbrsmntAgt", skip_serializing_if = "Option::is_none") )]
	pub instd_rmbrsmnt_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstdRmbrsmntAgtAcct", skip_serializing_if = "Option::is_none") )]
	pub instd_rmbrsmnt_agt_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ThrdRmbrsmntAgt", skip_serializing_if = "Option::is_none") )]
	pub thrd_rmbrsmnt_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ThrdRmbrsmntAgtAcct", skip_serializing_if = "Option::is_none") )]
	pub thrd_rmbrsmnt_agt_acct: Option<CashAccount40>,
}

impl SettlementInstruction15 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.sttlm_mtd.validate()?;
		if let Some(ref val) = self.sttlm_acct { val.validate()? }
		if let Some(ref val) = self.clr_sys { val.validate()? }
		if let Some(ref val) = self.instg_rmbrsmnt_agt { val.validate()? }
		if let Some(ref val) = self.instg_rmbrsmnt_agt_acct { val.validate()? }
		if let Some(ref val) = self.instd_rmbrsmnt_agt { val.validate()? }
		if let Some(ref val) = self.instd_rmbrsmnt_agt_acct { val.validate()? }
		if let Some(ref val) = self.thrd_rmbrsmnt_agt { val.validate()? }
		if let Some(ref val) = self.thrd_rmbrsmnt_agt_acct { val.validate()? }
		Ok(())
	}
}


// SettlementInstruction16 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct SettlementInstruction16 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstgRmbrsmntAgt", skip_serializing_if = "Option::is_none") )]
	pub instg_rmbrsmnt_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstgRmbrsmntAgtAcct", skip_serializing_if = "Option::is_none") )]
	pub instg_rmbrsmnt_agt_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstdRmbrsmntAgt", skip_serializing_if = "Option::is_none") )]
	pub instd_rmbrsmnt_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstdRmbrsmntAgtAcct", skip_serializing_if = "Option::is_none") )]
	pub instd_rmbrsmnt_agt_acct: Option<CashAccount40>,
}

impl SettlementInstruction16 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.instg_rmbrsmnt_agt { val.validate()? }
		if let Some(ref val) = self.instg_rmbrsmnt_agt_acct { val.validate()? }
		if let Some(ref val) = self.instd_rmbrsmnt_agt { val.validate()? }
		if let Some(ref val) = self.instd_rmbrsmnt_agt_acct { val.validate()? }
		Ok(())
	}
}


// SettlementMethod1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum SettlementMethod1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "INDA") )]
	CodeINDA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INGA") )]
	CodeINGA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "COVE") )]
	CodeCOVE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CLRG") )]
	CodeCLRG,
}

impl SettlementMethod1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// SettlementParties120 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct SettlementParties120 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DlvryAgt", skip_serializing_if = "Option::is_none") )]
	pub dlvry_agt: Option<PartyIdentification242Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Intrmy", skip_serializing_if = "Option::is_none") )]
	pub intrmy: Option<PartyIdentification242Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RcvgAgt") )]
	pub rcvg_agt: PartyIdentification242Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BnfcryInstn", skip_serializing_if = "Option::is_none") )]
	pub bnfcry_instn: Option<PartyIdentification242Choice>,
}

impl SettlementParties120 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.dlvry_agt { val.validate()? }
		if let Some(ref val) = self.intrmy { val.validate()? }
		self.rcvg_agt.validate()?;
		if let Some(ref val) = self.bnfcry_instn { val.validate()? }
		Ok(())
	}
}


// SettlementStatus16Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct SettlementStatus16Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pdg", skip_serializing_if = "Option::is_none") )]
	pub pdg: Option<PendingStatus36Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Flng", skip_serializing_if = "Option::is_none") )]
	pub flng: Option<FailingStatus9Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<ProprietaryStatusAndReason6>,
}

impl SettlementStatus16Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.pdg { val.validate()? }
		if let Some(ref val) = self.flng { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// SettlementStatus26Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct SettlementStatus26Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<SecuritiesSettlementStatus1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification30>,
}

impl SettlementStatus26Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// ShortPaymentIdentification4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct ShortPaymentIdentification4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxId", skip_serializing_if = "Option::is_none") )]
	pub tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UETR", skip_serializing_if = "Option::is_none") )]
	pub uetr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrBkSttlmDt") )]
	pub intr_bk_sttlm_dt: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstgAgt") )]
	pub instg_agt: BranchAndFinancialInstitutionIdentification8,
}

impl ShortPaymentIdentification4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.uetr {
			let pattern = Regex::new("[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "uetr does not match the required pattern".to_string()));
			}
		}
		self.instg_agt.validate()?;
		Ok(())
	}
}


// SimpleIdentificationInformation ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct SimpleIdentificationInformation {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: String,
}

impl SimpleIdentificationInformation {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
		}
		if self.id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
		}
		Ok(())
	}
}


// SkipPayload ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct SkipPayload {
}

impl SkipPayload {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// StandingOrder10 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct StandingOrder10 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt", skip_serializing_if = "Option::is_none") )]
	pub amt: Option<Amount2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cdtr", skip_serializing_if = "Option::is_none") )]
	pub cdtr: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtrAcct", skip_serializing_if = "Option::is_none") )]
	pub cdtr_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dbtr", skip_serializing_if = "Option::is_none") )]
	pub dbtr: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtrAcct", skip_serializing_if = "Option::is_none") )]
	pub dbtr_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ExctnTp", skip_serializing_if = "Option::is_none") )]
	pub exctn_tp: Option<ExecutionType1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Frqcy", skip_serializing_if = "Option::is_none") )]
	pub frqcy: Option<Frequency2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VldtyPrd", skip_serializing_if = "Option::is_none") )]
	pub vldty_prd: Option<DatePeriod2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ZeroSweepInd", skip_serializing_if = "Option::is_none") )]
	pub zero_sweep_ind: Option<bool>,
}

impl StandingOrder10 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.amt { val.validate()? }
		if let Some(ref val) = self.cdtr { val.validate()? }
		if let Some(ref val) = self.cdtr_acct { val.validate()? }
		if let Some(ref val) = self.dbtr { val.validate()? }
		if let Some(ref val) = self.dbtr_acct { val.validate()? }
		if let Some(ref val) = self.exctn_tp { val.validate()? }
		if let Some(ref val) = self.frqcy { val.validate()? }
		if let Some(ref val) = self.vldty_prd { val.validate()? }
		Ok(())
	}
}


// StandingOrder11 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct StandingOrder11 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: Amount2Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtDbtInd") )]
	pub cdt_dbt_ind: CreditDebitCode,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ccy", skip_serializing_if = "Option::is_none") )]
	pub ccy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<StandingOrderType1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AssoctdPoolAcct", skip_serializing_if = "Option::is_none") )]
	pub assoctd_pool_acct: Option<AccountIdentification4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ref", skip_serializing_if = "Option::is_none") )]
	pub ref_attr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Frqcy", skip_serializing_if = "Option::is_none") )]
	pub frqcy: Option<Frequency2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VldtyPrd", skip_serializing_if = "Option::is_none") )]
	pub vldty_prd: Option<DatePeriod3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SysMmb", skip_serializing_if = "Option::is_none") )]
	pub sys_mmb: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RspnsblPty", skip_serializing_if = "Option::is_none") )]
	pub rspnsbl_pty: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LkSetId", skip_serializing_if = "Option::is_none") )]
	pub lk_set_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LkSetOrdrId", skip_serializing_if = "Option::is_none") )]
	pub lk_set_ordr_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LkSetOrdrSeq", skip_serializing_if = "Option::is_none") )]
	pub lk_set_ordr_seq: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ExctnTp", skip_serializing_if = "Option::is_none") )]
	pub exctn_tp: Option<ExecutionType1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cdtr", skip_serializing_if = "Option::is_none") )]
	pub cdtr: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtrAcct", skip_serializing_if = "Option::is_none") )]
	pub cdtr_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dbtr", skip_serializing_if = "Option::is_none") )]
	pub dbtr: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtrAcct", skip_serializing_if = "Option::is_none") )]
	pub dbtr_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlsPerStgOrdr", skip_serializing_if = "Option::is_none") )]
	pub ttls_per_stg_ordr: Option<StandingOrderTotalAmount1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ZeroSweepInd", skip_serializing_if = "Option::is_none") )]
	pub zero_sweep_ind: Option<bool>,
}

impl StandingOrder11 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.amt.validate()?;
		self.cdt_dbt_ind.validate()?;
		if let Some(ref val) = self.ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ccy does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.tp { val.validate()? }
		if let Some(ref val) = self.assoctd_pool_acct { val.validate()? }
		if let Some(ref val) = self.ref_attr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "ref_attr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "ref_attr exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.frqcy { val.validate()? }
		if let Some(ref val) = self.vldty_prd { val.validate()? }
		if let Some(ref val) = self.sys_mmb { val.validate()? }
		if let Some(ref val) = self.rspnsbl_pty { val.validate()? }
		if let Some(ref val) = self.lk_set_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "lk_set_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "lk_set_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.lk_set_ordr_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "lk_set_ordr_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "lk_set_ordr_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.exctn_tp { val.validate()? }
		if let Some(ref val) = self.cdtr { val.validate()? }
		if let Some(ref val) = self.cdtr_acct { val.validate()? }
		if let Some(ref val) = self.dbtr { val.validate()? }
		if let Some(ref val) = self.dbtr_acct { val.validate()? }
		if let Some(ref val) = self.ttls_per_stg_ordr { val.validate()? }
		Ok(())
	}
}


// StandingOrderCriteria5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct StandingOrderCriteria5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NewQryNm", skip_serializing_if = "Option::is_none") )]
	pub new_qry_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SchCrit", skip_serializing_if = "Option::is_none") )]
	pub sch_crit: Option<Vec<StandingOrderSearchCriteria5>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RtrCrit", skip_serializing_if = "Option::is_none") )]
	pub rtr_crit: Option<StandingOrderReturnCriteria1>,
}

impl StandingOrderCriteria5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.new_qry_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "new_qry_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "new_qry_nm exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref vec) = self.sch_crit { for item in vec { item.validate()? } }
		if let Some(ref val) = self.rtr_crit { val.validate()? }
		Ok(())
	}
}


// StandingOrderCriteria5Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct StandingOrderCriteria5Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "QryNm", skip_serializing_if = "Option::is_none") )]
	pub qry_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NewCrit", skip_serializing_if = "Option::is_none") )]
	pub new_crit: Option<StandingOrderCriteria5>,
}

impl StandingOrderCriteria5Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.qry_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "qry_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "qry_nm exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.new_crit { val.validate()? }
		Ok(())
	}
}


// StandingOrderIdentification8 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct StandingOrderIdentification8 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Acct") )]
	pub acct: CashAccount40,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctOwnr", skip_serializing_if = "Option::is_none") )]
	pub acct_ownr: Option<BranchAndFinancialInstitutionIdentification8>,
}

impl StandingOrderIdentification8 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
			}
		}
		self.acct.validate()?;
		if let Some(ref val) = self.acct_ownr { val.validate()? }
		Ok(())
	}
}


// StandingOrderIdentification9 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct StandingOrderIdentification9 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Acct") )]
	pub acct: CashAccount40,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctOwnr", skip_serializing_if = "Option::is_none") )]
	pub acct_ownr: Option<BranchAndFinancialInstitutionIdentification8>,
}

impl StandingOrderIdentification9 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.acct.validate()?;
		if let Some(ref val) = self.acct_ownr { val.validate()? }
		Ok(())
	}
}


// StandingOrderOrAll4Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct StandingOrderOrAll4Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "StgOrdr", skip_serializing_if = "Option::is_none") )]
	pub stg_ordr: Option<Vec<StandingOrderIdentification8>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AllStgOrdrs", skip_serializing_if = "Option::is_none") )]
	pub all_stg_ordrs: Option<Vec<StandingOrderIdentification9>>,
}

impl StandingOrderOrAll4Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.stg_ordr { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.all_stg_ordrs { for item in vec { item.validate()? } }
		Ok(())
	}
}


// StandingOrderOrError10Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct StandingOrderOrError10Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "StgOrdr", skip_serializing_if = "Option::is_none") )]
	pub stg_ordr: Option<StandingOrder11>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BizErr", skip_serializing_if = "Option::is_none") )]
	pub biz_err: Option<Vec<ErrorHandling5>>,
}

impl StandingOrderOrError10Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.stg_ordr { val.validate()? }
		if let Some(ref vec) = self.biz_err { for item in vec { item.validate()? } }
		Ok(())
	}
}


// StandingOrderOrError9Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct StandingOrderOrError9Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rpt", skip_serializing_if = "Option::is_none") )]
	pub rpt: Option<Vec<StandingOrderReport3>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OprlErr", skip_serializing_if = "Option::is_none") )]
	pub oprl_err: Option<Vec<ErrorHandling5>>,
}

impl StandingOrderOrError9Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.rpt { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.oprl_err { for item in vec { item.validate()? } }
		Ok(())
	}
}


// StandingOrderQuery5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct StandingOrderQuery5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "QryTp", skip_serializing_if = "Option::is_none") )]
	pub qry_tp: Option<QueryType2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StgOrdrCrit", skip_serializing_if = "Option::is_none") )]
	pub stg_ordr_crit: Option<StandingOrderCriteria5Choice>,
}

impl StandingOrderQuery5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.qry_tp { val.validate()? }
		if let Some(ref val) = self.stg_ordr_crit { val.validate()? }
		Ok(())
	}
}


// StandingOrderQueryType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum StandingOrderQueryType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "SLST") )]
	CodeSLST,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SDTL") )]
	CodeSDTL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TAPS") )]
	CodeTAPS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SLSL") )]
	CodeSLSL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SWLS") )]
	CodeSWLS,
}

impl StandingOrderQueryType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// StandingOrderReport3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct StandingOrderReport3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "StgOrdrId") )]
	pub stg_ordr_id: StandingOrderIdentification8,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StgOrdrOrErr") )]
	pub stg_ordr_or_err: StandingOrderOrError10Choice,
}

impl StandingOrderReport3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.stg_ordr_id.validate()?;
		self.stg_ordr_or_err.validate()?;
		Ok(())
	}
}


// StandingOrderReturnCriteria1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct StandingOrderReturnCriteria1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "StgOrdrIdInd", skip_serializing_if = "Option::is_none") )]
	pub stg_ordr_id_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TpInd", skip_serializing_if = "Option::is_none") )]
	pub tp_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SysMmbInd", skip_serializing_if = "Option::is_none") )]
	pub sys_mmb_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RspnsblPtyInd", skip_serializing_if = "Option::is_none") )]
	pub rspnsbl_pty_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CcyInd", skip_serializing_if = "Option::is_none") )]
	pub ccy_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtrAcctInd", skip_serializing_if = "Option::is_none") )]
	pub dbtr_acct_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtrAcctInd", skip_serializing_if = "Option::is_none") )]
	pub cdtr_acct_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AssoctdPoolAcct", skip_serializing_if = "Option::is_none") )]
	pub assoctd_pool_acct: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrqcyInd", skip_serializing_if = "Option::is_none") )]
	pub frqcy_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ExctnTpInd", skip_serializing_if = "Option::is_none") )]
	pub exctn_tp_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VldtyFrInd", skip_serializing_if = "Option::is_none") )]
	pub vldty_fr_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VldToInd", skip_serializing_if = "Option::is_none") )]
	pub vld_to_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LkSetIdInd", skip_serializing_if = "Option::is_none") )]
	pub lk_set_id_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LkSetOrdrIdInd", skip_serializing_if = "Option::is_none") )]
	pub lk_set_ordr_id_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LkSetOrdrSeqInd", skip_serializing_if = "Option::is_none") )]
	pub lk_set_ordr_seq_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlAmtInd", skip_serializing_if = "Option::is_none") )]
	pub ttl_amt_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ZeroSweepInd", skip_serializing_if = "Option::is_none") )]
	pub zero_sweep_ind: Option<bool>,
}

impl StandingOrderReturnCriteria1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// StandingOrderSearchCriteria5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct StandingOrderSearchCriteria5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "KeyAttrbtsInd", skip_serializing_if = "Option::is_none") )]
	pub key_attrbts_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StgOrdrId", skip_serializing_if = "Option::is_none") )]
	pub stg_ordr_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<StandingOrderType1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Acct", skip_serializing_if = "Option::is_none") )]
	pub acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ccy", skip_serializing_if = "Option::is_none") )]
	pub ccy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VldtyPrd", skip_serializing_if = "Option::is_none") )]
	pub vldty_prd: Option<DatePeriod2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SysMmb", skip_serializing_if = "Option::is_none") )]
	pub sys_mmb: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RspnsblPty", skip_serializing_if = "Option::is_none") )]
	pub rspnsbl_pty: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AssoctdPoolAcct", skip_serializing_if = "Option::is_none") )]
	pub assoctd_pool_acct: Option<AccountIdentification4Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LkSetId", skip_serializing_if = "Option::is_none") )]
	pub lk_set_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LkSetOrdrId", skip_serializing_if = "Option::is_none") )]
	pub lk_set_ordr_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LkSetOrdrSeq", skip_serializing_if = "Option::is_none") )]
	pub lk_set_ordr_seq: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ZeroSweepInd", skip_serializing_if = "Option::is_none") )]
	pub zero_sweep_ind: Option<bool>,
}

impl StandingOrderSearchCriteria5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.stg_ordr_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "stg_ordr_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "stg_ordr_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.tp { val.validate()? }
		if let Some(ref val) = self.acct { val.validate()? }
		if let Some(ref val) = self.ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ccy does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.vldty_prd { val.validate()? }
		if let Some(ref val) = self.sys_mmb { val.validate()? }
		if let Some(ref val) = self.rspnsbl_pty { val.validate()? }
		if let Some(ref val) = self.assoctd_pool_acct { val.validate()? }
		if let Some(ref val) = self.lk_set_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "lk_set_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "lk_set_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.lk_set_ordr_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "lk_set_ordr_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "lk_set_ordr_id exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// StandingOrderTotalAmount1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct StandingOrderTotalAmount1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SetPrdfndOrdr") )]
	pub set_prdfnd_ordr: TotalAmountAndCurrency1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PdgPrdfndOrdr") )]
	pub pdg_prdfnd_ordr: TotalAmountAndCurrency1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SetStgOrdr") )]
	pub set_stg_ordr: TotalAmountAndCurrency1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PdgStgOrdr") )]
	pub pdg_stg_ordr: TotalAmountAndCurrency1,
}

impl StandingOrderTotalAmount1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.set_prdfnd_ordr.validate()?;
		self.pdg_prdfnd_ordr.validate()?;
		self.set_stg_ordr.validate()?;
		self.pdg_stg_ordr.validate()?;
		Ok(())
	}
}


// StandingOrderType1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct StandingOrderType1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<StandingOrderType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification1>,
}

impl StandingOrderType1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// StandingOrderType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum StandingOrderType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "USTO") )]
	CodeUSTO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PSTO") )]
	CodePSTO,
}

impl StandingOrderType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// StatementGroup5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct StatementGroup5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "GrpId") )]
	pub grp_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sndr") )]
	pub sndr: PartyIdentification273,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SndrIndvCtct", skip_serializing_if = "Option::is_none") )]
	pub sndr_indv_ctct: Option<Vec<Contact13>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rcvr") )]
	pub rcvr: PartyIdentification273,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RcvrIndvCtct", skip_serializing_if = "Option::is_none") )]
	pub rcvr_indv_ctct: Option<Vec<Contact13>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BllgStmt") )]
	pub bllg_stmt: Vec<BillingStatement5>,
}

impl StatementGroup5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.grp_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "grp_id is shorter than the minimum length of 1".to_string()));
		}
		if self.grp_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "grp_id exceeds the maximum length of 35".to_string()));
		}
		self.sndr.validate()?;
		if let Some(ref vec) = self.sndr_indv_ctct { for item in vec { item.validate()? } }
		self.rcvr.validate()?;
		if let Some(ref vec) = self.rcvr_indv_ctct { for item in vec { item.validate()? } }
		for item in &self.bllg_stmt { item.validate()? }
		Ok(())
	}
}


// StatementResolutionEntry5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct StatementResolutionEntry5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlGrpInf", skip_serializing_if = "Option::is_none") )]
	pub orgnl_grp_inf: Option<OriginalGroupInformation29>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlStmtId", skip_serializing_if = "Option::is_none") )]
	pub orgnl_stmt_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UETR", skip_serializing_if = "Option::is_none") )]
	pub uetr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctSvcrRef", skip_serializing_if = "Option::is_none") )]
	pub acct_svcr_ref: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CrrctdAmt", skip_serializing_if = "Option::is_none") )]
	pub crrctd_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Chrgs", skip_serializing_if = "Option::is_none") )]
	pub chrgs: Option<Vec<Charges15>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Purp", skip_serializing_if = "Option::is_none") )]
	pub purp: Option<Purpose2Choice>,
}

impl StatementResolutionEntry5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.orgnl_grp_inf { val.validate()? }
		if let Some(ref val) = self.orgnl_stmt_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_stmt_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_stmt_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.uetr {
			let pattern = Regex::new("[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "uetr does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.acct_svcr_ref {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "acct_svcr_ref is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "acct_svcr_ref exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.crrctd_amt { val.validate()? }
		if let Some(ref vec) = self.chrgs { for item in vec { item.validate()? } }
		if let Some(ref val) = self.purp { val.validate()? }
		Ok(())
	}
}


// StatementUpdateType1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum StatementUpdateType1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "COMP") )]
	CodeCOMP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DELT") )]
	CodeDELT,
}

impl StatementUpdateType1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// StatusReason6Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct StatusReason6Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl StatusReason6Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// StatusReasonInformation12 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct StatusReasonInformation12 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Orgtr", skip_serializing_if = "Option::is_none") )]
	pub orgtr: Option<PartyIdentification135>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn", skip_serializing_if = "Option::is_none") )]
	pub rsn: Option<StatusReason6Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_inf: Option<Vec<String>>,
}

impl StatusReasonInformation12 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.orgtr { val.validate()? }
		if let Some(ref val) = self.rsn { val.validate()? }
		if let Some(ref vec) = self.addtl_inf {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "addtl_inf is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 105 {
					return Err(ValidationError::new(1002, "addtl_inf exceeds the maximum length of 105".to_string()));
				}
			}
		}
		Ok(())
	}
}


// StatusReasonInformation14 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct StatusReasonInformation14 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Orgtr", skip_serializing_if = "Option::is_none") )]
	pub orgtr: Option<PartyIdentification272>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn", skip_serializing_if = "Option::is_none") )]
	pub rsn: Option<StatusReason6Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_inf: Option<Vec<String>>,
}

impl StatusReasonInformation14 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.orgtr { val.validate()? }
		if let Some(ref val) = self.rsn { val.validate()? }
		if let Some(ref vec) = self.addtl_inf {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "addtl_inf is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 105 {
					return Err(ValidationError::new(1002, "addtl_inf exceeds the maximum length of 105".to_string()));
				}
			}
		}
		Ok(())
	}
}


// StructuredLongPostalAddress1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct StructuredLongPostalAddress1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BldgNm", skip_serializing_if = "Option::is_none") )]
	pub bldg_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StrtNm", skip_serializing_if = "Option::is_none") )]
	pub strt_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StrtBldgId", skip_serializing_if = "Option::is_none") )]
	pub strt_bldg_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Flr", skip_serializing_if = "Option::is_none") )]
	pub flr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TwnNm") )]
	pub twn_nm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DstrctNm", skip_serializing_if = "Option::is_none") )]
	pub dstrct_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RgnId", skip_serializing_if = "Option::is_none") )]
	pub rgn_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Stat", skip_serializing_if = "Option::is_none") )]
	pub stat: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtyId", skip_serializing_if = "Option::is_none") )]
	pub cty_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ctry") )]
	pub ctry: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PstCdId") )]
	pub pst_cd_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "POB", skip_serializing_if = "Option::is_none") )]
	pub pob: Option<String>,
}

impl StructuredLongPostalAddress1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.bldg_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "bldg_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "bldg_nm exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.strt_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "strt_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "strt_nm exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.strt_bldg_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "strt_bldg_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "strt_bldg_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.flr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "flr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 16 {
				return Err(ValidationError::new(1002, "flr exceeds the maximum length of 16".to_string()));
			}
		}
		if self.twn_nm.chars().count() < 1 {
			return Err(ValidationError::new(1001, "twn_nm is shorter than the minimum length of 1".to_string()));
		}
		if self.twn_nm.chars().count() > 35 {
			return Err(ValidationError::new(1002, "twn_nm exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.dstrct_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "dstrct_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "dstrct_nm exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.rgn_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "rgn_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "rgn_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.stat {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "stat is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "stat exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.cty_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cty_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "cty_id exceeds the maximum length of 35".to_string()));
			}
		}
		let pattern = Regex::new("[A-Z]{2,2}").unwrap();
		if !pattern.is_match(&self.ctry) {
			return Err(ValidationError::new(1005, "ctry does not match the required pattern".to_string()));
		}
		if self.pst_cd_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "pst_cd_id is shorter than the minimum length of 1".to_string()));
		}
		if self.pst_cd_id.chars().count() > 16 {
			return Err(ValidationError::new(1002, "pst_cd_id exceeds the maximum length of 16".to_string()));
		}
		if let Some(ref val) = self.pob {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "pob is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 16 {
				return Err(ValidationError::new(1002, "pob exceeds the maximum length of 16".to_string()));
			}
		}
		Ok(())
	}
}


// StructuredRemittanceInformation16 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct StructuredRemittanceInformation16 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RfrdDocInf", skip_serializing_if = "Option::is_none") )]
	pub rfrd_doc_inf: Option<Vec<ReferredDocumentInformation7>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RfrdDocAmt", skip_serializing_if = "Option::is_none") )]
	pub rfrd_doc_amt: Option<RemittanceAmount2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtrRefInf", skip_serializing_if = "Option::is_none") )]
	pub cdtr_ref_inf: Option<CreditorReferenceInformation2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Invcr", skip_serializing_if = "Option::is_none") )]
	pub invcr: Option<PartyIdentification135>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Invcee", skip_serializing_if = "Option::is_none") )]
	pub invcee: Option<PartyIdentification135>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TaxRmt", skip_serializing_if = "Option::is_none") )]
	pub tax_rmt: Option<TaxInformation7>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GrnshmtRmt", skip_serializing_if = "Option::is_none") )]
	pub grnshmt_rmt: Option<Garnishment3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlRmtInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_rmt_inf: Option<Vec<String>>,
}

impl StructuredRemittanceInformation16 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.rfrd_doc_inf { for item in vec { item.validate()? } }
		if let Some(ref val) = self.rfrd_doc_amt { val.validate()? }
		if let Some(ref val) = self.cdtr_ref_inf { val.validate()? }
		if let Some(ref val) = self.invcr { val.validate()? }
		if let Some(ref val) = self.invcee { val.validate()? }
		if let Some(ref val) = self.tax_rmt { val.validate()? }
		if let Some(ref val) = self.grnshmt_rmt { val.validate()? }
		if let Some(ref vec) = self.addtl_rmt_inf {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "addtl_rmt_inf is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 140 {
					return Err(ValidationError::new(1002, "addtl_rmt_inf exceeds the maximum length of 140".to_string()));
				}
			}
		}
		Ok(())
	}
}


// StructuredRemittanceInformation17 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct StructuredRemittanceInformation17 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RfrdDocInf", skip_serializing_if = "Option::is_none") )]
	pub rfrd_doc_inf: Option<Vec<ReferredDocumentInformation7>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RfrdDocAmt", skip_serializing_if = "Option::is_none") )]
	pub rfrd_doc_amt: Option<RemittanceAmount2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtrRefInf", skip_serializing_if = "Option::is_none") )]
	pub cdtr_ref_inf: Option<CreditorReferenceInformation2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Invcr", skip_serializing_if = "Option::is_none") )]
	pub invcr: Option<PartyIdentification135>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Invcee", skip_serializing_if = "Option::is_none") )]
	pub invcee: Option<PartyIdentification135>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TaxRmt", skip_serializing_if = "Option::is_none") )]
	pub tax_rmt: Option<TaxData1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GrnshmtRmt", skip_serializing_if = "Option::is_none") )]
	pub grnshmt_rmt: Option<Garnishment3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlRmtInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_rmt_inf: Option<Vec<String>>,
}

impl StructuredRemittanceInformation17 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.rfrd_doc_inf { for item in vec { item.validate()? } }
		if let Some(ref val) = self.rfrd_doc_amt { val.validate()? }
		if let Some(ref val) = self.cdtr_ref_inf { val.validate()? }
		if let Some(ref val) = self.invcr { val.validate()? }
		if let Some(ref val) = self.invcee { val.validate()? }
		if let Some(ref val) = self.tax_rmt { val.validate()? }
		if let Some(ref val) = self.grnshmt_rmt { val.validate()? }
		if let Some(ref vec) = self.addtl_rmt_inf {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "addtl_rmt_inf is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 140 {
					return Err(ValidationError::new(1002, "addtl_rmt_inf exceeds the maximum length of 140".to_string()));
				}
			}
		}
		Ok(())
	}
}


// StructuredRemittanceInformation18 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct StructuredRemittanceInformation18 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "RfrdDocInf", skip_serializing_if = "Option::is_none") )]
	pub rfrd_doc_inf: Option<Vec<ReferredDocumentInformation8>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RfrdDocAmt", skip_serializing_if = "Option::is_none") )]
	pub rfrd_doc_amt: Option<RemittanceAmount4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtrRefInf", skip_serializing_if = "Option::is_none") )]
	pub cdtr_ref_inf: Option<CreditorReferenceInformation3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Invcr", skip_serializing_if = "Option::is_none") )]
	pub invcr: Option<PartyIdentification272>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Invcee", skip_serializing_if = "Option::is_none") )]
	pub invcee: Option<PartyIdentification272>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TaxRmt", skip_serializing_if = "Option::is_none") )]
	pub tax_rmt: Option<TaxData1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GrnshmtRmt", skip_serializing_if = "Option::is_none") )]
	pub grnshmt_rmt: Option<Garnishment4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlRmtInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_rmt_inf: Option<Vec<String>>,
}

impl StructuredRemittanceInformation18 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.rfrd_doc_inf { for item in vec { item.validate()? } }
		if let Some(ref val) = self.rfrd_doc_amt { val.validate()? }
		if let Some(ref val) = self.cdtr_ref_inf { val.validate()? }
		if let Some(ref val) = self.invcr { val.validate()? }
		if let Some(ref val) = self.invcee { val.validate()? }
		if let Some(ref val) = self.tax_rmt { val.validate()? }
		if let Some(ref val) = self.grnshmt_rmt { val.validate()? }
		if let Some(ref vec) = self.addtl_rmt_inf {
			for item in vec {
				if item.chars().count() < 1 {
					return Err(ValidationError::new(1001, "addtl_rmt_inf is shorter than the minimum length of 1".to_string()));
				}
				if item.chars().count() > 140 {
					return Err(ValidationError::new(1002, "addtl_rmt_inf exceeds the maximum length of 140".to_string()));
				}
			}
		}
		Ok(())
	}
}


// SupplementaryData1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct SupplementaryData1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PlcAndNm", skip_serializing_if = "Option::is_none") )]
	pub plc_and_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Envlp") )]
	pub envlp: SupplementaryDataEnvelope1,
}

impl SupplementaryData1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.plc_and_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "plc_and_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 350 {
				return Err(ValidationError::new(1002, "plc_and_nm exceeds the maximum length of 350".to_string()));
			}
		}
		self.envlp.validate()?;
		Ok(())
	}
}


// SupplementaryDataEnvelope1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct SupplementaryDataEnvelope1 {
}

impl SupplementaryDataEnvelope1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// SuspendedStatusReason1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum SuspendedStatusReason1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "SUBY") )]
	CodeSUBY,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SUBS") )]
	CodeSUBS,
}

impl SuspendedStatusReason1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// System3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct System3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SysId", skip_serializing_if = "Option::is_none") )]
	pub sys_id: Option<MarketInfrastructureIdentification1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MmbId", skip_serializing_if = "Option::is_none") )]
	pub mmb_id: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ctry", skip_serializing_if = "Option::is_none") )]
	pub ctry: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctId", skip_serializing_if = "Option::is_none") )]
	pub acct_id: Option<AccountIdentification4Choice>,
}

impl System3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.sys_id { val.validate()? }
		if let Some(ref val) = self.mmb_id { val.validate()? }
		if let Some(ref val) = self.ctry {
			let pattern = Regex::new("[A-Z]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ctry does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.acct_id { val.validate()? }
		Ok(())
	}
}


// SystemAvailabilityAndEvents3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct SystemAvailabilityAndEvents3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SysCcy", skip_serializing_if = "Option::is_none") )]
	pub sys_ccy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SsnPrd", skip_serializing_if = "Option::is_none") )]
	pub ssn_prd: Option<TimePeriod1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Evt", skip_serializing_if = "Option::is_none") )]
	pub evt: Option<Vec<SystemEvent3>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClsrInf", skip_serializing_if = "Option::is_none") )]
	pub clsr_inf: Option<Vec<SystemClosure2>>,
}

impl SystemAvailabilityAndEvents3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.sys_ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "sys_ccy does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.ssn_prd { val.validate()? }
		if let Some(ref vec) = self.evt { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.clsr_inf { for item in vec { item.validate()? } }
		Ok(())
	}
}


// SystemBalanceType2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum SystemBalanceType2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "OPNG") )]
	CodeOPNG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INTM") )]
	CodeINTM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CLSG") )]
	CodeCLSG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BOOK") )]
	CodeBOOK,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CRRT") )]
	CodeCRRT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PDNG") )]
	CodePDNG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LRLD") )]
	CodeLRLD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AVLB") )]
	CodeAVLB,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LTSF") )]
	CodeLTSF,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CRDT") )]
	CodeCRDT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EAST") )]
	CodeEAST,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PYMT") )]
	CodePYMT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BLCK") )]
	CodeBLCK,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XPCD") )]
	CodeXPCD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DLOD") )]
	CodeDLOD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XCRD") )]
	CodeXCRD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XDBT") )]
	CodeXDBT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ADJT") )]
	CodeADJT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PRAV") )]
	CodePRAV,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DBIT") )]
	CodeDBIT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "THRE") )]
	CodeTHRE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NOTE") )]
	CodeNOTE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FSET") )]
	CodeFSET,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BLOC") )]
	CodeBLOC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTHB") )]
	CodeOTHB,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CUST") )]
	CodeCUST,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FORC") )]
	CodeFORC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "COLC") )]
	CodeCOLC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FUND") )]
	CodeFUND,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PIPO") )]
	CodePIPO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XCHG") )]
	CodeXCHG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CCPS") )]
	CodeCCPS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TOHB") )]
	CodeTOHB,
	#[cfg_attr( feature = "derive_serde", serde(rename = "COHB") )]
	CodeCOHB,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DOHB") )]
	CodeDOHB,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TPBL") )]
	CodeTPBL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CPBL") )]
	CodeCPBL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DPBL") )]
	CodeDPBL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FUTB") )]
	CodeFUTB,
	#[cfg_attr( feature = "derive_serde", serde(rename = "REJB") )]
	CodeREJB,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FCOL") )]
	CodeFCOL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FCOU") )]
	CodeFCOU,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SCOL") )]
	CodeSCOL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SCOU") )]
	CodeSCOU,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CUSA") )]
	CodeCUSA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XCHC") )]
	CodeXCHC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "XCHN") )]
	CodeXCHN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DSET") )]
	CodeDSET,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LACK") )]
	CodeLACK,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NSET") )]
	CodeNSET,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTCC") )]
	CodeOTCC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTCG") )]
	CodeOTCG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OTCN") )]
	CodeOTCN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SAPD") )]
	CodeSAPD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SAPC") )]
	CodeSAPC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "REPD") )]
	CodeREPD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "REPC") )]
	CodeREPC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BSCD") )]
	CodeBSCD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BSCC") )]
	CodeBSCC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SAPP") )]
	CodeSAPP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IRLT") )]
	CodeIRLT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IRDR") )]
	CodeIRDR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DWRD") )]
	CodeDWRD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ADWR") )]
	CodeADWR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AIDR") )]
	CodeAIDR,
}

impl SystemBalanceType2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// SystemClosure2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct SystemClosure2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prd", skip_serializing_if = "Option::is_none") )]
	pub prd: Option<DateTimePeriod1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rsn") )]
	pub rsn: ClosureReason2Choice,
}

impl SystemClosure2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.prd { val.validate()? }
		self.rsn.validate()?;
		Ok(())
	}
}


// SystemClosureReason1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum SystemClosureReason1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "BHOL") )]
	CodeBHOL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SMTN") )]
	CodeSMTN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NOOP") )]
	CodeNOOP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RCVR") )]
	CodeRCVR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ADTW") )]
	CodeADTW,
}

impl SystemClosureReason1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// SystemEvent3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct SystemEvent3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: SystemEventType4Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SchdldTm") )]
	pub schdld_tm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FctvTm", skip_serializing_if = "Option::is_none") )]
	pub fctv_tm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StartTm", skip_serializing_if = "Option::is_none") )]
	pub start_tm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EndTm", skip_serializing_if = "Option::is_none") )]
	pub end_tm: Option<String>,
}

impl SystemEvent3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.tp.validate()?;
		Ok(())
	}
}


// SystemEventType2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct SystemEventType2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<SystemEventType2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification1>,
}

impl SystemEventType2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// SystemEventType2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum SystemEventType2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "LVCO") )]
	CodeLVCO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LVCC") )]
	CodeLVCC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LVRT") )]
	CodeLVRT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EUSU") )]
	CodeEUSU,
	#[cfg_attr( feature = "derive_serde", serde(rename = "STSU") )]
	CodeSTSU,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LWSU") )]
	CodeLWSU,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EUCO") )]
	CodeEUCO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FIRE") )]
	CodeFIRE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "STDY") )]
	CodeSTDY,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LTNC") )]
	CodeLTNC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CRCO") )]
	CodeCRCO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RECC") )]
	CodeRECC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LTGC") )]
	CodeLTGC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LTDC") )]
	CodeLTDC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CUSC") )]
	CodeCUSC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IBKC") )]
	CodeIBKC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SYSC") )]
	CodeSYSC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SSSC") )]
	CodeSSSC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "REOP") )]
	CodeREOP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PCOT") )]
	CodePCOT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NPCT") )]
	CodeNPCT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ESTF") )]
	CodeESTF,
}

impl SystemEventType2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// SystemEventType4Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct SystemEventType4Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification1>,
}

impl SystemEventType4Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// SystemIdentification2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct SystemIdentification2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MktInfrstrctrId", skip_serializing_if = "Option::is_none") )]
	pub mkt_infrstrctr_id: Option<MarketInfrastructureIdentification1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ctry", skip_serializing_if = "Option::is_none") )]
	pub ctry: Option<String>,
}

impl SystemIdentification2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.mkt_infrstrctr_id { val.validate()? }
		if let Some(ref val) = self.ctry {
			let pattern = Regex::new("[A-Z]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ctry does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// SystemMember3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct SystemMember3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SysId", skip_serializing_if = "Option::is_none") )]
	pub sys_id: Option<SystemIdentification2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MmbId") )]
	pub mmb_id: MemberIdentification3Choice,
}

impl SystemMember3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.sys_id { val.validate()? }
		self.mmb_id.validate()?;
		Ok(())
	}
}


// SystemMemberStatus1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct SystemMemberStatus1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<MemberStatus1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl SystemMemberStatus1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// SystemMemberType1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct SystemMemberType1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl SystemMemberType1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// SystemPartyIdentification8 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct SystemPartyIdentification8 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id") )]
	pub id: PartyIdentification136,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RspnsblPtyId", skip_serializing_if = "Option::is_none") )]
	pub rspnsbl_pty_id: Option<PartyIdentification136>,
}

impl SystemPartyIdentification8 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.id.validate()?;
		if let Some(ref val) = self.rspnsbl_pty_id { val.validate()? }
		Ok(())
	}
}


// SystemReturnCriteria2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct SystemReturnCriteria2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SysIdInd", skip_serializing_if = "Option::is_none") )]
	pub sys_id_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MmbIdInd", skip_serializing_if = "Option::is_none") )]
	pub mmb_id_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtryIdInd", skip_serializing_if = "Option::is_none") )]
	pub ctry_id_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctIdInd", skip_serializing_if = "Option::is_none") )]
	pub acct_id_ind: Option<bool>,
}

impl SystemReturnCriteria2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// SystemSearch5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct SystemSearch5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "SysId", skip_serializing_if = "Option::is_none") )]
	pub sys_id: Option<Vec<ClearingSystemIdentification3Choice>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MmbId", skip_serializing_if = "Option::is_none") )]
	pub mmb_id: Option<Vec<BranchAndFinancialInstitutionIdentification8>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ctry", skip_serializing_if = "Option::is_none") )]
	pub ctry: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctId", skip_serializing_if = "Option::is_none") )]
	pub acct_id: Option<AccountIdentification4Choice>,
}

impl SystemSearch5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.sys_id { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.mmb_id { for item in vec { item.validate()? } }
		if let Some(ref val) = self.ctry {
			let pattern = Regex::new("[A-Z]{2,2}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ctry does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.acct_id { val.validate()? }
		Ok(())
	}
}


// SystemStatus2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct SystemStatus2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<SystemStatus2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification1>,
}

impl SystemStatus2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// SystemStatus2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum SystemStatus2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "SUSP") )]
	CodeSUSP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ACTV") )]
	CodeACTV,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CLSD") )]
	CodeCLSD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CLSG") )]
	CodeCLSG,
}

impl SystemStatus2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// SystemStatus3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct SystemStatus3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sts") )]
	pub sts: SystemStatus2Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VldtyTm", skip_serializing_if = "Option::is_none") )]
	pub vldty_tm: Option<DateTimePeriod1Choice>,
}

impl SystemStatus3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.sts.validate()?;
		if let Some(ref val) = self.vldty_tm { val.validate()? }
		Ok(())
	}
}


// TaxAmount2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TaxAmount2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rate", skip_serializing_if = "Option::is_none") )]
	pub rate: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TaxblBaseAmt", skip_serializing_if = "Option::is_none") )]
	pub taxbl_base_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlAmt", skip_serializing_if = "Option::is_none") )]
	pub ttl_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dtls", skip_serializing_if = "Option::is_none") )]
	pub dtls: Option<Vec<TaxRecordDetails2>>,
}

impl TaxAmount2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.taxbl_base_amt { val.validate()? }
		if let Some(ref val) = self.ttl_amt { val.validate()? }
		if let Some(ref vec) = self.dtls { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TaxAmount3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TaxAmount3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rate", skip_serializing_if = "Option::is_none") )]
	pub rate: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TaxblBaseAmt", skip_serializing_if = "Option::is_none") )]
	pub taxbl_base_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlAmt", skip_serializing_if = "Option::is_none") )]
	pub ttl_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dtls", skip_serializing_if = "Option::is_none") )]
	pub dtls: Option<Vec<TaxRecordDetails3>>,
}

impl TaxAmount3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.taxbl_base_amt { val.validate()? }
		if let Some(ref val) = self.ttl_amt { val.validate()? }
		if let Some(ref vec) = self.dtls { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TaxAmountAndType1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TaxAmountAndType1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<TaxAmountType1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveOrHistoricCurrencyAndAmount,
}

impl TaxAmountAndType1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tp { val.validate()? }
		self.amt.validate()?;
		Ok(())
	}
}


// TaxAmountType1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TaxAmountType1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl TaxAmountType1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// TaxAuthorisation1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TaxAuthorisation1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Titl", skip_serializing_if = "Option::is_none") )]
	pub titl: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Nm", skip_serializing_if = "Option::is_none") )]
	pub nm: Option<String>,
}

impl TaxAuthorisation1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.titl {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "titl is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "titl exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "nm exceeds the maximum length of 140".to_string()));
			}
		}
		Ok(())
	}
}


// TaxCalculation1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TaxCalculation1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "HstCcy") )]
	pub hst_ccy: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TaxblSvcChrgConvs") )]
	pub taxbl_svc_chrg_convs: Vec<BillingServicesAmount3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlTaxblSvcChrgHstAmt") )]
	pub ttl_taxbl_svc_chrg_hst_amt: AmountAndDirection34,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TaxId") )]
	pub tax_id: Vec<BillingServicesTax3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlTax") )]
	pub ttl_tax: AmountAndDirection34,
}

impl TaxCalculation1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[A-Z]{3,3}").unwrap();
		if !pattern.is_match(&self.hst_ccy) {
			return Err(ValidationError::new(1005, "hst_ccy does not match the required pattern".to_string()));
		}
		for item in &self.taxbl_svc_chrg_convs { item.validate()? }
		self.ttl_taxbl_svc_chrg_hst_amt.validate()?;
		for item in &self.tax_id { item.validate()? }
		self.ttl_tax.validate()?;
		Ok(())
	}
}


// TaxCharges2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TaxCharges2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Id", skip_serializing_if = "Option::is_none") )]
	pub id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rate", skip_serializing_if = "Option::is_none") )]
	pub rate: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt", skip_serializing_if = "Option::is_none") )]
	pub amt: Option<ActiveOrHistoricCurrencyAndAmount>,
}

impl TaxCharges2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.amt { val.validate()? }
		Ok(())
	}
}


// TaxData1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TaxData1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cdtr", skip_serializing_if = "Option::is_none") )]
	pub cdtr: Option<TaxParty1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dbtr", skip_serializing_if = "Option::is_none") )]
	pub dbtr: Option<TaxParty2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UltmtDbtr", skip_serializing_if = "Option::is_none") )]
	pub ultmt_dbtr: Option<TaxParty2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AdmstnZone", skip_serializing_if = "Option::is_none") )]
	pub admstn_zone: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RefNb", skip_serializing_if = "Option::is_none") )]
	pub ref_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Mtd", skip_serializing_if = "Option::is_none") )]
	pub mtd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlTaxblBaseAmt", skip_serializing_if = "Option::is_none") )]
	pub ttl_taxbl_base_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlTaxAmt", skip_serializing_if = "Option::is_none") )]
	pub ttl_tax_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dt", skip_serializing_if = "Option::is_none") )]
	pub dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SeqNb", skip_serializing_if = "Option::is_none") )]
	pub seq_nb: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rcrd", skip_serializing_if = "Option::is_none") )]
	pub rcrd: Option<Vec<TaxRecord3>>,
}

impl TaxData1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cdtr { val.validate()? }
		if let Some(ref val) = self.dbtr { val.validate()? }
		if let Some(ref val) = self.ultmt_dbtr { val.validate()? }
		if let Some(ref val) = self.admstn_zone {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "admstn_zone is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "admstn_zone exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.ref_nb {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "ref_nb is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "ref_nb exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.mtd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "mtd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "mtd exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.ttl_taxbl_base_amt { val.validate()? }
		if let Some(ref val) = self.ttl_tax_amt { val.validate()? }
		if let Some(ref vec) = self.rcrd { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TaxInformation7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TaxInformation7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cdtr", skip_serializing_if = "Option::is_none") )]
	pub cdtr: Option<TaxParty1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dbtr", skip_serializing_if = "Option::is_none") )]
	pub dbtr: Option<TaxParty2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UltmtDbtr", skip_serializing_if = "Option::is_none") )]
	pub ultmt_dbtr: Option<TaxParty2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AdmstnZone", skip_serializing_if = "Option::is_none") )]
	pub admstn_zone: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RefNb", skip_serializing_if = "Option::is_none") )]
	pub ref_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Mtd", skip_serializing_if = "Option::is_none") )]
	pub mtd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlTaxblBaseAmt", skip_serializing_if = "Option::is_none") )]
	pub ttl_taxbl_base_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlTaxAmt", skip_serializing_if = "Option::is_none") )]
	pub ttl_tax_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dt", skip_serializing_if = "Option::is_none") )]
	pub dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SeqNb", skip_serializing_if = "Option::is_none") )]
	pub seq_nb: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rcrd", skip_serializing_if = "Option::is_none") )]
	pub rcrd: Option<Vec<TaxRecord2>>,
}

impl TaxInformation7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cdtr { val.validate()? }
		if let Some(ref val) = self.dbtr { val.validate()? }
		if let Some(ref val) = self.ultmt_dbtr { val.validate()? }
		if let Some(ref val) = self.admstn_zone {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "admstn_zone is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "admstn_zone exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.ref_nb {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "ref_nb is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "ref_nb exceeds the maximum length of 140".to_string()));
			}
		}
		if let Some(ref val) = self.mtd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "mtd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "mtd exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.ttl_taxbl_base_amt { val.validate()? }
		if let Some(ref val) = self.ttl_tax_amt { val.validate()? }
		if let Some(ref vec) = self.rcrd { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TaxParty1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TaxParty1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TaxId", skip_serializing_if = "Option::is_none") )]
	pub tax_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RegnId", skip_serializing_if = "Option::is_none") )]
	pub regn_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TaxTp", skip_serializing_if = "Option::is_none") )]
	pub tax_tp: Option<String>,
}

impl TaxParty1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tax_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tax_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "tax_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.regn_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "regn_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "regn_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.tax_tp {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tax_tp is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "tax_tp exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// TaxParty2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TaxParty2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TaxId", skip_serializing_if = "Option::is_none") )]
	pub tax_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RegnId", skip_serializing_if = "Option::is_none") )]
	pub regn_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TaxTp", skip_serializing_if = "Option::is_none") )]
	pub tax_tp: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Authstn", skip_serializing_if = "Option::is_none") )]
	pub authstn: Option<TaxAuthorisation1>,
}

impl TaxParty2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tax_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tax_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "tax_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.regn_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "regn_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "regn_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.tax_tp {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tax_tp is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "tax_tp exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.authstn { val.validate()? }
		Ok(())
	}
}


// TaxPeriod2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TaxPeriod2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Yr", skip_serializing_if = "Option::is_none") )]
	pub yr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<TaxRecordPeriod1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrToDt", skip_serializing_if = "Option::is_none") )]
	pub fr_to_dt: Option<DatePeriod2>,
}

impl TaxPeriod2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tp { val.validate()? }
		if let Some(ref val) = self.fr_to_dt { val.validate()? }
		Ok(())
	}
}


// TaxPeriod3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TaxPeriod3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Yr", skip_serializing_if = "Option::is_none") )]
	pub yr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<TaxRecordPeriod1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrToDt", skip_serializing_if = "Option::is_none") )]
	pub fr_to_dt: Option<DatePeriod2>,
}

impl TaxPeriod3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tp { val.validate()? }
		if let Some(ref val) = self.fr_to_dt { val.validate()? }
		Ok(())
	}
}


// TaxReason1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TaxReason1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd") )]
	pub cd: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Expltn") )]
	pub expltn: String,
}

impl TaxReason1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.cd.chars().count() < 1 {
			return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
		}
		if self.cd.chars().count() > 10 {
			return Err(ValidationError::new(1002, "cd exceeds the maximum length of 10".to_string()));
		}
		if self.expltn.chars().count() < 1 {
			return Err(ValidationError::new(1001, "expltn is shorter than the minimum length of 1".to_string()));
		}
		if self.expltn.chars().count() > 105 {
			return Err(ValidationError::new(1002, "expltn exceeds the maximum length of 105".to_string()));
		}
		Ok(())
	}
}


// TaxRecord2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TaxRecord2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ctgy", skip_serializing_if = "Option::is_none") )]
	pub ctgy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtgyDtls", skip_serializing_if = "Option::is_none") )]
	pub ctgy_dtls: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtrSts", skip_serializing_if = "Option::is_none") )]
	pub dbtr_sts: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CertId", skip_serializing_if = "Option::is_none") )]
	pub cert_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrmsCd", skip_serializing_if = "Option::is_none") )]
	pub frms_cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prd", skip_serializing_if = "Option::is_none") )]
	pub prd: Option<TaxPeriod2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TaxAmt", skip_serializing_if = "Option::is_none") )]
	pub tax_amt: Option<TaxAmount2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_inf: Option<String>,
}

impl TaxRecord2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tp {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tp is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "tp exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.ctgy {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "ctgy is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "ctgy exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.ctgy_dtls {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "ctgy_dtls is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "ctgy_dtls exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.dbtr_sts {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "dbtr_sts is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "dbtr_sts exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.cert_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cert_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "cert_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.frms_cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "frms_cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "frms_cd exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.prd { val.validate()? }
		if let Some(ref val) = self.tax_amt { val.validate()? }
		if let Some(ref val) = self.addtl_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "addtl_inf exceeds the maximum length of 140".to_string()));
			}
		}
		Ok(())
	}
}


// TaxRecord3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TaxRecord3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp", skip_serializing_if = "Option::is_none") )]
	pub tp: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ctgy", skip_serializing_if = "Option::is_none") )]
	pub ctgy: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtgyDtls", skip_serializing_if = "Option::is_none") )]
	pub ctgy_dtls: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtrSts", skip_serializing_if = "Option::is_none") )]
	pub dbtr_sts: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CertId", skip_serializing_if = "Option::is_none") )]
	pub cert_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrmsCd", skip_serializing_if = "Option::is_none") )]
	pub frms_cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prd", skip_serializing_if = "Option::is_none") )]
	pub prd: Option<TaxPeriod3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TaxAmt", skip_serializing_if = "Option::is_none") )]
	pub tax_amt: Option<TaxAmount3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_inf: Option<String>,
}

impl TaxRecord3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tp {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tp is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "tp exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.ctgy {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "ctgy is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "ctgy exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.ctgy_dtls {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "ctgy_dtls is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "ctgy_dtls exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.dbtr_sts {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "dbtr_sts is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "dbtr_sts exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.cert_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cert_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "cert_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.frms_cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "frms_cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "frms_cd exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.prd { val.validate()? }
		if let Some(ref val) = self.tax_amt { val.validate()? }
		if let Some(ref val) = self.addtl_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "addtl_inf exceeds the maximum length of 140".to_string()));
			}
		}
		Ok(())
	}
}


// TaxRecordDetails2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TaxRecordDetails2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prd", skip_serializing_if = "Option::is_none") )]
	pub prd: Option<TaxPeriod2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveOrHistoricCurrencyAndAmount,
}

impl TaxRecordDetails2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.prd { val.validate()? }
		self.amt.validate()?;
		Ok(())
	}
}


// TaxRecordDetails3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TaxRecordDetails3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prd", skip_serializing_if = "Option::is_none") )]
	pub prd: Option<TaxPeriod3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveOrHistoricCurrencyAndAmount,
}

impl TaxRecordDetails3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.prd { val.validate()? }
		self.amt.validate()?;
		Ok(())
	}
}


// TaxRecordPeriod1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum TaxRecordPeriod1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "MM01") )]
	CodeMM01,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MM02") )]
	CodeMM02,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MM03") )]
	CodeMM03,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MM04") )]
	CodeMM04,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MM05") )]
	CodeMM05,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MM06") )]
	CodeMM06,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MM07") )]
	CodeMM07,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MM08") )]
	CodeMM08,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MM09") )]
	CodeMM09,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MM10") )]
	CodeMM10,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MM11") )]
	CodeMM11,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MM12") )]
	CodeMM12,
	#[cfg_attr( feature = "derive_serde", serde(rename = "QTR1") )]
	CodeQTR1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "QTR2") )]
	CodeQTR2,
	#[cfg_attr( feature = "derive_serde", serde(rename = "QTR3") )]
	CodeQTR3,
	#[cfg_attr( feature = "derive_serde", serde(rename = "QTR4") )]
	CodeQTR4,
	#[cfg_attr( feature = "derive_serde", serde(rename = "HLF1") )]
	CodeHLF1,
	#[cfg_attr( feature = "derive_serde", serde(rename = "HLF2") )]
	CodeHLF2,
}

impl TaxRecordPeriod1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// TechnicalInputChannel1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TechnicalInputChannel1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl TechnicalInputChannel1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// TimePeriod1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TimePeriod1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrTm") )]
	pub fr_tm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ToTm") )]
	pub to_tm: String,
}

impl TimePeriod1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// TimePeriodDetails1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TimePeriodDetails1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "FrTm") )]
	pub fr_tm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ToTm", skip_serializing_if = "Option::is_none") )]
	pub to_tm: Option<String>,
}

impl TimePeriodDetails1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// TotalAmountAndCurrency1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TotalAmountAndCurrency1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlAmt") )]
	pub ttl_amt: f64,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtDbtInd", skip_serializing_if = "Option::is_none") )]
	pub cdt_dbt_ind: Option<CreditDebitCode>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ccy", skip_serializing_if = "Option::is_none") )]
	pub ccy: Option<String>,
}

impl TotalAmountAndCurrency1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cdt_dbt_ind { val.validate()? }
		if let Some(ref val) = self.ccy {
			let pattern = Regex::new("[A-Z]{3,3}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "ccy does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// TotalCharges7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TotalCharges7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfChrgsRcrds") )]
	pub nb_of_chrgs_rcrds: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrlSum", skip_serializing_if = "Option::is_none") )]
	pub ctrl_sum: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlChrgsAmt", skip_serializing_if = "Option::is_none") )]
	pub ttl_chrgs_amt: Option<ActiveCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtDbtInd", skip_serializing_if = "Option::is_none") )]
	pub cdt_dbt_ind: Option<CreditDebitCode>,
}

impl TotalCharges7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[0-9]{1,15}").unwrap();
		if !pattern.is_match(&self.nb_of_chrgs_rcrds) {
			return Err(ValidationError::new(1005, "nb_of_chrgs_rcrds does not match the required pattern".to_string()));
		}
		if let Some(ref val) = self.ttl_chrgs_amt { val.validate()? }
		if let Some(ref val) = self.cdt_dbt_ind { val.validate()? }
		Ok(())
	}
}


// TotalCharges8 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TotalCharges8 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfChrgsBrkdwnItms") )]
	pub nb_of_chrgs_brkdwn_itms: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CtrlSum", skip_serializing_if = "Option::is_none") )]
	pub ctrl_sum: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlChrgsAmt", skip_serializing_if = "Option::is_none") )]
	pub ttl_chrgs_amt: Option<ActiveCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtDbtInd", skip_serializing_if = "Option::is_none") )]
	pub cdt_dbt_ind: Option<CreditDebitCode>,
}

impl TotalCharges8 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[0-9]{1,15}").unwrap();
		if !pattern.is_match(&self.nb_of_chrgs_brkdwn_itms) {
			return Err(ValidationError::new(1005, "nb_of_chrgs_brkdwn_itms does not match the required pattern".to_string()));
		}
		if let Some(ref val) = self.ttl_chrgs_amt { val.validate()? }
		if let Some(ref val) = self.cdt_dbt_ind { val.validate()? }
		Ok(())
	}
}


// TotalNumber1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TotalNumber1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "CurInstrNb") )]
	pub cur_instr_nb: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlOfLkdInstrs") )]
	pub ttl_of_lkd_instrs: String,
}

impl TotalNumber1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		let pattern = Regex::new("[0-9]{3}").unwrap();
		if !pattern.is_match(&self.cur_instr_nb) {
			return Err(ValidationError::new(1005, "cur_instr_nb does not match the required pattern".to_string()));
		}
		let pattern = Regex::new("[0-9]{3}").unwrap();
		if !pattern.is_match(&self.ttl_of_lkd_instrs) {
			return Err(ValidationError::new(1005, "ttl_of_lkd_instrs does not match the required pattern".to_string()));
		}
		Ok(())
	}
}


// TotalTransactions6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TotalTransactions6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlNtries", skip_serializing_if = "Option::is_none") )]
	pub ttl_ntries: Option<NumberAndSumOfTransactions4>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlCdtNtries", skip_serializing_if = "Option::is_none") )]
	pub ttl_cdt_ntries: Option<NumberAndSumOfTransactions1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlDbtNtries", skip_serializing_if = "Option::is_none") )]
	pub ttl_dbt_ntries: Option<NumberAndSumOfTransactions1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlNtriesPerBkTxCd", skip_serializing_if = "Option::is_none") )]
	pub ttl_ntries_per_bk_tx_cd: Option<Vec<TotalsPerBankTransactionCode5>>,
}

impl TotalTransactions6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ttl_ntries { val.validate()? }
		if let Some(ref val) = self.ttl_cdt_ntries { val.validate()? }
		if let Some(ref val) = self.ttl_dbt_ntries { val.validate()? }
		if let Some(ref vec) = self.ttl_ntries_per_bk_tx_cd { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TotalsPerBankTransactionCode5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TotalsPerBankTransactionCode5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NbOfNtries", skip_serializing_if = "Option::is_none") )]
	pub nb_of_ntries: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sum", skip_serializing_if = "Option::is_none") )]
	pub sum: Option<f64>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlNetNtry", skip_serializing_if = "Option::is_none") )]
	pub ttl_net_ntry: Option<AmountAndDirection35>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtNtries", skip_serializing_if = "Option::is_none") )]
	pub cdt_ntries: Option<NumberAndSumOfTransactions1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtNtries", skip_serializing_if = "Option::is_none") )]
	pub dbt_ntries: Option<NumberAndSumOfTransactions1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FcstInd", skip_serializing_if = "Option::is_none") )]
	pub fcst_ind: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BkTxCd") )]
	pub bk_tx_cd: BankTransactionCodeStructure4,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Avlbty", skip_serializing_if = "Option::is_none") )]
	pub avlbty: Option<Vec<CashAvailability1>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dt", skip_serializing_if = "Option::is_none") )]
	pub dt: Option<DateAndDateTime2Choice>,
}

impl TotalsPerBankTransactionCode5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.nb_of_ntries {
			let pattern = Regex::new("[0-9]{1,15}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "nb_of_ntries does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.ttl_net_ntry { val.validate()? }
		if let Some(ref val) = self.cdt_ntries { val.validate()? }
		if let Some(ref val) = self.dbt_ntries { val.validate()? }
		self.bk_tx_cd.validate()?;
		if let Some(ref vec) = self.avlbty { for item in vec { item.validate()? } }
		if let Some(ref val) = self.dt { val.validate()? }
		Ok(())
	}
}


// TrackData1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TrackData1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TrckNb", skip_serializing_if = "Option::is_none") )]
	pub trck_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TrckVal") )]
	pub trck_val: String,
}

impl TrackData1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.trck_nb {
			let pattern = Regex::new("[0-9]").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "trck_nb does not match the required pattern".to_string()));
			}
		}
		if self.trck_val.chars().count() < 1 {
			return Err(ValidationError::new(1001, "trck_val is shorter than the minimum length of 1".to_string()));
		}
		if self.trck_val.chars().count() > 140 {
			return Err(ValidationError::new(1002, "trck_val exceeds the maximum length of 140".to_string()));
		}
		Ok(())
	}
}


// Transaction159 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Transaction159 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtTo", skip_serializing_if = "Option::is_none") )]
	pub pmt_to: Option<System3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtFr", skip_serializing_if = "Option::is_none") )]
	pub pmt_fr: Option<System3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtDbtInd", skip_serializing_if = "Option::is_none") )]
	pub cdt_dbt_ind: Option<CreditDebitCode>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pmt", skip_serializing_if = "Option::is_none") )]
	pub pmt: Option<PaymentInstruction47>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctNtry", skip_serializing_if = "Option::is_none") )]
	pub acct_ntry: Option<CashAccountAndEntry5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SctiesTxRefs", skip_serializing_if = "Option::is_none") )]
	pub scties_tx_refs: Option<SecuritiesTransactionReferences1>,
}

impl Transaction159 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.pmt_to { val.validate()? }
		if let Some(ref val) = self.pmt_fr { val.validate()? }
		if let Some(ref val) = self.cdt_dbt_ind { val.validate()? }
		if let Some(ref val) = self.pmt { val.validate()? }
		if let Some(ref val) = self.acct_ntry { val.validate()? }
		if let Some(ref val) = self.scties_tx_refs { val.validate()? }
		Ok(())
	}
}


// TransactionAgents6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TransactionAgents6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstgAgt", skip_serializing_if = "Option::is_none") )]
	pub instg_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstdAgt", skip_serializing_if = "Option::is_none") )]
	pub instd_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtrAgt", skip_serializing_if = "Option::is_none") )]
	pub dbtr_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtrAgt", skip_serializing_if = "Option::is_none") )]
	pub cdtr_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrmyAgt1", skip_serializing_if = "Option::is_none") )]
	pub intrmy_agt1: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrmyAgt2", skip_serializing_if = "Option::is_none") )]
	pub intrmy_agt2: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrmyAgt3", skip_serializing_if = "Option::is_none") )]
	pub intrmy_agt3: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RcvgAgt", skip_serializing_if = "Option::is_none") )]
	pub rcvg_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DlvrgAgt", skip_serializing_if = "Option::is_none") )]
	pub dlvrg_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IssgAgt", skip_serializing_if = "Option::is_none") )]
	pub issg_agt: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SttlmPlc", skip_serializing_if = "Option::is_none") )]
	pub sttlm_plc: Option<BranchAndFinancialInstitutionIdentification8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<Vec<ProprietaryAgent5>>,
}

impl TransactionAgents6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.instg_agt { val.validate()? }
		if let Some(ref val) = self.instd_agt { val.validate()? }
		if let Some(ref val) = self.dbtr_agt { val.validate()? }
		if let Some(ref val) = self.cdtr_agt { val.validate()? }
		if let Some(ref val) = self.intrmy_agt1 { val.validate()? }
		if let Some(ref val) = self.intrmy_agt2 { val.validate()? }
		if let Some(ref val) = self.intrmy_agt3 { val.validate()? }
		if let Some(ref val) = self.rcvg_agt { val.validate()? }
		if let Some(ref val) = self.dlvrg_agt { val.validate()? }
		if let Some(ref val) = self.issg_agt { val.validate()? }
		if let Some(ref val) = self.sttlm_plc { val.validate()? }
		if let Some(ref vec) = self.prtry { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TransactionAllocation1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TransactionAllocation1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt") )]
	pub amt: ActiveOrHistoricCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtDbtInd") )]
	pub cdt_dbt_ind: CreditDebitCode,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Acct") )]
	pub acct: CashAccount40,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Purp") )]
	pub purp: Purpose2Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Ref") )]
	pub ref_attr: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RltdRefs", skip_serializing_if = "Option::is_none") )]
	pub rltd_refs: Option<Vec<References74Choice>>,
}

impl TransactionAllocation1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.amt.validate()?;
		self.cdt_dbt_ind.validate()?;
		self.acct.validate()?;
		self.purp.validate()?;
		if self.ref_attr.chars().count() < 1 {
			return Err(ValidationError::new(1001, "ref_attr is shorter than the minimum length of 1".to_string()));
		}
		if self.ref_attr.chars().count() > 35 {
			return Err(ValidationError::new(1002, "ref_attr exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref vec) = self.rltd_refs { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TransactionAmendment1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TransactionAmendment1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pth", skip_serializing_if = "Option::is_none") )]
	pub pth: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rcrd") )]
	pub rcrd: TransactionAmendment1Choice,
}

impl TransactionAmendment1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.pth {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "pth is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 2048 {
				return Err(ValidationError::new(1002, "pth exceeds the maximum length of 2048".to_string()));
			}
		}
		self.rcrd.validate()?;
		Ok(())
	}
}


// TransactionAmendment1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TransactionAmendment1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Agt", skip_serializing_if = "Option::is_none") )]
	pub agt: Option<BranchAndFinancialInstitutionIdentification6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Amt", skip_serializing_if = "Option::is_none") )]
	pub amt: Option<ActiveCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AnyBIC", skip_serializing_if = "Option::is_none") )]
	pub any_bic: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BICFI", skip_serializing_if = "Option::is_none") )]
	pub bicfi: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CshAcct", skip_serializing_if = "Option::is_none") )]
	pub csh_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dt", skip_serializing_if = "Option::is_none") )]
	pub dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DtTm", skip_serializing_if = "Option::is_none") )]
	pub dt_tm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Pty", skip_serializing_if = "Option::is_none") )]
	pub pty: Option<PartyIdentification135>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rmt", skip_serializing_if = "Option::is_none") )]
	pub rmt: Option<Remittance1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<String>,
}

impl TransactionAmendment1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.agt { val.validate()? }
		if let Some(ref val) = self.amt { val.validate()? }
		if let Some(ref val) = self.any_bic {
			let pattern = Regex::new("[A-Z0-9]{4,4}[A-Z]{2,2}[A-Z0-9]{2,2}([A-Z0-9]{3,3}){0,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "any_bic does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.bicfi {
			let pattern = Regex::new("[A-Z0-9]{4,4}[A-Z]{2,2}[A-Z0-9]{2,2}([A-Z0-9]{3,3}){0,1}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "bicfi does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.csh_acct { val.validate()? }
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.pty { val.validate()? }
		if let Some(ref val) = self.rmt { val.validate()? }
		if let Some(ref val) = self.othr {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "othr is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "othr exceeds the maximum length of 140".to_string()));
			}
		}
		Ok(())
	}
}


// TransactionAndDocumentIdentification6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TransactionAndDocumentIdentification6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxId") )]
	pub tx_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DocId", skip_serializing_if = "Option::is_none") )]
	pub doc_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CreDtTm", skip_serializing_if = "Option::is_none") )]
	pub cre_dt_tm: Option<DateAndDateTime2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CpyDplct", skip_serializing_if = "Option::is_none") )]
	pub cpy_dplct: Option<CopyDuplicate1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgOrgtr", skip_serializing_if = "Option::is_none") )]
	pub msg_orgtr: Option<PartyIdentification136>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgRcpt", skip_serializing_if = "Option::is_none") )]
	pub msg_rcpt: Option<PartyIdentification136>,
}

impl TransactionAndDocumentIdentification6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.tx_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "tx_id is shorter than the minimum length of 1".to_string()));
		}
		if self.tx_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "tx_id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.doc_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "doc_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "doc_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.cre_dt_tm { val.validate()? }
		if let Some(ref val) = self.cpy_dplct { val.validate()? }
		if let Some(ref val) = self.msg_orgtr { val.validate()? }
		if let Some(ref val) = self.msg_rcpt { val.validate()? }
		Ok(())
	}
}


// TransactionChannel1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum TransactionChannel1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "MAIL") )]
	CodeMAIL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TLPH") )]
	CodeTLPH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ECOM") )]
	CodeECOM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TVPY") )]
	CodeTVPY,
}

impl TransactionChannel1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// TransactionCriteria11 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TransactionCriteria11 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "NewQryNm", skip_serializing_if = "Option::is_none") )]
	pub new_qry_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SchCrit", skip_serializing_if = "Option::is_none") )]
	pub sch_crit: Option<Vec<TransactionSearchCriteria11>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StmtRpt", skip_serializing_if = "Option::is_none") )]
	pub stmt_rpt: Option<ReportIndicator1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RtrCrit", skip_serializing_if = "Option::is_none") )]
	pub rtr_crit: Option<TransactionReturnCriteria5>,
}

impl TransactionCriteria11 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.new_qry_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "new_qry_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "new_qry_nm exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref vec) = self.sch_crit { for item in vec { item.validate()? } }
		if let Some(ref val) = self.stmt_rpt { val.validate()? }
		if let Some(ref val) = self.rtr_crit { val.validate()? }
		Ok(())
	}
}


// TransactionCriteria8Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TransactionCriteria8Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "QryNm", skip_serializing_if = "Option::is_none") )]
	pub qry_nm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NewCrit", skip_serializing_if = "Option::is_none") )]
	pub new_crit: Option<TransactionCriteria11>,
}

impl TransactionCriteria8Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.qry_nm {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "qry_nm is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "qry_nm exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.new_crit { val.validate()? }
		Ok(())
	}
}


// TransactionDates3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TransactionDates3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AccptncDtTm", skip_serializing_if = "Option::is_none") )]
	pub accptnc_dt_tm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradActvtyCtrctlSttlmDt", skip_serializing_if = "Option::is_none") )]
	pub trad_actvty_ctrctl_sttlm_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradDt", skip_serializing_if = "Option::is_none") )]
	pub trad_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrBkSttlmDt", skip_serializing_if = "Option::is_none") )]
	pub intr_bk_sttlm_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StartDt", skip_serializing_if = "Option::is_none") )]
	pub start_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EndDt", skip_serializing_if = "Option::is_none") )]
	pub end_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxDtTm", skip_serializing_if = "Option::is_none") )]
	pub tx_dt_tm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<Vec<ProprietaryDate3>>,
}

impl TransactionDates3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.prtry { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TransactionEnvironment1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum TransactionEnvironment1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "MERC") )]
	CodeMERC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PRIV") )]
	CodePRIV,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PUBL") )]
	CodePUBL,
}

impl TransactionEnvironment1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// TransactionIdentifications24 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TransactionIdentifications24 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctOwnrTxId") )]
	pub acct_ownr_tx_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctSvcrTxId", skip_serializing_if = "Option::is_none") )]
	pub acct_svcr_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MktInfrstrctrTxId", skip_serializing_if = "Option::is_none") )]
	pub mkt_infrstrctr_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrcrTxId", skip_serializing_if = "Option::is_none") )]
	pub prcr_tx_id: Option<String>,
}

impl TransactionIdentifications24 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.acct_ownr_tx_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "acct_ownr_tx_id is shorter than the minimum length of 1".to_string()));
		}
		if self.acct_ownr_tx_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "acct_ownr_tx_id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.acct_svcr_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "acct_svcr_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "acct_svcr_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.mkt_infrstrctr_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "mkt_infrstrctr_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "mkt_infrstrctr_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.prcr_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prcr_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prcr_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// TransactionIdentifier1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TransactionIdentifier1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxDtTm") )]
	pub tx_dt_tm: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxRef") )]
	pub tx_ref: String,
}

impl TransactionIdentifier1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.tx_ref.chars().count() < 1 {
			return Err(ValidationError::new(1001, "tx_ref is shorter than the minimum length of 1".to_string()));
		}
		if self.tx_ref.chars().count() > 35 {
			return Err(ValidationError::new(1002, "tx_ref exceeds the maximum length of 35".to_string()));
		}
		Ok(())
	}
}


// TransactionIndividualStatus1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum TransactionIndividualStatus1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "ACTC") )]
	CodeACTC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RJCT") )]
	CodeRJCT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PDNG") )]
	CodePDNG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ACCP") )]
	CodeACCP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ACSP") )]
	CodeACSP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ACSC") )]
	CodeACSC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ACCR") )]
	CodeACCR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ACWC") )]
	CodeACWC,
}

impl TransactionIndividualStatus1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// TransactionInterest4 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TransactionInterest4 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "TtlIntrstAndTaxAmt", skip_serializing_if = "Option::is_none") )]
	pub ttl_intrst_and_tax_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Rcrd", skip_serializing_if = "Option::is_none") )]
	pub rcrd: Option<Vec<InterestRecord2>>,
}

impl TransactionInterest4 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.ttl_intrst_and_tax_amt { val.validate()? }
		if let Some(ref vec) = self.rcrd { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TransactionModification7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TransactionModification7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtId") )]
	pub pmt_id: PaymentIdentification8Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NewPmtValSet") )]
	pub new_pmt_val_set: PaymentInstruction33,
}

impl TransactionModification7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.pmt_id.validate()?;
		self.new_pmt_val_set.validate()?;
		Ok(())
	}
}


// TransactionOrError6Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TransactionOrError6Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tx", skip_serializing_if = "Option::is_none") )]
	pub tx: Option<Transaction159>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "BizErr", skip_serializing_if = "Option::is_none") )]
	pub biz_err: Option<Vec<ErrorHandling5>>,
}

impl TransactionOrError6Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.tx { val.validate()? }
		if let Some(ref vec) = self.biz_err { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TransactionParties12 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TransactionParties12 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "InitgPty", skip_serializing_if = "Option::is_none") )]
	pub initg_pty: Option<Party50Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Dbtr", skip_serializing_if = "Option::is_none") )]
	pub dbtr: Option<Party50Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DbtrAcct", skip_serializing_if = "Option::is_none") )]
	pub dbtr_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UltmtDbtr", skip_serializing_if = "Option::is_none") )]
	pub ultmt_dbtr: Option<Party50Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cdtr", skip_serializing_if = "Option::is_none") )]
	pub cdtr: Option<Party50Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtrAcct", skip_serializing_if = "Option::is_none") )]
	pub cdtr_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UltmtCdtr", skip_serializing_if = "Option::is_none") )]
	pub ultmt_cdtr: Option<Party50Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TradgPty", skip_serializing_if = "Option::is_none") )]
	pub tradg_pty: Option<Party50Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<Vec<ProprietaryParty6>>,
}

impl TransactionParties12 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.initg_pty { val.validate()? }
		if let Some(ref val) = self.dbtr { val.validate()? }
		if let Some(ref val) = self.dbtr_acct { val.validate()? }
		if let Some(ref val) = self.ultmt_dbtr { val.validate()? }
		if let Some(ref val) = self.cdtr { val.validate()? }
		if let Some(ref val) = self.cdtr_acct { val.validate()? }
		if let Some(ref val) = self.ultmt_cdtr { val.validate()? }
		if let Some(ref val) = self.tradg_pty { val.validate()? }
		if let Some(ref vec) = self.prtry { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TransactionPrice4Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TransactionPrice4Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "DealPric", skip_serializing_if = "Option::is_none") )]
	pub deal_pric: Option<Price7>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<Vec<ProprietaryPrice2>>,
}

impl TransactionPrice4Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.deal_pric { val.validate()? }
		if let Some(ref vec) = self.prtry { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TransactionProcessingStatus3Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum TransactionProcessingStatus3Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "CAND") )]
	CodeCAND,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PACK") )]
	CodePACK,
	#[cfg_attr( feature = "derive_serde", serde(rename = "REJT") )]
	CodeREJT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "REPR") )]
	CodeREPR,
}

impl TransactionProcessingStatus3Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// TransactionQuantities3Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TransactionQuantities3Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Qty", skip_serializing_if = "Option::is_none") )]
	pub qty: Option<FinancialInstrumentQuantity1Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlAndCurFaceAmt", skip_serializing_if = "Option::is_none") )]
	pub orgnl_and_cur_face_amt: Option<OriginalAndCurrentQuantities1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<ProprietaryQuantity1>,
}

impl TransactionQuantities3Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.qty { val.validate()? }
		if let Some(ref val) = self.orgnl_and_cur_face_amt { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// TransactionQuery8 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TransactionQuery8 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "QryTp", skip_serializing_if = "Option::is_none") )]
	pub qry_tp: Option<QueryType2Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxCrit", skip_serializing_if = "Option::is_none") )]
	pub tx_crit: Option<TransactionCriteria8Choice>,
}

impl TransactionQuery8 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.qry_tp { val.validate()? }
		if let Some(ref val) = self.tx_crit { val.validate()? }
		Ok(())
	}
}


// TransactionReferences6 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TransactionReferences6 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgId", skip_serializing_if = "Option::is_none") )]
	pub msg_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctSvcrRef", skip_serializing_if = "Option::is_none") )]
	pub acct_svcr_ref: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtInfId", skip_serializing_if = "Option::is_none") )]
	pub pmt_inf_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstrId", skip_serializing_if = "Option::is_none") )]
	pub instr_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EndToEndId", skip_serializing_if = "Option::is_none") )]
	pub end_to_end_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UETR", skip_serializing_if = "Option::is_none") )]
	pub uetr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxId", skip_serializing_if = "Option::is_none") )]
	pub tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MndtId", skip_serializing_if = "Option::is_none") )]
	pub mndt_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChqNb", skip_serializing_if = "Option::is_none") )]
	pub chq_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrSysRef", skip_serializing_if = "Option::is_none") )]
	pub clr_sys_ref: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctOwnrTxId", skip_serializing_if = "Option::is_none") )]
	pub acct_ownr_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctSvcrTxId", skip_serializing_if = "Option::is_none") )]
	pub acct_svcr_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MktInfrstrctrTxId", skip_serializing_if = "Option::is_none") )]
	pub mkt_infrstrctr_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrcgId", skip_serializing_if = "Option::is_none") )]
	pub prcg_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<Vec<ProprietaryReference1>>,
}

impl TransactionReferences6 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.msg_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "msg_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "msg_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.acct_svcr_ref {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "acct_svcr_ref is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "acct_svcr_ref exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.pmt_inf_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "pmt_inf_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "pmt_inf_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.instr_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "instr_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "instr_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.end_to_end_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "end_to_end_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "end_to_end_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.uetr {
			let pattern = Regex::new("[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "uetr does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.mndt_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "mndt_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "mndt_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.chq_nb {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "chq_nb is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "chq_nb exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.clr_sys_ref {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "clr_sys_ref is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "clr_sys_ref exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.acct_ownr_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "acct_ownr_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "acct_ownr_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.acct_svcr_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "acct_svcr_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "acct_svcr_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.mkt_infrstrctr_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "mkt_infrstrctr_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "mkt_infrstrctr_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.prcg_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prcg_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prcg_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref vec) = self.prtry { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TransactionReferences7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TransactionReferences7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgId", skip_serializing_if = "Option::is_none") )]
	pub msg_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MsgNmId", skip_serializing_if = "Option::is_none") )]
	pub msg_nm_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctSvcrRef", skip_serializing_if = "Option::is_none") )]
	pub acct_svcr_ref: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtInfId", skip_serializing_if = "Option::is_none") )]
	pub pmt_inf_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "InstrId", skip_serializing_if = "Option::is_none") )]
	pub instr_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "EndToEndId", skip_serializing_if = "Option::is_none") )]
	pub end_to_end_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "UETR", skip_serializing_if = "Option::is_none") )]
	pub uetr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxId", skip_serializing_if = "Option::is_none") )]
	pub tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MndtId", skip_serializing_if = "Option::is_none") )]
	pub mndt_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ChqNb", skip_serializing_if = "Option::is_none") )]
	pub chq_nb: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ClrSysRef", skip_serializing_if = "Option::is_none") )]
	pub clr_sys_ref: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctOwnrTxId", skip_serializing_if = "Option::is_none") )]
	pub acct_ownr_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctSvcrTxId", skip_serializing_if = "Option::is_none") )]
	pub acct_svcr_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MktInfrstrctrTxId", skip_serializing_if = "Option::is_none") )]
	pub mkt_infrstrctr_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PrcgId", skip_serializing_if = "Option::is_none") )]
	pub prcg_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<Vec<ProprietaryReference1>>,
}

impl TransactionReferences7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.msg_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "msg_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "msg_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.msg_nm_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "msg_nm_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "msg_nm_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.acct_svcr_ref {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "acct_svcr_ref is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "acct_svcr_ref exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.pmt_inf_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "pmt_inf_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "pmt_inf_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.instr_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "instr_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "instr_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.end_to_end_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "end_to_end_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "end_to_end_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.uetr {
			let pattern = Regex::new("[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "uetr does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.mndt_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "mndt_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "mndt_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.chq_nb {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "chq_nb is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "chq_nb exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.clr_sys_ref {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "clr_sys_ref is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "clr_sys_ref exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.acct_ownr_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "acct_ownr_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "acct_ownr_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.acct_svcr_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "acct_svcr_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "acct_svcr_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.mkt_infrstrctr_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "mkt_infrstrctr_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "mkt_infrstrctr_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.prcg_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prcg_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prcg_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref vec) = self.prtry { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TransactionReport8 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TransactionReport8 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtId") )]
	pub pmt_id: PaymentIdentification8Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxOrErr") )]
	pub tx_or_err: TransactionOrError6Choice,
}

impl TransactionReport8 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.pmt_id.validate()?;
		self.tx_or_err.validate()?;
		Ok(())
	}
}


// TransactionReportOrError7Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TransactionReportOrError7Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BizRpt", skip_serializing_if = "Option::is_none") )]
	pub biz_rpt: Option<Transactions11>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OprlErr", skip_serializing_if = "Option::is_none") )]
	pub oprl_err: Option<Vec<ErrorHandling5>>,
}

impl TransactionReportOrError7Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.biz_rpt { val.validate()? }
		if let Some(ref vec) = self.oprl_err { for item in vec { item.validate()? } }
		Ok(())
	}
}


// TransactionReturnCriteria5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TransactionReturnCriteria5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtToRtrCrit", skip_serializing_if = "Option::is_none") )]
	pub pmt_to_rtr_crit: Option<SystemReturnCriteria2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtFrRtrCrit", skip_serializing_if = "Option::is_none") )]
	pub pmt_fr_rtr_crit: Option<SystemReturnCriteria2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctCshNtryRtrCrit", skip_serializing_if = "Option::is_none") )]
	pub acct_csh_ntry_rtr_crit: Option<AccountCashEntryReturnCriteria3>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtRtrCrit", skip_serializing_if = "Option::is_none") )]
	pub pmt_rtr_crit: Option<PaymentReturnCriteria4>,
}

impl TransactionReturnCriteria5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.pmt_to_rtr_crit { val.validate()? }
		if let Some(ref val) = self.pmt_fr_rtr_crit { val.validate()? }
		if let Some(ref val) = self.acct_csh_ntry_rtr_crit { val.validate()? }
		if let Some(ref val) = self.pmt_rtr_crit { val.validate()? }
		Ok(())
	}
}


// TransactionSearchCriteria11 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TransactionSearchCriteria11 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtTo", skip_serializing_if = "Option::is_none") )]
	pub pmt_to: Option<Vec<SystemSearch5>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtFr", skip_serializing_if = "Option::is_none") )]
	pub pmt_fr: Option<Vec<SystemSearch5>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtSch", skip_serializing_if = "Option::is_none") )]
	pub pmt_sch: Option<PaymentSearch10>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AcctNtrySch", skip_serializing_if = "Option::is_none") )]
	pub acct_ntry_sch: Option<CashAccountEntrySearch8>,
}

impl TransactionSearchCriteria11 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref vec) = self.pmt_to { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.pmt_fr { for item in vec { item.validate()? } }
		if let Some(ref val) = self.pmt_sch { val.validate()? }
		if let Some(ref val) = self.acct_ntry_sch { val.validate()? }
		Ok(())
	}
}


// TransactionStatus1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TransactionStatus1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl TransactionStatus1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// TransactionType2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct TransactionType2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Sts") )]
	pub sts: EntryStatus1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CdtDbtInd") )]
	pub cdt_dbt_ind: CreditDebitCode,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FlrLmt", skip_serializing_if = "Option::is_none") )]
	pub flr_lmt: Option<Vec<Limit2>>,
}

impl TransactionType2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.sts.validate()?;
		self.cdt_dbt_ind.validate()?;
		if let Some(ref vec) = self.flr_lmt { for item in vec { item.validate()? } }
		Ok(())
	}
}


// Transactions11 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Transactions11 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PmtCmonInf", skip_serializing_if = "Option::is_none") )]
	pub pmt_cmon_inf: Option<PaymentCommon6>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxsSummry", skip_serializing_if = "Option::is_none") )]
	pub txs_summry: Option<NumberAndSumOfTransactions2>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxRpt") )]
	pub tx_rpt: Vec<TransactionReport8>,
}

impl Transactions11 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.pmt_cmon_inf { val.validate()? }
		if let Some(ref val) = self.txs_summry { val.validate()? }
		for item in &self.tx_rpt { item.validate()? }
		Ok(())
	}
}


// TypeOfPrice10Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum TypeOfPrice10Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "BIDE") )]
	CodeBIDE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OFFR") )]
	CodeOFFR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NAVL") )]
	CodeNAVL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CREA") )]
	CodeCREA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CANC") )]
	CodeCANC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INTE") )]
	CodeINTE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SWNG") )]
	CodeSWNG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MIDD") )]
	CodeMIDD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RINV") )]
	CodeRINV,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SWIC") )]
	CodeSWIC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DDVR") )]
	CodeDDVR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ACTU") )]
	CodeACTU,
}

impl TypeOfPrice10Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// UnableToApplyIncorrect2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct UnableToApplyIncorrect2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: IncorrectData1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlIncrrctInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_incrrct_inf: Option<String>,
}

impl UnableToApplyIncorrect2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.tp.validate()?;
		if let Some(ref val) = self.addtl_incrrct_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_incrrct_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "addtl_incrrct_inf exceeds the maximum length of 140".to_string()));
			}
		}
		Ok(())
	}
}


// UnableToApplyJustification4Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct UnableToApplyJustification4Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "AnyInf", skip_serializing_if = "Option::is_none") )]
	pub any_inf: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MssngOrIncrrctInf", skip_serializing_if = "Option::is_none") )]
	pub mssng_or_incrrct_inf: Option<MissingOrIncorrectData1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PssblDplctInstr", skip_serializing_if = "Option::is_none") )]
	pub pssbl_dplct_instr: Option<bool>,
}

impl UnableToApplyJustification4Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.mssng_or_incrrct_inf { val.validate()? }
		Ok(())
	}
}


// UnableToApplyMissing2 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct UnableToApplyMissing2 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Tp") )]
	pub tp: MissingData1Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AddtlMssngInf", skip_serializing_if = "Option::is_none") )]
	pub addtl_mssng_inf: Option<String>,
}

impl UnableToApplyMissing2 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.tp.validate()?;
		if let Some(ref val) = self.addtl_mssng_inf {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "addtl_mssng_inf is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 140 {
				return Err(ValidationError::new(1002, "addtl_mssng_inf exceeds the maximum length of 140".to_string()));
			}
		}
		Ok(())
	}
}


// UnderlyingData2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct UnderlyingData2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Initn", skip_serializing_if = "Option::is_none") )]
	pub initn: Option<UnderlyingPaymentInstruction8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrBk", skip_serializing_if = "Option::is_none") )]
	pub intr_bk: Option<UnderlyingPaymentTransaction7>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StmtNtry", skip_serializing_if = "Option::is_none") )]
	pub stmt_ntry: Option<UnderlyingStatementEntry5>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Acct", skip_serializing_if = "Option::is_none") )]
	pub acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Othr", skip_serializing_if = "Option::is_none") )]
	pub othr: Option<GenericIdentification1>,
}

impl UnderlyingData2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.initn { val.validate()? }
		if let Some(ref val) = self.intr_bk { val.validate()? }
		if let Some(ref val) = self.stmt_ntry { val.validate()? }
		if let Some(ref val) = self.acct { val.validate()? }
		if let Some(ref val) = self.othr { val.validate()? }
		Ok(())
	}
}


// UnderlyingGroupInformation1 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct UnderlyingGroupInformation1 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlMsgId") )]
	pub orgnl_msg_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlMsgNmId") )]
	pub orgnl_msg_nm_id: String,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlCreDtTm", skip_serializing_if = "Option::is_none") )]
	pub orgnl_cre_dt_tm: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlMsgDlvryChanl", skip_serializing_if = "Option::is_none") )]
	pub orgnl_msg_dlvry_chanl: Option<String>,
}

impl UnderlyingGroupInformation1 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if self.orgnl_msg_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "orgnl_msg_id is shorter than the minimum length of 1".to_string()));
		}
		if self.orgnl_msg_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "orgnl_msg_id exceeds the maximum length of 35".to_string()));
		}
		if self.orgnl_msg_nm_id.chars().count() < 1 {
			return Err(ValidationError::new(1001, "orgnl_msg_nm_id is shorter than the minimum length of 1".to_string()));
		}
		if self.orgnl_msg_nm_id.chars().count() > 35 {
			return Err(ValidationError::new(1002, "orgnl_msg_nm_id exceeds the maximum length of 35".to_string()));
		}
		if let Some(ref val) = self.orgnl_msg_dlvry_chanl {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_msg_dlvry_chanl is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_msg_dlvry_chanl exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// UnderlyingInvestigationInstrument1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct UnderlyingInvestigationInstrument1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<String>,
}

impl UnderlyingInvestigationInstrument1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "cd is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 4 {
				return Err(ValidationError::new(1002, "cd exceeds the maximum length of 4".to_string()));
			}
		}
		if let Some(ref val) = self.prtry {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "prtry is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "prtry exceeds the maximum length of 35".to_string()));
			}
		}
		Ok(())
	}
}


// UnderlyingPaymentInstruction8 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct UnderlyingPaymentInstruction8 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlGrpInf", skip_serializing_if = "Option::is_none") )]
	pub orgnl_grp_inf: Option<UnderlyingGroupInformation1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlPmtInfId", skip_serializing_if = "Option::is_none") )]
	pub orgnl_pmt_inf_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlInstrId", skip_serializing_if = "Option::is_none") )]
	pub orgnl_instr_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlEndToEndId", skip_serializing_if = "Option::is_none") )]
	pub orgnl_end_to_end_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlUETR", skip_serializing_if = "Option::is_none") )]
	pub orgnl_uetr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlInstdAmt", skip_serializing_if = "Option::is_none") )]
	pub orgnl_instd_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReqdExctnDt", skip_serializing_if = "Option::is_none") )]
	pub reqd_exctn_dt: Option<DateAndDateTime2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReqdColltnDt", skip_serializing_if = "Option::is_none") )]
	pub reqd_colltn_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlTxRef", skip_serializing_if = "Option::is_none") )]
	pub orgnl_tx_ref: Option<OriginalTransactionReference35>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlSvcLvl", skip_serializing_if = "Option::is_none") )]
	pub orgnl_svc_lvl: Option<ServiceLevel8Choice>,
}

impl UnderlyingPaymentInstruction8 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.orgnl_grp_inf { val.validate()? }
		if let Some(ref val) = self.orgnl_pmt_inf_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_pmt_inf_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_pmt_inf_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.orgnl_instr_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_instr_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_instr_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.orgnl_end_to_end_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_end_to_end_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_end_to_end_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.orgnl_uetr {
			let pattern = Regex::new("[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "orgnl_uetr does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.orgnl_instd_amt { val.validate()? }
		if let Some(ref val) = self.reqd_exctn_dt { val.validate()? }
		if let Some(ref val) = self.orgnl_tx_ref { val.validate()? }
		if let Some(ref val) = self.orgnl_svc_lvl { val.validate()? }
		Ok(())
	}
}


// UnderlyingPaymentInstruction9 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct UnderlyingPaymentInstruction9 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlGrpInf", skip_serializing_if = "Option::is_none") )]
	pub orgnl_grp_inf: Option<UnderlyingGroupInformation1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlPmtInfId", skip_serializing_if = "Option::is_none") )]
	pub orgnl_pmt_inf_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlInstrId", skip_serializing_if = "Option::is_none") )]
	pub orgnl_instr_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlEndToEndId", skip_serializing_if = "Option::is_none") )]
	pub orgnl_end_to_end_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlUETR", skip_serializing_if = "Option::is_none") )]
	pub orgnl_uetr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlInstdAmt", skip_serializing_if = "Option::is_none") )]
	pub orgnl_instd_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReqdExctnDt", skip_serializing_if = "Option::is_none") )]
	pub reqd_exctn_dt: Option<DateAndDateTime2Choice>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ReqdColltnDt", skip_serializing_if = "Option::is_none") )]
	pub reqd_colltn_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlTxRef", skip_serializing_if = "Option::is_none") )]
	pub orgnl_tx_ref: Option<OriginalTransactionReference42>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlSvcLvl", skip_serializing_if = "Option::is_none") )]
	pub orgnl_svc_lvl: Option<ServiceLevel8Choice>,
}

impl UnderlyingPaymentInstruction9 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.orgnl_grp_inf { val.validate()? }
		if let Some(ref val) = self.orgnl_pmt_inf_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_pmt_inf_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_pmt_inf_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.orgnl_instr_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_instr_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_instr_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.orgnl_end_to_end_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_end_to_end_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_end_to_end_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.orgnl_uetr {
			let pattern = Regex::new("[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "orgnl_uetr does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.orgnl_instd_amt { val.validate()? }
		if let Some(ref val) = self.reqd_exctn_dt { val.validate()? }
		if let Some(ref val) = self.orgnl_tx_ref { val.validate()? }
		if let Some(ref val) = self.orgnl_svc_lvl { val.validate()? }
		Ok(())
	}
}


// UnderlyingPaymentTransaction7 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct UnderlyingPaymentTransaction7 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlGrpInf", skip_serializing_if = "Option::is_none") )]
	pub orgnl_grp_inf: Option<UnderlyingGroupInformation1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlInstrId", skip_serializing_if = "Option::is_none") )]
	pub orgnl_instr_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlEndToEndId", skip_serializing_if = "Option::is_none") )]
	pub orgnl_end_to_end_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlTxId", skip_serializing_if = "Option::is_none") )]
	pub orgnl_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlUETR", skip_serializing_if = "Option::is_none") )]
	pub orgnl_uetr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlIntrBkSttlmAmt", skip_serializing_if = "Option::is_none") )]
	pub orgnl_intr_bk_sttlm_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlIntrBkSttlmDt", skip_serializing_if = "Option::is_none") )]
	pub orgnl_intr_bk_sttlm_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlTxRef", skip_serializing_if = "Option::is_none") )]
	pub orgnl_tx_ref: Option<OriginalTransactionReference35>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlSvcLvl", skip_serializing_if = "Option::is_none") )]
	pub orgnl_svc_lvl: Option<ServiceLevel8Choice>,
}

impl UnderlyingPaymentTransaction7 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.orgnl_grp_inf { val.validate()? }
		if let Some(ref val) = self.orgnl_instr_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_instr_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_instr_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.orgnl_end_to_end_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_end_to_end_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_end_to_end_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.orgnl_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.orgnl_uetr {
			let pattern = Regex::new("[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "orgnl_uetr does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.orgnl_intr_bk_sttlm_amt { val.validate()? }
		if let Some(ref val) = self.orgnl_tx_ref { val.validate()? }
		if let Some(ref val) = self.orgnl_svc_lvl { val.validate()? }
		Ok(())
	}
}


// UnderlyingPaymentTransaction8 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct UnderlyingPaymentTransaction8 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlGrpInf", skip_serializing_if = "Option::is_none") )]
	pub orgnl_grp_inf: Option<UnderlyingGroupInformation1>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlInstrId", skip_serializing_if = "Option::is_none") )]
	pub orgnl_instr_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlEndToEndId", skip_serializing_if = "Option::is_none") )]
	pub orgnl_end_to_end_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlTxId", skip_serializing_if = "Option::is_none") )]
	pub orgnl_tx_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlUETR", skip_serializing_if = "Option::is_none") )]
	pub orgnl_uetr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlIntrBkSttlmAmt", skip_serializing_if = "Option::is_none") )]
	pub orgnl_intr_bk_sttlm_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlIntrBkSttlmDt", skip_serializing_if = "Option::is_none") )]
	pub orgnl_intr_bk_sttlm_dt: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlTxRef", skip_serializing_if = "Option::is_none") )]
	pub orgnl_tx_ref: Option<OriginalTransactionReference42>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlSvcLvl", skip_serializing_if = "Option::is_none") )]
	pub orgnl_svc_lvl: Option<ServiceLevel8Choice>,
}

impl UnderlyingPaymentTransaction8 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.orgnl_grp_inf { val.validate()? }
		if let Some(ref val) = self.orgnl_instr_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_instr_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_instr_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.orgnl_end_to_end_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_end_to_end_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_end_to_end_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.orgnl_tx_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_tx_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_tx_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.orgnl_uetr {
			let pattern = Regex::new("[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "orgnl_uetr does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.orgnl_intr_bk_sttlm_amt { val.validate()? }
		if let Some(ref val) = self.orgnl_tx_ref { val.validate()? }
		if let Some(ref val) = self.orgnl_svc_lvl { val.validate()? }
		Ok(())
	}
}


// UnderlyingStatementEntry3 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct UnderlyingStatementEntry3 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlGrpInf", skip_serializing_if = "Option::is_none") )]
	pub orgnl_grp_inf: Option<OriginalGroupInformation29>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlStmtId", skip_serializing_if = "Option::is_none") )]
	pub orgnl_stmt_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlNtryId", skip_serializing_if = "Option::is_none") )]
	pub orgnl_ntry_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlUETR", skip_serializing_if = "Option::is_none") )]
	pub orgnl_uetr: Option<String>,
}

impl UnderlyingStatementEntry3 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.orgnl_grp_inf { val.validate()? }
		if let Some(ref val) = self.orgnl_stmt_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_stmt_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_stmt_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.orgnl_ntry_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_ntry_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_ntry_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.orgnl_uetr {
			let pattern = Regex::new("[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "orgnl_uetr does not match the required pattern".to_string()));
			}
		}
		Ok(())
	}
}


// UnderlyingStatementEntry5 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct UnderlyingStatementEntry5 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlAcct", skip_serializing_if = "Option::is_none") )]
	pub orgnl_acct: Option<CashAccount40>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlGrpInf", skip_serializing_if = "Option::is_none") )]
	pub orgnl_grp_inf: Option<OriginalGroupInformation29>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlStmtId", skip_serializing_if = "Option::is_none") )]
	pub orgnl_stmt_id: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlNtryRef", skip_serializing_if = "Option::is_none") )]
	pub orgnl_ntry_ref: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlUETR", skip_serializing_if = "Option::is_none") )]
	pub orgnl_uetr: Option<String>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlNtryAmt", skip_serializing_if = "Option::is_none") )]
	pub orgnl_ntry_amt: Option<ActiveOrHistoricCurrencyAndAmount>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlNtryValDt", skip_serializing_if = "Option::is_none") )]
	pub orgnl_ntry_val_dt: Option<DateAndDateTime2Choice>,
}

impl UnderlyingStatementEntry5 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.orgnl_acct { val.validate()? }
		if let Some(ref val) = self.orgnl_grp_inf { val.validate()? }
		if let Some(ref val) = self.orgnl_stmt_id {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_stmt_id is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_stmt_id exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.orgnl_ntry_ref {
			if val.chars().count() < 1 {
				return Err(ValidationError::new(1001, "orgnl_ntry_ref is shorter than the minimum length of 1".to_string()));
			}
			if val.chars().count() > 35 {
				return Err(ValidationError::new(1002, "orgnl_ntry_ref exceeds the maximum length of 35".to_string()));
			}
		}
		if let Some(ref val) = self.orgnl_uetr {
			let pattern = Regex::new("[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}").unwrap();
			if !pattern.is_match(val) {
				return Err(ValidationError::new(1005, "orgnl_uetr does not match the required pattern".to_string()));
			}
		}
		if let Some(ref val) = self.orgnl_ntry_amt { val.validate()? }
		if let Some(ref val) = self.orgnl_ntry_val_dt { val.validate()? }
		Ok(())
	}
}


// UnderlyingTransaction32 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct UnderlyingTransaction32 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlGrpInfAndSts", skip_serializing_if = "Option::is_none") )]
	pub orgnl_grp_inf_and_sts: Option<OriginalGroupHeader23>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlPmtInfAndSts", skip_serializing_if = "Option::is_none") )]
	pub orgnl_pmt_inf_and_sts: Option<Vec<OriginalPaymentInstruction48>>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxInfAndSts", skip_serializing_if = "Option::is_none") )]
	pub tx_inf_and_sts: Option<Vec<PaymentTransaction152>>,
}

impl UnderlyingTransaction32 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.orgnl_grp_inf_and_sts { val.validate()? }
		if let Some(ref vec) = self.orgnl_pmt_inf_and_sts { for item in vec { item.validate()? } }
		if let Some(ref vec) = self.tx_inf_and_sts { for item in vec { item.validate()? } }
		Ok(())
	}
}


// UnderlyingTransaction33 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct UnderlyingTransaction33 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlGrpInfAndCxl", skip_serializing_if = "Option::is_none") )]
	pub orgnl_grp_inf_and_cxl: Option<OriginalGroupHeader21>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlPmtInfAndCxl", skip_serializing_if = "Option::is_none") )]
	pub orgnl_pmt_inf_and_cxl: Option<Vec<OriginalPaymentInstruction49>>,
}

impl UnderlyingTransaction33 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.orgnl_grp_inf_and_cxl { val.validate()? }
		if let Some(ref vec) = self.orgnl_pmt_inf_and_cxl { for item in vec { item.validate()? } }
		Ok(())
	}
}


// UnderlyingTransaction34 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct UnderlyingTransaction34 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "OrgnlGrpInfAndCxl", skip_serializing_if = "Option::is_none") )]
	pub orgnl_grp_inf_and_cxl: Option<OriginalGroupHeader21>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TxInf", skip_serializing_if = "Option::is_none") )]
	pub tx_inf: Option<Vec<PaymentTransaction155>>,
}

impl UnderlyingTransaction34 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.orgnl_grp_inf_and_cxl { val.validate()? }
		if let Some(ref vec) = self.tx_inf { for item in vec { item.validate()? } }
		Ok(())
	}
}


// UnderlyingTransaction8Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct UnderlyingTransaction8Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Initn", skip_serializing_if = "Option::is_none") )]
	pub initn: Option<UnderlyingPaymentInstruction9>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IntrBk", skip_serializing_if = "Option::is_none") )]
	pub intr_bk: Option<UnderlyingPaymentTransaction8>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "StmtNtry", skip_serializing_if = "Option::is_none") )]
	pub stmt_ntry: Option<UnderlyingStatementEntry3>,
}

impl UnderlyingTransaction8Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.initn { val.validate()? }
		if let Some(ref val) = self.intr_bk { val.validate()? }
		if let Some(ref val) = self.stmt_ntry { val.validate()? }
		Ok(())
	}
}


// UnitOfMeasure1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum UnitOfMeasure1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "PIEC") )]
	CodePIEC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TONS") )]
	CodeTONS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FOOT") )]
	CodeFOOT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GBGA") )]
	CodeGBGA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "USGA") )]
	CodeUSGA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GRAM") )]
	CodeGRAM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "INCH") )]
	CodeINCH,
	#[cfg_attr( feature = "derive_serde", serde(rename = "KILO") )]
	CodeKILO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PUND") )]
	CodePUND,
	#[cfg_attr( feature = "derive_serde", serde(rename = "METR") )]
	CodeMETR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CMET") )]
	CodeCMET,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MMET") )]
	CodeMMET,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LITR") )]
	CodeLITR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CELI") )]
	CodeCELI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MILI") )]
	CodeMILI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GBOU") )]
	CodeGBOU,
	#[cfg_attr( feature = "derive_serde", serde(rename = "USOU") )]
	CodeUSOU,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GBQA") )]
	CodeGBQA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "USQA") )]
	CodeUSQA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "GBPI") )]
	CodeGBPI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "USPI") )]
	CodeUSPI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "MILE") )]
	CodeMILE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "KMET") )]
	CodeKMET,
	#[cfg_attr( feature = "derive_serde", serde(rename = "YARD") )]
	CodeYARD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SQKI") )]
	CodeSQKI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "HECT") )]
	CodeHECT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ARES") )]
	CodeARES,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SMET") )]
	CodeSMET,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SCMT") )]
	CodeSCMT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SMIL") )]
	CodeSMIL,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SQMI") )]
	CodeSQMI,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SQYA") )]
	CodeSQYA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SQFO") )]
	CodeSQFO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SQIN") )]
	CodeSQIN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ACRE") )]
	CodeACRE,
}

impl UnitOfMeasure1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// UnitPrice19 ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct UnitPrice19 {
	#[cfg_attr( feature = "derive_serde", serde(rename = "PricTp") )]
	pub pric_tp: UnitPriceType2Choice,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Val") )]
	pub val: PriceValue1,
}

impl UnitPrice19 {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.pric_tp.validate()?;
		self.val.validate()?;
		Ok(())
	}
}


// UnitPriceType2Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct UnitPriceType2Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<TypeOfPrice10Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification47>,
}

impl UnitPriceType2Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// UnmatchedStatusReason1Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum UnmatchedStatusReason1Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "CMIS") )]
	CodeCMIS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DDAT") )]
	CodeDDAT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DELN") )]
	CodeDELN,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DEPT") )]
	CodeDEPT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DMON") )]
	CodeDMON,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DDEA") )]
	CodeDDEA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DQUA") )]
	CodeDQUA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CADE") )]
	CodeCADE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SETR") )]
	CodeSETR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DSEC") )]
	CodeDSEC,
	#[cfg_attr( feature = "derive_serde", serde(rename = "VASU") )]
	CodeVASU,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DTRA") )]
	CodeDTRA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RSPR") )]
	CodeRSPR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "REPO") )]
	CodeREPO,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CLAT") )]
	CodeCLAT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RERT") )]
	CodeRERT,
	#[cfg_attr( feature = "derive_serde", serde(rename = "REPA") )]
	CodeREPA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "REPP") )]
	CodeREPP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PHYS") )]
	CodePHYS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IIND") )]
	CodeIIND,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FRAP") )]
	CodeFRAP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PLCE") )]
	CodePLCE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "PODU") )]
	CodePODU,
	#[cfg_attr( feature = "derive_serde", serde(rename = "FORF") )]
	CodeFORF,
	#[cfg_attr( feature = "derive_serde", serde(rename = "REGD") )]
	CodeREGD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "RTGS") )]
	CodeRTGS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ICAG") )]
	CodeICAG,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CPCA") )]
	CodeCPCA,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CHAR") )]
	CodeCHAR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "IEXE") )]
	CodeIEXE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NCRR") )]
	CodeNCRR,
	#[cfg_attr( feature = "derive_serde", serde(rename = "NMAS") )]
	CodeNMAS,
	#[cfg_attr( feature = "derive_serde", serde(rename = "SAFE") )]
	CodeSAFE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "DTRD") )]
	CodeDTRD,
	#[cfg_attr( feature = "derive_serde", serde(rename = "LATE") )]
	CodeLATE,
	#[cfg_attr( feature = "derive_serde", serde(rename = "TERM") )]
	CodeTERM,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ICUS") )]
	CodeICUS,
}

impl UnmatchedStatusReason1Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// UpdateType15Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct UpdateType15Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Cd", skip_serializing_if = "Option::is_none") )]
	pub cd: Option<StatementUpdateType1Code>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "Prtry", skip_serializing_if = "Option::is_none") )]
	pub prtry: Option<GenericIdentification30>,
}

impl UpdateType15Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.cd { val.validate()? }
		if let Some(ref val) = self.prtry { val.validate()? }
		Ok(())
	}
}


// UserInterface2Code ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub enum UserInterface2Code {
	#[cfg_attr(feature = "derive_default", default)]
	#[cfg_attr( feature = "derive_serde", serde(rename = "MDSP") )]
	CodeMDSP,
	#[cfg_attr( feature = "derive_serde", serde(rename = "CDSP") )]
	CodeCDSP,
}

impl UserInterface2Code {
	pub fn validate(&self) -> Result<(), ValidationError> {
		Ok(())
	}
}


// Value ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct Value {
	#[cfg_attr( feature = "derive_serde", serde(rename = "BaseCcyItm") )]
	pub base_ccy_itm: ActiveOrHistoricCurrencyAndAmount,
	#[cfg_attr( feature = "derive_serde", serde(rename = "AltrnCcyItm") )]
	pub altrn_ccy_itm: Vec<ActiveOrHistoricCurrencyAndAmount>,
}

impl Value {
	pub fn validate(&self) -> Result<(), ValidationError> {
		self.base_ccy_itm.validate()?;
		for item in &self.altrn_ccy_itm { item.validate()? }
		Ok(())
	}
}


// YieldedOrValueType1Choice ...
#[cfg_attr(feature = "derive_debug", derive(Debug))]
#[cfg_attr(feature = "derive_default", derive(Default))]
#[cfg_attr(feature = "derive_serde", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "derive_clone", derive(Clone))]
#[cfg_attr(feature = "derive_partial_eq", derive(PartialEq))]
pub struct YieldedOrValueType1Choice {
	#[cfg_attr( feature = "derive_serde", serde(rename = "Yldd", skip_serializing_if = "Option::is_none") )]
	pub yldd: Option<bool>,
	#[cfg_attr( feature = "derive_serde", serde(rename = "ValTp", skip_serializing_if = "Option::is_none") )]
	pub val_tp: Option<PriceValueType1Code>,
}

impl YieldedOrValueType1Choice {
	pub fn validate(&self) -> Result<(), ValidationError> {
		if let Some(ref val) = self.val_tp { val.validate()? }
		Ok(())
	}
}